// Code generated by 'ccgo -pkgname gojp2 -trace-translation-units -export-externs X -export-defines D -export-fields F -export-structs S -export-typedefs T -I../src/lib/openjp2/ -I../src/bin/common/ ../src/bin/common/color.c ../src/lib/openjp2/bio.c ../src/lib/openjp2/cio.c ../src/lib/openjp2/dwt.c ../src/lib/openjp2/event.c ../src/lib/openjp2/function_list.c ../src/lib/openjp2/helper.c ../src/lib/openjp2/ht_dec.c ../src/lib/openjp2/image.c ../src/lib/openjp2/invert.c ../src/lib/openjp2/j2k.c ../src/lib/openjp2/jp2.c ../src/lib/openjp2/mct.c ../src/lib/openjp2/mqc.c ../src/lib/openjp2/openjpeg.c ../src/lib/openjp2/opj_malloc.c ../src/lib/openjp2/pi.c ../src/lib/openjp2/sparse_array.c ../src/lib/openjp2/t1.c ../src/lib/openjp2/t2.c ../src/lib/openjp2/tcd.c ../src/lib/openjp2/tgt.c ../src/lib/openjp2/thread.c', DO NOT EDIT.

package gojp2

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

const (
	DBIG_ENDIAN                                 = 4321                         // endian.h:28:1:
	DBUFSIZ                                     = 8192                         // stdio.h:99:1:
	DBYTE_ORDER                                 = 1234                         // endian.h:30:1:
	DEOF                                        = -1                           // stdio.h:104:1:
	DEXIT_FAILURE                               = 1                            // stdlib.h:91:1:
	DEXIT_SUCCESS                               = 0                            // stdlib.h:92:1:
	DFD_SETSIZE                                 = 1024                         // select.h:73:1:
	DFILENAME_MAX                               = 4096                         // stdio_lim.h:27:1:
	DFOPEN_MAX                                  = 16                           // stdio_lim.h:37:1:
	DFP_ILOGB0                                  = -2147483648                  // math.h:193:1:
	DFP_ILOGBNAN                                = -2147483648                  // math.h:198:1:
	DFP_INFINITE                                = 1                            // math.h:859:1:
	DFP_NAN                                     = 0                            // math.h:856:1:
	DFP_NORMAL                                  = 4                            // math.h:868:1:
	DFP_SUBNORMAL                               = 3                            // math.h:865:1:
	DFP_ZERO                                    = 2                            // math.h:862:1:
	DINT16_MAX                                  = 32767                        // stdint.h:122:1:
	DINT16_MIN                                  = -32768                       // stdint.h:117:1:
	DINT32_MAX                                  = 2147483647                   // stdint.h:123:1:
	DINT32_MIN                                  = -2147483648                  // stdint.h:118:1:
	DINT64_MAX                                  = 9223372036854775807          // stdint.h:124:1:
	DINT64_MIN                                  = -9223372036854775808         // stdint.h:119:1:
	DINT8_MAX                                   = 127                          // stdint.h:121:1:
	DINT8_MIN                                   = -128                         // stdint.h:116:1:
	DINTMAX_MAX                                 = 9223372036854775807          // stdint.h:199:1:
	DINTMAX_MIN                                 = -9223372036854775808         // stdint.h:197:1:
	DINTPTR_MAX                                 = 9223372036854775807          // stdint.h:187:1:
	DINTPTR_MIN                                 = -9223372036854775808         // stdint.h:186:1:
	DINT_FAST16_MAX                             = 9223372036854775807          // stdint.h:164:1:
	DINT_FAST16_MIN                             = -9223372036854775808         // stdint.h:154:1:
	DINT_FAST32_MAX                             = 9223372036854775807          // stdint.h:165:1:
	DINT_FAST32_MIN                             = -9223372036854775808         // stdint.h:155:1:
	DINT_FAST64_MAX                             = 9223372036854775807          // stdint.h:170:1:
	DINT_FAST64_MIN                             = -9223372036854775808         // stdint.h:160:1:
	DINT_FAST8_MAX                              = 127                          // stdint.h:162:1:
	DINT_FAST8_MIN                              = -128                         // stdint.h:152:1:
	DINT_LEAST16_MAX                            = 32767                        // stdint.h:140:1:
	DINT_LEAST16_MIN                            = -32768                       // stdint.h:135:1:
	DINT_LEAST32_MAX                            = 2147483647                   // stdint.h:141:1:
	DINT_LEAST32_MIN                            = -2147483648                  // stdint.h:136:1:
	DINT_LEAST64_MAX                            = 9223372036854775807          // stdint.h:142:1:
	DINT_LEAST64_MIN                            = -9223372036854775808         // stdint.h:137:1:
	DINT_LEAST8_MAX                             = 127                          // stdint.h:139:1:
	DINT_LEAST8_MIN                             = -128                         // stdint.h:134:1:
	DJPWL_EXPECTED_COMPONENTS                   = 3                            // openjpeg.h:166:1:
	DJPWL_MAXIMUM_EPB_ROOM                      = 65450                        // openjpeg.h:169:1:
	DJPWL_MAXIMUM_HAMMING                       = 2                            // openjpeg.h:168:1:
	DJPWL_MAXIMUM_TILES                         = 8192                         // openjpeg.h:167:1:
	DJPWL_MAX_NO_MARKERS                        = 512                          // openjpeg.h:164:1:
	DJPWL_MAX_NO_PACKSPECS                      = 16                           // openjpeg.h:163:1:
	DJPWL_MAX_NO_TILESPECS                      = 16                           // openjpeg.h:162:1:
	DJPWL_PRIVATEINDEX_NAME                     = "jpwl_index_privatefilename" // openjpeg.h:165:1:
	DLITTLE_ENDIAN                              = 1234                         // endian.h:27:1:
	DL_ctermid                                  = 9                            // stdio_lim.h:30:1:
	DL_tmpnam                                   = 20                           // stdio_lim.h:25:1:
	DMATH_ERREXCEPT                             = 2                            // math.h:955:1:
	DMATH_ERRNO                                 = 1                            // math.h:954:1:
	DM_1_PI                                     = 0.31830988618379067154       // math.h:1073:1:
	DM_2_PI                                     = 0.63661977236758134308       // math.h:1074:1:
	DM_2_SQRTPI                                 = 1.12837916709551257390       // math.h:1075:1:
	DM_E                                        = 2.7182818284590452354        // math.h:1065:1:
	DM_LN10                                     = 2.30258509299404568402       // math.h:1069:1:
	DM_LN2                                      = 0.69314718055994530942       // math.h:1068:1:
	DM_LOG10E                                   = 0.43429448190325182765       // math.h:1067:1:
	DM_LOG2E                                    = 1.4426950408889634074        // math.h:1066:1:
	DM_PI                                       = 3.14159265358979323846       // math.h:1070:1:
	DM_PI_2                                     = 1.57079632679489661923       // math.h:1071:1:
	DM_PI_4                                     = 0.78539816339744830962       // math.h:1072:1:
	DM_SQRT1_2                                  = 0.70710678118654752440       // math.h:1077:1:
	DM_SQRT2                                    = 1.41421356237309504880       // math.h:1076:1:
	DOPENJPEG_H                                 = 0                            // openjpeg.h:43:1:
	DOPJ_CALLCONV                               = 0                            // openjpeg.h:98:1:
	DOPJ_CINEMA_24_COMP                         = 1041666                      // openjpeg.h:269:1:
	DOPJ_CINEMA_24_CS                           = 1302083                      // openjpeg.h:267:1:
	DOPJ_CINEMA_48_COMP                         = 520833                       // openjpeg.h:270:1:
	DOPJ_CINEMA_48_CS                           = 651041                       // openjpeg.h:268:1:
	DOPJ_DPARAMETERS_DUMP_FLAG                  = 0x0002                       // openjpeg.h:547:1:
	DOPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG = 0x0001                       // openjpeg.h:546:1:
	DOPJ_EXTENSION_MCT                          = 0x0100                       // openjpeg.h:223:1:
	DOPJ_EXTENSION_NONE                         = 0x0000                       // openjpeg.h:222:1:
	DOPJ_FALSE                                  = 0                            // openjpeg.h:118:1:
	DOPJ_HAVE_INTTYPES_H                        = 1                            // opj_config_private.h:2:1:
	DOPJ_HAVE_MALLOC_H                          = 0                            // opj_config_private.h:21:1:
	DOPJ_HAVE_MEMALIGN                          = 0                            // opj_config_private.h:27:1:
	DOPJ_HAVE_POSIX_MEMALIGN                    = 0                            // opj_config_private.h:29:1:
	DOPJ_HAVE_STDINT_H                          = 1                            // opj_config.h:2:1:
	DOPJ_IMF_MAINLEVEL_10_MSAMPLESEC            = 19200                        // openjpeg.h:250:1:
	DOPJ_IMF_MAINLEVEL_11_MSAMPLESEC            = 38400                        // openjpeg.h:251:1:
	DOPJ_IMF_MAINLEVEL_1_MSAMPLESEC             = 65                           // openjpeg.h:241:1:
	DOPJ_IMF_MAINLEVEL_2_MSAMPLESEC             = 130                          // openjpeg.h:242:1:
	DOPJ_IMF_MAINLEVEL_3_MSAMPLESEC             = 195                          // openjpeg.h:243:1:
	DOPJ_IMF_MAINLEVEL_4_MSAMPLESEC             = 260                          // openjpeg.h:244:1:
	DOPJ_IMF_MAINLEVEL_5_MSAMPLESEC             = 520                          // openjpeg.h:245:1:
	DOPJ_IMF_MAINLEVEL_6_MSAMPLESEC             = 1200                         // openjpeg.h:246:1:
	DOPJ_IMF_MAINLEVEL_7_MSAMPLESEC             = 2400                         // openjpeg.h:247:1:
	DOPJ_IMF_MAINLEVEL_8_MSAMPLESEC             = 4800                         // openjpeg.h:248:1:
	DOPJ_IMF_MAINLEVEL_9_MSAMPLESEC             = 9600                         // openjpeg.h:249:1:
	DOPJ_IMF_MAINLEVEL_MAX                      = 11                           // openjpeg.h:238:1:
	DOPJ_IMF_SUBLEVEL_1_MBITSSEC                = 200                          // openjpeg.h:254:1:
	DOPJ_IMF_SUBLEVEL_2_MBITSSEC                = 400                          // openjpeg.h:255:1:
	DOPJ_IMF_SUBLEVEL_3_MBITSSEC                = 800                          // openjpeg.h:256:1:
	DOPJ_IMF_SUBLEVEL_4_MBITSSEC                = 1600                         // openjpeg.h:257:1:
	DOPJ_IMF_SUBLEVEL_5_MBITSSEC                = 3200                         // openjpeg.h:258:1:
	DOPJ_IMF_SUBLEVEL_6_MBITSSEC                = 6400                         // openjpeg.h:259:1:
	DOPJ_IMF_SUBLEVEL_7_MBITSSEC                = 12800                        // openjpeg.h:260:1:
	DOPJ_IMF_SUBLEVEL_8_MBITSSEC                = 25600                        // openjpeg.h:261:1:
	DOPJ_IMF_SUBLEVEL_9_MBITSSEC                = 51200                        // openjpeg.h:262:1:
	DOPJ_IMG_INFO                               = 1                            // openjpeg.h:176:1:
	DOPJ_J2K_DEFAULT_HEADER_SIZE                = 1000                         // openjpeg.h:157:1:
	DOPJ_J2K_DEFAULT_NB_SEGS                    = 10                           // openjpeg.h:155:1:
	DOPJ_J2K_MAXBANDS                           = 97                           // openjpeg.h:153:1:
	DOPJ_J2K_MAXRLVLS                           = 33                           // openjpeg.h:152:1:
	DOPJ_J2K_MCC_DEFAULT_NB_RECORDS             = 10                           // openjpeg.h:158:1:
	DOPJ_J2K_MCT_DEFAULT_NB_RECORDS             = 10                           // openjpeg.h:159:1:
	DOPJ_J2K_MH_IND                             = 16                           // openjpeg.h:180:1:
	DOPJ_J2K_MH_INFO                            = 2                            // openjpeg.h:177:1:
	DOPJ_J2K_STREAM_CHUNK_SIZE                  = 0x100000                     // openjpeg.h:156:1:
	DOPJ_J2K_TCH_INFO                           = 8                            // openjpeg.h:179:1:
	DOPJ_J2K_TH_IND                             = 32                           // openjpeg.h:181:1:
	DOPJ_J2K_TH_INFO                            = 4                            // openjpeg.h:178:1:
	DOPJ_JP2_IND                                = 256                          // openjpeg.h:184:1:
	DOPJ_JP2_INFO                               = 128                          // openjpeg.h:183:1:
	DOPJ_PACKAGE_VERSION                        = "2.5.0"                      // opj_config_private.h:4:1:
	DOPJ_PATH_LEN                               = 4096                         // openjpeg.h:150:1:
	DOPJ_PROFILE_0                              = 0x0001                       // openjpeg.h:201:1:
	DOPJ_PROFILE_1                              = 0x0002                       // openjpeg.h:202:1:
	DOPJ_PROFILE_BC_MULTI                       = 0x0200                       // openjpeg.h:210:1:
	DOPJ_PROFILE_BC_MULTI_R                     = 0x0300                       // openjpeg.h:211:1:
	DOPJ_PROFILE_BC_SINGLE                      = 0x0100                       // openjpeg.h:209:1:
	DOPJ_PROFILE_CINEMA_2K                      = 0x0003                       // openjpeg.h:204:1:
	DOPJ_PROFILE_CINEMA_4K                      = 0x0004                       // openjpeg.h:205:1:
	DOPJ_PROFILE_CINEMA_LTS                     = 0x0007                       // openjpeg.h:208:1:
	DOPJ_PROFILE_CINEMA_S2K                     = 0x0005                       // openjpeg.h:206:1:
	DOPJ_PROFILE_CINEMA_S4K                     = 0x0006                       // openjpeg.h:207:1:
	DOPJ_PROFILE_IMF_2K                         = 0x0400                       // openjpeg.h:212:1:
	DOPJ_PROFILE_IMF_2K_R                       = 0x0700                       // openjpeg.h:215:1:
	DOPJ_PROFILE_IMF_4K                         = 0x0500                       // openjpeg.h:213:1:
	DOPJ_PROFILE_IMF_4K_R                       = 0x0800                       // openjpeg.h:216:1:
	DOPJ_PROFILE_IMF_8K                         = 0x0600                       // openjpeg.h:214:1:
	DOPJ_PROFILE_IMF_8K_R                       = 0x0900                       // openjpeg.h:217:1:
	DOPJ_PROFILE_NONE                           = 0x0000                       // openjpeg.h:200:1:
	DOPJ_PROFILE_PART2                          = 0x8000                       // openjpeg.h:203:1:
	DOPJ_STDINT_H                               = 0                            // opj_stdint.h:32:1:
	DOPJ_STREAM_READ                            = 1                            // openjpeg.h:630:1:
	DOPJ_STREAM_WRITE                           = 0                            // openjpeg.h:632:1:
	DOPJ_TRUE                                   = 1                            // openjpeg.h:117:1:
	DOPJ_VERSION_BUILD                          = 0                            // opj_config.h:10:1:
	DOPJ_VERSION_MAJOR                          = 2                            // opj_config.h:8:1:
	DOPJ_VERSION_MINOR                          = 5                            // opj_config.h:9:1:
	DPDP_ENDIAN                                 = 3412                         // endian.h:29:1:
	DPTRDIFF_MAX                                = 9223372036854775807          // stdint.h:210:1:
	DPTRDIFF_MIN                                = -9223372036854775808         // stdint.h:209:1:
	DP_tmpdir                                   = "/tmp"                       // stdio.h:120:1:
	DRAND_MAX                                   = 2147483647                   // stdlib.h:86:1:
	DSEEK_CUR                                   = 1                            // stdio.h:110:1:
	DSEEK_END                                   = 2                            // stdio.h:111:1:
	DSEEK_SET                                   = 0                            // stdio.h:109:1:
	DSIG_ATOMIC_MAX                             = 2147483647                   // stdint.h:223:1:
	DSIG_ATOMIC_MIN                             = -2147483648                  // stdint.h:222:1:
	DSIZE_MAX                                   = 18446744073709551615         // stdint.h:227:1:
	DTMP_MAX                                    = 238328                       // stdio_lim.h:26:1:
	DUINT16_MAX                                 = 65535                        // stdint.h:128:1:
	DUINT32_MAX                                 = 4294967295                   // stdint.h:129:1:
	DUINT64_MAX                                 = 18446744073709551615         // stdint.h:130:1:
	DUINT8_MAX                                  = 255                          // stdint.h:127:1:
	DUINTMAX_MAX                                = 18446744073709551615         // stdint.h:202:1:
	DUINTPTR_MAX                                = 18446744073709551615         // stdint.h:188:1:
	DUINT_FAST16_MAX                            = 18446744073709551615         // stdint.h:175:1:
	DUINT_FAST32_MAX                            = 18446744073709551615         // stdint.h:176:1:
	DUINT_FAST64_MAX                            = 18446744073709551615         // stdint.h:181:1:
	DUINT_FAST8_MAX                             = 255                          // stdint.h:173:1:
	DUINT_LEAST16_MAX                           = 65535                        // stdint.h:146:1:
	DUINT_LEAST32_MAX                           = 4294967295                   // stdint.h:147:1:
	DUINT_LEAST64_MAX                           = 18446744073709551615         // stdint.h:148:1:
	DUINT_LEAST8_MAX                            = 255                          // stdint.h:145:1:
	DWCHAR_MAX                                  = 2147483647                   // stdint.h:240:1:
	DWCHAR_MIN                                  = -2147483648                  // stdint.h:239:1:
	DWCONTINUED                                 = 8                            // waitflags.h:32:1:
	DWEXITED                                    = 4                            // waitflags.h:31:1:
	DWINT_MAX                                   = 4294967295                   // stdint.h:245:1:
	DWINT_MIN                                   = 0                            // stdint.h:244:1:
	DWNOHANG                                    = 1                            // waitflags.h:25:1:
	DWNOWAIT                                    = 0x01000000                   // waitflags.h:33:1:
	DWSTOPPED                                   = 2                            // waitflags.h:30:1:
	DWUNTRACED                                  = 2                            // waitflags.h:26:1:
	D_ALLOCA_H                                  = 1                            // alloca.h:19:1:
	D_ASSERT_H                                  = 1                            // assert.h:34:1:
	D_ASSERT_H_DECLS                            = 0                            // assert.h:65:1:
	D_ATFILE_SOURCE                             = 1                            // features.h:342:1:
	D_BITS_BYTESWAP_H                           = 1                            // byteswap.h:24:1:
	D_BITS_ENDIANNESS_H                         = 1                            // endianness.h:2:1:
	D_BITS_ENDIAN_H                             = 1                            // endian.h:20:1:
	D_BITS_FLOATN_COMMON_H                      = 0                            // floatn-common.h:21:1:
	D_BITS_FLOATN_H                             = 0                            // floatn.h:20:1:
	D_BITS_LIBM_SIMD_DECL_STUBS_H               = 1                            // libm-simd-decl-stubs.h:34:1:
	D_BITS_PTHREADTYPES_ARCH_H                  = 1                            // pthreadtypes-arch.h:19:1:
	D_BITS_PTHREADTYPES_COMMON_H                = 1                            // pthreadtypes.h:20:1:
	D_BITS_STDINT_INTN_H                        = 1                            // stdint-intn.h:20:1:
	D_BITS_STDINT_UINTN_H                       = 1                            // stdint-uintn.h:20:1:
	D_BITS_STDIO_LIM_H                          = 1                            // stdio_lim.h:19:1:
	D_BITS_TIME64_H                             = 1                            // time64.h:24:1:
	D_BITS_TYPESIZES_H                          = 1                            // typesizes.h:24:1:
	D_BITS_TYPES_H                              = 1                            // types.h:24:1:
	D_BITS_TYPES_LOCALE_T_H                     = 1                            // locale_t.h:20:1:
	D_BITS_TYPES___LOCALE_T_H                   = 1                            // __locale_t.h:21:1:
	D_BITS_UINTN_IDENTITY_H                     = 1                            // uintn-identity.h:24:1:
	D_BITS_WCHAR_H                              = 1                            // wchar.h:20:1:
	D_BSD_SIZE_T_                               = 0                            // stddef.h:189:1:
	D_BSD_SIZE_T_DEFINED_                       = 0                            // stddef.h:192:1:
	D_DEFAULT_SOURCE                            = 1                            // features.h:227:1:
	D_ENDIAN_H                                  = 1                            // endian.h:19:1:
	D_FEATURES_H                                = 1                            // features.h:19:1:
	D_FILE_OFFSET_BITS                          = 64                           // <builtin>:25:1:
	D_GCC_SIZE_T                                = 0                            // stddef.h:195:1:
	D_GCC_WCHAR_T                               = 0                            // stddef.h:273:1:
	D_GCC_WRAP_STDINT_H                         = 0                            // stdint.h:13:1:
	D_IOFBF                                     = 0                            // stdio.h:93:1:
	D_IOLBF                                     = 1                            // stdio.h:94:1:
	D_IONBF                                     = 2                            // stdio.h:95:1:
	D_IO_EOF_SEEN                               = 0x0010                       // struct_FILE.h:111:1:
	D_IO_ERR_SEEN                               = 0x0020                       // struct_FILE.h:114:1:
	D_IO_USER_LOCK                              = 0x8000                       // struct_FILE.h:117:1:
	D_LP64                                      = 1                            // <predefined>:284:1:
	D_MATH_H                                    = 1                            // math.h:24:1:
	D_OPJ_COLOR_H_                              = 0                            // color.h:39:1:
	D_POSIX_C_SOURCE                            = 200809                       // features.h:281:1:
	D_POSIX_SOURCE                              = 1                            // features.h:279:1:
	D_RWLOCK_INTERNAL_H                         = 0                            // struct_rwlock.h:21:1:
	D_SIZET_                                    = 0                            // stddef.h:196:1:
	D_SIZE_T                                    = 0                            // stddef.h:183:1:
	D_SIZE_T_                                   = 0                            // stddef.h:188:1:
	D_SIZE_T_DECLARED                           = 0                            // stddef.h:193:1:
	D_SIZE_T_DEFINED                            = 0                            // stddef.h:191:1:
	D_SIZE_T_DEFINED_                           = 0                            // stddef.h:190:1:
	D_STDC_PREDEF_H                             = 1                            // <predefined>:162:1:
	D_STDINT_H                                  = 1                            // stdint.h:23:1:
	D_STDIO_H                                   = 1                            // stdio.h:24:1:
	D_STDLIB_H                                  = 1                            // stdlib.h:35:1:
	D_STRINGS_H                                 = 1                            // strings.h:19:1:
	D_STRING_H                                  = 1                            // string.h:23:1:
	D_STRUCT_TIMESPEC                           = 1                            // struct_timespec.h:3:1:
	D_SYS_CDEFS_H                               = 1                            // cdefs.h:19:1:
	D_SYS_SELECT_H                              = 1                            // select.h:22:1:
	D_SYS_SIZE_T_H                              = 0                            // stddef.h:184:1:
	D_SYS_TYPES_H                               = 1                            // types.h:23:1:
	D_THREAD_MUTEX_INTERNAL_H                   = 1                            // struct_mutex.h:20:1:
	D_THREAD_SHARED_TYPES_H                     = 1                            // thread-shared-types.h:20:1:
	D_T_SIZE                                    = 0                            // stddef.h:186:1:
	D_T_SIZE_                                   = 0                            // stddef.h:185:1:
	D_T_WCHAR                                   = 0                            // stddef.h:264:1:
	D_T_WCHAR_                                  = 0                            // stddef.h:263:1:
	D_VA_LIST_DEFINED                           = 0                            // stdio.h:53:1:
	D_WCHAR_T                                   = 0                            // stddef.h:262:1:
	D_WCHAR_T_                                  = 0                            // stddef.h:266:1:
	D_WCHAR_T_DECLARED                          = 0                            // stddef.h:274:1:
	D_WCHAR_T_DEFINED                           = 0                            // stddef.h:269:1:
	D_WCHAR_T_DEFINED_                          = 0                            // stddef.h:268:1:
	D_WCHAR_T_H                                 = 0                            // stddef.h:270:1:
	Dlinux                                      = 1                            // <predefined>:231:1:
	Dmath_errhandling                           = 3                            // math.h:967:1:
	Dunix                                       = 1                            // <predefined>:177:1:
	DAIO_PRIO_DELTA_MAX                         = 20                           // local_lim.h:78:1:
	DBC_BASE_MAX                                = 99                           // posix2_lim.h:63:1:
	DBC_DIM_MAX                                 = 2048                         // posix2_lim.h:66:1:
	DBC_SCALE_MAX                               = 99                           // posix2_lim.h:69:1:
	DBC_STRING_MAX                              = 1000                         // posix2_lim.h:72:1:
	DBYPASS_CT_INIT                             = 0xDEADBEEF                   // mqc.h:99:1:
	DCHARCLASS_NAME_MAX                         = 2048                         // posix2_lim.h:84:1:
	DCHAR_BIT                                   = 8                            // limits.h:64:1:
	DCHAR_MAX                                   = 127                          // limits.h:99:1:
	DCHAR_MIN                                   = -128                         // limits.h:97:1:
	DCLOCK_BOOTTIME                             = 7                            // time.h:60:1:
	DCLOCK_BOOTTIME_ALARM                       = 9                            // time.h:64:1:
	DCLOCK_MONOTONIC                            = 1                            // time.h:48:1:
	DCLOCK_MONOTONIC_COARSE                     = 6                            // time.h:58:1:
	DCLOCK_MONOTONIC_RAW                        = 4                            // time.h:54:1:
	DCLOCK_PROCESS_CPUTIME_ID                   = 2                            // time.h:50:1:
	DCLOCK_REALTIME                             = 0                            // time.h:46:1:
	DCLOCK_REALTIME_ALARM                       = 8                            // time.h:62:1:
	DCLOCK_REALTIME_COARSE                      = 5                            // time.h:56:1:
	DCLOCK_TAI                                  = 11                           // time.h:66:1:
	DCLOCK_THREAD_CPUTIME_ID                    = 3                            // time.h:52:1:
	DCOLL_WEIGHTS_MAX                           = 255                          // posix2_lim.h:75:1:
	DDBL_DECIMAL_DIG                            = 17                           // float.h:220:1:
	DDBL_DIG                                    = 15                           // float.h:54:1:
	DDBL_HAS_SUBNORM                            = 1                            // float.h:228:1:
	DDBL_MANT_DIG                               = 53                           // float.h:40:1:
	DDBL_MAX_10_EXP                             = 308                          // float.h:94:1:
	DDBL_MAX_EXP                                = 1024                         // float.h:82:1:
	DDBL_MIN_10_EXP                             = -307                         // float.h:74:1:
	DDBL_MIN_EXP                                = -1021                        // float.h:62:1:
	DDECIMAL_DIG                                = 21                           // float.h:209:1:
	DDELAYTIMER_MAX                             = 2147483647                   // local_lim.h:84:1:
	DEVT_ERROR                                  = 1                            // event.h:66:1:
	DEVT_INFO                                   = 4                            // event.h:68:1:
	DEVT_WARNING                                = 2                            // event.h:67:1:
	DEXPR_NEST_MAX                              = 32                           // posix2_lim.h:78:1:
	DFLT_DECIMAL_DIG                            = 9                            // float.h:219:1:
	DFLT_DIG                                    = 6                            // float.h:53:1:
	DFLT_EPSILON                                = 0                            // float.h:113:1:
	DFLT_EVAL_METHOD                            = 0                            // float.h:197:1:
	DFLT_HAS_SUBNORM                            = 1                            // float.h:227:1:
	DFLT_MANT_DIG                               = 24                           // float.h:39:1:
	DFLT_MAX                                    = 0                            // float.h:104:1:
	DFLT_MAX_10_EXP                             = 38                           // float.h:93:1:
	DFLT_MAX_EXP                                = 128                          // float.h:81:1:
	DFLT_MIN                                    = 0                            // float.h:121:1:
	DFLT_MIN_10_EXP                             = -37                          // float.h:73:1:
	DFLT_MIN_EXP                                = -125                         // float.h:61:1:
	DFLT_RADIX                                  = 2                            // float.h:33:1:
	DFLT_ROUNDS                                 = 1                            // float.h:128:1:
	DHOST_NAME_MAX                              = 64                           // local_lim.h:93:1:
	DINT_MAX                                    = 2147483647                   // limits.h:120:1:
	DINT_MIN                                    = -2147483648                  // limits.h:118:1:
	DJ2K_CCP_CBLKSTY_HT                         = 0x40                         // j2k.h:64:1:
	DJ2K_CCP_CBLKSTY_HTMIXED                    = 0x80                         // j2k.h:65:1:
	DJ2K_CCP_CBLKSTY_LAZY                       = 0x01                         // j2k.h:58:1:
	DJ2K_CCP_CBLKSTY_PTERM                      = 0x10                         // j2k.h:62:1:
	DJ2K_CCP_CBLKSTY_RESET                      = 0x02                         // j2k.h:59:1:
	DJ2K_CCP_CBLKSTY_SEGSYM                     = 0x20                         // j2k.h:63:1:
	DJ2K_CCP_CBLKSTY_TERMALL                    = 0x04                         // j2k.h:60:1:
	DJ2K_CCP_CBLKSTY_VSC                        = 0x08                         // j2k.h:61:1:
	DJ2K_CCP_CSTY_PRT                           = 0x01                         // j2k.h:57:1:
	DJ2K_CCP_QNTSTY_NOQNT                       = 0                            // j2k.h:66:1:
	DJ2K_CCP_QNTSTY_SEQNT                       = 2                            // j2k.h:68:1:
	DJ2K_CCP_QNTSTY_SIQNT                       = 1                            // j2k.h:67:1:
	DJ2K_CP_CSTY_EPH                            = 0x04                         // j2k.h:56:1:
	DJ2K_CP_CSTY_PRT                            = 0x01                         // j2k.h:54:1:
	DJ2K_CP_CSTY_SOP                            = 0x02                         // j2k.h:55:1:
	DJ2K_MAX_POCS                               = 32                           // j2k.h:114:1:
	DJ2K_MS_CAP                                 = 0xff50                       // j2k.h:76:1:
	DJ2K_MS_CBD                                 = 0xff78                       // j2k.h:94:1:
	DJ2K_MS_COC                                 = 0xff53                       // j2k.h:79:1:
	DJ2K_MS_COD                                 = 0xff52                       // j2k.h:78:1:
	DJ2K_MS_COM                                 = 0xff64                       // j2k.h:93:1:
	DJ2K_MS_CPF                                 = 0xff59                       // j2k.h:80:1:
	DJ2K_MS_CRG                                 = 0xff63                       // j2k.h:92:1:
	DJ2K_MS_EOC                                 = 0xffd9                       // j2k.h:75:1:
	DJ2K_MS_EPH                                 = 0xff92                       // j2k.h:91:1:
	DJ2K_MS_MCC                                 = 0xff75                       // j2k.h:95:1:
	DJ2K_MS_MCO                                 = 0xff77                       // j2k.h:97:1:
	DJ2K_MS_MCT                                 = 0xff74                       // j2k.h:96:1:
	DJ2K_MS_PLM                                 = 0xff57                       // j2k.h:86:1:
	DJ2K_MS_PLT                                 = 0xff58                       // j2k.h:87:1:
	DJ2K_MS_POC                                 = 0xff5f                       // j2k.h:84:1:
	DJ2K_MS_PPM                                 = 0xff60                       // j2k.h:88:1:
	DJ2K_MS_PPT                                 = 0xff61                       // j2k.h:89:1:
	DJ2K_MS_QCC                                 = 0xff5d                       // j2k.h:83:1:
	DJ2K_MS_QCD                                 = 0xff5c                       // j2k.h:82:1:
	DJ2K_MS_RGN                                 = 0xff5e                       // j2k.h:81:1:
	DJ2K_MS_SIZ                                 = 0xff51                       // j2k.h:77:1:
	DJ2K_MS_SOC                                 = 0xff4f                       // j2k.h:72:1:
	DJ2K_MS_SOD                                 = 0xff93                       // j2k.h:74:1:
	DJ2K_MS_SOP                                 = 0xff91                       // j2k.h:90:1:
	DJ2K_MS_SOT                                 = 0xff90                       // j2k.h:73:1:
	DJ2K_MS_TLM                                 = 0xff55                       // j2k.h:85:1:
	DJ2K_MS_UNK                                 = 0                            // j2k.h:99:1:
	DJP2_BPCC                                   = 0x62706363                   // jp2.h:60:1:
	DJP2_CDEF                                   = 0x63646566                   // jp2.h:58:1:
	DJP2_CMAP                                   = 0x636d6170                   // jp2.h:57:1:
	DJP2_COLR                                   = 0x636f6c72                   // jp2.h:53:1:
	DJP2_DTBL                                   = 0x6474626c                   // jp2.h:59:1:
	DJP2_FTYP                                   = 0x66747970                   // jp2.h:50:1:
	DJP2_IHDR                                   = 0x69686472                   // jp2.h:52:1:
	DJP2_JP                                     = 0x6a502020                   // jp2.h:49:1:
	DJP2_JP2                                    = 0x6a703220                   // jp2.h:61:1:
	DJP2_JP2C                                   = 0x6a703263                   // jp2.h:54:1:
	DJP2_JP2H                                   = 0x6a703268                   // jp2.h:51:1:
	DJP2_PCLR                                   = 0x70636c72                   // jp2.h:56:1:
	DJP2_URL                                    = 0x75726c20                   // jp2.h:55:1:
	DLDBL_DECIMAL_DIG                           = 21                           // float.h:221:1:
	DLDBL_DIG                                   = 18                           // float.h:55:1:
	DLDBL_EPSILON                               = 0                            // float.h:115:1:
	DLDBL_HAS_SUBNORM                           = 1                            // float.h:229:1:
	DLDBL_MANT_DIG                              = 64                           // float.h:41:1:
	DLDBL_MAX                                   = 0                            // float.h:106:1:
	DLDBL_MAX_10_EXP                            = 4932                         // float.h:95:1:
	DLDBL_MAX_EXP                               = 16384                        // float.h:83:1:
	DLDBL_MIN                                   = 0                            // float.h:123:1:
	DLDBL_MIN_10_EXP                            = -4931                        // float.h:75:1:
	DLDBL_MIN_EXP                               = -16381                       // float.h:63:1:
	DLINE_MAX                                   = 2048                         // posix2_lim.h:81:1:
	DLLONG_MAX                                  = 9223372036854775807          // limits.h:142:1:
	DLLONG_MIN                                  = -9223372036854775808         // limits.h:140:1:
	DLOGIN_NAME_MAX                             = 256                          // local_lim.h:90:1:
	DLONG_MAX                                   = 9223372036854775807          // limits.h:131:1:
	DLONG_MIN                                   = -9223372036854775808         // limits.h:129:1:
	DMAX_CANON                                  = 255                          // limits.h:10:1:
	DMAX_INPUT                                  = 255                          // limits.h:11:1:
	DMB_LEN_MAX                                 = 16                           // limits.h:32:1:
	DMQC_NUMCTXS                                = 19                           // mqc.h:69:1:
	DMQ_PRIO_MAX                                = 32768                        // local_lim.h:96:1:
	DNAME_MAX                                   = 255                          // limits.h:12:1:
	DNGROUPS_MAX                                = 65536                        // limits.h:7:1:
	DOPJ_BIO_H                                  = 0                            // bio.h:39:1:
	DOPJ_CIO_H                                  = 0                            // cio.h:41:1:
	DOPJ_CLOCK_H                                = 0                            // opj_clock.h:32:1:
	DOPJ_CODEC_H                                = 0                            // opj_codec.h:33:1:
	DOPJ_COMMMON_H                              = 0                            // opj_common.h:32:1:
	DOPJ_COMMON_CBLK_DATA_EXTRA                 = 2                            // opj_common.h:39:1:
	DOPJ_COMP_PARAM_DEFAULT_CBLOCKH             = 64                           // opj_common.h:43:1:
	DOPJ_COMP_PARAM_DEFAULT_CBLOCKW             = 64                           // opj_common.h:42:1:
	DOPJ_COMP_PARAM_DEFAULT_NUMRESOLUTION       = 6                            // opj_common.h:45:1:
	DOPJ_DWT_H                                  = 0                            // dwt.h:39:1:
	DOPJ_EVENT_H                                = 0                            // event.h:34:1:
	DOPJ_FUNCTION_LIST_H                        = 0                            // function_list.h:33:1:
	DOPJ_IMAGE_H                                = 0                            // image.h:32:1:
	DOPJ_INCLUDES_H                             = 0                            // opj_includes.h:34:1:
	DOPJ_INTMATH_H                              = 0                            // opj_intmath.h:38:1:
	DOPJ_INTTYPES_H                             = 0                            // opj_inttypes.h:32:1:
	DOPJ_INVERT_H                               = 0                            // invert.h:33:1:
	DOPJ_J2K_H                                  = 0                            // j2k.h:43:1:
	DOPJ_JP2_H                                  = 0                            // jp2.h:37:1:
	DOPJ_MALLOC_H                               = 0                            // opj_malloc.h:33:1:
	DOPJ_MCT_H                                  = 0                            // mct.h:41:1:
	DOPJ_MQC_H                                  = 0                            // mqc.h:40:1:
	DOPJ_MQC_INL_H                              = 0                            // mqc_inl.h:40:1:
	DOPJ_PI_H                                   = 0                            // pi.h:39:1:
	DOPJ_SKIP_POISON                            = 0                            // opj_includes.h:35:1:
	DOPJ_SPARSE_ARRAY_H                         = 0                            // sparse_array.h:35:1:
	DOPJ_STREAM_STATUS_END                      = 0x4                          // cio.h:75:1:
	DOPJ_STREAM_STATUS_ERROR                    = 0x8                          // cio.h:76:1:
	DOPJ_STREAM_STATUS_INPUT                    = 0x2                          // cio.h:74:1:
	DOPJ_STREAM_STATUS_OUTPUT                   = 0x1                          // cio.h:73:1:
	DOPJ_T1_H                                   = 0                            // t1.h:40:1:
	DOPJ_T2_H                                   = 0                            // t2.h:41:1:
	DOPJ_TCD_H                                  = 0                            // tcd.h:41:1:
	DOPJ_TGT_H                                  = 0                            // tgt.h:42:1:
	DOPJ_TLS_KEYS_H                             = 0                            // tls_keys.h:33:1:
	DOPJ_TLS_KEY_T1                             = 0                            // tls_keys.h:35:1:
	DPATH_MAX                                   = 4096                         // limits.h:13:1:
	DPIPE_BUF                                   = 4096                         // limits.h:14:1:
	DPRIX16                                     = "X"                          // inttypes.h:135:1:
	DPRIX32                                     = "X"                          // inttypes.h:136:1:
	DPRIX8                                      = "X"                          // inttypes.h:134:1:
	DPRIXFAST8                                  = "X"                          // inttypes.h:144:1:
	DPRIXLEAST16                                = "X"                          // inttypes.h:140:1:
	DPRIXLEAST32                                = "X"                          // inttypes.h:141:1:
	DPRIXLEAST8                                 = "X"                          // inttypes.h:139:1:
	DPRId16                                     = "d"                          // inttypes.h:55:1:
	DPRId32                                     = "d"                          // inttypes.h:56:1:
	DPRId8                                      = "d"                          // inttypes.h:54:1:
	DPRIdFAST8                                  = "d"                          // inttypes.h:64:1:
	DPRIdLEAST16                                = "d"                          // inttypes.h:60:1:
	DPRIdLEAST32                                = "d"                          // inttypes.h:61:1:
	DPRIdLEAST8                                 = "d"                          // inttypes.h:59:1:
	DPRIi16                                     = "i"                          // inttypes.h:71:1:
	DPRIi32                                     = "i"                          // inttypes.h:72:1:
	DPRIi8                                      = "i"                          // inttypes.h:70:1:
	DPRIiFAST8                                  = "i"                          // inttypes.h:80:1:
	DPRIiLEAST16                                = "i"                          // inttypes.h:76:1:
	DPRIiLEAST32                                = "i"                          // inttypes.h:77:1:
	DPRIiLEAST8                                 = "i"                          // inttypes.h:75:1:
	DPRIo16                                     = "o"                          // inttypes.h:87:1:
	DPRIo32                                     = "o"                          // inttypes.h:88:1:
	DPRIo8                                      = "o"                          // inttypes.h:86:1:
	DPRIoFAST8                                  = "o"                          // inttypes.h:96:1:
	DPRIoLEAST16                                = "o"                          // inttypes.h:92:1:
	DPRIoLEAST32                                = "o"                          // inttypes.h:93:1:
	DPRIoLEAST8                                 = "o"                          // inttypes.h:91:1:
	DPRIu16                                     = "u"                          // inttypes.h:103:1:
	DPRIu32                                     = "u"                          // inttypes.h:104:1:
	DPRIu8                                      = "u"                          // inttypes.h:102:1:
	DPRIuFAST8                                  = "u"                          // inttypes.h:112:1:
	DPRIuLEAST16                                = "u"                          // inttypes.h:108:1:
	DPRIuLEAST32                                = "u"                          // inttypes.h:109:1:
	DPRIuLEAST8                                 = "u"                          // inttypes.h:107:1:
	DPRIx16                                     = "x"                          // inttypes.h:119:1:
	DPRIx32                                     = "x"                          // inttypes.h:120:1:
	DPRIx8                                      = "x"                          // inttypes.h:118:1:
	DPRIxFAST8                                  = "x"                          // inttypes.h:128:1:
	DPRIxLEAST16                                = "x"                          // inttypes.h:124:1:
	DPRIxLEAST32                                = "x"                          // inttypes.h:125:1:
	DPRIxLEAST8                                 = "x"                          // inttypes.h:123:1:
	DPTHREAD_DESTRUCTOR_ITERATIONS              = 4                            // local_lim.h:69:1:
	DPTHREAD_KEYS_MAX                           = 1024                         // local_lim.h:64:1:
	DPTHREAD_STACK_MIN                          = 16384                        // local_lim.h:81:1:
	DRE_DUP_MAX                                 = 32767                        // posix2_lim.h:88:1:
	DRTSIG_MAX                                  = 32                           // limits.h:19:1:
	DSCHAR_MAX                                  = 127                          // limits.h:75:1:
	DSCHAR_MIN                                  = -128                         // limits.h:73:1:
	DSCNd16                                     = "hd"                         // inttypes.h:172:1:
	DSCNd32                                     = "d"                          // inttypes.h:173:1:
	DSCNd8                                      = "hhd"                        // inttypes.h:171:1:
	DSCNdFAST8                                  = "hhd"                        // inttypes.h:181:1:
	DSCNdLEAST16                                = "hd"                         // inttypes.h:177:1:
	DSCNdLEAST32                                = "d"                          // inttypes.h:178:1:
	DSCNdLEAST8                                 = "hhd"                        // inttypes.h:176:1:
	DSCNi16                                     = "hi"                         // inttypes.h:188:1:
	DSCNi32                                     = "i"                          // inttypes.h:189:1:
	DSCNi8                                      = "hhi"                        // inttypes.h:187:1:
	DSCNiFAST8                                  = "hhi"                        // inttypes.h:197:1:
	DSCNiLEAST16                                = "hi"                         // inttypes.h:193:1:
	DSCNiLEAST32                                = "i"                          // inttypes.h:194:1:
	DSCNiLEAST8                                 = "hhi"                        // inttypes.h:192:1:
	DSCNo16                                     = "ho"                         // inttypes.h:220:1:
	DSCNo32                                     = "o"                          // inttypes.h:221:1:
	DSCNo8                                      = "hho"                        // inttypes.h:219:1:
	DSCNoFAST8                                  = "hho"                        // inttypes.h:229:1:
	DSCNoLEAST16                                = "ho"                         // inttypes.h:225:1:
	DSCNoLEAST32                                = "o"                          // inttypes.h:226:1:
	DSCNoLEAST8                                 = "hho"                        // inttypes.h:224:1:
	DSCNu16                                     = "hu"                         // inttypes.h:204:1:
	DSCNu32                                     = "u"                          // inttypes.h:205:1:
	DSCNu8                                      = "hhu"                        // inttypes.h:203:1:
	DSCNuFAST8                                  = "hhu"                        // inttypes.h:213:1:
	DSCNuLEAST16                                = "hu"                         // inttypes.h:209:1:
	DSCNuLEAST32                                = "u"                          // inttypes.h:210:1:
	DSCNuLEAST8                                 = "hhu"                        // inttypes.h:208:1:
	DSCNx16                                     = "hx"                         // inttypes.h:236:1:
	DSCNx32                                     = "x"                          // inttypes.h:237:1:
	DSCNx8                                      = "hhx"                        // inttypes.h:235:1:
	DSCNxFAST8                                  = "hhx"                        // inttypes.h:245:1:
	DSCNxLEAST16                                = "hx"                         // inttypes.h:241:1:
	DSCNxLEAST32                                = "x"                          // inttypes.h:242:1:
	DSCNxLEAST8                                 = "hhx"                        // inttypes.h:240:1:
	DSEM_VALUE_MAX                              = 2147483647                   // local_lim.h:99:1:
	DSHRT_MAX                                   = 32767                        // limits.h:106:1:
	DSHRT_MIN                                   = -32768                       // limits.h:104:1:
	DSSIZE_MAX                                  = 9223372036854775807          // posix1_lim.h:169:1:
	DT1_CHI_0                                   = 262144                       // t1.h:110:1:
	DT1_CHI_0_I                                 = 18                           // t1.h:111:1:
	DT1_CHI_1                                   = 524288                       // t1.h:112:1:
	DT1_CHI_1_I                                 = 19                           // t1.h:113:1:
	DT1_CHI_2                                   = 4194304                      // t1.h:116:1:
	DT1_CHI_2_I                                 = 22                           // t1.h:117:1:
	DT1_CHI_3                                   = 33554432                     // t1.h:120:1:
	DT1_CHI_4                                   = 268435456                    // t1.h:123:1:
	DT1_CHI_5                                   = 2147483648                   // t1.h:126:1:
	DT1_CHI_5_I                                 = 31                           // t1.h:127:1:
	DT1_CHI_S                                   = 4194304                      // t1.h:164:1:
	DT1_CHI_THIS                                = 524288                       // t1.h:160:1:
	DT1_CHI_THIS_I                              = 19                           // t1.h:161:1:
	DT1_CTXNO_AGG                               = 17                           // t1.h:64:1:
	DT1_CTXNO_MAG                               = 14                           // t1.h:63:1:
	DT1_CTXNO_SC                                = 9                            // t1.h:62:1:
	DT1_CTXNO_UNI                               = 18                           // t1.h:65:1:
	DT1_CTXNO_ZC                                = 0                            // t1.h:61:1:
	DT1_LUT_SGN_E                               = 4                            // t1.h:168:1:
	DT1_LUT_SGN_N                               = 16                           // t1.h:170:1:
	DT1_LUT_SGN_S                               = 64                           // t1.h:172:1:
	DT1_LUT_SGN_W                               = 1                            // t1.h:166:1:
	DT1_LUT_SIG_E                               = 32                           // t1.h:171:1:
	DT1_LUT_SIG_N                               = 2                            // t1.h:167:1:
	DT1_LUT_SIG_S                               = 128                          // t1.h:173:1:
	DT1_LUT_SIG_W                               = 8                            // t1.h:169:1:
	DT1_MU_0                                    = 1048576                      // t1.h:114:1:
	DT1_MU_1                                    = 8388608                      // t1.h:118:1:
	DT1_MU_2                                    = 67108864                     // t1.h:121:1:
	DT1_MU_3                                    = 536870912                    // t1.h:124:1:
	DT1_MU_THIS                                 = 1048576                      // t1.h:162:1:
	DT1_NMSEDEC_BITS                            = 7                            // t1.h:53:1:
	DT1_NMSEDEC_FRACBITS                        = 6                            // t1.h:68:1:
	DT1_NUMCTXS                                 = 19                           // t1.h:66:1:
	DT1_NUMCTXS_AGG                             = 1                            // t1.h:58:1:
	DT1_NUMCTXS_MAG                             = 3                            // t1.h:57:1:
	DT1_NUMCTXS_SC                              = 5                            // t1.h:56:1:
	DT1_NUMCTXS_UNI                             = 1                            // t1.h:59:1:
	DT1_NUMCTXS_ZC                              = 9                            // t1.h:55:1:
	DT1_PI_0                                    = 2097152                      // t1.h:115:1:
	DT1_PI_1                                    = 16777216                     // t1.h:119:1:
	DT1_PI_2                                    = 134217728                    // t1.h:122:1:
	DT1_PI_3                                    = 1073741824                   // t1.h:125:1:
	DT1_PI_THIS                                 = 2097152                      // t1.h:163:1:
	DT1_SIGMA_0                                 = 1                            // t1.h:91:1:
	DT1_SIGMA_1                                 = 2                            // t1.h:92:1:
	DT1_SIGMA_10                                = 1024                         // t1.h:101:1:
	DT1_SIGMA_11                                = 2048                         // t1.h:102:1:
	DT1_SIGMA_12                                = 4096                         // t1.h:103:1:
	DT1_SIGMA_13                                = 8192                         // t1.h:104:1:
	DT1_SIGMA_14                                = 16384                        // t1.h:105:1:
	DT1_SIGMA_15                                = 32768                        // t1.h:106:1:
	DT1_SIGMA_16                                = 65536                        // t1.h:107:1:
	DT1_SIGMA_17                                = 131072                       // t1.h:108:1:
	DT1_SIGMA_2                                 = 4                            // t1.h:93:1:
	DT1_SIGMA_3                                 = 8                            // t1.h:94:1:
	DT1_SIGMA_4                                 = 16                           // t1.h:95:1:
	DT1_SIGMA_5                                 = 32                           // t1.h:96:1:
	DT1_SIGMA_6                                 = 64                           // t1.h:97:1:
	DT1_SIGMA_7                                 = 128                          // t1.h:98:1:
	DT1_SIGMA_8                                 = 256                          // t1.h:99:1:
	DT1_SIGMA_9                                 = 512                          // t1.h:100:1:
	DT1_SIGMA_E                                 = 32                           // t1.h:154:1:
	DT1_SIGMA_N                                 = 2                            // t1.h:150:1:
	DT1_SIGMA_NE                                = 4                            // t1.h:151:1:
	DT1_SIGMA_NEIGHBOURS                        = 495                          // t1.h:158:1:
	DT1_SIGMA_NW                                = 1                            // t1.h:149:1:
	DT1_SIGMA_S                                 = 128                          // t1.h:156:1:
	DT1_SIGMA_SE                                = 256                          // t1.h:157:1:
	DT1_SIGMA_SW                                = 64                           // t1.h:155:1:
	DT1_SIGMA_THIS                              = 16                           // t1.h:153:1:
	DT1_SIGMA_W                                 = 8                            // t1.h:152:1:
	DT1_TYPE_MQ                                 = 0                            // t1.h:70:1:
	DT1_TYPE_RAW                                = 1                            // t1.h:71:1:
	DTHREAD_H                                   = 0                            // thread.h:33:1:
	DTIMER_ABSTIME                              = 1                            // time.h:69:1:
	DTIME_UTC                                   = 1                            // time.h:65:1:
	DTTY_NAME_MAX                               = 32                           // local_lim.h:87:1:
	DUCHAR_MAX                                  = 255                          // limits.h:82:1:
	DUINT_MAX                                   = 4294967295                   // limits.h:124:1:
	DULLONG_MAX                                 = 18446744073709551615         // limits.h:146:1:
	DULONG_MAX                                  = 18446744073709551615         // limits.h:135:1:
	DUSHRT_MAX                                  = 65535                        // limits.h:113:1:
	DXATTR_LIST_MAX                             = 65536                        // limits.h:17:1:
	DXATTR_NAME_MAX                             = 255                          // limits.h:15:1:
	DXATTR_SIZE_MAX                             = 65536                        // limits.h:16:1:
	D_ANSI_STDARG_H_                            = 0                            // stdarg.h:32:1:
	D_ANSI_STDDEF_H                             = 0                            // stddef.h:42:1:
	D_BITS_POSIX1_LIM_H                         = 1                            // posix1_lim.h:25:1:
	D_BITS_POSIX2_LIM_H                         = 1                            // posix2_lim.h:23:1:
	D_BITS_TIME_H                               = 1                            // time.h:24:1:
	D_BSD_PTRDIFF_T_                            = 0                            // stddef.h:136:1:
	D_CTYPE_H                                   = 1                            // ctype.h:23:1:
	D_FLOAT_H___                                = 0                            // float.h:29:1:
	D_GCC_LIMITS_H_                             = 0                            // limits.h:30:1:
	D_GCC_MAX_ALIGN_T                           = 0                            // stddef.h:411:1:
	D_GCC_PTRDIFF_T                             = 0                            // stddef.h:138:1:
	D_INTTYPES_H                                = 1                            // inttypes.h:23:1:
	D_LIBC_LIMITS_H_                            = 1                            // limits.h:23:1:
	D_LIMITS_H___                               = 0                            // limits.h:60:1:
	D_LINUX_LIMITS_H                            = 0                            // limits.h:3:1:
	D_MEMORY_H                                  = 1                            // memory.h:23:1:
	D_POSIX2_BC_BASE_MAX                        = 99                           // posix2_lim.h:27:1:
	D_POSIX2_BC_DIM_MAX                         = 2048                         // posix2_lim.h:30:1:
	D_POSIX2_BC_SCALE_MAX                       = 99                           // posix2_lim.h:33:1:
	D_POSIX2_BC_STRING_MAX                      = 1000                         // posix2_lim.h:36:1:
	D_POSIX2_CHARCLASS_NAME_MAX                 = 14                           // posix2_lim.h:55:1:
	D_POSIX2_COLL_WEIGHTS_MAX                   = 2                            // posix2_lim.h:40:1:
	D_POSIX2_EXPR_NEST_MAX                      = 32                           // posix2_lim.h:44:1:
	D_POSIX2_LINE_MAX                           = 2048                         // posix2_lim.h:47:1:
	D_POSIX2_RE_DUP_MAX                         = 255                          // posix2_lim.h:51:1:
	D_POSIX_AIO_LISTIO_MAX                      = 2                            // posix1_lim.h:32:1:
	D_POSIX_AIO_MAX                             = 1                            // posix1_lim.h:35:1:
	D_POSIX_ARG_MAX                             = 4096                         // posix1_lim.h:38:1:
	D_POSIX_CHILD_MAX                           = 25                           // posix1_lim.h:42:1:
	D_POSIX_CLOCKRES_MIN                        = 20000000                     // posix1_lim.h:157:1:
	D_POSIX_DELAYTIMER_MAX                      = 32                           // posix1_lim.h:48:1:
	D_POSIX_HOST_NAME_MAX                       = 255                          // posix1_lim.h:52:1:
	D_POSIX_LINK_MAX                            = 8                            // posix1_lim.h:55:1:
	D_POSIX_LOGIN_NAME_MAX                      = 9                            // posix1_lim.h:58:1:
	D_POSIX_MAX_CANON                           = 255                          // posix1_lim.h:61:1:
	D_POSIX_MAX_INPUT                           = 255                          // posix1_lim.h:65:1:
	D_POSIX_MQ_OPEN_MAX                         = 8                            // posix1_lim.h:68:1:
	D_POSIX_MQ_PRIO_MAX                         = 32                           // posix1_lim.h:71:1:
	D_POSIX_NAME_MAX                            = 14                           // posix1_lim.h:74:1:
	D_POSIX_NGROUPS_MAX                         = 8                            // posix1_lim.h:78:1:
	D_POSIX_OPEN_MAX                            = 20                           // posix1_lim.h:85:1:
	D_POSIX_PATH_MAX                            = 256                          // posix1_lim.h:97:1:
	D_POSIX_PIPE_BUF                            = 512                          // posix1_lim.h:100:1:
	D_POSIX_RE_DUP_MAX                          = 255                          // posix1_lim.h:104:1:
	D_POSIX_RTSIG_MAX                           = 8                            // posix1_lim.h:107:1:
	D_POSIX_SEM_NSEMS_MAX                       = 256                          // posix1_lim.h:110:1:
	D_POSIX_SEM_VALUE_MAX                       = 32767                        // posix1_lim.h:113:1:
	D_POSIX_SIGQUEUE_MAX                        = 32                           // posix1_lim.h:116:1:
	D_POSIX_SSIZE_MAX                           = 32767                        // posix1_lim.h:119:1:
	D_POSIX_STREAM_MAX                          = 8                            // posix1_lim.h:122:1:
	D_POSIX_SYMLINK_MAX                         = 255                          // posix1_lim.h:125:1:
	D_POSIX_SYMLOOP_MAX                         = 8                            // posix1_lim.h:129:1:
	D_POSIX_THREAD_DESTRUCTOR_ITERATIONS        = 4                            // local_lim.h:67:1:
	D_POSIX_THREAD_KEYS_MAX                     = 128                          // local_lim.h:62:1:
	D_POSIX_THREAD_THREADS_MAX                  = 64                           // local_lim.h:72:1:
	D_POSIX_TIMER_MAX                           = 32                           // posix1_lim.h:132:1:
	D_POSIX_TTY_NAME_MAX                        = 9                            // posix1_lim.h:135:1:
	D_POSIX_TZNAME_MAX                          = 6                            // posix1_lim.h:139:1:
	D_PTRDIFF_T                                 = 0                            // stddef.h:131:1:
	D_PTRDIFF_T_                                = 0                            // stddef.h:135:1:
	D_PTRDIFF_T_DECLARED                        = 0                            // stddef.h:139:1:
	D_STDARG_H                                  = 0                            // stdarg.h:31:1:
	D_STDDEF_H                                  = 0                            // stddef.h:39:1:
	D_STDDEF_H_                                 = 0                            // stddef.h:40:1:
	D_TIME_H                                    = 1                            // time.h:23:1:
	D_T_PTRDIFF                                 = 0                            // stddef.h:133:1:
	D_T_PTRDIFF_                                = 0                            // stddef.h:132:1:
	D_VA_LIST                                   = 0                            // stdarg.h:108:1:
	D_VA_LIST_                                  = 0                            // stdarg.h:105:1:
	D_VA_LIST_T_H                               = 0                            // stdarg.h:114:1:
	DNB_ELTS_V8                                 = 8                            // dwt.c:95:1:
	DPARALLEL_COLS_53                           = 8                            // dwt.c:83:1:
	DSTANDARD_SLOW_VERSION                      = 1                            // dwt.c:45:1:
	DVREG_INT_COUNT                             = 4                            // dwt.c:79:1:
	DOPJ_MSG_SIZE                               = 512                          // event.c:94:1:
	DOPJ_VALIDATION_SIZE                        = 10                           // function_list.c:37:1:
	DBMP_DFMT                                   = 12                           // format_defs.h:47:1:
	DJ2K_CFMT                                   = 0                            // format_defs.h:41:1:
	DJP2_CFMT                                   = 1                            // format_defs.h:42:1:
	DJPT_CFMT                                   = 2                            // format_defs.h:43:1:
	DPGX_DFMT                                   = 11                           // format_defs.h:46:1:
	DPNG_DFMT                                   = 17                           // format_defs.h:52:1:
	DPXM_DFMT                                   = 10                           // format_defs.h:45:1:
	DRAWL_DFMT                                  = 18                           // format_defs.h:53:1:
	DRAW_DFMT                                   = 15                           // format_defs.h:50:1:
	DTGA_DFMT                                   = 16                           // format_defs.h:51:1:
	DTIF_DFMT                                   = 14                           // format_defs.h:49:1:
	DYUV_DFMT                                   = 13                           // format_defs.h:48:1:
	D_OPJ_FORMAT_DEFS_H_                        = 0                            // format_defs.h:39:1:
	DOPJ_COMPILER_GNUC                          = 0                            // ht_dec.c:55:1:
	DOPJ_BOX_SIZE                               = 1024                         // jp2.c:45:1:
)

const ( /* helper.c:43:1: */
	OPJ_PREC_MODE_CLIP  = 0
	OPJ_PREC_MODE_SCALE = 1
)

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2006-2007, Parvatha Elangovan
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France
// Copyright (c) 2012, CS Systemes d'Information, France
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file j2k.h
// @brief The JPEG-2000 Codestream Reader/Writer (J2K)
//
// The functions in J2K.C have for goal to read/write the several parts of the codestream: markers and data.

//* @defgroup J2K J2K - JPEG-2000 codestream reader/writer
//@{

// -----------------------------------------------------------------------

// UniPG>>
// <<UniPG

// -----------------------------------------------------------------------

// *
// Values that specify the status of the decoding process when decoding the main header.
// These values may be combined with a | operator.
//
const ( /* j2k.h:122:1: */
	J2K_STATE_NONE   = 0   //*< a SOC marker is expected
	J2K_STATE_MHSOC  = 1   //*< a SOC marker is expected
	J2K_STATE_MHSIZ  = 2   //*< a SIZ marker is expected
	J2K_STATE_MH     = 4   //*< the decoding process is in the main header
	J2K_STATE_TPHSOT = 8   //*< the decoding process is in a tile part header and expects a SOT marker
	J2K_STATE_TPH    = 16  //*< the decoding process is in a tile part header
	J2K_STATE_MT     = 32  //*< the EOC marker has just been read
	J2K_STATE_NEOC   = 64  //*< the decoding process must not expect a EOC marker because the codestream is truncated
	J2K_STATE_DATA   = 128 //*< a tile header has been successfully read and codestream is expected

	J2K_STATE_EOC = 256 //*< the decoding process has encountered the EOC marker
	J2K_STATE_ERR = 32768
)

// *
// Type of elements storing in the MCT data
const ( /* j2k.h:140:1: */
	MCT_TYPE_INT16  = 0 //* MCT data is stored as signed shorts
	MCT_TYPE_INT32  = 1 //* MCT data is stored as signed integers
	MCT_TYPE_FLOAT  = 2 //* MCT data is stored as floats
	MCT_TYPE_DOUBLE = 3
)

// *
// Type of MCT array
const ( /* j2k.h:150:1: */
	MCT_TYPE_DEPENDENCY    = 0
	MCT_TYPE_DECORRELATION = 1
	MCT_TYPE_OFFSET        = 2
)

// -----------------------------------------------------------------------

//*
// T2 encoding mode
const ( /* j2k.h:161:1: */
	THRESH_CALC = 0 //* Function called in Rate allocation process
	FINAL_PASS  = 1
)

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file jp2.h
// @brief The JPEG-2000 file format Reader/Writer (JP2)
//

//* @defgroup JP2 JP2 - JPEG-2000 file format reader/writer
//@{

//#define JPIP_JPIP 0x6a706970

// For the future
/* #define JP2_RES 0x72657320 */ //*< Resolution box (super-box)
/* #define JP2_JP2I 0x6a703269 */ //*< Intellectual property box
/* #define JP2_XML  0x786d6c20 */ //*< XML box
/* #define JP2_UUID 0x75756994 */ //*< UUID box
/* #define JP2_UINF 0x75696e66 */ //*< UUID info box (super-box)
/* #define JP2_ULST 0x756c7374 */ //*< UUID list box

// -----------------------------------------------------------------------

const ( /* jp2.h:73:1: */
	JP2_STATE_NONE           = 0
	JP2_STATE_SIGNATURE      = 1
	JP2_STATE_FILE_TYPE      = 2
	JP2_STATE_HEADER         = 4
	JP2_STATE_CODESTREAM     = 8
	JP2_STATE_END_CODESTREAM = 16
	JP2_STATE_UNKNOWN        = 2147483647
)

const ( /* jp2.h:84:1: */
	JP2_IMG_STATE_NONE    = 0
	JP2_IMG_STATE_UNKNOWN = 2147483647
)

// Avoid compile-time warning because parameter is not used

//
// ==========================================================
//    Useful constant definitions
// ==========================================================

/* UniPG>> */ // NOT YET USED IN THE V2 VERSION OF OPENJPEG
// <<UniPG

// *
// EXPERIMENTAL FOR THE MOMENT
// Supported options about file information used only in j2k_dump
/*FIXME #define OPJ_J2K_CSTR_IND    48*/ //*<

// *
// JPEG 2000 Profiles, see Table A.10 from 15444-1 (updated in various AMD)
// These values help choosing the RSIZ value for the J2K codestream.
// The RSIZ value triggers various encoding options, as detailed in Table A.10.
// If OPJ_PROFILE_PART2 is chosen, it has to be combined with one or more extensions
// described hereunder.
//   Example: rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;
// For broadcast profiles, the OPJ_PROFILE value has to be combined with the targeted
// mainlevel (3-0 LSB, value between 0 and 11):
//   Example: rsiz = OPJ_PROFILE_BC_MULTI | 0x0005; (here mainlevel 5)
// For IMF profiles, the OPJ_PROFILE value has to be combined with the targeted mainlevel
// (3-0 LSB, value between 0 and 11) and sublevel (7-4 LSB, value between 0 and 9):
//   Example: rsiz = OPJ_PROFILE_IMF_2K | 0x0040 | 0x0005; (here main 5 and sublevel 4)
//

// *
// JPEG 2000 Part-2 extensions
//

// *
// JPEG 2000 profile macros
//

//* Max. Components Sampling Rate (MSamples/sec) per IMF main level

//* Max. compressed Bit Rate (Mbits/s) per IMF sub level

// *
// JPEG 2000 codestream and component size limits in cinema profiles
//

//
// ==========================================================
//    enum definitions
// ==========================================================

// *
// DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead
// Rsiz Capabilities
//
const ( /* openjpeg.h:282:1: */
	OPJ_STD_RSIZ = 0 //* Standard JPEG2000 profile
	OPJ_CINEMA2K = 3 //* Profile name for a 2K image
	OPJ_CINEMA4K = 4 //* Profile name for a 4K image
	OPJ_MCT      = 33024
)

// *
// DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead
// Digital cinema operation mode
//
const ( /* openjpeg.h:293:1: */
	OPJ_OFF         = 0 //* Not Digital Cinema
	OPJ_CINEMA2K_24 = 1 //* 2K Digital Cinema at 24 fps
	OPJ_CINEMA2K_48 = 2 //* 2K Digital Cinema at 48 fps
	OPJ_CINEMA4K_24 = 3
)

// *
// Progression order
//
const ( /* openjpeg.h:303:1: */
	OPJ_PROG_UNKNOWN = -1 //*< place-holder
	OPJ_LRCP         = 0  //*< layer-resolution-component-precinct order
	OPJ_RLCP         = 1  //*< resolution-layer-component-precinct order
	OPJ_RPCL         = 2  //*< resolution-precinct-component-layer order
	OPJ_PCRL         = 3  //*< precinct-component-resolution-layer order
	OPJ_CPRL         = 4
)

// *
// Supported image color spaces
const ( /* openjpeg.h:315:1: */
	OPJ_CLRSPC_UNKNOWN     = -1 //*< not supported by the library
	OPJ_CLRSPC_UNSPECIFIED = 0  //*< not specified in the codestream
	OPJ_CLRSPC_SRGB        = 1  //*< sRGB
	OPJ_CLRSPC_GRAY        = 2  //*< grayscale
	OPJ_CLRSPC_SYCC        = 3  //*< YUV
	OPJ_CLRSPC_EYCC        = 4  //*< e-YCC
	OPJ_CLRSPC_CMYK        = 5
)

// *
// Supported codec
const ( /* openjpeg.h:328:1: */
	OPJ_CODEC_UNKNOWN = -1 //*< place-holder
	OPJ_CODEC_J2K     = 0  //*< JPEG-2000 codestream : read/write
	OPJ_CODEC_JPT     = 1  //*< JPT-stream (JPEG 2000, JPIP) : read only
	OPJ_CODEC_JP2     = 2  //*< JP2 file format : read/write
	OPJ_CODEC_JPP     = 3  //*< JPP-stream (JPEG 2000, JPIP) : to be coded
	OPJ_CODEC_JPX     = 4
)

const ( /* thread.c:587:1: */
	OPJWTS_OK    = 0
	OPJWTS_STOP  = 1
	OPJWTS_ERROR = 2
)

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

// Define the standard macros for the user,
//    if this invocation was from the user program.

// Define va_list, if desired, from __gnuc_va_list.
// We deliberately do not define va_list when called from
//    stdio.h, because ANSI C says that stdio.h is not supposed to define
//    va_list.  stdio.h needs to have access to that data type,
//    but must not use that name.  It should use the name __gnuc_va_list,
//    which is safe because it is reserved for the implementation.

// The macro _VA_LIST_ is the same thing used by this file in Ultrix.
//    But on BSD NET2 we must not test or define or undef it.
//    (Note that the comments in NET 2's ansi.h
//    are incorrect for _VA_LIST_--see stdio.h!)
// The macro _VA_LIST_DEFINED is used in Windows NT 3.5

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard 7.4: Character handling	<ctype.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// These are all the characteristics of characters.
//    If there get to be more than 16 distinct characteristics,
//    many things must be changed that use `unsigned short int's.
//
//    The characteristics are stored always in network byte order (big
//    endian).  We define the bit value interpretations here dependent on the
//    machine's byte order.

// Endian macros for string.h functions
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

const ( /* ctype.h:46:1: */
	_ISupper  = 256   // UPPERCASE.
	_ISlower  = 512   // lowercase.
	_ISalpha  = 1024  // Alphabetic.
	_ISdigit  = 2048  // Numeric.
	_ISxdigit = 4096  // Hexadecimal numeric.
	_ISspace  = 8192  // Whitespace.
	_ISprint  = 16384 // Printing.
	_ISgraph  = 32768 // Graphical.
	_ISblank  = 1     // Blank (usually SPC and TAB).
	_IScntrl  = 2     // Control character.
	_ISpunct  = 4     // Punctuation.
	_ISalnum  = 8
)

// Declare functions returning a narrower type.

// Depending on the type of TG_ARG, call an appropriately suffixed
//    version of FUNC with arguments (including parentheses) ARGS.
//    Suffixed functions may not exist for long double if it has the same
//    format as double, or for other types with the same format as float,
//    double or long double.  The behavior is undefined if the argument
//    does not have a real floating type.  The definition may use a
//    conditional expression, so all suffixed versions of FUNC must
//    return the same type (FUNC may include a cast if necessary rather
//    than being a single identifier).

// ISO C99 defines some generic macros which work on any data type.

// All floating-point numbers can be put in one of these categories.
const ( /* math.h:853:1: */
	FP_NAN       = 0
	FP_INFINITE  = 1
	FP_ZERO      = 2
	FP_SUBNORMAL = 3
	FP_NORMAL    = 4
)

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

const ( /* waitflags.h:52:1: */
	P_ALL  = 0 // Wait for any child.
	P_PID  = 1 // Wait for specified process.
	P_PGID = 2
)

type Tptrdiff_t = int32 /* <builtin>:3:26 */

type Tsize_t = uint32 /* <builtin>:9:23 */

type Twchar_t = int32 /* <builtin>:15:24 */

type T__int128_t = struct {
	Flo int32
	Fhi int32
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type T__uint128_t = struct {
	Flo uint32
	Fhi uint32
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type T__builtin_va_list = uintptr /* <builtin>:46:14 */
type T__float128 = float64        /* <builtin>:47:21 */

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type T__gnuc_va_list = T__builtin_va_list /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For others, time size is word size.

// Convenience types.
type T__u_char = uint8   /* types.h:31:23 */
type T__u_short = uint16 /* types.h:32:28 */
type T__u_int = uint32   /* types.h:33:22 */
type T__u_long = uint32  /* types.h:34:27 */

// Fixed-size types, underlying types depend on word size and compiler.
type T__int8_t = int8     /* types.h:37:21 */
type T__uint8_t = uint8   /* types.h:38:23 */
type T__int16_t = int16   /* types.h:39:26 */
type T__uint16_t = uint16 /* types.h:40:28 */
type T__int32_t = int32   /* types.h:41:20 */
type T__uint32_t = uint32 /* types.h:42:22 */
type T__int64_t = int32   /* types.h:44:25 */
type T__uint64_t = uint32 /* types.h:45:27 */

// Smallest types with at least a given width.
type T__int_least8_t = T__int8_t     /* types.h:52:18 */
type T__uint_least8_t = T__uint8_t   /* types.h:53:19 */
type T__int_least16_t = T__int16_t   /* types.h:54:19 */
type T__uint_least16_t = T__uint16_t /* types.h:55:20 */
type T__int_least32_t = T__int32_t   /* types.h:56:19 */
type T__uint_least32_t = T__uint32_t /* types.h:57:20 */
type T__int_least64_t = T__int64_t   /* types.h:58:19 */
type T__uint_least64_t = T__uint64_t /* types.h:59:20 */

// quad_t is also 64 bits.
type T__quad_t = int32    /* types.h:63:18 */
type T__u_quad_t = uint32 /* types.h:64:27 */

// Largest integral types.
type T__intmax_t = int32   /* types.h:72:18 */
type T__uintmax_t = uint32 /* types.h:73:27 */

// The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
//    macros for each of the OS types we define below.  The definitions
//    of those macros must use the following macros for underlying types.
//    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
//    variants of each of the following integer types on this machine.
//
// 	16		-- "natural" 16-bit type (always short)
// 	32		-- "natural" 32-bit type (always int)
// 	64		-- "natural" 64-bit type (long or long long)
// 	LONG32		-- 32-bit type, traditionally long
// 	QUAD		-- 64-bit type, traditionally long long
// 	WORD		-- natural type of __WORDSIZE bits (int or long)
// 	LONGWORD	-- type of __WORDSIZE bits, traditionally long
//
//    We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
//    conventional uses of `long' or `long long' type modifiers match the
//    types we define, even when a less-adorned type would be the same size.
//    This matters for (somewhat) portably writing printf/scanf formats for
//    these types, where using the appropriate l or ll format modifiers can
//    make the typedefs and the formats match up across all GNU platforms.  If
//    we used `long' when it's 64 bits where `long long' is expected, then the
//    compiler would warn about the formats not matching the argument types,
//    and the programmer changing them to shut up the compiler would break the
//    program's portability.
//
//    Here we assume what is presently the case in all the GCC configurations
//    we support: long long is always 64 bits, long is always word/address size,
//    and int is always 32 bits.

// No need to mark the typedef with __extension__.
// bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
//    Copyright (C) 2012-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// See <bits/types.h> for the meaning of these macros.  This file exists so
//    that <bits/types.h> need not vary across different GNU platforms.

// X32 kernel interface is 64-bit.

// Tell the libc code that off_t and off64_t are actually the same type
//    for all ABI purposes, even if possibly expressed as different base types
//    for C type-checking purposes.

// Same for ino_t and ino64_t.

// And for __rlim_t and __rlim64_t.

// And for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.

// Number of descriptors that can fit in an `fd_set'.

// bits/time64.h -- underlying types for __time64_t.  Generic version.
//    Copyright (C) 2018-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define __TIME64_T_TYPE so that it is always a 64-bit type.

// If we already have 64-bit time type then use it.

type T__dev_t = uint32                     /* types.h:145:25 */ // Type of device numbers.
type T__uid_t = uint32                     /* types.h:146:25 */ // Type of user identifications.
type T__gid_t = uint32                     /* types.h:147:25 */ // Type of group identifications.
type T__ino_t = uint32                     /* types.h:148:25 */ // Type of file serial numbers.
type T__ino64_t = uint32                   /* types.h:149:27 */ // Type of file serial numbers (LFS).
type T__mode_t = uint32                    /* types.h:150:26 */ // Type of file attribute bitmasks.
type T__nlink_t = uint32                   /* types.h:151:27 */ // Type of file link counts.
type T__off_t = int32                      /* types.h:152:25 */ // Type of file sizes and offsets.
type T__off64_t = int32                    /* types.h:153:27 */ // Type of file sizes and offsets (LFS).
type T__pid_t = int32                      /* types.h:154:25 */ // Type of process identifications.
type T__fsid_t = struct{ F__val [2]int32 } /* types.h:155:26 */ // Type of file system IDs.
type T__clock_t = int32                    /* types.h:156:27 */ // Type of CPU usage counts.
type T__rlim_t = uint32                    /* types.h:157:26 */ // Type for resource measurement.
type T__rlim64_t = uint32                  /* types.h:158:28 */ // Type for resource measurement (LFS).
type T__id_t = uint32                      /* types.h:159:24 */ // General type for IDs.
type T__time_t = int32                     /* types.h:160:26 */ // Seconds since the Epoch.
type T__useconds_t = uint32                /* types.h:161:30 */ // Count of microseconds.
type T__suseconds_t = int32                /* types.h:162:31 */ // Signed count of microseconds.

type T__daddr_t = int32 /* types.h:164:27 */ // The type of a disk address.
type T__key_t = int32   /* types.h:165:25 */ // Type of an IPC key.

// Clock ID used in clock and timer functions.
type T__clockid_t = int32 /* types.h:168:29 */

// Timer ID returned by `timer_create'.
type T__timer_t = uintptr /* types.h:171:12 */

// Type to represent block size.
type T__blksize_t = int32 /* types.h:174:29 */

// Types from the Large File Support interface.

// Type to count number of disk blocks.
type T__blkcnt_t = int32   /* types.h:179:28 */
type T__blkcnt64_t = int32 /* types.h:180:30 */

// Type to count file system blocks.
type T__fsblkcnt_t = uint32   /* types.h:183:30 */
type T__fsblkcnt64_t = uint32 /* types.h:184:32 */

// Type to count file system nodes.
type T__fsfilcnt_t = uint32   /* types.h:187:30 */
type T__fsfilcnt64_t = uint32 /* types.h:188:32 */

// Type of miscellaneous file system fields.
type T__fsword_t = int32 /* types.h:191:28 */

type T__ssize_t = int32 /* types.h:193:27 */ // Type of a byte count, or error.

// Signed long type used in system calls.
type T__syscall_slong_t = int32 /* types.h:196:33 */
// Unsigned long type used in system calls.
type T__syscall_ulong_t = uint32 /* types.h:198:33 */

// These few don't really vary by system, they always correspond
//    to one of the other defined types.
type T__loff_t = T__off64_t /* types.h:202:19 */ // Type of file sizes and offsets (LFS).
type T__caddr_t = uintptr   /* types.h:203:14 */

// Duplicates info from stdint.h but this is used in unistd.h.
type T__intptr_t = int32 /* types.h:206:25 */

// Duplicate info from sys/socket.h.
type T__socklen_t = uint32 /* types.h:209:23 */

// C99: An integer type that can be accessed as an atomic entity,
//    even in the presence of asynchronous interrupts.
//    It is not currently necessary for this to be machine-specific.
type T__sig_atomic_t = int32 /* types.h:214:13 */

// Seconds since the Epoch, visible to user code when time_t is too
//    narrow only for consistency with the old way of widening too-narrow
//    types.  User code should never use __time64_t.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Integral type unchanged by default argument promotions that can
//    hold any value corresponding to members of the extended character
//    set, as well as at least one value that does not correspond to any
//    member of the extended character set.

// Conversion state information.
type T__mbstate_t = struct {
	F__count int32
	F__value struct{ F__wch uint32 }
} /* __mbstate_t.h:21:3 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type S_G_fpos_t = struct {
	F__pos   T__off_t
	F__state T__mbstate_t
} /* __fpos_t.h:10:9 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type T__fpos_t = S_G_fpos_t /* __fpos_t.h:14:3 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type S_G_fpos64_t = struct {
	F__pos   T__off64_t
	F__state T__mbstate_t
} /* __fpos64_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type T__fpos64_t = S_G_fpos64_t /* __fpos64_t.h:14:3 */

type S_IO_FILE = struct {
	F_flags          int32
	F__ccgo_pad1     [4]byte
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     T__off_t
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F_lock           uintptr
	F_offset         T__off64_t
	F__ccgo_pad2     [4]byte
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          Tsize_t
	F_mode           int32
	F_unused2        [24]int8
} /* __FILE.h:4:1 */

type T__FILE = S_IO_FILE /* __FILE.h:5:25 */

// The opaque type of streams.  This is the definition used elsewhere.
type TFILE = S_IO_FILE /* FILE.h:7:25 */

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

type Tva_list = T__gnuc_va_list /* stdio.h:52:24 */

type Toff_t = T__off64_t /* stdio.h:65:19 */

type Tssize_t = T__ssize_t /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type Tfpos_t = T__fpos64_t /* stdio.h:86:20 */

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type S__locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
} /* __locale_t.h:28:1 */

type T__locale_t = uintptr /* __locale_t.h:42:32 */

type Tlocale_t = T__locale_t /* locale_t.h:24:20 */

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

type Tidtype_t = uint32 /* waitflags.h:57:3 */
// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the IEEE 754 binary128 format, and this
//    glibc includes corresponding *f128 interfaces for it.  The required
//    libgcc support was added some time after the basic compiler
//    support, for x86_64 and x86.

// Defined to 1 if __HAVE_FLOAT128 is 1 and the type is ABI-distinct
//    from the default float, double and long double types in this glibc.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for _Float64x, and this
//    glibc includes corresponding *f64x interfaces for it.

// Defined to 1 if __HAVE_FLOAT64X is 1 and _Float64x has the format
//    of long double.  Otherwise, if __HAVE_FLOAT64X is 1, _Float64x has
//    the format of _Float128, which must be different from that of long
//    double.

// Defined to concatenate the literal suffix to be used with _Float128
//    types, if __HAVE_FLOAT128 is 1.

// Defined to a complex binary128 type if __HAVE_FLOAT128 is 1.

// The remaining of this file provides support for older compilers.

// The type _Float128 exists only since GCC 7.0.

// __builtin_huge_valf128 doesn't exist before GCC 7.0.

// Older GCC has only a subset of built-in functions for _Float128 on
//    x86, and __builtin_infq is not usable in static initializers.
//    Converting a narrower sNaN to _Float128 produces a quiet NaN, so
//    attempts to use _Float128 sNaNs will not work properly with older
//    compilers.

// In math/math.h, __MATH_TG will expand signbit to __builtin_signbit*,
//    e.g.: __builtin_signbitf128, before GCC 6.  However, there has never
//    been a __builtin_signbitf128 in GCC and the type-generic builtin is
//    only available since GCC 6.

// Macros to control TS 18661-3 glibc features where the same
//    definitions are appropriate for all platforms.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// This header should be included at the bottom of each bits/floatn.h.
//    It defines the following macros for each _FloatN and _FloatNx type,
//    where the same definitions, or definitions based only on the macros
//    in bits/floatn.h, are appropriate for all glibc configurations.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for this type, and this
//    glibc includes corresponding *fN or *fNx interfaces for it.

// Defined to 1 if the corresponding __HAVE_<type> macro is 1 and the
//    type is the first with its format in the sequence of (the default
//    choices for) float, double, long double, _Float16, _Float32,
//    _Float64, _Float128, _Float32x, _Float64x, _Float128x for this
//    glibc; that is, if functions present once per floating-point format
//    rather than once per type are present for this type.
//
//    All configurations supported by glibc have _Float32 the same format
//    as float, _Float64 and _Float32x the same format as double, the
//    _Float64x the same format as either long double or _Float128.  No
//    configurations support _Float128x or, as of GCC 7, have compiler
//    support for a type meeting the requirements for _Float128x.

// Defined to 1 if the corresponding _FloatN type is not binary compatible
//    with the corresponding ISO C type in the current compilation unit as
//    opposed to __HAVE_DISTINCT_FLOATN, which indicates the default types built
//    in glibc.

// Defined to 1 if any _FloatN or _FloatNx types that are not
//    ABI-distinct are however distinct types at the C language level (so
//    for the purposes of __builtin_types_compatible_p and _Generic).

// Defined to concatenate the literal suffix to be used with _FloatN
//    or _FloatNx types, if __HAVE_<type> is 1.  The corresponding
//    literal suffixes exist since GCC 7, for C only.

// Defined to a complex type if __HAVE_<type> is 1.

// The remaining of this file provides support for older compilers.

// If double, long double and _Float64 all have the same set of
//    values, TS 18661-3 requires the usual arithmetic conversions on
//    long double and _Float64 to produce _Float64.  For this to be the
//    case when building with a compiler without a distinct _Float64
//    type, _Float64 must be a typedef for long double, not for
//    double.

// Returned by `div'.
type Tdiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:62:5 */

// Returned by `ldiv'.
type Tldiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:70:5 */

// Returned by `lldiv'.
type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:80:5 */

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tu_char = T__u_char     /* types.h:33:18 */
type Tu_short = T__u_short   /* types.h:34:19 */
type Tu_int = T__u_int       /* types.h:35:17 */
type Tu_long = T__u_long     /* types.h:36:18 */
type Tquad_t = T__quad_t     /* types.h:37:18 */
type Tu_quad_t = T__u_quad_t /* types.h:38:20 */
type Tfsid_t = T__fsid_t     /* types.h:39:18 */
type Tloff_t = T__loff_t     /* types.h:42:18 */

type Tino_t = T__ino64_t /* types.h:49:19 */

type Tdev_t = T__dev_t /* types.h:59:17 */

type Tgid_t = T__gid_t /* types.h:64:17 */

type Tmode_t = T__mode_t /* types.h:69:18 */

type Tnlink_t = T__nlink_t /* types.h:74:19 */

type Tuid_t = T__uid_t /* types.h:79:17 */

type Tpid_t = T__pid_t /* types.h:97:17 */

type Tid_t = T__id_t /* types.h:103:16 */

type Tdaddr_t = T__daddr_t /* types.h:114:19 */
type Tcaddr_t = T__caddr_t /* types.h:115:19 */

type Tkey_t = T__key_t /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type Tclock_t = T__clock_t /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type Tclockid_t = T__clockid_t /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type Ttime_t = T__time_t /* time_t.h:7:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type Ttimer_t = T__timer_t /* timer_t.h:7:19 */

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Old compatibility names for C types.
type Tulong = uint32  /* types.h:148:27 */
type Tushort = uint16 /* types.h:149:28 */
type Tuint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tint8_t = T__int8_t   /* stdint-intn.h:24:18 */
type Tint16_t = T__int16_t /* stdint-intn.h:25:19 */
type Tint32_t = T__int32_t /* stdint-intn.h:26:19 */
type Tint64_t = T__int64_t /* stdint-intn.h:27:19 */

// These were defined by ISO C without the first `_'.
type Tu_int8_t = T__uint8_t   /* types.h:158:19 */
type Tu_int16_t = T__uint16_t /* types.h:159:20 */
type Tu_int32_t = T__uint32_t /* types.h:160:20 */
type Tu_int64_t = T__uint64_t /* types.h:161:20 */

type Tregister_t = int32 /* types.h:164:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Get sigset_t.

type T__sigset_t = struct{ F__val [32]uint32 } /* __sigset_t.h:8:3 */

// A set of signals to be blocked, unblocked, or waited for.
type Tsigset_t = T__sigset_t /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//    microsecond but also has a range of years.
type Stimeval = struct {
	Ftv_sec  T__time_t
	Ftv_usec T__suseconds_t
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Endian macros for string.h functions
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//    has nanoseconds instead of microseconds.
type Stimespec = struct {
	Ftv_sec  T__time_t
	Ftv_nsec T__syscall_slong_t
} /* struct_timespec.h:10:1 */

type Tsuseconds_t = T__suseconds_t /* select.h:43:23 */

// The fd_set member is required to be an array of longs.
type T__fd_mask = int32 /* select.h:49:18 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type Tfd_set = struct{ F__fds_bits [32]T__fd_mask } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type Tfd_mask = T__fd_mask /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type Tblksize_t = T__blksize_t /* types.h:185:21 */

// Types from the Large File Support interface.
type Tblkcnt_t = T__blkcnt64_t     /* types.h:205:22 */ // Type to count number of disk blocks.
type Tfsblkcnt_t = T__fsblkcnt64_t /* types.h:209:24 */ // Type to count file system blocks.
type Tfsfilcnt_t = T__fsfilcnt64_t /* types.h:213:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Common definition of pthread_mutex_t.

type S__pthread_internal_list = struct {
	F__prev uintptr
	F__next uintptr
} /* thread-shared-types.h:49:9 */

// Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Common definition of pthread_mutex_t.

type T__pthread_list_t = S__pthread_internal_list /* thread-shared-types.h:53:3 */

type S__pthread_internal_slist = struct{ F__next uintptr } /* thread-shared-types.h:55:9 */

type T__pthread_slist_t = S__pthread_internal_slist /* thread-shared-types.h:58:3 */

// Arch-specific mutex definitions.  A generic implementation is provided
//    by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
//    can override it by defining:
//
//    1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
//       definition).  It should contains at least the internal members
//       defined in the generic version.
//
//    2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
//       atomic operations.
//
//    3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
//       It should initialize the mutex internal flag.

// x86 internal mutex struct definitions.
//    Copyright (C) 2019-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_mutex_s = struct {
	F__lock    int32
	F__count   uint32
	F__owner   int32
	F__nusers  uint32
	F__kind    int32
	F__spins   int16
	F__elision int16
	F__list    T__pthread_list_t
} /* struct_mutex.h:22:1 */

// Arch-sepecific read-write lock definitions.  A generic implementation is
//    provided by struct_rwlock.h.  If required, an architecture can override it
//    by defining:
//
//    1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
//       It should contain at least the internal members defined in the
//       generic version.
//
//    2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
//       It should initialize the rwlock internal type.

// x86 internal rwlock struct definitions.
//    Copyright (C) 2019-2020 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__cur_writer    int32
	F__shared        int32
	F__rwelision     int8
	F__pad1          [7]uint8
	F__pad2          uint32
	F__flags         uint32
} /* struct_rwlock.h:23:1 */

// Common definition of pthread_cond_t.

type S__pthread_cond_s = struct {
	F__0            struct{ F__wseq uint64 }
	F__8            struct{ F__g1_start uint64 }
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
} /* thread-shared-types.h:92:1 */

// Thread identifiers.  The structure of the attribute type is not
//    exposed on purpose.
type Tpthread_t = uint32 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//    type is not exposed on purpose.
type Tpthread_mutexattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//    the attribute type is not exposed on purpose.
type Tpthread_condattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type Tpthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type Tpthread_once_t = int32 /* pthreadtypes.h:53:30 */

type Spthread_attr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [56]int8
} /* pthreadtypes.h:56:1 */

type Tpthread_attr_t = Spthread_attr_t /* pthreadtypes.h:62:30 */

type Tpthread_mutex_t = struct{ F__data S__pthread_mutex_s } /* pthreadtypes.h:72:3 */

type Tpthread_cond_t = struct{ F__data S__pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//    structure of the attribute type is deliberately not exposed.
type Tpthread_rwlock_t = struct {
	F__data      S__pthread_rwlock_arch_t
	F__ccgo_pad1 [8]byte
} /* pthreadtypes.h:91:3 */

type Tpthread_rwlockattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type Tpthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//    deliberately not exposed.
type Tpthread_barrier_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [32]int8
} /* pthreadtypes.h:112:3 */

type Tpthread_barrierattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:118:3 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type Srandom_data = struct {
	Ffptr        uintptr
	Frptr        uintptr
	Fstate       uintptr
	Frand_type   int32
	Frand_deg    int32
	Frand_sep    int32
	F__ccgo_pad1 [4]byte
	Fend_ptr     uintptr
} /* stdlib.h:423:1 */

// Data structure for communication with thread safe versions.  This
//    type is to be regarded as opaque.  It's only exported because users
//    have to allocate objects of this type.
type Sdrand48_data = struct {
	F__x     [3]uint16
	F__old_x [3]uint16
	F__c     uint16
	F__init  uint16
	F__a     uint64
} /* stdlib.h:490:1 */

// Shorthand for type of comparison functions.
type T__compar_fn_t = uintptr /* stdlib.h:808:13 */

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Declarations for math functions.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X; the symbols in Annex F
//    still require that macro in C2X.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get definitions of __intmax_t and __uintmax_t.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get machine-dependent vector math functions declarations.
// Platform-specific SIMD declarations of math functions.
//    Copyright (C) 2014-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get default empty definitions for simd declarations.
// Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
//    Copyright (C) 2014-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Needed definitions could be generated with:
//    for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
//      echo "#define __DECL_SIMD_${func}";
//      echo "#define __DECL_SIMD_${func}f";
//      echo "#define __DECL_SIMD_${func}l";
//    done
//

// Gather machine dependent type support.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Value returned on overflow.  With IEEE 754 floating point, this is
//    +Infinity, otherwise the largest representable positive value.

// IEEE positive infinity.

// IEEE Not A Number.

// Get __GLIBC_FLT_EVAL_METHOD.
// Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define the following typedefs.
//
//     float_t	floating-point type at least as wide as `float' used
// 		to evaluate `float' expressions
//     double_t	floating-point type at least as wide as `double' used
// 		to evaluate `double' expressions
type Tfloat_t = float32  /* math.h:149:15 */
type Tdouble_t = float64 /* math.h:150:16 */

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// create opj_config_private.h for CMake

// Not used by openjp2
//#define HAVE_MEMORY_H 1
//#define HAVE_STDLIB_H 1
//#define HAVE_STRINGS_H 1
//#define HAVE_STRING_H 1
//#define HAVE_SYS_STAT_H 1
//#define HAVE_SYS_TYPES_H 1
//#define HAVE_UNISTD_H 1

// #undef _LARGEFILE_SOURCE
// #undef _LARGE_FILES
// #undef _FILE_OFFSET_BITS

// find whether or not have <malloc.h>
// check if function `aligned_alloc` exists
// #undef OPJ_HAVE_ALIGNED_ALLOC
// check if function `_aligned_malloc` exists
// #undef OPJ_HAVE__ALIGNED_MALLOC
// check if function `memalign` exists
// check if function `posix_memalign` exists

// Byte order.
// All compilers that support Mac OS X define either __BIG_ENDIAN__ or
// __LITTLE_ENDIAN__ to match the endianness of the architecture being
// compiled for. This is not necessarily the same as the architecture of the
// machine doing the building. In order to support Universal Binaries on
// Mac OS X, we prefer those defines to decide the endianness.
// On other platforms we use the result of the TRY_RUN.
// #undef OPJ_BIG_ENDIAN

// create opj_apps_config.h for CMake

// #undef OPJ_HAVE_LIBPNG
// #undef OPJ_HAVE_PNG_H
// #undef OPJ_HAVE_LIBTIFF
// #undef OPJ_HAVE_TIFF_H

// #undef OPJ_HAVE_LIBLCMS1
// #undef OPJ_HAVE_LIBLCMS2
// #undef OPJ_HAVE_LCMS1_H
// #undef OPJ_HAVE_LCMS2_H

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2006-2007, Parvatha Elangovan
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// Copyright (c) 2010-2011, Kaori Hagihara
// Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//
// ==========================================================
//    Compiler directives
// ==========================================================

//
// The inline keyword is supported by C99 but not by C90.
// Most compilers implement their own version of this keyword ...

// deprecated attribute

// http://gcc.gnu.org/wiki/Visibility

type TOPJ_BOOL = int32 /* openjpeg.h:116:13 */

type TOPJ_CHAR = int8       /* openjpeg.h:120:23 */
type TOPJ_FLOAT32 = float32 /* openjpeg.h:121:23 */
type TOPJ_FLOAT64 = float64 /* openjpeg.h:122:23 */
type TOPJ_BYTE = uint8      /* openjpeg.h:123:23 */

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2012, Mathieu Malaterre <mathieu.malaterre@gmail.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// create opj_config.h for CMake

//--------------------------------------------------------------------------
// OpenJPEG Versioning

// Version number.
// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X; the symbols in Annex F
//    still require that macro in C2X.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// wchar_t type related definitions.
//    Copyright (C) 2000-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//    are not defined, give the right value and type as long as both int
//    and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//    ensures that the type is correct; it is necessary to use (L'\0' +
//    0) rather than just L'\0' so that the type in C++ is the promoted
//    version of wchar_t rather than the distinct wchar_t type itself.
//    Because wchar_t in preprocessor #if expressions is treated as
//    intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//    wrong value for WCHAR_MAX in such expressions and so cannot be used
//    to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Exact integral types.

// Signed.
// Define intN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tuint8_t = T__uint8_t   /* stdint-uintn.h:24:19 */
type Tuint16_t = T__uint16_t /* stdint-uintn.h:25:20 */
type Tuint32_t = T__uint32_t /* stdint-uintn.h:26:20 */
type Tuint64_t = T__uint64_t /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type Tint_least8_t = T__int_least8_t   /* stdint.h:43:24 */
type Tint_least16_t = T__int_least16_t /* stdint.h:44:25 */
type Tint_least32_t = T__int_least32_t /* stdint.h:45:25 */
type Tint_least64_t = T__int_least64_t /* stdint.h:46:25 */

// Unsigned.
type Tuint_least8_t = T__uint_least8_t   /* stdint.h:49:25 */
type Tuint_least16_t = T__uint_least16_t /* stdint.h:50:26 */
type Tuint_least32_t = T__uint_least32_t /* stdint.h:51:26 */
type Tuint_least64_t = T__uint_least64_t /* stdint.h:52:26 */

// Fast types.

// Signed.
type Tint_fast8_t = int8   /* stdint.h:58:22 */
type Tint_fast16_t = int32 /* stdint.h:60:19 */
type Tint_fast32_t = int32 /* stdint.h:61:19 */
type Tint_fast64_t = int32 /* stdint.h:62:19 */

// Unsigned.
type Tuint_fast8_t = uint8   /* stdint.h:71:24 */
type Tuint_fast16_t = uint32 /* stdint.h:73:27 */
type Tuint_fast32_t = uint32 /* stdint.h:74:27 */
type Tuint_fast64_t = uint32 /* stdint.h:75:27 */

// Types for `void *' pointers.
type Tintptr_t = int32   /* stdint.h:87:19 */
type Tuintptr_t = uint32 /* stdint.h:90:27 */

// Largest integral types.
type Tintmax_t = T__intmax_t   /* stdint.h:101:21 */
type Tuintmax_t = T__uintmax_t /* stdint.h:102:22 */

// Limits of integral types.

// Minimum of signed integral types.
// Maximum of signed integral types.

// Maximum of unsigned integral types.

// Minimum of signed integral types having a minimum size.
// Maximum of signed integral types having a minimum size.

// Maximum of unsigned integral types having a minimum size.

// Minimum of fast signed integral types having a minimum size.
// Maximum of fast signed integral types having a minimum size.

// Maximum of fast unsigned integral types having a minimum size.

// Values to test for integral types holding `void *' pointer.

// Minimum for largest signed integral type.
// Maximum for largest signed integral type.

// Maximum for largest unsigned integral type.

// Limits of other integer types.

// Limits of `ptrdiff_t' type.

// Limits of `sig_atomic_t'.

// Limit of `size_t' type.

// Limits of `wchar_t'.
// These constants might also be defined in <wchar.h>.

// Limits of `wint_t'.

// Signed.

// Unsigned.

// Maximal type.

type TOPJ_INT8 = Tint8_t     /* openjpeg.h:127:18 */
type TOPJ_UINT8 = Tuint8_t   /* openjpeg.h:128:18 */
type TOPJ_INT16 = Tint16_t   /* openjpeg.h:129:18 */
type TOPJ_UINT16 = Tuint16_t /* openjpeg.h:130:18 */
type TOPJ_INT32 = Tint32_t   /* openjpeg.h:131:18 */
type TOPJ_UINT32 = Tuint32_t /* openjpeg.h:132:18 */
type TOPJ_INT64 = Tint64_t   /* openjpeg.h:133:18 */
type TOPJ_UINT64 = Tuint64_t /* openjpeg.h:134:18 */

type TOPJ_OFF_T = Tint64_t /* openjpeg.h:136:18 */ // 64-bit file offset type

// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

type TOPJ_SIZE_T = Tsize_t /* openjpeg.h:139:18 */

// Avoid compile-time warning because parameter is not used

//
// ==========================================================
//    Useful constant definitions
// ==========================================================

/* UniPG>> */ // NOT YET USED IN THE V2 VERSION OF OPENJPEG
// <<UniPG

// *
// EXPERIMENTAL FOR THE MOMENT
// Supported options about file information used only in j2k_dump
/*FIXME #define OPJ_J2K_CSTR_IND    48*/ //*<

// *
// JPEG 2000 Profiles, see Table A.10 from 15444-1 (updated in various AMD)
// These values help choosing the RSIZ value for the J2K codestream.
// The RSIZ value triggers various encoding options, as detailed in Table A.10.
// If OPJ_PROFILE_PART2 is chosen, it has to be combined with one or more extensions
// described hereunder.
//   Example: rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;
// For broadcast profiles, the OPJ_PROFILE value has to be combined with the targeted
// mainlevel (3-0 LSB, value between 0 and 11):
//   Example: rsiz = OPJ_PROFILE_BC_MULTI | 0x0005; (here mainlevel 5)
// For IMF profiles, the OPJ_PROFILE value has to be combined with the targeted mainlevel
// (3-0 LSB, value between 0 and 11) and sublevel (7-4 LSB, value between 0 and 9):
//   Example: rsiz = OPJ_PROFILE_IMF_2K | 0x0040 | 0x0005; (here main 5 and sublevel 4)
//

// *
// JPEG 2000 Part-2 extensions
//

// *
// JPEG 2000 profile macros
//

//* Max. Components Sampling Rate (MSamples/sec) per IMF main level

//* Max. compressed Bit Rate (Mbits/s) per IMF sub level

// *
// JPEG 2000 codestream and component size limits in cinema profiles
//

//
// ==========================================================
//    enum definitions
// ==========================================================

// *
// DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead
// Rsiz Capabilities
//
type TOPJ_RSIZ_CAPABILITIES = uint32 /* openjpeg.h:287:3 */

// *
// DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead
// Digital cinema operation mode
//
type TOPJ_CINEMA_MODE = uint32 /* openjpeg.h:298:3 */

// *
// Progression order
//
type TOPJ_PROG_ORDER = int32 /* openjpeg.h:310:3 */

// *
// Supported image color spaces
type TOPJ_COLOR_SPACE = int32 /* openjpeg.h:323:3 */

// *
// Supported codec
type TOPJ_CODEC_FORMAT = int32 /* openjpeg.h:335:3 */

//
// ==========================================================
//    event manager typedef definitions
// ==========================================================

// *
// Callback function prototype for events
// @param msg               Event message
// @param client_data       Client object where will be return the event message
//
type Topj_msg_callback = uintptr /* openjpeg.h:349:14 */

//
// ==========================================================
//    codec typedef definitions
// ==========================================================

// *
// Progression order changes
//
type Topj_poc_t = struct {
	Fresno0      TOPJ_UINT32
	Fcompno0     TOPJ_UINT32
	Flayno1      TOPJ_UINT32
	Fresno1      TOPJ_UINT32
	Fcompno1     TOPJ_UINT32
	Flayno0      TOPJ_UINT32
	Fprecno0     TOPJ_UINT32
	Fprecno1     TOPJ_UINT32
	Fprg1        TOPJ_PROG_ORDER
	Fprg         TOPJ_PROG_ORDER
	Fprogorder   [5]TOPJ_CHAR
	F__ccgo_pad1 [3]byte
	Ftile        TOPJ_UINT32
	Ftx0         TOPJ_INT32
	Ftx1         TOPJ_INT32
	Fty0         TOPJ_INT32
	Fty1         TOPJ_INT32
	FlayS        TOPJ_UINT32
	FresS        TOPJ_UINT32
	FcompS       TOPJ_UINT32
	FprcS        TOPJ_UINT32
	FlayE        TOPJ_UINT32
	FresE        TOPJ_UINT32
	FcompE       TOPJ_UINT32
	FprcE        TOPJ_UINT32
	FtxS         TOPJ_UINT32
	FtxE         TOPJ_UINT32
	FtyS         TOPJ_UINT32
	FtyE         TOPJ_UINT32
	Fdx          TOPJ_UINT32
	Fdy          TOPJ_UINT32
	Flay_t       TOPJ_UINT32
	Fres_t       TOPJ_UINT32
	Fcomp_t      TOPJ_UINT32
	Fprc_t       TOPJ_UINT32
	Ftx0_t       TOPJ_UINT32
	Fty0_t       TOPJ_UINT32
} /* openjpeg.h:388:3 */

// *
// Compression parameters
//
type Sopj_cparameters = struct {
	Ftile_size_on          TOPJ_BOOL
	Fcp_tx0                int32
	Fcp_ty0                int32
	Fcp_tdx                int32
	Fcp_tdy                int32
	Fcp_disto_alloc        int32
	Fcp_fixed_alloc        int32
	Fcp_fixed_quality      int32
	Fcp_matrice            uintptr
	Fcp_comment            uintptr
	Fcsty                  int32
	Fprog_order            TOPJ_PROG_ORDER
	FPOC                   [32]Topj_poc_t
	Fnumpocs               TOPJ_UINT32
	Ftcp_numlayers         int32
	Ftcp_rates             [100]float32
	Ftcp_distoratio        [100]float32
	Fnumresolution         int32
	Fcblockw_init          int32
	Fcblockh_init          int32
	Fmode                  int32
	Firreversible          int32
	Froi_compno            int32
	Froi_shift             int32
	Fres_spec              int32
	Fprcw_init             [33]int32
	Fprch_init             [33]int32
	Finfile                [4096]int8
	Foutfile               [4096]int8
	Findex_on              int32
	Findex                 [4096]int8
	Fimage_offset_x0       int32
	Fimage_offset_y0       int32
	Fsubsampling_dx        int32
	Fsubsampling_dy        int32
	Fdecod_format          int32
	Fcod_format            int32
	Fjpwl_epc_on           TOPJ_BOOL
	Fjpwl_hprot_MH         int32
	Fjpwl_hprot_TPH_tileno [16]int32
	Fjpwl_hprot_TPH        [16]int32
	Fjpwl_pprot_tileno     [16]int32
	Fjpwl_pprot_packno     [16]int32
	Fjpwl_pprot            [16]int32
	Fjpwl_sens_size        int32
	Fjpwl_sens_addr        int32
	Fjpwl_sens_range       int32
	Fjpwl_sens_MH          int32
	Fjpwl_sens_TPH_tileno  [16]int32
	Fjpwl_sens_TPH         [16]int32
	Fcp_cinema             TOPJ_CINEMA_MODE
	Fmax_comp_size         int32
	Fcp_rsiz               TOPJ_RSIZ_CAPABILITIES
	Ftp_on                 int8
	Ftp_flag               int8
	Ftcp_mct               int8
	F__ccgo_pad1           [1]byte
	Fjpip_on               TOPJ_BOOL
	Fmct_data              uintptr
	Fmax_cs_size           int32
	Frsiz                  TOPJ_UINT16
	F__ccgo_pad2           [2]byte
} /* openjpeg.h:393:9 */

// *
// Compression parameters
//
type Topj_cparameters_t = Sopj_cparameters /* openjpeg.h:544:3 */

// *
// Decompression parameters
//
type Sopj_dparameters = struct {
	Fcp_reduce         TOPJ_UINT32
	Fcp_layer          TOPJ_UINT32
	Finfile            [4096]int8
	Foutfile           [4096]int8
	Fdecod_format      int32
	Fcod_format        int32
	FDA_x0             TOPJ_UINT32
	FDA_x1             TOPJ_UINT32
	FDA_y0             TOPJ_UINT32
	FDA_y1             TOPJ_UINT32
	Fm_verbose         TOPJ_BOOL
	Ftile_index        TOPJ_UINT32
	Fnb_tile_to_decode TOPJ_UINT32
	Fjpwl_correct      TOPJ_BOOL
	Fjpwl_exp_comps    int32
	Fjpwl_max_tiles    int32
	Fflags             uint32
} /* openjpeg.h:552:9 */

// *
// Decompression parameters
//
type Topj_dparameters_t = Sopj_dparameters /* openjpeg.h:612:3 */

// *
// JPEG2000 codec V2.
//
type Topj_codec_t = uintptr /* openjpeg.h:618:14 */

//
// ==========================================================
//    I/O stream typedef definitions
// ==========================================================

// *
// Stream open flags.
//
//* The stream was opened for reading.
//* The stream was opened for writing.

// Callback function prototype for read function
type Topj_stream_read_fn = uintptr /* openjpeg.h:637:19 */

// Callback function prototype for write function
type Topj_stream_write_fn = uintptr /* openjpeg.h:643:19 */

// Callback function prototype for skip function
type Topj_stream_skip_fn = uintptr /* openjpeg.h:649:18 */

// Callback function prototype for seek function
type Topj_stream_seek_fn = uintptr /* openjpeg.h:655:17 */

// Callback function prototype for free user data function
type Topj_stream_free_user_data_fn = uintptr /* openjpeg.h:661:14 */

// JPEG2000 Stream.
type Topj_stream_t = uintptr /* openjpeg.h:666:14 */

//
// ==========================================================
//    image typedef definitions
// ==========================================================

// *
// Defines a single image component
//
type Sopj_image_comp = struct {
	Fdx            TOPJ_UINT32
	Fdy            TOPJ_UINT32
	Fw             TOPJ_UINT32
	Fh             TOPJ_UINT32
	Fx0            TOPJ_UINT32
	Fy0            TOPJ_UINT32
	Fprec          TOPJ_UINT32
	Fbpp           TOPJ_UINT32
	Fsgnd          TOPJ_UINT32
	Fresno_decoded TOPJ_UINT32
	Ffactor        TOPJ_UINT32
	F__ccgo_pad1   [4]byte
	Fdata          uintptr
	Falpha         TOPJ_UINT16
	F__ccgo_pad2   [6]byte
} /* openjpeg.h:677:9 */

//
// ==========================================================
//    image typedef definitions
// ==========================================================

// *
// Defines a single image component
//
type Topj_image_comp_t = Sopj_image_comp /* openjpeg.h:704:3 */

// *
// Defines image data and characteristics
//
type Sopj_image = struct {
	Fx0              TOPJ_UINT32
	Fy0              TOPJ_UINT32
	Fx1              TOPJ_UINT32
	Fy1              TOPJ_UINT32
	Fnumcomps        TOPJ_UINT32
	Fcolor_space     TOPJ_COLOR_SPACE
	Fcomps           uintptr
	Ficc_profile_buf uintptr
	Ficc_profile_len TOPJ_UINT32
	F__ccgo_pad1     [4]byte
} /* openjpeg.h:709:9 */

// *
// Defines image data and characteristics
//
type Topj_image_t = Sopj_image /* openjpeg.h:728:3 */

// *
// Component parameters structure used by the opj_image_create function
//
type Sopj_image_comptparm = struct {
	Fdx   TOPJ_UINT32
	Fdy   TOPJ_UINT32
	Fw    TOPJ_UINT32
	Fh    TOPJ_UINT32
	Fx0   TOPJ_UINT32
	Fy0   TOPJ_UINT32
	Fprec TOPJ_UINT32
	Fbpp  TOPJ_UINT32
	Fsgnd TOPJ_UINT32
} /* openjpeg.h:734:9 */

// *
// Component parameters structure used by the opj_image_create function
//
type Topj_image_cmptparm_t = Sopj_image_comptparm /* openjpeg.h:753:3 */

//
// ==========================================================
//    Information on the JPEG 2000 codestream
// ==========================================================
// QUITE EXPERIMENTAL FOR THE MOMENT

// *
// Index structure : Information concerning a packet inside tile
//
type Sopj_packet_info = struct {
	Fstart_pos   TOPJ_OFF_T
	Fend_ph_pos  TOPJ_OFF_T
	Fend_pos     TOPJ_OFF_T
	F__ccgo_pad1 [4]byte
	Fdisto       float64
} /* openjpeg.h:766:9 */

//
// ==========================================================
//    Information on the JPEG 2000 codestream
// ==========================================================
// QUITE EXPERIMENTAL FOR THE MOMENT

// *
// Index structure : Information concerning a packet inside tile
//
type Topj_packet_info_t = Sopj_packet_info /* openjpeg.h:775:3 */

// UniPG>>
// *
// Marker structure
//
type Sopj_marker_info = struct {
	Ftype        uint16
	F__ccgo_pad1 [2]byte
	Fpos         TOPJ_OFF_T
	Flen         int32
} /* openjpeg.h:782:9 */

// UniPG>>
// *
// Marker structure
//
type Topj_marker_info_t = Sopj_marker_info /* openjpeg.h:789:3 */
// <<UniPG

// *
// Index structure : Information concerning tile-parts
type Sopj_tp_info = struct {
	Ftp_start_pos  int32
	Ftp_end_header int32
	Ftp_end_pos    int32
	Ftp_start_pack int32
	Ftp_numpacks   int32
} /* openjpeg.h:795:9 */

// <<UniPG

// *
// Index structure : Information concerning tile-parts
type Topj_tp_info_t = Sopj_tp_info /* openjpeg.h:806:3 */

// *
// Index structure : information regarding tiles
type Sopj_tile_info = struct {
	Fthresh      uintptr
	Ftileno      int32
	Fstart_pos   int32
	Fend_header  int32
	Fend_pos     int32
	Fpw          [33]int32
	Fph          [33]int32
	Fpdx         [33]int32
	Fpdy         [33]int32
	Fpacket      uintptr
	Fnumpix      int32
	F__ccgo_pad1 [4]byte
	Fdistotile   float64
	Fmarknum     int32
	F__ccgo_pad2 [4]byte
	Fmarker      uintptr
	Fmaxmarknum  int32
	Fnum_tps     int32
	Ftp          uintptr
} /* openjpeg.h:811:9 */

// *
// Index structure : information regarding tiles
type Topj_tile_info_t = Sopj_tile_info /* openjpeg.h:846:3 */

// *
// Index structure of the codestream
type Sopj_codestream_info = struct {
	FD_max           float64
	Fpackno          int32
	Findex_write     int32
	Fimage_w         int32
	Fimage_h         int32
	Fprog            TOPJ_PROG_ORDER
	Ftile_x          int32
	Ftile_y          int32
	Ftile_Ox         int32
	Ftile_Oy         int32
	Ftw              int32
	Fth              int32
	Fnumcomps        int32
	Fnumlayers       int32
	F__ccgo_pad1     [4]byte
	Fnumdecompos     uintptr
	Fmarknum         int32
	F__ccgo_pad2     [4]byte
	Fmarker          uintptr
	Fmaxmarknum      int32
	Fmain_head_start int32
	Fmain_head_end   int32
	Fcodestream_size int32
	Ftile            uintptr
} /* openjpeg.h:851:9 */

// *
// Index structure of the codestream
type Topj_codestream_info_t = Sopj_codestream_info /* openjpeg.h:898:3 */

// <-----------------------------------------------------------
// new output management of the codestream information and index

// *
// Tile-component coding parameters information
type Sopj_tccp_info = struct {
	Fcompno         TOPJ_UINT32
	Fcsty           TOPJ_UINT32
	Fnumresolutions TOPJ_UINT32
	Fcblkw          TOPJ_UINT32
	Fcblkh          TOPJ_UINT32
	Fcblksty        TOPJ_UINT32
	Fqmfbid         TOPJ_UINT32
	Fqntsty         TOPJ_UINT32
	Fstepsizes_mant [97]TOPJ_UINT32
	Fstepsizes_expn [97]TOPJ_UINT32
	Fnumgbits       TOPJ_UINT32
	Froishift       TOPJ_INT32
	Fprcw           [33]TOPJ_UINT32
	Fprch           [33]TOPJ_UINT32
} /* openjpeg.h:906:9 */

// <-----------------------------------------------------------
// new output management of the codestream information and index

// *
// Tile-component coding parameters information
type Topj_tccp_info_t = Sopj_tccp_info /* openjpeg.h:936:1 */

// *
// Tile coding parameters information
type Sopj_tile_v2_info = struct {
	Ftileno      int32
	Fcsty        TOPJ_UINT32
	Fprg         TOPJ_PROG_ORDER
	Fnumlayers   TOPJ_UINT32
	Fmct         TOPJ_UINT32
	F__ccgo_pad1 [4]byte
	Ftccp_info   uintptr
} /* openjpeg.h:941:9 */

// *
// Tile coding parameters information
type Topj_tile_info_v2_t = Sopj_tile_v2_info /* openjpeg.h:957:3 */

// *
// Information structure about the codestream (FIXME should be expand and enhance)
type Sopj_codestream_info_v2 = struct {
	Ftx0                 TOPJ_UINT32
	Fty0                 TOPJ_UINT32
	Ftdx                 TOPJ_UINT32
	Ftdy                 TOPJ_UINT32
	Ftw                  TOPJ_UINT32
	Fth                  TOPJ_UINT32
	Fnbcomps             TOPJ_UINT32
	F__ccgo_pad1         [4]byte
	Fm_default_tile_info Topj_tile_info_v2_t
	Ftile_info           uintptr
} /* openjpeg.h:962:9 */

// *
// Information structure about the codestream (FIXME should be expand and enhance)
type Topj_codestream_info_v2_t = Sopj_codestream_info_v2 /* openjpeg.h:986:3 */

// *
// Index structure about a tile part
type Sopj_tp_index = struct {
	Fstart_pos  TOPJ_OFF_T
	Fend_header TOPJ_OFF_T
	Fend_pos    TOPJ_OFF_T
} /* openjpeg.h:992:9 */

// *
// Index structure about a tile part
type Topj_tp_index_t = Sopj_tp_index /* openjpeg.h:1000:3 */

// *
// Index structure about a tile
type Sopj_tile_index = struct {
	Ftileno         TOPJ_UINT32
	Fnb_tps         TOPJ_UINT32
	Fcurrent_nb_tps TOPJ_UINT32
	Fcurrent_tpsno  TOPJ_UINT32
	Ftp_index       uintptr
	Fmarknum        TOPJ_UINT32
	F__ccgo_pad1    [4]byte
	Fmarker         uintptr
	Fmaxmarknum     TOPJ_UINT32
	Fnb_packet      TOPJ_UINT32
	Fpacket_index   uintptr
} /* openjpeg.h:1005:9 */

// *
// Index structure about a tile
type Topj_tile_index_t = Sopj_tile_index /* openjpeg.h:1032:3 */

// *
// Index structure of the codestream (FIXME should be expand and enhance)
type Sopj_codestream_index = struct {
	Fmain_head_start TOPJ_OFF_T
	Fmain_head_end   TOPJ_OFF_T
	Fcodestream_size TOPJ_UINT64
	Fmarknum         TOPJ_UINT32
	Fmarker          uintptr
	Fmaxmarknum      TOPJ_UINT32
	Fnb_of_tiles     TOPJ_UINT32
	Ftile_index      uintptr
} /* openjpeg.h:1037:9 */

// *
// Index structure of the codestream (FIXME should be expand and enhance)
type Topj_codestream_index_t = Sopj_codestream_index /* openjpeg.h:1060:3 */
// ----------------------------------------------------------->

//
// ==========================================================
//    Metadata from the JP2file
// ==========================================================

// *
// Info structure of the JP2 file
// EXPERIMENTAL FOR THE MOMENT
type Sopj_jp2_metadata = struct{ Fnot_used TOPJ_INT32 } /* openjpeg.h:1073:9 */

// ----------------------------------------------------------->

//
// ==========================================================
//    Metadata from the JP2file
// ==========================================================

// *
// Info structure of the JP2 file
// EXPERIMENTAL FOR THE MOMENT
type Topj_jp2_metadata_t = Sopj_jp2_metadata /* openjpeg.h:1077:3 */

// *
// Index structure of the JP2 file
// EXPERIMENTAL FOR THE MOMENT
type Sopj_jp2_index = struct{ Fnot_used TOPJ_INT32 } /* openjpeg.h:1083:9 */

// *
// Index structure of the JP2 file
// EXPERIMENTAL FOR THE MOMENT
type Topj_jp2_index_t = Sopj_jp2_index /* openjpeg.h:1087:3 */

//--------------------------------------------------------
// Matrix for sYCC, Amendment 1 to IEC 61966-2-1
//
// Y :   0.299   0.587    0.114   :R
// Cb:  -0.1687 -0.3312   0.5     :G
// Cr:   0.5    -0.4187  -0.0812  :B
//
// Inverse:
//
// R: 1        -3.68213e-05    1.40199      :Y
// G: 1.00003  -0.344125      -0.714128     :Cb - 2^(prec - 1)
// B: 0.999823  1.77204       -8.04142e-06  :Cr - 2^(prec - 1)
//
// -----------------------------------------------------------
func sycc_to_rgb(tls *libc.TLS, offset int32, upb int32, y int32, cb int32, cr int32, out_r uintptr, out_g uintptr, out_b uintptr) { /* color.c:74:13: */
	var r int32
	var g int32
	var b int32

	cb = cb - offset
	cr = cr - offset
	r = y + libc.Int32FromFloat64(1.402*float64(float32(cr)))
	if r < 0 {
		r = 0
	} else if r > upb {
		r = upb
	}
	*(*int32)(unsafe.Pointer(out_r)) = r

	g = y - libc.Int32FromFloat64(0.344*float64(float32(cb))+0.714*float64(float32(cr)))
	if g < 0 {
		g = 0
	} else if g > upb {
		g = upb
	}
	*(*int32)(unsafe.Pointer(out_g)) = g

	b = y + libc.Int32FromFloat64(1.772*float64(float32(cb)))
	if b < 0 {
		b = 0
	} else if b > upb {
		b = upb
	}
	*(*int32)(unsafe.Pointer(out_b)) = b
}

func sycc444_to_rgb(tls *libc.TLS, img uintptr) { /* color.c:106:13: */
	var d0 uintptr
	var d1 uintptr
	var d2 uintptr
	var r uintptr
	var g uintptr
	var b uintptr
	var y uintptr
	var cb uintptr
	var cr uintptr
	var maxw Tsize_t
	var maxh Tsize_t
	var max Tsize_t
	var i Tsize_t
	var offset int32
	var upb int32

	upb = int32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fprec)
	offset = int32(1) << (upb - 1)
	upb = int32(1)<<upb - 1

	maxw = Tsize_t((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fw)
	maxh = Tsize_t((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fh)
	max = maxw * maxh

	y = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata
	cb = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdata
	cr = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 2*64)).Fdata

	d0 = libc.AssignUintptr(&r, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))
	d1 = libc.AssignUintptr(&g, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))
	d2 = libc.AssignUintptr(&b, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))

	if !(r == uintptr(0) || g == uintptr(0) || b == uintptr(0)) {
		goto __1
	}
	goto fails
__1:
	;

	i = 0
__2:
	if !(i < max) {
		goto __4
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)
	y += 4
	cb += 4
	cr += 4
	r += 4
	g += 4
	b += 4
	goto __3
__3:
	i++
	goto __2
	goto __4
__4:
	;
	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata = d0
	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdata = d1
	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 2*64)).Fdata = d2
	(*Topj_image_t)(unsafe.Pointer(img)).Fcolor_space = OPJ_CLRSPC_SRGB
	return

fails:
	Xopj_image_data_free(tls, r)
	Xopj_image_data_free(tls, g)
	Xopj_image_data_free(tls, b)
}

// sycc444_to_rgb()

func sycc422_to_rgb(tls *libc.TLS, img uintptr) { /* color.c:157:13: */
	var d0 uintptr
	var d1 uintptr
	var d2 uintptr
	var r uintptr
	var g uintptr
	var b uintptr
	var y uintptr
	var cb uintptr
	var cr uintptr
	var maxw Tsize_t
	var maxh Tsize_t
	var max Tsize_t
	var offx Tsize_t
	var loopmaxw Tsize_t
	var offset int32
	var upb int32
	var i Tsize_t
	var j Tsize_t

	upb = int32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fprec)
	offset = int32(1) << (upb - 1)
	upb = int32(1)<<upb - 1

	maxw = Tsize_t((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fw)
	maxh = Tsize_t((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fh)
	max = maxw * maxh

	y = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata
	cb = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdata
	cr = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 2*64)).Fdata

	d0 = libc.AssignUintptr(&r, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))
	d1 = libc.AssignUintptr(&g, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))
	d2 = libc.AssignUintptr(&b, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))

	if !(r == uintptr(0) || g == uintptr(0) || b == uintptr(0)) {
		goto __1
	}
	goto fails
__1:
	;

	// if img->x0 is odd, then first column shall use Cb/Cr = 0
	offx = Tsize_t((*Topj_image_t)(unsafe.Pointer(img)).Fx0 & 1)
	loopmaxw = maxw - offx

	i = 0
__2:
	if !(i < maxh) {
		goto __4
	}

	if !(offx > 0) {
		goto __5
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), 0, 0, r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4
__5:
	;

	j = 0
__6:
	if !(j < loopmaxw&libc.CplUint32(1)) {
		goto __8
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4
	cb += 4
	cr += 4
	goto __7
__7:
	j = j + 2
	goto __6
	goto __8
__8:
	;
	if !(j < loopmaxw) {
		goto __9
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4
	cb += 4
	cr += 4
__9:
	;
	goto __3
__3:
	i++
	goto __2
	goto __4
__4:
	;

	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata = d0
	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdata = d1
	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 2*64)).Fdata = d2

	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fw = libc.AssignPtrUint32((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64+8, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fw)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fh = libc.AssignPtrUint32((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64+12, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fh)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdx = libc.AssignPtrUint32((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdx)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdy = libc.AssignPtrUint32((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64+4, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdy)
	(*Topj_image_t)(unsafe.Pointer(img)).Fcolor_space = OPJ_CLRSPC_SRGB
	return

fails:
	Xopj_image_data_free(tls, r)
	Xopj_image_data_free(tls, g)
	Xopj_image_data_free(tls, b)
}

// sycc422_to_rgb()

func sycc420_to_rgb(tls *libc.TLS, img uintptr) { /* color.c:245:13: */
	var d0 uintptr
	var d1 uintptr
	var d2 uintptr
	var r uintptr
	var g uintptr
	var b uintptr
	var nr uintptr
	var ng uintptr
	var nb uintptr
	var y uintptr
	var cb uintptr
	var cr uintptr
	var ny uintptr
	var maxw Tsize_t
	var maxh Tsize_t
	var max Tsize_t
	var offx Tsize_t
	var loopmaxw Tsize_t
	var offy Tsize_t
	var loopmaxh Tsize_t
	var offset int32
	var upb int32
	var i Tsize_t
	var j Tsize_t
	var j1 Tsize_t
	var j2 Tsize_t

	upb = int32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fprec)
	offset = int32(1) << (upb - 1)
	upb = int32(1)<<upb - 1

	maxw = Tsize_t((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fw)
	maxh = Tsize_t((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fh)
	max = maxw * maxh

	y = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata
	cb = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdata
	cr = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 2*64)).Fdata

	d0 = libc.AssignUintptr(&r, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))
	d1 = libc.AssignUintptr(&g, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))
	d2 = libc.AssignUintptr(&b, Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(int32(0)))*max))

	if !(r == uintptr(0) || g == uintptr(0) || b == uintptr(0)) {
		goto __1
	}
	goto fails
__1:
	;

	// if img->x0 is odd, then first column shall use Cb/Cr = 0
	offx = Tsize_t((*Topj_image_t)(unsafe.Pointer(img)).Fx0 & 1)
	loopmaxw = maxw - offx
	// if img->y0 is odd, then first line shall use Cb/Cr = 0
	offy = Tsize_t((*Topj_image_t)(unsafe.Pointer(img)).Fy0 & 1)
	loopmaxh = maxh - offy

	if !(offy > 0) {
		goto __2
	}

	j = Tsize_t(0)
__3:
	if !(j < maxw) {
		goto __5
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), 0, 0, r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4
	goto __4
__4:
	j++
	goto __3
	goto __5
__5:
	;
__2:
	;

	i = 0
__6:
	if !(i < loopmaxh&libc.CplUint32(1)) {
		goto __8
	}

	ny = y + uintptr(maxw)*4
	nr = r + uintptr(maxw)*4
	ng = g + uintptr(maxw)*4
	nb = b + uintptr(maxw)*4

	if !(offx > 0) {
		goto __9
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), 0, 0, r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(ny)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), nr, ng, nb)
	ny += 4
	nr += 4
	ng += 4
	nb += 4
__9:
	;

	j1 = Tsize_t(0)
__10:
	if !(j1 < loopmaxw&libc.CplUint32(1)) {
		goto __12
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4

	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(ny)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), nr, ng, nb)
	ny += 4
	nr += 4
	ng += 4
	nb += 4
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(ny)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), nr, ng, nb)
	ny += 4
	nr += 4
	ng += 4
	nb += 4
	cb += 4
	cr += 4
	goto __11
__11:
	j1 = j1 + 2
	goto __10
	goto __12
__12:
	;
	if !(j1 < loopmaxw) {
		goto __13
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)
	y += 4
	r += 4
	g += 4
	b += 4

	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(ny)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), nr, ng, nb)
	ny += 4
	nr += 4
	ng += 4
	nb += 4
	cb += 4
	cr += 4
__13:
	;
	y += 4 * uintptr(maxw)
	r += 4 * uintptr(maxw)
	g += 4 * uintptr(maxw)
	b += 4 * uintptr(maxw)
	goto __7
__7:
	i = i + 2
	goto __6
	goto __8
__8:
	;
	if !(i < loopmaxh) {
		goto __14
	}

	j2 = 0
__15:
	if !(j2 < maxw&libc.CplUint32(1)) {
		goto __17
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)

	y += 4
	r += 4
	g += 4
	b += 4

	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)

	y += 4
	r += 4
	g += 4
	b += 4
	cb += 4
	cr += 4
	goto __16
__16:
	j2 = j2 + 2
	goto __15
	goto __17
__17:
	;
	if !(j2 < maxw) {
		goto __18
	}
	sycc_to_rgb(tls, offset, upb, *(*int32)(unsafe.Pointer(y)), *(*int32)(unsafe.Pointer(cb)), *(*int32)(unsafe.Pointer(cr)), r, g, b)
__18:
	;
__14:
	;

	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdata = d0
	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdata = d1
	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 2*64)).Fdata = d2

	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fw = libc.AssignPtrUint32((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64+8, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fw)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fh = libc.AssignPtrUint32((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64+12, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fh)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdx = libc.AssignPtrUint32((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdx)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps + 1*64)).Fdy = libc.AssignPtrUint32((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64+4, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdy)
	(*Topj_image_t)(unsafe.Pointer(img)).Fcolor_space = OPJ_CLRSPC_SRGB
	return

fails:
	Xopj_image_data_free(tls, r)
	Xopj_image_data_free(tls, g)
	Xopj_image_data_free(tls, b)
}

// sycc420_to_rgb()

func Xcolor_sycc_to_rgb(tls *libc.TLS, img uintptr) { /* color.c:403:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if (*Topj_image_t)(unsafe.Pointer(img)).Fnumcomps < TOPJ_UINT32(3) {
		(*Topj_image_t)(unsafe.Pointer(img)).Fcolor_space = OPJ_CLRSPC_GRAY
		return
	}

	if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdx == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdx == TOPJ_UINT32(2) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdx == TOPJ_UINT32(2) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdy == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdy == TOPJ_UINT32(2) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdy == TOPJ_UINT32(2) { // horizontal and vertical sub-sample
		sycc420_to_rgb(tls, img)
	} else if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdx == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdx == TOPJ_UINT32(2) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdx == TOPJ_UINT32(2) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdy == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdy == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdy == TOPJ_UINT32(1) { // horizontal sub-sample only
		sycc422_to_rgb(tls, img)
	} else if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdx == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdx == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdx == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps)).Fdy == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+1*64)).Fdy == TOPJ_UINT32(1) &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(img)).Fcomps+2*64)).Fdy == TOPJ_UINT32(1) { // no sub-sample
		sycc444_to_rgb(tls, img)
	} else {
		libc.Xfprintf(tls, libc.Xstderr, ts, libc.VaList(bp, ts+42,
			433))
		return
	}
}

// color_sycc_to_rgb()

func Xcolor_cmyk_to_rgb(tls *libc.TLS, image uintptr) { /* color.c:1004:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var C float32
	var M float32
	var Y float32
	var K float32
	var sC float32
	var sM float32
	var sY float32
	var sK float32
	var w uint32
	var h uint32
	var max uint32
	var i uint32

	w = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw
	h = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh

	if (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps < TOPJ_UINT32(4) ||
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdx || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdx || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+3*64)).Fdx ||
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdy || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdy || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+3*64)).Fdy {
		libc.Xfprintf(tls, libc.Xstderr, ts+68, libc.VaList(bp, ts+42,
			1023))
		return
	}

	max = w * h

	sC = 1.0 / float32(int32(1)<<(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec-1)
	sM = 1.0 / float32(int32(1)<<(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fprec-1)
	sY = 1.0 / float32(int32(1)<<(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fprec-1)
	sK = 1.0 / float32(int32(1)<<(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+3*64)).Fprec-1)

	for i = uint32(0); i < max; i++ {
		// CMYK values from 0 to 1
		C = float32(*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdata + uintptr(i)*4))) * sC
		M = float32(*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdata + uintptr(i)*4))) * sM
		Y = float32(*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdata + uintptr(i)*4))) * sY
		K = float32(*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+3*64)).Fdata + uintptr(i)*4))) * sK

		// Invert all CMYK values
		C = 1.0 - C
		M = 1.0 - M
		Y = 1.0 - Y
		K = 1.0 - K

		// CMYK -> RGB : RGB results from 0 to 255
		*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdata + uintptr(i)*4)) = libc.Int32FromFloat32(255.0 * C * K)      // R
		*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdata + uintptr(i)*4)) = libc.Int32FromFloat32(255.0 * M * K) // G
		*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdata + uintptr(i)*4)) = libc.Int32FromFloat32(255.0 * Y * K) // B
	}

	Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+3*64)).Fdata)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps + 3*64)).Fdata = uintptr(0)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec = TOPJ_UINT32(8)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps + 1*64)).Fprec = TOPJ_UINT32(8)
	(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps + 2*64)).Fprec = TOPJ_UINT32(8)
	*(*TOPJ_UINT32)(unsafe.Pointer(image + 16)) -= TOPJ_UINT32(1)
	(*Topj_image_t)(unsafe.Pointer(image)).Fcolor_space = OPJ_CLRSPC_SRGB

	for i = uint32(3); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
		libc.Xmemcpy(tls, (*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64, (*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i+uint32(1))*64, uint32(unsafe.Sizeof(Topj_image_comp_t{})))
	}

}

// color_cmyk_to_rgb()

// This code has been adopted from sjpx_openjpeg.c of ghostscript
func Xcolor_esycc_to_rgb(tls *libc.TLS, image uintptr) { /* color.c:1070:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var y int32
	var cb int32
	var cr int32
	var sign1 int32
	var sign2 int32
	var val int32
	var w uint32
	var h uint32
	var max uint32
	var i uint32
	var flip_value int32 = int32(1) << ((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec - TOPJ_UINT32(1))
	var max_value int32 = int32(1)<<(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec - 1

	if (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps < TOPJ_UINT32(3) ||
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdx || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdx ||
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdy || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdy {
		libc.Xfprintf(tls, libc.Xstderr, ts+110, libc.VaList(bp, ts+42,
			1085))
		return
	}

	w = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw
	h = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh

	sign1 = int32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps + 1*64)).Fsgnd)
	sign2 = int32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps + 2*64)).Fsgnd)

	max = w * h

	for i = uint32(0); i < max; i++ {

		y = *(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdata + uintptr(i)*4))
		cb = *(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdata + uintptr(i)*4))
		cr = *(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdata + uintptr(i)*4))

		if !(sign1 != 0) {
			cb = cb - flip_value
		}
		if !(sign2 != 0) {
			cr = cr - flip_value
		}

		val = libc.Int32FromFloat32(float32(y) - 0.0000368*float32(cb) +
			1.40199*float32(cr) + 0.5)

		if val > max_value {
			val = max_value
		} else if val < 0 {
			val = 0
		}
		*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdata + uintptr(i)*4)) = val

		val = libc.Int32FromFloat32(1.0003*float32(y) - 0.344125*float32(cb) -
			0.7141128*float32(cr) + 0.5)

		if val > max_value {
			val = max_value
		} else if val < 0 {
			val = 0
		}
		*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdata + uintptr(i)*4)) = val

		val = libc.Int32FromFloat32(0.999823*float32(y) + 1.77204*float32(cb) -
			0.000008*float32(cr) + 0.5)

		if val > max_value {
			val = max_value
		} else if val < 0 {
			val = 0
		}
		*(*TOPJ_INT32)(unsafe.Pointer((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdata + uintptr(i)*4)) = val
	}
	(*Topj_image_t)(unsafe.Pointer(image)).Fcolor_space = OPJ_CLRSPC_SRGB

} // color_esycc_to_rgb()

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// NB: Include guard matches what <linux/time.h> uses.

// POSIX.1b structure for timer start values and intervals.
type Sitimerspec = struct {
	Fit_interval struct {
		Ftv_sec  T__time_t
		Ftv_nsec T__syscall_slong_t
	}
	Fit_value struct {
		Ftv_sec  T__time_t
		Ftv_nsec T__syscall_slong_t
	}
} /* struct_itimerspec.h:8:1 */

//
//  ==========================================================
//    OpenJPEG modules
//  ==========================================================

// Are restricted pointers available? (C99)

// MSVC before 2013 and Borland C do not have lrintf
func opj_lrintf(tls *libc.TLS, f float32) int32 { /* opj_includes.h:176:20: */
	return Xlrintf(tls, f)
}

// MSVC x86 is really bad at doing int64 = int32 * int32 on its own. Use intrinsic.

// Apparently Visual Studio doesn't define __SSE__ / __SSE2__ macros

// For x86, test the value of the _M_IX86_FP macro.
// See https://msdn.microsoft.com/en-us/library/b0084kay.aspx

// Type to use for bit-fields in internal headers
type TOPJ_BITFIELD = uint32 /* opj_includes.h:219:22 */

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2012, Mathieu Malaterre <mathieu.malaterre@gmail.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// create opj_config_private.h for CMake

// Not used by openjp2
//#define HAVE_MEMORY_H 1
//#define HAVE_STDLIB_H 1
//#define HAVE_STRINGS_H 1
//#define HAVE_STRING_H 1
//#define HAVE_SYS_STAT_H 1
//#define HAVE_SYS_TYPES_H 1
//#define HAVE_UNISTD_H 1

// #undef _LARGEFILE_SOURCE
// #undef _LARGE_FILES
// #undef _FILE_OFFSET_BITS

// find whether or not have <malloc.h>
// check if function `aligned_alloc` exists
// #undef OPJ_HAVE_ALIGNED_ALLOC
// check if function `_aligned_malloc` exists
// #undef OPJ_HAVE__ALIGNED_MALLOC
// check if function `memalign` exists
// check if function `posix_memalign` exists

// Byte order.
// All compilers that support Mac OS X define either __BIG_ENDIAN__ or
// __LITTLE_ENDIAN__ to match the endianness of the architecture being
// compiled for. This is not necessarily the same as the architecture of the
// machine doing the building. In order to support Universal Binaries on
// Mac OS X, we prefer those defines to decide the endianness.
// On other platforms we use the result of the TRY_RUN.
// #undef OPJ_BIG_ENDIAN
// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get the type definitions.

// Get a definition for wchar_t.  But we must not define wchar_t itself.
type T__gwchar_t = int32 /* inttypes.h:34:24 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `ldiv_t'.
type Timaxdiv_t = struct {
	Fquot int32
	Frem  int32
} /* inttypes.h:275:5 */

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//    as great as that of any standard type not using alignment
//    specifiers.
type Tmax_align_t = struct {
	F__max_align_ll int64
	F__max_align_ld float64
} /* stddef.h:426:3 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file event.h
// @brief Implementation of a event callback system
//
// The functions in EVENT.C have for goal to send output messages (errors, warnings, debug) to the user.
//*
// Message handler object
// used for
// <ul>
// <li>Error messages
// <li>Warning messages
// <li>Debugging messages
// </ul>
type Sopj_event_mgr = struct {
	Fm_error_data    uintptr
	Fm_warning_data  uintptr
	Fm_info_data     uintptr
	Ferror_handler   Topj_msg_callback
	Fwarning_handler Topj_msg_callback
	Finfo_handler    Topj_msg_callback
} /* event.h:50:9 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file event.h
// @brief Implementation of a event callback system
//
// The functions in EVENT.C have for goal to send output messages (errors, warnings, debug) to the user.
//*
// Message handler object
// used for
// <ul>
// <li>Error messages
// <li>Warning messages
// <li>Debugging messages
// </ul>
type Topj_event_mgr_t = Sopj_event_mgr /* event.h:63:3 */

//
// #ifdef __GNUC__
// #pragma GCC poison printf fprintf
// #endif

//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
//  @file function_list.h
//  @brief Implementation of a list of procedures.
//
//  * The functions in validation.c aims to have access to a list of procedures.

//* @defgroup VAL VAL - validation procedure
//@{

// *************************************************************************************************
//
// FORWARD DECLARATION ************************************
//

// *
// declare a function pointer
type Topj_procedure = uintptr /* function_list.h:52:14 */

// *
// A list of procedures.
type Sopj_procedure_list = struct {
	Fm_nb_procedures     TOPJ_UINT32
	Fm_nb_max_procedures TOPJ_UINT32
	Fm_procedures        uintptr
} /* function_list.h:57:9 */

// *
// A list of procedures.
type Topj_procedure_list_t = Sopj_procedure_list /* function_list.h:71:3 */
//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

//*
// @file bio.h
// @brief Implementation of an individual bit input-output (BIO)
//
// The functions in BIO.C have for goal to realize an individual bit input - output.

//* @defgroup BIO BIO - Individual bit input-output stream
//@{

//*
// Individual bit input-output stream (BIO)
type Sopj_bio = struct {
	Fstart uintptr
	Fend   uintptr
	Fbp    uintptr
	Fbuf   TOPJ_UINT32
	Fct    TOPJ_UINT32
} /* bio.h:56:9 */

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// Copyright (C) 1989-2020 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

//*
// @file bio.h
// @brief Implementation of an individual bit input-output (BIO)
//
// The functions in BIO.C have for goal to realize an individual bit input - output.

//* @defgroup BIO BIO - Individual bit input-output stream
//@{

//*
// Individual bit input-output stream (BIO)
type Topj_bio_t = Sopj_bio /* bio.h:67:3 */
// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
// @file cio.h
// @brief Implementation of a byte input-output process (CIO)
//
// The functions in CIO.C have for goal to realize a byte input / output process.

//* @defgroup CIO CIO - byte input-output stream
//@{

// create opj_config_private.h for CMake

// Not used by openjp2
//#define HAVE_MEMORY_H 1
//#define HAVE_STDLIB_H 1
//#define HAVE_STRINGS_H 1
//#define HAVE_STRING_H 1
//#define HAVE_SYS_STAT_H 1
//#define HAVE_SYS_TYPES_H 1
//#define HAVE_UNISTD_H 1

// #undef _LARGEFILE_SOURCE
// #undef _LARGE_FILES
// #undef _FILE_OFFSET_BITS

// find whether or not have <malloc.h>
// check if function `aligned_alloc` exists
// #undef OPJ_HAVE_ALIGNED_ALLOC
// check if function `_aligned_malloc` exists
// #undef OPJ_HAVE__ALIGNED_MALLOC
// check if function `memalign` exists
// check if function `posix_memalign` exists

// Byte order.
// All compilers that support Mac OS X define either __BIG_ENDIAN__ or
// __LITTLE_ENDIAN__ to match the endianness of the architecture being
// compiled for. This is not necessarily the same as the architecture of the
// machine doing the building. In order to support Universal Binaries on
// Mac OS X, we prefer those defines to decide the endianness.
// On other platforms we use the result of the TRY_RUN.
// #undef OPJ_BIG_ENDIAN

// -----------------------------------------------------------------------

//*
// Byte input-output stream.
type Sopj_stream_private = struct {
	Fm_user_data         uintptr
	Fm_free_user_data_fn Topj_stream_free_user_data_fn
	Fm_user_data_length  TOPJ_UINT64
	F__ccgo_pad1         [4]byte
	Fm_read_fn           Topj_stream_read_fn
	Fm_write_fn          Topj_stream_write_fn
	Fm_skip_fn           Topj_stream_skip_fn
	Fm_seek_fn           Topj_stream_seek_fn
	Fm_stored_data       uintptr
	Fm_current_data      uintptr
	Fm_opj_skip          uintptr
	Fm_opj_seek          uintptr
	Fm_bytes_in_buffer   TOPJ_SIZE_T
	Fm_byte_offset       TOPJ_OFF_T
	Fm_buffer_size       TOPJ_SIZE_T
	Fm_status            TOPJ_UINT32
} /* cio.h:81:9 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
// @file cio.h
// @brief Implementation of a byte input-output process (CIO)
//
// The functions in CIO.C have for goal to realize a byte input / output process.

//* @defgroup CIO CIO - byte input-output stream
//@{

// create opj_config_private.h for CMake

// Not used by openjp2
//#define HAVE_MEMORY_H 1
//#define HAVE_STDLIB_H 1
//#define HAVE_STRINGS_H 1
//#define HAVE_STRING_H 1
//#define HAVE_SYS_STAT_H 1
//#define HAVE_SYS_TYPES_H 1
//#define HAVE_UNISTD_H 1

// #undef _LARGEFILE_SOURCE
// #undef _LARGE_FILES
// #undef _FILE_OFFSET_BITS

// find whether or not have <malloc.h>
// check if function `aligned_alloc` exists
// #undef OPJ_HAVE_ALIGNED_ALLOC
// check if function `_aligned_malloc` exists
// #undef OPJ_HAVE__ALIGNED_MALLOC
// check if function `memalign` exists
// check if function `posix_memalign` exists

// Byte order.
// All compilers that support Mac OS X define either __BIG_ENDIAN__ or
// __LITTLE_ENDIAN__ to match the endianness of the architecture being
// compiled for. This is not necessarily the same as the architecture of the
// machine doing the building. In order to support Universal Binaries on
// Mac OS X, we prefer those defines to decide the endianness.
// On other platforms we use the result of the TRY_RUN.
// #undef OPJ_BIG_ENDIAN

// -----------------------------------------------------------------------

//*
// Byte input-output stream.
type Topj_stream_private_t = Sopj_stream_private /* cio.h:165:1 */

// * User function to execute in a thread
// @param user_data user data provided with opj_thread_create()
type Topj_thread_fn = uintptr /* thread.h:146:14 */

//@}

//* @name Thread local storage
//@{
//* Opaque type for a thread local storage
type Sopj_tls_t = struct {
	Fkey_val       uintptr
	Fkey_val_count int32
	F__ccgo_pad1   [4]byte
} /* thread.h:167:9 */

//* Type of the function used to free a TLS value
type Topj_tls_free_func = uintptr /* thread.h:177:14 */

//@}

//* @name Thread pool
//@{

//* Opaque type for a thread pool
type Sopj_thread_pool_t = struct {
	Fworker_threads              uintptr
	Fworker_threads_count        int32
	F__ccgo_pad1                 [4]byte
	Fcond                        uintptr
	Fmutex                       uintptr
	Fstate                       Topj_worker_thread_state
	F__ccgo_pad2                 [4]byte
	Fjob_queue                   uintptr
	Fpending_jobs_count          int32
	F__ccgo_pad3                 [4]byte
	Fwaiting_worker_thread_list  uintptr
	Fwaiting_worker_thread_count int32
	F__ccgo_pad4                 [4]byte
	Ftls                         uintptr
	Fsignaling_threshold         int32
	F__ccgo_pad5                 [4]byte
} /* thread.h:195:9 */

// * User function to execute in a thread
// @param user_data user data provided with opj_thread_create()
// @param tls handle to thread local storage
type Topj_job_fn = uintptr /* thread.h:213:14 */
type Sopj_cp = struct {
	Frsiz              TOPJ_UINT16
	F__ccgo_pad1       [2]byte
	Ftx0               TOPJ_UINT32
	Fty0               TOPJ_UINT32
	Ftdx               TOPJ_UINT32
	Ftdy               TOPJ_UINT32
	F__ccgo_pad2       [4]byte
	Fcomment           uintptr
	Ftw                TOPJ_UINT32
	Fth                TOPJ_UINT32
	Fppm_markers_count TOPJ_UINT32
	F__ccgo_pad3       [4]byte
	Fppm_markers       uintptr
	Fppm_data          uintptr
	Fppm_len           TOPJ_UINT32
	Fppm_data_read     TOPJ_UINT32
	Fppm_data_current  uintptr
	Fppm_buffer        uintptr
	Fppm_data_first    uintptr
	Fppm_data_size     TOPJ_UINT32
	Fppm_store         TOPJ_INT32
	Fppm_previous      TOPJ_INT32
	F__ccgo_pad4       [4]byte
	Ftcps              uintptr
	Fm_specific_param  struct {
		F__ccgo_pad1 [0]uint64
		Fm_dec       Topj_decoding_param_t
		F__ccgo_pad2 [16]byte
	}
	Fstrict      TOPJ_BOOL
	Fppm         uint8 /* OPJ_BITFIELD ppm: 1, OPJ_BITFIELD m_is_decoder: 1, OPJ_BITFIELD allow_different_bit_depth_sign: 1 */
	F__ccgo_pad5 [3]byte
} /* image.h:41:1 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2006-2007, Parvatha Elangovan
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France
// Copyright (c) 2012, CS Systemes d'Information, France
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file j2k.h
// @brief The JPEG-2000 Codestream Reader/Writer (J2K)
//
// The functions in J2K.C have for goal to read/write the several parts of the codestream: markers and data.

//* @defgroup J2K J2K - JPEG-2000 codestream reader/writer
//@{

// -----------------------------------------------------------------------

// UniPG>>
// <<UniPG

// -----------------------------------------------------------------------

// *
// Values that specify the status of the decoding process when decoding the main header.
// These values may be combined with a | operator.
//
type TJ2K_STATUS = uint32 /* j2k.h:135:3 */

// *
// Type of elements storing in the MCT data
type TJ2K_MCT_ELEMENT_TYPE = uint32 /* j2k.h:145:3 */

// *
// Type of MCT array
type TJ2K_MCT_ARRAY_TYPE = uint32 /* j2k.h:154:3 */

// -----------------------------------------------------------------------

//*
// T2 encoding mode
type TJ2K_T2_MODE = uint32 /* j2k.h:164:3 */

// *
// Quantization stepsize
type Sopj_stepsize = struct {
	Fexpn TOPJ_INT32
	Fmant TOPJ_INT32
} /* image.h:41:1 */

// *
// Quantization stepsize
type Topj_stepsize_t = Sopj_stepsize /* j2k.h:174:3 */

//*
// Tile-component coding parameters
type Sopj_tccp = struct {
	Fcsty             TOPJ_UINT32
	Fnumresolutions   TOPJ_UINT32
	Fcblkw            TOPJ_UINT32
	Fcblkh            TOPJ_UINT32
	Fcblksty          TOPJ_UINT32
	Fqmfbid           TOPJ_UINT32
	Fqntsty           TOPJ_UINT32
	Fstepsizes        [97]Topj_stepsize_t
	Fnumgbits         TOPJ_UINT32
	Froishift         TOPJ_INT32
	Fprcw             [33]TOPJ_UINT32
	Fprch             [33]TOPJ_UINT32
	Fm_dc_level_shift TOPJ_INT32
} /* image.h:41:1 */

//*
// Tile-component coding parameters
type Topj_tccp_t = Sopj_tccp /* j2k.h:207:1 */

// *
// FIXME DOC
type Sopj_mct_data = struct {
	Fm_element_type TJ2K_MCT_ELEMENT_TYPE
	Fm_array_type   TJ2K_MCT_ARRAY_TYPE
	Fm_index        TOPJ_UINT32
	F__ccgo_pad1    [4]byte
	Fm_data         uintptr
	Fm_data_size    TOPJ_UINT32
	F__ccgo_pad2    [4]byte
} /* image.h:41:1 */

// *
// FIXME DOC
type Topj_mct_data_t = Sopj_mct_data /* j2k.h:221:1 */

// *
// FIXME DOC
type Sopj_simple_mcc_decorrelation_data = struct {
	Fm_index               TOPJ_UINT32
	Fm_nb_comps            TOPJ_UINT32
	Fm_decorrelation_array uintptr
	Fm_offset_array        uintptr
	Fm_is_irreversible     uint8 /* OPJ_BITFIELD m_is_irreversible: 1 */
	F__ccgo_pad1           [7]byte
} /* image.h:41:1 */

// *
// FIXME DOC
type Topj_simple_mcc_decorrelation_data_t = Sopj_simple_mcc_decorrelation_data /* j2k.h:233:1 */

type Sopj_ppx_struct = struct {
	Fm_data      uintptr
	Fm_data_size TOPJ_UINT32
	F__ccgo_pad1 [4]byte
} /* image.h:41:1 */

type Topj_ppx = Sopj_ppx_struct /* j2k.h:238:3 */

//*
// Tile coding parameters :
// this structure is used to store coding/decoding parameters common to all
// tiles (information like COD, COC in main header)
type Sopj_tcp = struct {
	Fcsty                       TOPJ_UINT32
	Fprg                        TOPJ_PROG_ORDER
	Fnumlayers                  TOPJ_UINT32
	Fnum_layers_to_decode       TOPJ_UINT32
	Fmct                        TOPJ_UINT32
	Frates                      [100]TOPJ_FLOAT32
	Fnumpocs                    TOPJ_UINT32
	Fpocs                       [32]Topj_poc_t
	Fppt_markers_count          TOPJ_UINT32
	F__ccgo_pad1                [4]byte
	Fppt_markers                uintptr
	Fppt_data                   uintptr
	Fppt_buffer                 uintptr
	Fppt_data_size              TOPJ_UINT32
	Fppt_len                    TOPJ_UINT32
	Fdistoratio                 [100]TOPJ_FLOAT32
	Ftccps                      uintptr
	Fm_current_tile_part_number TOPJ_INT32
	Fm_nb_tile_parts            TOPJ_UINT32
	Fm_data                     uintptr
	Fm_data_size                TOPJ_UINT32
	F__ccgo_pad2                [4]byte
	Fmct_norms                  uintptr
	Fm_mct_decoding_matrix      uintptr
	Fm_mct_coding_matrix        uintptr
	Fm_mct_records              uintptr
	Fm_nb_mct_records           TOPJ_UINT32
	Fm_nb_max_mct_records       TOPJ_UINT32
	Fm_mcc_records              uintptr
	Fm_nb_mcc_records           TOPJ_UINT32
	Fm_nb_max_mcc_records       TOPJ_UINT32
	Fcod                        uint8 /* OPJ_BITFIELD cod: 1, OPJ_BITFIELD ppt: 1, OPJ_BITFIELD POC: 1 */
	F__ccgo_pad3                [7]byte
} /* image.h:41:1 */

//*
// Tile coding parameters :
// this structure is used to store coding/decoding parameters common to all
// tiles (information like COD, COC in main header)
type Topj_tcp_t = Sopj_tcp /* j2k.h:314:3 */

type Sopj_encoding_param = struct {
	Fm_max_comp_size TOPJ_UINT32
	Fm_tp_pos        TOPJ_INT32
	Fm_matrice       uintptr
	Fm_tp_flag       TOPJ_BYTE
	F__ccgo_pad1     [3]byte
	Fm_disto_alloc   uint8 /* OPJ_BITFIELD m_disto_alloc: 1, OPJ_BITFIELD m_fixed_alloc: 1, OPJ_BITFIELD m_fixed_quality: 1, OPJ_BITFIELD m_tp_on: 1 */
	F__ccgo_pad2     [3]byte
} /* j2k.h:319:9 */

type Topj_encoding_param_t = Sopj_encoding_param /* j2k.h:337:1 */

type Sopj_decoding_param = struct {
	Fm_reduce TOPJ_UINT32
	Fm_layer  TOPJ_UINT32
} /* j2k.h:339:9 */

type Topj_decoding_param_t = Sopj_decoding_param /* j2k.h:345:1 */

// *
// Coding parameters
type Topj_cp_t = Sopj_cp /* j2k.h:460:3 */

type Sopj_j2k_dec = struct {
	Fm_state                   TOPJ_UINT32
	F__ccgo_pad1               [4]byte
	Fm_default_tcp             uintptr
	Fm_header_data             uintptr
	Fm_header_data_size        TOPJ_UINT32
	Fm_sot_length              TOPJ_UINT32
	Fm_start_tile_x            TOPJ_UINT32
	Fm_start_tile_y            TOPJ_UINT32
	Fm_end_tile_x              TOPJ_UINT32
	Fm_end_tile_y              TOPJ_UINT32
	Fm_tile_ind_to_dec         TOPJ_INT32
	Fm_last_sot_read_pos       TOPJ_OFF_T
	Fm_last_tile_part          TOPJ_BOOL
	Fm_numcomps_to_decode      TOPJ_UINT32
	Fm_comps_indices_to_decode uintptr
	Fm_can_decode              uint8 /* OPJ_BITFIELD m_can_decode: 1, OPJ_BITFIELD m_discard_tiles: 1, OPJ_BITFIELD m_skip_data: 1, OPJ_BITFIELD m_nb_tile_parts_correction_checked: 1, OPJ_BITFIELD m_nb_tile_parts_correction: 1 */
	F__ccgo_pad2               [7]byte
} /* j2k.h:463:9 */

type Topj_j2k_dec_t = Sopj_j2k_dec /* j2k.h:503:3 */

type Sopj_j2k_enc = struct {
	Fm_current_poc_tile_part_number TOPJ_UINT32
	Fm_current_tile_part_number     TOPJ_UINT32
	Fm_TLM                          TOPJ_BOOL
	Fm_Ttlmi_is_byte                TOPJ_BOOL
	Fm_tlm_start                    TOPJ_OFF_T
	F__ccgo_pad1                    [4]byte
	Fm_tlm_sot_offsets_buffer       uintptr
	Fm_tlm_sot_offsets_current      uintptr
	Fm_total_tile_parts             TOPJ_UINT32
	F__ccgo_pad2                    [4]byte
	Fm_encoded_tile_data            uintptr
	Fm_encoded_tile_size            TOPJ_UINT32
	F__ccgo_pad3                    [4]byte
	Fm_header_tile_data             uintptr
	Fm_header_tile_data_size        TOPJ_UINT32
	Fm_PLT                          TOPJ_BOOL
	Fm_reserved_bytes_for_PLT       TOPJ_UINT32
	Fm_nb_comps                     TOPJ_UINT32
} /* j2k.h:505:9 */

type Topj_j2k_enc_t = Sopj_j2k_enc /* j2k.h:558:3 */

type Sopj_tcd = struct {
	Ftp_pos              TOPJ_INT32
	Ftp_num              TOPJ_UINT32
	Fcur_tp_num          TOPJ_UINT32
	Fcur_totnum_tp       TOPJ_UINT32
	Fcur_pino            TOPJ_UINT32
	F__ccgo_pad1         [4]byte
	Ftcd_image           uintptr
	Fimage               uintptr
	Fcp                  uintptr
	Ftcp                 uintptr
	Ftcd_tileno          TOPJ_UINT32
	Fm_is_decoder        uint8 /* OPJ_BITFIELD m_is_decoder: 1 */
	F__ccgo_pad2         [3]byte
	Fthread_pool         uintptr
	Fwin_x0              TOPJ_UINT32
	Fwin_y0              TOPJ_UINT32
	Fwin_x1              TOPJ_UINT32
	Fwin_y1              TOPJ_UINT32
	Fwhole_tile_decoding TOPJ_BOOL
	F__ccgo_pad3         [4]byte
	Fused_component      uintptr
} /* j2k.h:562:1 */

//*
// JPEG-2000 codestream reader/writer
type Sopj_j2k = struct {
	Fm_is_decoder     TOPJ_BOOL
	F__ccgo_pad1      [4]byte
	Fm_specific_param struct {
		Fm_decoder   Topj_j2k_dec_t
		F__ccgo_pad1 [8]byte
	}
	Fm_private_image       uintptr
	Fm_output_image        uintptr
	Fm_cp                  Topj_cp_t
	Fm_procedure_list      uintptr
	Fm_validation_list     uintptr
	Fcstr_index            uintptr
	Fm_current_tile_number TOPJ_UINT32
	F__ccgo_pad2           [4]byte
	Fm_tcd                 uintptr
	Fm_tp                  uintptr
	Fihdr_w                TOPJ_UINT32
	Fihdr_h                TOPJ_UINT32
	Fdump_state            uint32
	F__ccgo_pad3           [4]byte
} /* j2k.h:566:9 */

//*
// JPEG-2000 codestream reader/writer
type Topj_j2k_t = Sopj_j2k /* j2k.h:613:1 */

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file jp2.h
// @brief The JPEG-2000 file format Reader/Writer (JP2)
//

//* @defgroup JP2 JP2 - JPEG-2000 file format reader/writer
//@{

//#define JPIP_JPIP 0x6a706970

// For the future
/* #define JP2_RES 0x72657320 */ //*< Resolution box (super-box)
/* #define JP2_JP2I 0x6a703269 */ //*< Intellectual property box
/* #define JP2_XML  0x786d6c20 */ //*< XML box
/* #define JP2_UUID 0x75756994 */ //*< UUID box
/* #define JP2_UINF 0x75696e66 */ //*< UUID info box (super-box)
/* #define JP2_ULST 0x756c7374 */ //*< UUID list box

// -----------------------------------------------------------------------

type TJP2_STATE = uint32 /* jp2.h:82:1 */

type TJP2_IMG_STATE = uint32 /* jp2.h:88:1 */

//*
// Channel description: channel index, type, association
type Sopj_jp2_cdef_info = struct {
	Fcn   TOPJ_UINT16
	Ftyp  TOPJ_UINT16
	Fasoc TOPJ_UINT16
} /* jp2.h:93:9 */

//*
// Channel description: channel index, type, association
type Topj_jp2_cdef_info_t = Sopj_jp2_cdef_info /* jp2.h:95:3 */

//*
// Channel descriptions and number of descriptions
type Sopj_jp2_cdef = struct {
	Finfo        uintptr
	Fn           TOPJ_UINT16
	F__ccgo_pad1 [6]byte
} /* jp2.h:100:9 */

//*
// Channel descriptions and number of descriptions
type Topj_jp2_cdef_t = Sopj_jp2_cdef /* jp2.h:103:3 */

//*
// Component mappings: channel index, mapping type, palette index
type Sopj_jp2_cmap_comp = struct {
	Fcmp  TOPJ_UINT16
	Fmtyp TOPJ_BYTE
	Fpcol TOPJ_BYTE
} /* jp2.h:108:9 */

//*
// Component mappings: channel index, mapping type, palette index
type Topj_jp2_cmap_comp_t = Sopj_jp2_cmap_comp /* jp2.h:111:3 */

//*
// Palette data: table entries, palette columns
type Sopj_jp2_pclr = struct {
	Fentries      uintptr
	Fchannel_sign uintptr
	Fchannel_size uintptr
	Fcmap         uintptr
	Fnr_entries   TOPJ_UINT16
	Fnr_channels  TOPJ_BYTE
	F__ccgo_pad1  [5]byte
} /* jp2.h:116:9 */

//*
// Palette data: table entries, palette columns
type Topj_jp2_pclr_t = Sopj_jp2_pclr /* jp2.h:123:3 */

//*
// Collector for ICC profile, palette, component mapping, channel description
type Sopj_jp2_color = struct {
	Ficc_profile_buf uintptr
	Ficc_profile_len TOPJ_UINT32
	F__ccgo_pad1     [4]byte
	Fjp2_cdef        uintptr
	Fjp2_pclr        uintptr
	Fjp2_has_colr    TOPJ_BYTE
	F__ccgo_pad2     [7]byte
} /* jp2.h:128:9 */

//*
// Collector for ICC profile, palette, component mapping, channel description
type Topj_jp2_color_t = Sopj_jp2_color /* jp2.h:135:3 */

//*
// JP2 component
type Sopj_jp2_comps = struct {
	Fdepth TOPJ_UINT32
	Fsgnd  TOPJ_UINT32
	Fbpcc  TOPJ_UINT32
} /* jp2.h:140:9 */

//*
// JP2 component
type Topj_jp2_comps_t = Sopj_jp2_comps /* jp2.h:144:3 */

//*
// JPEG-2000 file format reader/writer
type Sopj_jp2 = struct {
	Fj2k                   uintptr
	Fm_validation_list     uintptr
	Fm_procedure_list      uintptr
	Fw                     TOPJ_UINT32
	Fh                     TOPJ_UINT32
	Fnumcomps              TOPJ_UINT32
	Fbpc                   TOPJ_UINT32
	FC                     TOPJ_UINT32
	FUnkC                  TOPJ_UINT32
	FIPR                   TOPJ_UINT32
	Fmeth                  TOPJ_UINT32
	Fapprox                TOPJ_UINT32
	Fenumcs                TOPJ_UINT32
	Fprecedence            TOPJ_UINT32
	Fbrand                 TOPJ_UINT32
	Fminversion            TOPJ_UINT32
	Fnumcl                 TOPJ_UINT32
	Fcl                    uintptr
	Fcomps                 uintptr
	Fj2k_codestream_offset TOPJ_OFF_T
	Fjpip_iptr_offset      TOPJ_OFF_T
	Fjpip_on               TOPJ_BOOL
	Fjp2_state             TOPJ_UINT32
	Fjp2_img_state         TOPJ_UINT32
	F__ccgo_pad1           [4]byte
	Fcolor                 Topj_jp2_color_t
	Fignore_pclr_cmap_cdef TOPJ_BOOL
	Fhas_jp2h              TOPJ_BYTE
	Fhas_ihdr              TOPJ_BYTE
	F__ccgo_pad2           [2]byte
} /* jp2.h:149:9 */

//*
// JPEG-2000 file format reader/writer
type Topj_jp2_t = Sopj_jp2 /* jp2.h:193:1 */

//*
// JP2 Box
type Sopj_jp2_box = struct {
	Flength   TOPJ_UINT32
	Ftype     TOPJ_UINT32
	Finit_pos TOPJ_INT32
} /* jp2.h:198:9 */

//*
// JP2 Box
type Topj_jp2_box_t = Sopj_jp2_box /* jp2.h:202:3 */

type Sopj_jp2_header_handler = struct {
	Fid          TOPJ_UINT32
	F__ccgo_pad1 [4]byte
	Fhandler     uintptr
} /* jp2.h:204:9 */

type Topj_jp2_header_handler_t = Sopj_jp2_header_handler /* jp2.h:213:1 */

type Sopj_jp2_img_header_writer_handler = struct {
	Fhandler     uintptr
	Fm_data      uintptr
	Fm_size      TOPJ_UINT32
	F__ccgo_pad1 [4]byte
} /* jp2.h:216:9 */

type Topj_jp2_img_header_writer_handler_t = Sopj_jp2_img_header_writer_handler /* jp2.h:224:1 */

//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2017, IntoPIX SA <support@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//
//  ==========================================================
//    Common constants shared among several modules
//  ==========================================================

//*
// @file mqc.h
// @brief Implementation of an MQ-Coder (MQC)
//
// The functions in MQC.C have for goal to realize the MQ-coder operations. The functions
// in MQC.C are used by some function in T1.C.

//* @defgroup MQC MQC - Implementation of an MQ-Coder
//@{

//*
// This struct defines the state of a context.
type Sopj_mqc_state = struct {
	Fqeval TOPJ_UINT32
	Fmps   TOPJ_UINT32
	Fnmps  uintptr
	Fnlps  uintptr
} /* mqc.h:58:9 */

//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2017, IntoPIX SA <support@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//
//  ==========================================================
//    Common constants shared among several modules
//  ==========================================================

//*
// @file mqc.h
// @brief Implementation of an MQ-Coder (MQC)
//
// The functions in MQC.C have for goal to realize the MQ-coder operations. The functions
// in MQC.C are used by some function in T1.C.

//* @defgroup MQC MQC - Implementation of an MQ-Coder
//@{

//*
// This struct defines the state of a context.
type Topj_mqc_state_t = Sopj_mqc_state /* mqc.h:67:3 */

//*
// MQ coder
type Sopj_mqc = struct {
	Fc                          TOPJ_UINT32
	Fa                          TOPJ_UINT32
	Fct                         TOPJ_UINT32
	Fend_of_byte_stream_counter TOPJ_UINT32
	Fbp                         uintptr
	Fstart                      uintptr
	Fend                        uintptr
	Fctxs                       [19]uintptr
	Fcurctx                     uintptr
	Flut_ctxno_zc_orient        uintptr
	Fbackup                     [2]TOPJ_BYTE
	F__ccgo_pad1                [6]byte
} /* mqc.h:74:9 */

//*
// MQ coder
type Topj_mqc_t = Sopj_mqc /* mqc.h:97:3 */

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// For internal use of opj_mqc_decode_macro()

// For internal use of opj_mqc_decode_macro()

//*
// Decode a symbol using raw-decoder. Cfr p.506 TAUBMAN
// @param mqc MQC handle
// @return Returns the decoded symbol (0 or 1)
func opj_mqc_raw_decode(tls *libc.TLS, mqc uintptr) TOPJ_UINT32 { /* mqc_inl.h:74:26: */
	var d TOPJ_UINT32
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
		// Given opj_mqc_raw_init_dec() we know that at some point we will
		// have a 0xFF 0xFF artificial marker
		if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc == TOPJ_UINT32(0xff) {
			if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) > 0x8f {
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(0xff)
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
			} else {
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)))
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
			}
		} else {
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)))
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
		}
	}
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
	d = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc >> (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct & 0x01

	return d
}

// For internal use of opj_mqc_decode_macro()

//*
// Input a byte
// @param mqc MQC handle
func opj_mqc_bytein(tls *libc.TLS, mqc uintptr) { /* mqc_inl.h:175:20: */
	{
		var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
		l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
		if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
			if l_c > TOPJ_UINT32(0x8f) {
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
			} else {
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
			}
		} else {
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
		}
	}

}

//*
// Decode a symbol
// @param mqc MQC handle
// @return Returns the decoded symbol (0 or 1)
//static INLINE OPJ_UINT32 opj_mqc_decode(opj_mqc_t * const mqc);
// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
// @file pi.h
// @brief Implementation of a packet iterator (PI)
//
// The functions in PI.C have for goal to realize a packet iterator that permits to get the next
// packet following the progression order and change of it. The functions in PI.C are used
// by some function in T2.C.

//* @defgroup PI PI - Implementation of a packet iterator
//@{

//*
// FIXME DOC
type Sopj_pi_resolution = struct {
	Fpdx TOPJ_UINT32
	Fpdy TOPJ_UINT32
	Fpw  TOPJ_UINT32
	Fph  TOPJ_UINT32
} /* pi.h:55:9 */

//*
// Decode a symbol
// @param mqc MQC handle
// @return Returns the decoded symbol (0 or 1)
//static INLINE OPJ_UINT32 opj_mqc_decode(opj_mqc_t * const mqc);
// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
// @file pi.h
// @brief Implementation of a packet iterator (PI)
//
// The functions in PI.C have for goal to realize a packet iterator that permits to get the next
// packet following the progression order and change of it. The functions in PI.C are used
// by some function in T2.C.

//* @defgroup PI PI - Implementation of a packet iterator
//@{

//*
// FIXME DOC
type Topj_pi_resolution_t = Sopj_pi_resolution /* pi.h:58:3 */

//*
// FIXME DOC
type Sopj_pi_comp = struct {
	Fdx             TOPJ_UINT32
	Fdy             TOPJ_UINT32
	Fnumresolutions TOPJ_UINT32
	F__ccgo_pad1    [4]byte
	Fresolutions    uintptr
} /* pi.h:63:9 */

//*
// FIXME DOC
type Topj_pi_comp_t = Sopj_pi_comp /* pi.h:68:3 */

//*
// Packet iterator
type Topj_pi_iterator_t = struct {
	Ftp_on        TOPJ_BYTE
	F__ccgo_pad1  [7]byte
	Finclude      uintptr
	Finclude_size TOPJ_UINT32
	Fstep_l       TOPJ_UINT32
	Fstep_r       TOPJ_UINT32
	Fstep_c       TOPJ_UINT32
	Fstep_p       TOPJ_UINT32
	Fcompno       TOPJ_UINT32
	Fresno        TOPJ_UINT32
	Fprecno       TOPJ_UINT32
	Flayno        TOPJ_UINT32
	Ffirst        TOPJ_BOOL
	Fpoc          Topj_poc_t
	Fnumcomps     TOPJ_UINT32
	Fcomps        uintptr
	Ftx0          TOPJ_UINT32
	Fty0          TOPJ_UINT32
	Ftx1          TOPJ_UINT32
	Fty1          TOPJ_UINT32
	Fx            TOPJ_UINT32
	Fy            TOPJ_UINT32
	Fdx           TOPJ_UINT32
	Fdy           TOPJ_UINT32
	Fmanager      uintptr
} /* pi.h:112:3 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
// @file tgt.h
// @brief Implementation of a tag-tree coder (TGT)
//
// The functions in TGT.C have for goal to realize a tag-tree coder. The functions in TGT.C
// are used by some function in T2.C.

//* @defgroup TGT TGT - Implementation of a tag-tree coder
//@{

//*
// Tag node
type Sopj_tgt_node = struct {
	Fparent      uintptr
	Fvalue       TOPJ_INT32
	Flow         TOPJ_INT32
	Fknown       TOPJ_UINT32
	F__ccgo_pad1 [4]byte
} /* j2k.h:562:1 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
// Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
// @file tgt.h
// @brief Implementation of a tag-tree coder (TGT)
//
// The functions in TGT.C have for goal to realize a tag-tree coder. The functions in TGT.C
// are used by some function in T2.C.

//* @defgroup TGT TGT - Implementation of a tag-tree coder
//@{

//*
// Tag node
type Topj_tgt_node_t = Sopj_tgt_node /* tgt.h:62:3 */

//*
// Tag tree
type Sopj_tgt_tree = struct {
	Fnumleafsh   TOPJ_UINT32
	Fnumleafsv   TOPJ_UINT32
	Fnumnodes    TOPJ_UINT32
	F__ccgo_pad1 [4]byte
	Fnodes       uintptr
	Fnodes_size  TOPJ_UINT32
	F__ccgo_pad2 [4]byte
} /* j2k.h:562:1 */

//*
// Tag tree
type Topj_tgt_tree_t = Sopj_tgt_tree /* tgt.h:73:3 */
// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// Copyright (c) 2017, IntoPIX SA <support@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file tcd.h
// @brief Implementation of a tile coder/decoder (TCD)
//
// The functions in TCD.C encode or decode each tile independently from
// each other. The functions in TCD.C are used by other functions in J2K.C.

//* @defgroup TCD TCD - Implementation of a tile coder/decoder
//@{

//*
// FIXME DOC
type Sopj_tcd_pass = struct {
	Frate          TOPJ_UINT32
	F__ccgo_pad1   [4]byte
	Fdistortiondec TOPJ_FLOAT64
	Flen           TOPJ_UINT32
	Fterm          uint8 /* OPJ_BITFIELD term: 1 */
	F__ccgo_pad2   [3]byte
} /* tcd.h:57:9 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// Copyright (c) 2017, IntoPIX SA <support@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file tcd.h
// @brief Implementation of a tile coder/decoder (TCD)
//
// The functions in TCD.C encode or decode each tile independently from
// each other. The functions in TCD.C are used by other functions in J2K.C.

//* @defgroup TCD TCD - Implementation of a tile coder/decoder
//@{

//*
// FIXME DOC
type Topj_tcd_pass_t = Sopj_tcd_pass /* tcd.h:62:3 */

//*
// FIXME DOC
type Sopj_tcd_layer = struct {
	Fnumpasses TOPJ_UINT32
	Flen       TOPJ_UINT32
	Fdisto     TOPJ_FLOAT64
	Fdata      uintptr
} /* tcd.h:67:9 */

//*
// FIXME DOC
type Topj_tcd_layer_t = Sopj_tcd_layer /* tcd.h:72:3 */

//*
// FIXME DOC
type Sopj_tcd_cblk_enc = struct {
	Fdata              uintptr
	Flayers            uintptr
	Fpasses            uintptr
	Fx0                TOPJ_INT32
	Fy0                TOPJ_INT32
	Fx1                TOPJ_INT32
	Fy1                TOPJ_INT32
	Fnumbps            TOPJ_UINT32
	Fnumlenbits        TOPJ_UINT32
	Fdata_size         TOPJ_UINT32
	Fnumpasses         TOPJ_UINT32
	Fnumpassesinlayers TOPJ_UINT32
	Ftotalpasses       TOPJ_UINT32
} /* tcd.h:77:9 */

//*
// FIXME DOC
type Topj_tcd_cblk_enc_t = Sopj_tcd_cblk_enc /* tcd.h:90:3 */

//* Chunk of codestream data that is part of a code block
type Sopj_tcd_seg_data_chunk = struct {
	Fdata        uintptr
	Flen         TOPJ_UINT32
	F__ccgo_pad1 [4]byte
} /* tcd.h:94:9 */

//* Chunk of codestream data that is part of a code block
type Topj_tcd_seg_data_chunk_t = Sopj_tcd_seg_data_chunk /* tcd.h:100:3 */

// * Segment of a code-block.
// A segment represent a number of consecutive coding passes, without termination
// of MQC or RAW between them.
type Sopj_tcd_seg = struct {
	Flen             TOPJ_UINT32
	Fnumpasses       TOPJ_UINT32
	Freal_num_passes TOPJ_UINT32
	Fmaxpasses       TOPJ_UINT32
	Fnumnewpasses    TOPJ_UINT32
	Fnewlen          TOPJ_UINT32
} /* tcd.h:105:9 */

// * Segment of a code-block.
// A segment represent a number of consecutive coding passes, without termination
// of MQC or RAW between them.
type Topj_tcd_seg_t = Sopj_tcd_seg /* tcd.h:117:3 */

//* Code-block for decoding
type Sopj_tcd_cblk_dec = struct {
	Fsegs               uintptr
	Fchunks             uintptr
	Fx0                 TOPJ_INT32
	Fy0                 TOPJ_INT32
	Fx1                 TOPJ_INT32
	Fy1                 TOPJ_INT32
	FMb                 TOPJ_UINT32
	Fnumbps             TOPJ_UINT32
	Fnumlenbits         TOPJ_UINT32
	Fnumnewpasses       TOPJ_UINT32
	Fnumsegs            TOPJ_UINT32
	Freal_num_segs      TOPJ_UINT32
	Fm_current_max_segs TOPJ_UINT32
	Fnumchunks          TOPJ_UINT32
	Fnumchunksalloc     TOPJ_UINT32
	F__ccgo_pad1        [4]byte
	Fdecoded_data       uintptr
} /* tcd.h:120:9 */

//* Code-block for decoding
type Topj_tcd_cblk_dec_t = Sopj_tcd_cblk_dec /* tcd.h:144:3 */

//* Precinct structure
type Sopj_tcd_precinct = struct {
	Fx0          TOPJ_INT32
	Fy0          TOPJ_INT32
	Fx1          TOPJ_INT32
	Fy1          TOPJ_INT32
	Fcw          TOPJ_UINT32
	Fch          TOPJ_UINT32
	Fcblks       struct{ Fenc uintptr }
	Fblock_size  TOPJ_UINT32
	F__ccgo_pad1 [4]byte
	Fincltree    uintptr
	Fimsbtree    uintptr
} /* j2k.h:562:1 */

//* Precinct structure
type Topj_tcd_precinct_t = Sopj_tcd_precinct /* tcd.h:159:3 */

//* Sub-band structure
type Sopj_tcd_band = struct {
	Fx0                  TOPJ_INT32
	Fy0                  TOPJ_INT32
	Fx1                  TOPJ_INT32
	Fy1                  TOPJ_INT32
	Fbandno              TOPJ_UINT32
	F__ccgo_pad1         [4]byte
	Fprecincts           uintptr
	Fprecincts_data_size TOPJ_UINT32
	Fnumbps              TOPJ_INT32
	Fstepsize            TOPJ_FLOAT32
	F__ccgo_pad2         [4]byte
} /* j2k.h:562:1 */

//* Sub-band structure
type Topj_tcd_band_t = Sopj_tcd_band /* tcd.h:173:3 */

//* Tile-component resolution structure
type Sopj_tcd_resolution = struct {
	Fx0          TOPJ_INT32
	Fy0          TOPJ_INT32
	Fx1          TOPJ_INT32
	Fy1          TOPJ_INT32
	Fpw          TOPJ_UINT32
	Fph          TOPJ_UINT32
	Fnumbands    TOPJ_UINT32
	F__ccgo_pad1 [4]byte
	Fbands       [3]Topj_tcd_band_t
	Fwin_x0      TOPJ_UINT32
	Fwin_y0      TOPJ_UINT32
	Fwin_x1      TOPJ_UINT32
	Fwin_y1      TOPJ_UINT32
} /* j2k.h:562:1 */

//* Tile-component resolution structure
type Topj_tcd_resolution_t = Sopj_tcd_resolution /* tcd.h:191:3 */

//* Tile-component structure
type Sopj_tcd_tilecomp = struct {
	Fx0                      TOPJ_INT32
	Fy0                      TOPJ_INT32
	Fx1                      TOPJ_INT32
	Fy1                      TOPJ_INT32
	Fcompno                  TOPJ_UINT32
	Fnumresolutions          TOPJ_UINT32
	Fminimum_num_resolutions TOPJ_UINT32
	F__ccgo_pad1             [4]byte
	Fresolutions             uintptr
	Fresolutions_size        TOPJ_UINT32
	F__ccgo_pad2             [4]byte
	Fdata                    uintptr
	FownsData                TOPJ_BOOL
	Fdata_size_needed        Tsize_t
	Fdata_size               Tsize_t
	F__ccgo_pad3             [4]byte
	Fdata_win                uintptr
	Fwin_x0                  TOPJ_UINT32
	Fwin_y0                  TOPJ_UINT32
	Fwin_x1                  TOPJ_UINT32
	Fwin_y1                  TOPJ_UINT32
	Fnumpix                  TOPJ_INT32
	F__ccgo_pad4             [4]byte
} /* j2k.h:562:1 */

//* Tile-component structure
type Topj_tcd_tilecomp_t = Sopj_tcd_tilecomp /* tcd.h:227:3 */

//*
// FIXME DOC
type Sopj_tcd_tile = struct {
	Fx0          TOPJ_INT32
	Fy0          TOPJ_INT32
	Fx1          TOPJ_INT32
	Fy1          TOPJ_INT32
	Fnumcomps    TOPJ_UINT32
	F__ccgo_pad1 [4]byte
	Fcomps       uintptr
	Fnumpix      TOPJ_INT32
	F__ccgo_pad2 [4]byte
	Fdistotile   TOPJ_FLOAT64
	Fdistolayer  [100]TOPJ_FLOAT64
	Fpackno      TOPJ_UINT32
	F__ccgo_pad3 [4]byte
} /* j2k.h:562:1 */

//*
// FIXME DOC
type Topj_tcd_tile_t = Sopj_tcd_tile /* tcd.h:242:3 */

//*
// FIXME DOC
type Sopj_tcd_image = struct{ Ftiles uintptr } /* j2k.h:562:1 */

//*
// FIXME DOC
type Topj_tcd_image_t = Sopj_tcd_image /* tcd.h:250:1 */

//*
// Tile coder/decoder
type Topj_tcd_t = Sopj_tcd /* tcd.h:290:3 */

// *
// Structure to hold information needed to generate some markers.
// Used by encoder.
type Sopj_tcd_marker_info = struct {
	Fneed_PLT      TOPJ_BOOL
	Fpacket_count  TOPJ_UINT32
	Fp_packet_size uintptr
} /* tcd.h:296:9 */

// *
// Structure to hold information needed to generate some markers.
// Used by encoder.
type Topj_tcd_marker_info_t = Sopj_tcd_marker_info /* tcd.h:306:3 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2012, Carl Hetherington
// Copyright (c) 2017, IntoPIX SA <support@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file t1.h
// @brief Implementation of the tier-1 coding (coding of code-block coefficients) (T1)
//
// The functions in T1.C have for goal to realize the tier-1 coding operation. The functions
// in T1.C are used by some function in TCD.C.

//* @defgroup T1 T1 - Implementation of the tier-1 coding
//@{

// -----------------------------------------------------------------------

// BEGINNING of flags that apply to opj_flag_t
// * We hold the state of individual data points for the T1 encoder using
//  a single 32-bit flags word to hold the state of 4 data points.  This corresponds
//  to the 4-point-high columns that the data is processed in.
//
//  These \#defines declare the layout of a 32-bit flags word.
//
//  This is currently done for encoding only.
//  The values must NOT be changed, otherwise this is going to break a lot of
//  assumptions.

// SIGMA: significance state (3 cols x 6 rows)
// CHI:   state for negative sample value (1 col x 6 rows)
// MU:    state for visited in refinement pass (1 col x 4 rows)
// PI:    state for visited in significance pass (1 col * 4 rows)

// * As an example, the bits T1_SIGMA_3, T1_SIGMA_4 and T1_SIGMA_5
//  indicate the significance state of the west neighbour of data point zero
//  of our four, the point itself, and its east neighbour respectively.
//  Many of the bits are arranged so that given a flags word, you can
//  look at the values for the data point 0, then shift the flags
//  word right by 3 bits and look at the same bit positions to see the
//  values for data point 1.
//
//  The \#defines below help a bit with this; say you have a flags word
//  f, you can do things like
//
//  (f & T1_SIGMA_THIS)
//
//  to see the significance bit of data point 0, then do
//
//  ((f >> 3) & T1_SIGMA_THIS)
//
//  to see the significance bit of data point 1.

// END of flags that apply to opj_flag_t

// -----------------------------------------------------------------------

//* Flags for 4 consecutive rows of a column
type Topj_flag_t = TOPJ_UINT32 /* t1.h:179:20 */

//*
// Tier-1 coding (coding of code-block coefficients)
type Sopj_t1 = struct {
	Fmqc                    Topj_mqc_t
	Fdata                   uintptr
	Fflags                  uintptr
	Fw                      TOPJ_UINT32
	Fh                      TOPJ_UINT32
	Fdatasize               TOPJ_UINT32
	Fflagssize              TOPJ_UINT32
	Fencoder                TOPJ_BOOL
	Fmustuse_cblkdatabuffer TOPJ_BOOL
	Fcblkdatabuffer         uintptr
	Fcblkdatabuffersize     TOPJ_UINT32
	F__ccgo_pad1            [4]byte
} /* t1.h:184:9 */

//*
// Tier-1 coding (coding of code-block coefficients)
type Topj_t1_t = Sopj_t1 /* t1.h:210:3 */
// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// Copyright (c) 2017, IntoPIX SA <support@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file t2.h
// @brief Implementation of a tier-2 coding (packetization of code-block data) (T2)
//

//* @defgroup T2 T2 - Implementation of a tier-2 coding
//@{

//*
// Tier-2 coding
type Sopj_t2 = struct {
	Fimage uintptr
	Fcp    uintptr
} /* t2.h:54:9 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// Copyright (c) 2017, IntoPIX SA <support@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file t2.h
// @brief Implementation of a tier-2 coding (packetization of code-block data) (T2)
//

//* @defgroup T2 T2 - Implementation of a tier-2 coding
//@{

//*
// Tier-2 coding
type Topj_t2_t = Sopj_t2 /* t2.h:60:3 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// Copyright (c) 2001-2003, David Janssens
// Copyright (c) 2002-2003, Yannick Verschueren
// Copyright (c) 2003-2007, Francois-Olivier Devaux
// Copyright (c) 2003-2014, Antonin Descampe
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file opj_intmath.h
// @brief Implementation of operations on integers (INT)
//
// The functions in OPJ_INTMATH.H have for goal to realize operations on integers.

//* @defgroup OPJ_INTMATH OPJ_INTMATH - Implementation of operations on integers
//@{

//* @name Exported functions (see also openjpeg.h)
//@{
// -----------------------------------------------------------------------
//*
// Get the minimum of two integers
// @return Returns a if a < b else b
func opj_int_min(tls *libc.TLS, a TOPJ_INT32, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:56:25: */
	if a < b {
		return a
	}
	return b
}

//*
// Get the minimum of two integers
// @return Returns a if a < b else b
func opj_uint_min(tls *libc.TLS, a TOPJ_UINT32, b TOPJ_UINT32) TOPJ_UINT32 { /* opj_intmath.h:65:26: */
	if a < b {
		return a
	}
	return b
}

//*
// Get the maximum of two integers
// @return Returns a if a > b else b
func opj_int_max(tls *libc.TLS, a TOPJ_INT32, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:74:25: */
	if a > b {
		return a
	}
	return b
}

//*
// Get the maximum of two integers
// @return Returns a if a > b else b
func opj_uint_max(tls *libc.TLS, a TOPJ_UINT32, b TOPJ_UINT32) TOPJ_UINT32 { /* opj_intmath.h:83:26: */
	if a > b {
		return a
	}
	return b
}

//*
//  Get the saturated sum of two unsigned integers
//  @return Returns saturated sum of a+b
//
func opj_uint_adds(tls *libc.TLS, a TOPJ_UINT32, b TOPJ_UINT32) TOPJ_UINT32 { /* opj_intmath.h:92:26: */
	var sum TOPJ_UINT64 = TOPJ_UINT64(a) + TOPJ_UINT64(b)
	return TOPJ_UINT32(-TOPJ_INT32(sum>>32)) | TOPJ_UINT32(sum)
}

//*
//  Get the saturated difference of two unsigned integers
//  @return Returns saturated sum of a-b
//
func opj_uint_subs(tls *libc.TLS, a TOPJ_UINT32, b TOPJ_UINT32) TOPJ_UINT32 { /* opj_intmath.h:102:26: */
	if a >= b {
		return a - b
	}
	return uint32(0)
}

//*
// Clamp an integer inside an interval
// @return
// <ul>
// <li>Returns a if (min < a < max)
// <li>Returns max if (a > max)
// <li>Returns min if (a < min)
// </ul>
func opj_int_clamp(tls *libc.TLS, a TOPJ_INT32, min TOPJ_INT32, max TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:116:25: */
	if a < min {
		return min
	}
	if a > max {
		return max
	}
	return a
}

//*
// Clamp an integer inside an interval
// @return
// <ul>
// <li>Returns a if (min < a < max)
// <li>Returns max if (a > max)
// <li>Returns min if (a < min)
// </ul>
func opj_int64_clamp(tls *libc.TLS, a TOPJ_INT64, min TOPJ_INT64, max TOPJ_INT64) TOPJ_INT64 { /* opj_intmath.h:137:25: */
	if a < min {
		return min
	}
	if a > max {
		return max
	}
	return a
}

//*
// @return Get absolute value of integer
func opj_int_abs(tls *libc.TLS, a TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:152:25: */
	if a < 0 {
		return -a
	}
	return a
}

//*
// Divide an integer and round upwards
// @return Returns a divided by b
func opj_int_ceildiv(tls *libc.TLS, a TOPJ_INT32, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:160:25: */
	if b != 0 {
	} else {
		libc.X__assert_fail(tls, ts+153, ts+155, uint32(162), uintptr(unsafe.Pointer(&__func__279)))
	}
	return TOPJ_INT32((TOPJ_INT64(a) + TOPJ_INT64(b) - 1) / TOPJ_INT64(b))
}

var __func__279 = *(*[16]int8)(unsafe.Pointer(ts + 188)) /* opj_intmath.h:161:1 */

//*
// Divide an integer and round upwards
// @return Returns a divided by b
func opj_uint_ceildiv(tls *libc.TLS, a TOPJ_UINT32, b TOPJ_UINT32) TOPJ_UINT32 { /* opj_intmath.h:170:27: */
	if b != 0 {
	} else {
		libc.X__assert_fail(tls, ts+153, ts+155, uint32(172), uintptr(unsafe.Pointer(&__func__280)))
	}
	return TOPJ_UINT32((TOPJ_UINT64(a) + TOPJ_UINT64(b) - TOPJ_UINT64(1)) / TOPJ_UINT64(b))
}

var __func__280 = *(*[17]int8)(unsafe.Pointer(ts + 204)) /* opj_intmath.h:171:1 */

//*
// Divide an integer by a power of 2 and round upwards
// @return Returns a divided by 2^b
func opj_int_ceildivpow2(tls *libc.TLS, a TOPJ_INT32, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:180:25: */
	return TOPJ_INT32((TOPJ_INT64(a) + TOPJ_INT64(1)<<b - 1) >> b)
}

//*
//  Divide a 64bits integer by a power of 2 and round upwards
//  @return Returns a divided by 2^b
//
func opj_int64_ceildivpow2(tls *libc.TLS, a TOPJ_INT64, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:189:25: */
	return TOPJ_INT32((a + TOPJ_INT64(1)<<b - 1) >> b)
}

//*
//  Divide an integer by a power of 2 and round upwards
//  @return Returns a divided by 2^b
//
func opj_uint_ceildivpow2(tls *libc.TLS, a TOPJ_UINT32, b TOPJ_UINT32) TOPJ_UINT32 { /* opj_intmath.h:198:26: */
	return TOPJ_UINT32((TOPJ_UINT64(a) + TOPJ_UINT64(1)<<b - 1) >> b)
}

//*
// Divide an integer by a power of 2 and round downwards
// @return Returns a divided by 2^b
func opj_int_floordivpow2(tls *libc.TLS, a TOPJ_INT32, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:207:25: */
	return a >> b
}

//*
// Divide an integer by a power of 2 and round downwards
// @return Returns a divided by 2^b
func opj_uint_floordivpow2(tls *libc.TLS, a TOPJ_UINT32, b TOPJ_UINT32) TOPJ_UINT32 { /* opj_intmath.h:216:26: */
	return a >> b
}

//*
// Get logarithm of an integer and round downwards
// @return Returns log2(a)
func opj_int_floorlog2(tls *libc.TLS, a TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:225:25: */
	var l TOPJ_INT32
	for l = 0; a > 1; l++ {
		a >>= 1
	}
	return l
}

//*
// Get logarithm of an integer and round downwards
// @return Returns log2(a)
func opj_uint_floorlog2(tls *libc.TLS, a TOPJ_UINT32) TOPJ_UINT32 { /* opj_intmath.h:237:27: */
	var l TOPJ_UINT32
	for l = TOPJ_UINT32(0); a > TOPJ_UINT32(1); l++ {
		a >>= 1
	}
	return l
}

//*
// Multiply two fixed-precision rational numbers.
// @param a
// @param b
// @return Returns a * b
func opj_int_fix_mul(tls *libc.TLS, a TOPJ_INT32, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:252:25: */
	var temp TOPJ_INT64 = TOPJ_INT64(a) * TOPJ_INT64(b)
	temp = temp + 4096
	if temp>>13 <= 0x7FFFFFFF {
	} else {
		libc.X__assert_fail(tls, ts+221, ts+155, uint32(260), uintptr(unsafe.Pointer(&__func__281)))
	}
	if temp>>13 >= -0x7FFFFFFF-1 {
	} else {
		libc.X__assert_fail(tls, ts+259, ts+155, uint32(261), uintptr(unsafe.Pointer(&__func__281)))
	}
	return TOPJ_INT32(temp >> 13)
}

var __func__281 = *(*[16]int8)(unsafe.Pointer(ts + 315)) /* opj_intmath.h:253:1 */

//*
// Addition two signed integers with a wrap-around behaviour.
// Assumes complement-to-two signed integers.
// @param a
// @param b
// @return Returns a + b
func opj_int_add_no_overflow(tls *libc.TLS, a TOPJ_INT32, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:286:25: */
	bp := tls.Alloc(12)
	defer tls.Free(12)
	*(*TOPJ_INT32)(unsafe.Pointer(bp)) = a
	*(*TOPJ_INT32)(unsafe.Pointer(bp + 4)) = b

	var pa uintptr = bp     /* &a */
	var pb uintptr = bp + 4 /* &b */
	var upa uintptr = pa
	var upb uintptr = pb
	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* ures */)) = *(*TOPJ_UINT32)(unsafe.Pointer(upa)) + *(*TOPJ_UINT32)(unsafe.Pointer(upb))
	var pures uintptr = bp + 8 /* &ures */
	var ipres uintptr = pures
	return *(*TOPJ_INT32)(unsafe.Pointer(ipres))
}

//*
// Subtract two signed integers with a wrap-around behaviour.
// Assumes complement-to-two signed integers.
// @param a
// @param b
// @return Returns a - b
func opj_int_sub_no_overflow(tls *libc.TLS, a TOPJ_INT32, b TOPJ_INT32) TOPJ_INT32 { /* opj_intmath.h:305:25: */
	bp := tls.Alloc(12)
	defer tls.Free(12)
	*(*TOPJ_INT32)(unsafe.Pointer(bp)) = a
	*(*TOPJ_INT32)(unsafe.Pointer(bp + 4)) = b

	var pa uintptr = bp     /* &a */
	var pb uintptr = bp + 4 /* &b */
	var upa uintptr = pa
	var upb uintptr = pb
	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* ures */)) = *(*TOPJ_UINT32)(unsafe.Pointer(upa)) - *(*TOPJ_UINT32)(unsafe.Pointer(upb))
	var pures uintptr = bp + 8 /* &ures */
	var ipres uintptr = pures
	return *(*TOPJ_INT32)(unsafe.Pointer(ipres))
}

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2017, IntoPix SA <contact@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
// @file sparse_array.h
// @brief Sparse array management
//
// The functions in this file manage sparse arrays. Sparse arrays are arrays with
// potential big dimensions, but with very few samples actually set. Such sparse
// arrays require allocating a low amount of memory, by just allocating memory
// for blocks of the array that are set. The minimum memory allocation unit is a
// a block. There is a trade-off to pick up an appropriate dimension for blocks.
// If it is too big, and pixels set are far from each other, too much memory will
// be used. If blocks are too small, the book-keeping costs of blocks will raise.

//* @defgroup SPARSE_ARRAY SPARSE ARRAYS - Sparse arrays
//@{

//* Opaque type for sparse arrays that contain int32 values
type Sopj_sparse_array_int32 = struct {
	Fwidth           TOPJ_UINT32
	Fheight          TOPJ_UINT32
	Fblock_width     TOPJ_UINT32
	Fblock_height    TOPJ_UINT32
	Fblock_count_hor TOPJ_UINT32
	Fblock_count_ver TOPJ_UINT32
	Fdata_blocks     uintptr
} /* sparse_array.h:53:9 */

//@}

// JPWL>>
// <<JPWL

// V2
// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file opj_codec.h

// *
// Main codec handler used for compression or decompression.
type Sopj_codec_private = struct {
	Fm_codec_data struct {
		Fm_decompression struct {
			Fopj_read_header                   uintptr
			Fopj_decode                        uintptr
			Fopj_read_tile_header              uintptr
			Fopj_decode_tile_data              uintptr
			Fopj_end_decompress                uintptr
			Fopj_destroy                       uintptr
			Fopj_setup_decoder                 uintptr
			Fopj_decoder_set_strict_mode       uintptr
			Fopj_set_decode_area               uintptr
			Fopj_get_decoded_tile              uintptr
			Fopj_set_decoded_resolution_factor uintptr
			Fopj_set_decoded_components        uintptr
		}
	}
	Fm_codec             uintptr
	Fm_event_mgr         Topj_event_mgr_t
	Fis_decompressor     TOPJ_BOOL
	F__ccgo_pad1         [4]byte
	Fopj_dump_codec      uintptr
	Fopj_get_codec_info  uintptr
	Fopj_get_codec_index uintptr
	Fopj_set_threads     uintptr
} /* opj_codec.h:42:9 */

//@}

// JPWL>>
// <<JPWL

// V2
// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file opj_codec.h

// *
// Main codec handler used for compression or decompression.
type Sopj_decompression = struct {
	Fopj_read_header                   uintptr
	Fopj_decode                        uintptr
	Fopj_read_tile_header              uintptr
	Fopj_decode_tile_data              uintptr
	Fopj_end_decompress                uintptr
	Fopj_destroy                       uintptr
	Fopj_setup_decoder                 uintptr
	Fopj_decoder_set_strict_mode       uintptr
	Fopj_set_decode_area               uintptr
	Fopj_get_decoded_tile              uintptr
	Fopj_set_decoded_resolution_factor uintptr
	Fopj_set_decoded_components        uintptr
} /* opj_codec.h:48:9 */

//@}

// JPWL>>
// <<JPWL

// V2
// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file opj_codec.h

// *
// Main codec handler used for compression or decompression.
type Sopj_compression = struct {
	Fopj_start_compress            uintptr
	Fopj_encode                    uintptr
	Fopj_write_tile                uintptr
	Fopj_end_compress              uintptr
	Fopj_destroy                   uintptr
	Fopj_setup_encoder             uintptr
	Fopj_encoder_set_extra_options uintptr
} /* opj_codec.h:127:9 */

//@}

// JPWL>>
// <<JPWL

// V2
// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
// Copyright (c) 2002-2014, Professor Benoit Macq
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//*
// @file opj_codec.h

// *
// Main codec handler used for compression or decompression.
type Topj_codec_private_t = Sopj_codec_private /* opj_codec.h:175:1 */

//@}

//@}

//
// ==========================================================
//    local functions
// ==========================================================

func opj_bio_byteout(tls *libc.TLS, bio uintptr) TOPJ_BOOL { /* bio.c:81:17: */
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf = (*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf << 8 & TOPJ_UINT32(0xffff)
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fct = func() uint32 {
		if (*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf == TOPJ_UINT32(0xff00) {
			return uint32(7)
		}
		return uint32(8)
	}()
	if TOPJ_SIZE_T((*Topj_bio_t)(unsafe.Pointer(bio)).Fbp) >= TOPJ_SIZE_T((*Topj_bio_t)(unsafe.Pointer(bio)).Fend) {
		return DOPJ_FALSE
	}
	*(*TOPJ_BYTE)(unsafe.Pointer(libc.PostIncUintptr(&(*Topj_bio_t)(unsafe.Pointer(bio)).Fbp, 1))) = TOPJ_BYTE((*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf >> 8)
	return DOPJ_TRUE
}

func opj_bio_bytein(tls *libc.TLS, bio uintptr) TOPJ_BOOL { /* bio.c:92:17: */
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf = (*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf << 8 & TOPJ_UINT32(0xffff)
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fct = func() uint32 {
		if (*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf == TOPJ_UINT32(0xff00) {
			return uint32(7)
		}
		return uint32(8)
	}()
	if TOPJ_SIZE_T((*Topj_bio_t)(unsafe.Pointer(bio)).Fbp) >= TOPJ_SIZE_T((*Topj_bio_t)(unsafe.Pointer(bio)).Fend) {
		return DOPJ_FALSE
	}
	*(*TOPJ_UINT32)(unsafe.Pointer(bio + 24)) |= TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer(libc.PostIncUintptr(&(*Topj_bio_t)(unsafe.Pointer(bio)).Fbp, 1))))
	return DOPJ_TRUE
}

func opj_bio_putbit(tls *libc.TLS, bio uintptr, b TOPJ_UINT32) { /* bio.c:103:13: */
	if (*Topj_bio_t)(unsafe.Pointer(bio)).Fct == TOPJ_UINT32(0) {
		opj_bio_byteout(tls,
			bio) // MSD: why not check the return value of this function ?
	}
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fct--
	*(*TOPJ_UINT32)(unsafe.Pointer(bio + 24)) |= b << (*Topj_bio_t)(unsafe.Pointer(bio)).Fct
}

func opj_bio_getbit(tls *libc.TLS, bio uintptr) TOPJ_UINT32 { /* bio.c:113:19: */
	if (*Topj_bio_t)(unsafe.Pointer(bio)).Fct == TOPJ_UINT32(0) {
		opj_bio_bytein(tls,
			bio) // MSD: why not check the return value of this function ?
	}
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fct--
	return (*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf >> (*Topj_bio_t)(unsafe.Pointer(bio)).Fct & TOPJ_UINT32(1)
}

//
// ==========================================================
//    Bit Input/Output interface
// ==========================================================

func Xopj_bio_create(tls *libc.TLS) uintptr { /* bio.c:129:10: */
	var bio uintptr = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_bio_t{})))
	return bio
}

func Xopj_bio_destroy(tls *libc.TLS, bio uintptr) { /* bio.c:135:6: */
	if bio != 0 {
		Xopj_free(tls, bio)
	}
}

func Xopj_bio_numbytes(tls *libc.TLS, bio uintptr) Tptrdiff_t { /* bio.c:142:11: */
	return (int32((*Topj_bio_t)(unsafe.Pointer(bio)).Fbp) - int32((*Topj_bio_t)(unsafe.Pointer(bio)).Fstart)) / 1
}

func Xopj_bio_init_enc(tls *libc.TLS, bio uintptr, bp uintptr, len TOPJ_UINT32) { /* bio.c:147:6: */
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fstart = bp
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fend = bp + uintptr(len)
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fbp = bp
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf = TOPJ_UINT32(0)
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fct = TOPJ_UINT32(8)
}

func Xopj_bio_init_dec(tls *libc.TLS, bio uintptr, bp uintptr, len TOPJ_UINT32) { /* bio.c:156:6: */
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fstart = bp
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fend = bp + uintptr(len)
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fbp = bp
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf = TOPJ_UINT32(0)
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fct = TOPJ_UINT32(0)
}

func Xopj_bio_write(tls *libc.TLS, bio uintptr, v TOPJ_UINT32, n TOPJ_UINT32) { /* bio.c:165:6: */
	var i TOPJ_INT32

	if n > 0 && n <= 32 {
	} else {
		libc.X__assert_fail(tls, ts+331, ts+354, uint32(169), uintptr(unsafe.Pointer(&__func__4)))
	}
	for i = TOPJ_INT32(n) - 1; i >= 0; i-- {
		opj_bio_putbit(tls, bio, v>>i&TOPJ_UINT32(1))
	}
}

var __func__4 = *(*[14]int8)(unsafe.Pointer(ts + 379)) /* bio.c:166:1 */

func Xopj_bio_read(tls *libc.TLS, bio uintptr, n TOPJ_UINT32) TOPJ_UINT32 { /* bio.c:175:12: */
	var i TOPJ_INT32
	var v TOPJ_UINT32

	if n > 0 {
	} else {
		libc.X__assert_fail(tls, ts+393, ts+354, uint32(180), uintptr(unsafe.Pointer(&__func__5)))
	}
	v = 0
	for i = TOPJ_INT32(n) - 1; i >= 0; i-- {
		v = v | opj_bio_getbit(tls, bio)<<i // can't overflow, opj_bio_getbit returns 0 or 1
	}
	return v
}

var __func__5 = *(*[13]int8)(unsafe.Pointer(ts + 402)) /* bio.c:176:1 */

func Xopj_bio_flush(tls *libc.TLS, bio uintptr) TOPJ_BOOL { /* bio.c:195:10: */
	if !(opj_bio_byteout(tls, bio) != 0) {
		return DOPJ_FALSE
	}
	if (*Topj_bio_t)(unsafe.Pointer(bio)).Fct == TOPJ_UINT32(7) {
		if !(opj_bio_byteout(tls, bio) != 0) {
			return DOPJ_FALSE
		}
	}
	return DOPJ_TRUE
}

func Xopj_bio_inalign(tls *libc.TLS, bio uintptr) TOPJ_BOOL { /* bio.c:208:10: */
	if (*Topj_bio_t)(unsafe.Pointer(bio)).Fbuf&TOPJ_UINT32(0xff) == TOPJ_UINT32(0xff) {
		if !(opj_bio_bytein(tls, bio) != 0) {
			return DOPJ_FALSE
		}
	}
	(*Topj_bio_t)(unsafe.Pointer(bio)).Fct = TOPJ_UINT32(0)
	return DOPJ_TRUE
}

// -----------------------------------------------------------------------

// -----------------------------------------------------------------------

func Xopj_write_bytes_BE(tls *libc.TLS, p_buffer uintptr, p_value TOPJ_UINT32, p_nb_bytes TOPJ_UINT32) { /* cio.c:47:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*TOPJ_UINT32)(unsafe.Pointer(bp)) = p_value

	var l_data_ptr uintptr = bp + uintptr(uint32(unsafe.Sizeof(TOPJ_UINT32(0)))) - uintptr(p_nb_bytes)

	if p_nb_bytes > TOPJ_UINT32(0) && uint32(p_nb_bytes) <= uint32(unsafe.Sizeof(TOPJ_UINT32(0))) {
	} else {
		libc.X__assert_fail(tls, ts+415, ts+466, uint32(53), uintptr(unsafe.Pointer(&__func__10)))
	}

	libc.Xmemcpy(tls, p_buffer, l_data_ptr, uint32(p_nb_bytes))
}

var __func__10 = *(*[19]int8)(unsafe.Pointer(ts + 491)) /* cio.c:49:1 */

func Xopj_write_bytes_LE(tls *libc.TLS, p_buffer uintptr, p_value TOPJ_UINT32, p_nb_bytes TOPJ_UINT32) { /* cio.c:58:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*TOPJ_UINT32)(unsafe.Pointer(bp)) = p_value

	var l_data_ptr uintptr = bp + uintptr(p_nb_bytes) - uintptr(1)
	var i TOPJ_UINT32

	if p_nb_bytes > TOPJ_UINT32(0) && uint32(p_nb_bytes) <= uint32(unsafe.Sizeof(TOPJ_UINT32(0))) {
	} else {
		libc.X__assert_fail(tls, ts+415, ts+466, uint32(64), uintptr(unsafe.Pointer(&__func__11)))
	}

	for i = TOPJ_UINT32(0); i < p_nb_bytes; i++ {
		*(*TOPJ_BYTE)(unsafe.Pointer(libc.PostIncUintptr(&p_buffer, 1))) = *(*TOPJ_BYTE)(unsafe.Pointer(libc.PostDecUintptr(&l_data_ptr, 1)))
	}
}

var __func__11 = *(*[19]int8)(unsafe.Pointer(ts + 510)) /* cio.c:60:1 */

func Xopj_read_bytes_BE(tls *libc.TLS, p_buffer uintptr, p_value uintptr, p_nb_bytes TOPJ_UINT32) { /* cio.c:71:6: */
	var l_data_ptr uintptr = p_value

	if p_nb_bytes > TOPJ_UINT32(0) && uint32(p_nb_bytes) <= uint32(unsafe.Sizeof(TOPJ_UINT32(0))) {
	} else {
		libc.X__assert_fail(tls, ts+415, ts+466, uint32(76), uintptr(unsafe.Pointer(&__func__12)))
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_value)) = TOPJ_UINT32(0)
	libc.Xmemcpy(tls, l_data_ptr+uintptr(uint32(unsafe.Sizeof(TOPJ_UINT32(0))))-uintptr(p_nb_bytes), p_buffer, uint32(p_nb_bytes))
}

var __func__12 = *(*[18]int8)(unsafe.Pointer(ts + 529)) /* cio.c:73:1 */

func Xopj_read_bytes_LE(tls *libc.TLS, p_buffer uintptr, p_value uintptr, p_nb_bytes TOPJ_UINT32) { /* cio.c:82:6: */
	var l_data_ptr uintptr = p_value + uintptr(p_nb_bytes) - uintptr(1)
	var i TOPJ_UINT32

	if p_nb_bytes > TOPJ_UINT32(0) && uint32(p_nb_bytes) <= uint32(unsafe.Sizeof(TOPJ_UINT32(0))) {
	} else {
		libc.X__assert_fail(tls, ts+415, ts+466, uint32(88), uintptr(unsafe.Pointer(&__func__13)))
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_value)) = TOPJ_UINT32(0)
	for i = TOPJ_UINT32(0); i < p_nb_bytes; i++ {
		*(*TOPJ_BYTE)(unsafe.Pointer(libc.PostDecUintptr(&l_data_ptr, 1))) = *(*TOPJ_BYTE)(unsafe.Pointer(libc.PostIncUintptr(&p_buffer, 1)))
	}
}

var __func__13 = *(*[18]int8)(unsafe.Pointer(ts + 547)) /* cio.c:84:1 */

func Xopj_write_double_BE(tls *libc.TLS, p_buffer uintptr, p_value TOPJ_FLOAT64) { /* cio.c:96:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*TOPJ_FLOAT64)(unsafe.Pointer(bp)) = p_value

	var l_data_ptr uintptr = bp
	libc.Xmemcpy(tls, p_buffer, l_data_ptr, uint32(unsafe.Sizeof(TOPJ_FLOAT64(0))))
}

func Xopj_write_double_LE(tls *libc.TLS, p_buffer uintptr, p_value TOPJ_FLOAT64) { /* cio.c:102:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*TOPJ_FLOAT64)(unsafe.Pointer(bp)) = p_value

	var l_data_ptr uintptr = bp + uintptr(uint32(unsafe.Sizeof(TOPJ_FLOAT64(0)))) - uintptr(1)
	var i TOPJ_UINT32
	for i = TOPJ_UINT32(0); uint32(i) < uint32(unsafe.Sizeof(TOPJ_FLOAT64(0))); i++ {
		*(*TOPJ_BYTE)(unsafe.Pointer(libc.PostIncUintptr(&p_buffer, 1))) = *(*TOPJ_BYTE)(unsafe.Pointer(libc.PostDecUintptr(&l_data_ptr, 1)))
	}
}

func Xopj_read_double_BE(tls *libc.TLS, p_buffer uintptr, p_value uintptr) { /* cio.c:112:6: */
	var l_data_ptr uintptr = p_value
	libc.Xmemcpy(tls, l_data_ptr, p_buffer, uint32(unsafe.Sizeof(TOPJ_FLOAT64(0))))
}

func Xopj_read_double_LE(tls *libc.TLS, p_buffer uintptr, p_value uintptr) { /* cio.c:118:6: */
	var l_data_ptr uintptr = p_value + uintptr(uint32(unsafe.Sizeof(TOPJ_FLOAT64(0)))) - uintptr(1)
	var i TOPJ_UINT32
	for i = TOPJ_UINT32(0); uint32(i) < uint32(unsafe.Sizeof(TOPJ_FLOAT64(0))); i++ {
		*(*TOPJ_BYTE)(unsafe.Pointer(libc.PostDecUintptr(&l_data_ptr, 1))) = *(*TOPJ_BYTE)(unsafe.Pointer(libc.PostIncUintptr(&p_buffer, 1)))
	}
}

func Xopj_write_float_BE(tls *libc.TLS, p_buffer uintptr, p_value TOPJ_FLOAT32) { /* cio.c:127:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*TOPJ_FLOAT32)(unsafe.Pointer(bp)) = p_value

	var l_data_ptr uintptr = bp
	libc.Xmemcpy(tls, p_buffer, l_data_ptr, uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))))
}

func Xopj_write_float_LE(tls *libc.TLS, p_buffer uintptr, p_value TOPJ_FLOAT32) { /* cio.c:133:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*TOPJ_FLOAT32)(unsafe.Pointer(bp)) = p_value

	var l_data_ptr uintptr = bp + uintptr(uint32(unsafe.Sizeof(TOPJ_FLOAT32(0)))) - uintptr(1)
	var i TOPJ_UINT32
	for i = TOPJ_UINT32(0); uint32(i) < uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))); i++ {
		*(*TOPJ_BYTE)(unsafe.Pointer(libc.PostIncUintptr(&p_buffer, 1))) = *(*TOPJ_BYTE)(unsafe.Pointer(libc.PostDecUintptr(&l_data_ptr, 1)))
	}
}

func Xopj_read_float_BE(tls *libc.TLS, p_buffer uintptr, p_value uintptr) { /* cio.c:143:6: */
	var l_data_ptr uintptr = p_value
	libc.Xmemcpy(tls, l_data_ptr, p_buffer, uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))))
}

func Xopj_read_float_LE(tls *libc.TLS, p_buffer uintptr, p_value uintptr) { /* cio.c:149:6: */
	var l_data_ptr uintptr = p_value + uintptr(uint32(unsafe.Sizeof(TOPJ_FLOAT32(0)))) - uintptr(1)
	var i TOPJ_UINT32
	for i = TOPJ_UINT32(0); uint32(i) < uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))); i++ {
		*(*TOPJ_BYTE)(unsafe.Pointer(libc.PostDecUintptr(&l_data_ptr, 1))) = *(*TOPJ_BYTE)(unsafe.Pointer(libc.PostIncUintptr(&p_buffer, 1)))
	}
}

func Xopj_stream_create(tls *libc.TLS, p_buffer_size TOPJ_SIZE_T, l_is_input TOPJ_BOOL) uintptr { /* cio.c:158:13: */
	var l_stream uintptr = uintptr(00)
	l_stream = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_stream_private_t{})))
	if !(l_stream != 0) {
		return uintptr(00)
	}

	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_buffer_size = p_buffer_size
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_stored_data = Xopj_malloc(tls, p_buffer_size)
	if !(int32((*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_stored_data) != 0) {
		Xopj_free(tls, l_stream)
		return uintptr(00)
	}

	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_stored_data

	if l_is_input != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(l_stream + 100)) |= DOPJ_STREAM_STATUS_INPUT
		(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_opj_skip = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_OFF_T, uintptr) TOPJ_OFF_T
		}{Xopj_stream_read_skip}))
		(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_opj_seek = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_OFF_T, uintptr) TOPJ_BOOL
		}{Xopj_stream_read_seek}))
	} else {
		*(*TOPJ_UINT32)(unsafe.Pointer(l_stream + 100)) |= DOPJ_STREAM_STATUS_OUTPUT
		(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_opj_skip = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_OFF_T, uintptr) TOPJ_OFF_T
		}{Xopj_stream_write_skip}))
		(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_opj_seek = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_OFF_T, uintptr) TOPJ_BOOL
		}{Xopj_stream_write_seek}))
	}

	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_read_fn = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, TOPJ_SIZE_T, uintptr) TOPJ_SIZE_T
	}{Xopj_stream_default_read}))
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_write_fn = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, TOPJ_SIZE_T, uintptr) TOPJ_SIZE_T
	}{Xopj_stream_default_write}))
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_skip_fn = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_OFF_T
	}{Xopj_stream_default_skip}))
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_seek_fn = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_BOOL
	}{Xopj_stream_default_seek}))

	return l_stream
}

func Xopj_stream_default_create(tls *libc.TLS, l_is_input TOPJ_BOOL) uintptr { /* cio.c:194:13: */
	return Xopj_stream_create(tls, uint32(DOPJ_J2K_STREAM_CHUNK_SIZE), l_is_input)
}

func Xopj_stream_destroy(tls *libc.TLS, p_stream uintptr) { /* cio.c:199:19: */
	var l_stream uintptr = p_stream

	if l_stream != 0 {
		if (*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_free_user_data_fn != 0 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_free_user_data_fn})).f(tls, (*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_user_data)
		}
		Xopj_free(tls, (*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_stored_data)
		(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_stored_data = uintptr(00)
		Xopj_free(tls, l_stream)
	}
}

func Xopj_stream_set_read_function(tls *libc.TLS, p_stream uintptr, p_function Topj_stream_read_fn) { /* cio.c:213:19: */
	var l_stream uintptr = p_stream

	if !(l_stream != 0) || !((*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_status&DOPJ_STREAM_STATUS_INPUT != 0) {
		return
	}

	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_read_fn = p_function
}

func Xopj_stream_set_seek_function(tls *libc.TLS, p_stream uintptr, p_function Topj_stream_seek_fn) { /* cio.c:225:19: */
	var l_stream uintptr = p_stream

	if !(l_stream != 0) {
		return
	}
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_seek_fn = p_function
}

func Xopj_stream_set_write_function(tls *libc.TLS, p_stream uintptr, p_function Topj_stream_write_fn) { /* cio.c:236:19: */
	var l_stream uintptr = p_stream

	if !(l_stream != 0) || !((*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_status&DOPJ_STREAM_STATUS_OUTPUT != 0) {
		return
	}

	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_write_fn = p_function
}

func Xopj_stream_set_skip_function(tls *libc.TLS, p_stream uintptr, p_function Topj_stream_skip_fn) { /* cio.c:248:19: */
	var l_stream uintptr = p_stream

	if !(l_stream != 0) {
		return
	}

	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_skip_fn = p_function
}

func Xopj_stream_set_current_data(tls *libc.TLS, p_stream uintptr, p_data uintptr, p_size TOPJ_SIZE_T) { /* cio.c:260:19: */
	var l_stream uintptr = p_stream
	if !(l_stream != 0) {
		return
	}
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_current_data = p_data
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_bytes_in_buffer = p_size
	*(*TOPJ_UINT32)(unsafe.Pointer(l_stream + 100)) |= DOPJ_STREAM_STATUS_END
}

func Xopj_stream_set_user_data(tls *libc.TLS, p_stream uintptr, p_data uintptr, p_function Topj_stream_free_user_data_fn) { /* cio.c:272:19: */
	var l_stream uintptr = p_stream
	if !(l_stream != 0) {
		return
	}
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_user_data = p_data
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_free_user_data_fn = p_function
}

func Xopj_stream_set_user_data_length(tls *libc.TLS, p_stream uintptr, data_length TOPJ_UINT64) { /* cio.c:283:19: */
	var l_stream uintptr = p_stream
	if !(l_stream != 0) {
		return
	}
	(*Topj_stream_private_t)(unsafe.Pointer(l_stream)).Fm_user_data_length = data_length
}

func Xopj_stream_read_data(tls *libc.TLS, p_stream uintptr, p_buffer uintptr, p_size TOPJ_SIZE_T, p_event_mgr uintptr) TOPJ_SIZE_T { /* cio.c:293:12: */
	var l_read_nb_bytes TOPJ_SIZE_T = TOPJ_SIZE_T(0)
	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer >= p_size {
		libc.Xmemcpy(tls, p_buffer, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data, p_size)
		*(*uintptr)(unsafe.Pointer(p_stream + 64)) += uintptr(p_size)
		*(*TOPJ_SIZE_T)(unsafe.Pointer(p_stream + 88)) -= p_size
		l_read_nb_bytes = l_read_nb_bytes + p_size
		*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T(p_size)
		return l_read_nb_bytes
	}

	// we are now in the case when the remaining data if not sufficient
	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_status&DOPJ_STREAM_STATUS_END != 0 {
		l_read_nb_bytes = l_read_nb_bytes + (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer
		libc.Xmemcpy(tls, p_buffer, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		*(*uintptr)(unsafe.Pointer(p_stream + 64)) += uintptr((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
		if l_read_nb_bytes != 0 {
			return l_read_nb_bytes
		}
		return libc.Uint32(libc.Uint32FromInt32(-1))
	}

	// the flag is not set, we copy data and then do an actual read on the stream
	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer != 0 {
		l_read_nb_bytes = l_read_nb_bytes + (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer
		libc.Xmemcpy(tls, p_buffer, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data
		p_buffer += uintptr((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		p_size = p_size - (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer
		*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
	} else {
		// case where we are already at the end of the buffer
		//            so reset the m_current_data to point to the start of the
		//            stored buffer to get ready to read from disk
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data
	}

	for {
		// we should read less than a chunk -> read a chunk
		if p_size < (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_buffer_size {
			// we should do an actual read on the media
			(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = (*struct {
				f func(*libc.TLS, uintptr, TOPJ_SIZE_T, uintptr) TOPJ_SIZE_T
			})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_read_fn})).f(tls, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data,
				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_buffer_size, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data)

			if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer == libc.Uint32(libc.Uint32FromInt32(-1)) {
				// end of stream
				Xopj_event_msg(tls, p_event_mgr, DEVT_INFO, ts+565, 0)

				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
				*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_END
				// end of stream
				if l_read_nb_bytes != 0 {
					return l_read_nb_bytes
				}
				return libc.Uint32(libc.Uint32FromInt32(-1))
			} else if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer < p_size {
				// not enough data
				l_read_nb_bytes = l_read_nb_bytes + (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer
				libc.Xmemcpy(tls, p_buffer, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data
				p_buffer += uintptr((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
				p_size = p_size - (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer
				*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
			} else {
				l_read_nb_bytes = l_read_nb_bytes + p_size
				libc.Xmemcpy(tls, p_buffer, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data, p_size)
				*(*uintptr)(unsafe.Pointer(p_stream + 64)) += uintptr(p_size)
				*(*TOPJ_SIZE_T)(unsafe.Pointer(p_stream + 88)) -= p_size
				*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T(p_size)
				return l_read_nb_bytes
			}
		} else {
			// direct read on the dest buffer
			(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = (*struct {
				f func(*libc.TLS, uintptr, TOPJ_SIZE_T, uintptr) TOPJ_SIZE_T
			})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_read_fn})).f(tls, p_buffer, p_size,
				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data)

			if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer == libc.Uint32(libc.Uint32FromInt32(-1)) {
				//  end of stream
				Xopj_event_msg(tls, p_event_mgr, DEVT_INFO, ts+565, 0)

				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
				*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_END
				// end of stream
				if l_read_nb_bytes != 0 {
					return l_read_nb_bytes
				}
				return libc.Uint32(libc.Uint32FromInt32(-1))
			} else if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer < p_size {
				// not enough data
				l_read_nb_bytes = l_read_nb_bytes + (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer
				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data
				p_buffer += uintptr((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
				p_size = p_size - (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer
				*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
			} else {
				// we have read the exact size
				l_read_nb_bytes = l_read_nb_bytes + (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer
				*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data
				(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
				return l_read_nb_bytes
			}
		}
	}
	return TOPJ_SIZE_T(0)
}

func Xopj_stream_write_data(tls *libc.TLS, p_stream uintptr, p_buffer uintptr, p_size TOPJ_SIZE_T, p_event_mgr uintptr) TOPJ_SIZE_T { /* cio.c:397:12: */
	var l_remaining_bytes TOPJ_SIZE_T = TOPJ_SIZE_T(0)
	var l_write_nb_bytes TOPJ_SIZE_T = TOPJ_SIZE_T(0)

	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_status&DOPJ_STREAM_STATUS_ERROR != 0 {
		return libc.Uint32(libc.Uint32FromInt32(-1))
	}

	for {
		l_remaining_bytes = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_buffer_size - (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer

		// we have more memory than required
		if l_remaining_bytes >= p_size {
			libc.Xmemcpy(tls, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data, p_buffer, p_size)

			*(*uintptr)(unsafe.Pointer(p_stream + 64)) += uintptr(p_size)
			*(*TOPJ_SIZE_T)(unsafe.Pointer(p_stream + 88)) += p_size
			l_write_nb_bytes = l_write_nb_bytes + p_size
			*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T(p_size)

			return l_write_nb_bytes
		}

		// we copy data and then do an actual read on the stream
		if l_remaining_bytes != 0 {
			l_write_nb_bytes = l_write_nb_bytes + l_remaining_bytes

			libc.Xmemcpy(tls, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data, p_buffer, l_remaining_bytes)

			(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data

			p_buffer += uintptr(l_remaining_bytes)
			p_size = p_size - l_remaining_bytes
			*(*TOPJ_SIZE_T)(unsafe.Pointer(p_stream + 88)) += l_remaining_bytes
			*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += TOPJ_OFF_T(l_remaining_bytes)
		}

		if !(Xopj_stream_flush(tls, p_stream, p_event_mgr) != 0) {
			return libc.Uint32(libc.Uint32FromInt32(-1))
		}
	}
	return TOPJ_SIZE_T(0)

}

func Xopj_stream_flush(tls *libc.TLS, p_stream uintptr, p_event_mgr uintptr) TOPJ_BOOL { /* cio.c:445:10: */
	// the number of bytes written on the media.
	var l_current_write_nb_bytes TOPJ_SIZE_T = TOPJ_SIZE_T(0)

	(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data

	for (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer != 0 {
		// we should do an actual write on the media
		l_current_write_nb_bytes = (*struct {
			f func(*libc.TLS, uintptr, TOPJ_SIZE_T, uintptr) TOPJ_SIZE_T
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_write_fn})).f(tls, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data,
			(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer,
			(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data)

		if l_current_write_nb_bytes == libc.Uint32(libc.Uint32FromInt32(-1)) {
			*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_ERROR
			Xopj_event_msg(tls, p_event_mgr, DEVT_INFO, ts+591, 0)

			return DOPJ_FALSE
		}

		*(*uintptr)(unsafe.Pointer(p_stream + 64)) += uintptr(l_current_write_nb_bytes)
		*(*TOPJ_SIZE_T)(unsafe.Pointer(p_stream + 88)) -= l_current_write_nb_bytes
	}

	(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data

	return DOPJ_TRUE
}

func Xopj_stream_read_skip(tls *libc.TLS, p_stream uintptr, p_size TOPJ_OFF_T, p_event_mgr uintptr) TOPJ_OFF_T { /* cio.c:475:11: */
	var l_skip_nb_bytes TOPJ_OFF_T = 0
	var l_current_skip_nb_bytes TOPJ_OFF_T = 0

	if p_size >= 0 {
	} else {
		libc.X__assert_fail(tls, ts+617, ts+466, uint32(481), uintptr(unsafe.Pointer(&__func__14)))
	}

	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer >= TOPJ_SIZE_T(p_size) {
		*(*uintptr)(unsafe.Pointer(p_stream + 64)) += uintptr(p_size)
		// it is safe to cast p_size to OPJ_SIZE_T since it is <= m_bytes_in_buffer
		//         which is of type OPJ_SIZE_T
		*(*TOPJ_SIZE_T)(unsafe.Pointer(p_stream + 88)) -= TOPJ_SIZE_T(p_size)
		l_skip_nb_bytes = l_skip_nb_bytes + p_size
		*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += l_skip_nb_bytes
		return l_skip_nb_bytes
	}

	// we are now in the case when the remaining data if not sufficient
	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_status&DOPJ_STREAM_STATUS_END != 0 {
		l_skip_nb_bytes = l_skip_nb_bytes + TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		*(*uintptr)(unsafe.Pointer(p_stream + 64)) += uintptr((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
		*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += l_skip_nb_bytes
		if l_skip_nb_bytes != 0 {
			return l_skip_nb_bytes
		}
		return -1
	}

	// the flag is not set, we copy data and then do an actual skip on the stream
	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer != 0 {
		l_skip_nb_bytes = l_skip_nb_bytes + TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data
		p_size = p_size - TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer)
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
	}

	for p_size > 0 {
		// Check if we are going beyond the end of file. Most skip_fn do not
		// check that, but we must be careful not to advance m_byte_offset
		// beyond m_user_data_length, otherwise
		// opj_stream_get_number_byte_left() will assert.
		if TOPJ_UINT64((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_byte_offset+l_skip_nb_bytes+p_size) > (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data_length {
			Xopj_event_msg(tls, p_event_mgr, DEVT_INFO, ts+565, 0)

			*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += l_skip_nb_bytes
			l_skip_nb_bytes = TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data_length - TOPJ_UINT64((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_byte_offset))

			Xopj_stream_read_seek(tls, p_stream, TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data_length),
				p_event_mgr)
			*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_END

			// end if stream
			if l_skip_nb_bytes != 0 {
				return l_skip_nb_bytes
			}
			return -1
		}

		// we should do an actual skip on the media
		l_current_skip_nb_bytes = (*struct {
			f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_OFF_T
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_skip_fn})).f(tls, p_size, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data)
		if l_current_skip_nb_bytes == -1 {
			Xopj_event_msg(tls, p_event_mgr, DEVT_INFO, ts+565, 0)

			*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_END
			*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += l_skip_nb_bytes
			// end if stream
			if l_skip_nb_bytes != 0 {
				return l_skip_nb_bytes
			}
			return -1
		}
		p_size = p_size - l_current_skip_nb_bytes
		l_skip_nb_bytes = l_skip_nb_bytes + l_current_skip_nb_bytes
	}

	*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += l_skip_nb_bytes

	return l_skip_nb_bytes
}

var __func__14 = *(*[21]int8)(unsafe.Pointer(ts + 629)) /* cio.c:477:1 */

func Xopj_stream_write_skip(tls *libc.TLS, p_stream uintptr, p_size TOPJ_OFF_T, p_event_mgr uintptr) TOPJ_OFF_T { /* cio.c:550:11: */
	var l_is_written TOPJ_BOOL = 0
	var l_current_skip_nb_bytes TOPJ_OFF_T = 0
	var l_skip_nb_bytes TOPJ_OFF_T = 0

	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_status&DOPJ_STREAM_STATUS_ERROR != 0 {
		return -1
	}

	// we should flush data
	l_is_written = Xopj_stream_flush(tls, p_stream, p_event_mgr)
	if !(l_is_written != 0) {
		*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_ERROR
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)
		return -1
	}
	// then skip

	for p_size > 0 {
		// we should do an actual skip on the media
		l_current_skip_nb_bytes = (*struct {
			f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_OFF_T
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_skip_fn})).f(tls, p_size, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data)

		if l_current_skip_nb_bytes == -1 {
			Xopj_event_msg(tls, p_event_mgr, DEVT_INFO, ts+650, 0)

			*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_ERROR
			*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += l_skip_nb_bytes
			// end if stream
			if l_skip_nb_bytes != 0 {
				return l_skip_nb_bytes
			}
			return -1
		}
		p_size = p_size - l_current_skip_nb_bytes
		l_skip_nb_bytes = l_skip_nb_bytes + l_current_skip_nb_bytes
	}

	*(*TOPJ_OFF_T)(unsafe.Pointer(p_stream + 92)) += l_skip_nb_bytes

	return l_skip_nb_bytes
}

func Xopj_stream_tell(tls *libc.TLS, p_stream uintptr) TOPJ_OFF_T { /* cio.c:591:11: */
	return (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_byte_offset
}

func Xopj_stream_get_number_byte_left(tls *libc.TLS, p_stream uintptr) TOPJ_OFF_T { /* cio.c:596:11: */
	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_byte_offset >= 0 {
	} else {
		libc.X__assert_fail(tls, ts+665, ts+466, uint32(598), uintptr(unsafe.Pointer(&__func__15)))
	}
	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data_length >= TOPJ_UINT64((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_byte_offset) {
	} else {
		libc.X__assert_fail(tls, ts+694, ts+466, uint32(599), uintptr(unsafe.Pointer(&__func__15)))
	}
	if (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data_length != 0 {
		return TOPJ_OFF_T((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data_length) - (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_byte_offset
	}
	return 0
}

var __func__15 = *(*[32]int8)(unsafe.Pointer(ts + 762)) /* cio.c:597:1 */

func Xopj_stream_skip(tls *libc.TLS, p_stream uintptr, p_size TOPJ_OFF_T, p_event_mgr uintptr) TOPJ_OFF_T { /* cio.c:605:11: */
	if p_size >= 0 {
	} else {
		libc.X__assert_fail(tls, ts+617, ts+466, uint32(608), uintptr(unsafe.Pointer(&__func__16)))
	}
	return (*struct {
		f func(*libc.TLS, uintptr, TOPJ_OFF_T, uintptr) TOPJ_OFF_T
	})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_opj_skip})).f(tls, p_stream, p_size, p_event_mgr)
}

var __func__16 = *(*[16]int8)(unsafe.Pointer(ts + 794)) /* cio.c:607:1 */

func Xopj_stream_read_seek(tls *libc.TLS, p_stream uintptr, p_size TOPJ_OFF_T, p_event_mgr uintptr) TOPJ_BOOL { /* cio.c:612:10: */
	_ = p_event_mgr
	(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data
	(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)

	if !((*struct {
		f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_BOOL
	})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_seek_fn})).f(tls, p_size, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data) != 0) {
		*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_END
		return DOPJ_FALSE
	} else {
		// reset stream status
		*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) &= libc.CplUint32(DOPJ_STREAM_STATUS_END)
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_byte_offset = p_size

	}

	return DOPJ_TRUE
}

func Xopj_stream_write_seek(tls *libc.TLS, p_stream uintptr, p_size TOPJ_OFF_T, p_event_mgr uintptr) TOPJ_BOOL { /* cio.c:632:10: */
	if !(Xopj_stream_flush(tls, p_stream, p_event_mgr) != 0) {
		*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_ERROR
		return DOPJ_FALSE
	}

	(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_current_data = (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_stored_data
	(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_bytes_in_buffer = TOPJ_SIZE_T(0)

	if !((*struct {
		f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_BOOL
	})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_seek_fn})).f(tls, p_size, (*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_user_data) != 0) {
		*(*TOPJ_UINT32)(unsafe.Pointer(p_stream + 100)) |= DOPJ_STREAM_STATUS_ERROR
		return DOPJ_FALSE
	} else {
		(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_byte_offset = p_size
	}

	return DOPJ_TRUE
}

func Xopj_stream_seek(tls *libc.TLS, p_stream uintptr, p_size TOPJ_OFF_T, p_event_mgr uintptr) TOPJ_BOOL { /* cio.c:653:10: */
	if p_size >= 0 {
	} else {
		libc.X__assert_fail(tls, ts+617, ts+466, uint32(656), uintptr(unsafe.Pointer(&__func__17)))
	}
	return (*struct {
		f func(*libc.TLS, uintptr, TOPJ_OFF_T, uintptr) TOPJ_BOOL
	})(unsafe.Pointer(&struct{ uintptr }{(*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_opj_seek})).f(tls, p_stream, p_size, p_event_mgr)
}

var __func__17 = *(*[16]int8)(unsafe.Pointer(ts + 810)) /* cio.c:655:1 */

func Xopj_stream_has_seek(tls *libc.TLS, p_stream uintptr) TOPJ_BOOL { /* cio.c:660:10: */
	return libc.Bool32((*Topj_stream_private_t)(unsafe.Pointer(p_stream)).Fm_seek_fn != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_BOOL
	}{Xopj_stream_default_seek})))
}

func Xopj_stream_default_read(tls *libc.TLS, p_buffer uintptr, p_nb_bytes TOPJ_SIZE_T, p_user_data uintptr) TOPJ_SIZE_T { /* cio.c:665:12: */
	_ = p_buffer
	_ = p_nb_bytes
	_ = p_user_data
	return libc.Uint32(libc.Uint32FromInt32(-1))
}

func Xopj_stream_default_write(tls *libc.TLS, p_buffer uintptr, p_nb_bytes TOPJ_SIZE_T, p_user_data uintptr) TOPJ_SIZE_T { /* cio.c:674:12: */
	_ = p_buffer
	_ = p_nb_bytes
	_ = p_user_data
	return libc.Uint32(libc.Uint32FromInt32(-1))
}

func Xopj_stream_default_skip(tls *libc.TLS, p_nb_bytes TOPJ_OFF_T, p_user_data uintptr) TOPJ_OFF_T { /* cio.c:683:11: */
	_ = p_nb_bytes
	_ = p_user_data
	return -1
}

func Xopj_stream_default_seek(tls *libc.TLS, p_nb_bytes TOPJ_OFF_T, p_user_data uintptr) TOPJ_BOOL { /* cio.c:690:10: */
	_ = p_nb_bytes
	_ = p_user_data
	return DOPJ_FALSE
}

//#ifdef __SSE__
//#include <xmmintrin.h>
//#endif
//#ifdef __SSE2__
//#include <emmintrin.h>
//#endif
//#ifdef __SSSE3__
//#include <tmmintrin.h>
//#endif
//#ifdef __AVX2__
//#include <immintrin.h>
//#endif

//* @defgroup DWT DWT - Implementation of a discrete wavelet transform
//@{

//* Number of int32 values in a SSE2 register

//* Number of columns that we can process in parallel in the vertical pass

//* @name Local data structures
//@{

type Sdwt_local = struct {
	Fmem         uintptr
	Fdn          TOPJ_INT32
	Fsn          TOPJ_INT32
	Fcas         TOPJ_INT32
	F__ccgo_pad1 [4]byte
} /* dwt.c:88:9 */

//#ifdef __SSE__
//#include <xmmintrin.h>
//#endif
//#ifdef __SSE2__
//#include <emmintrin.h>
//#endif
//#ifdef __SSSE3__
//#include <tmmintrin.h>
//#endif
//#ifdef __AVX2__
//#include <immintrin.h>
//#endif

//* @defgroup DWT DWT - Implementation of a discrete wavelet transform
//@{

//* Number of int32 values in a SSE2 register

//* Number of columns that we can process in parallel in the vertical pass

//* @name Local data structures
//@{

type Topj_dwt_t = Sdwt_local /* dwt.c:93:3 */

type Topj_v8_t = struct{ Ff [8]TOPJ_FLOAT32 } /* dwt.c:99:3 */

type Sv8dwt_local = struct {
	Fwavelet     uintptr
	Fdn          TOPJ_INT32
	Fsn          TOPJ_INT32
	Fcas         TOPJ_INT32
	Fwin_l_x0    TOPJ_UINT32
	Fwin_l_x1    TOPJ_UINT32
	Fwin_h_x0    TOPJ_UINT32
	Fwin_h_x1    TOPJ_UINT32
	F__ccgo_pad1 [4]byte
} /* dwt.c:101:9 */

type Topj_v8dwt_t = Sv8dwt_local /* dwt.c:110:3 */

// From table F.4 from the standard
var opj_dwt_alpha TOPJ_FLOAT32 = -1.586134342 /* dwt.c:113:26 */
var opj_dwt_beta TOPJ_FLOAT32 = -0.052980118  /* dwt.c:114:26 */
var opj_dwt_gamma TOPJ_FLOAT32 = 0.882911075  /* dwt.c:115:26 */
var opj_dwt_delta TOPJ_FLOAT32 = 0.443506852  /* dwt.c:116:26 */

var opj_K TOPJ_FLOAT32 = 1.230174105                                 /* dwt.c:118:26 */
var opj_invK TOPJ_FLOAT32 = TOPJ_FLOAT32(float64(1.0) / 1.230174105) /* dwt.c:119:26 */

// Forward transform, for the vertical pass, processing cols columns
// where cols <= NB_ELTS_V8
// Where void* is a OPJ_INT32* for 5x3 and OPJ_FLOAT32* for 9x7
type Topj_encode_and_deinterleave_v_fnptr_type = uintptr /* dwt.c:157:14 */

// Where void* is a OPJ_INT32* for 5x3 and OPJ_FLOAT32* for 9x7
type Topj_encode_and_deinterleave_h_one_row_fnptr_type = uintptr /* dwt.c:166:14 */

// <summary>
// Inverse 9-7 wavelet transform in 1-D.
// </summary>

//@}

//@}

// new

// <summary>
// This table contains the norms of the 5-3 wavelets for different bands.
// </summary>
// FIXME! the array should really be extended up to 33 resolution levels
// See https://github.com/uclouvain/openjpeg/issues/493
var opj_dwt_norms = [4][10]TOPJ_FLOAT64{
	{1.000, 1.500, 2.750, 5.375, 10.68, 21.34, 42.67, 85.33, 170.7, 341.3},
	{0: 1.038, 1: 1.592, 2: 2.919, 3: 5.703, 4: 11.33, 5: 22.64, 6: 45.25, 7: 90.48, 8: 180.9},
	{0: 1.038, 1: 1.592, 2: 2.919, 3: 5.703, 4: 11.33, 5: 22.64, 6: 45.25, 7: 90.48, 8: 180.9},
	{0: .7186, 1: .9218, 2: 1.586, 3: 3.043, 4: 6.019, 5: 12.01, 6: 24.00, 7: 47.97, 8: 95.93},
} /* dwt.c:202:26 */

// <summary>
// This table contains the norms of the 9-7 wavelets for different bands.
// </summary>
// FIXME! the array should really be extended up to 33 resolution levels
// See https://github.com/uclouvain/openjpeg/issues/493
var opj_dwt_norms_real = [4][10]TOPJ_FLOAT64{
	{1.000, 1.965, 4.177, 8.403, 16.90, 33.84, 67.69, 135.3, 270.6, 540.9},
	{0: 2.022, 1: 3.989, 2: 8.355, 3: 17.04, 4: 34.27, 5: 68.63, 6: 137.3, 7: 274.6, 8: 549.0},
	{0: 2.022, 1: 3.989, 2: 8.355, 3: 17.04, 4: 34.27, 5: 68.63, 6: 137.3, 7: 274.6, 8: 549.0},
	{0: 2.080, 1: 3.865, 2: 8.307, 3: 17.18, 4: 34.71, 5: 69.59, 6: 139.3, 7: 278.6, 8: 557.2},
} /* dwt.c:214:26 */

//
// ==========================================================
//    local functions
// ==========================================================

// <summary>
// Forward lazy transform (horizontal).
// </summary>
func opj_dwt_deinterleave_h(tls *libc.TLS, a uintptr, b uintptr, dn TOPJ_INT32, sn TOPJ_INT32, cas TOPJ_INT32) { /* dwt.c:230:13: */
	var i TOPJ_INT32
	var l_dest uintptr = b
	var l_src uintptr = a + uintptr(cas)*4

	for i = 0; i < sn; i++ {
		*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest, 4))) = *(*TOPJ_INT32)(unsafe.Pointer(l_src))
		l_src += 4 * uintptr(2)
	}

	l_dest = b + uintptr(sn)*4
	l_src = a + uintptr(1)*4 - uintptr(cas)*4

	for i = 0; i < dn; i++ {
		*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest, 4))) = *(*TOPJ_INT32)(unsafe.Pointer(l_src))
		l_src += 4 * uintptr(2)
	}
}

// <summary>
// Inverse lazy transform (horizontal).
// </summary>
func opj_dwt_interleave_h(tls *libc.TLS, h uintptr, a uintptr) { /* dwt.c:257:13: */
	var ai uintptr = a
	var bi uintptr = (*Topj_dwt_t)(unsafe.Pointer(h)).Fmem + uintptr((*Topj_dwt_t)(unsafe.Pointer(h)).Fcas)*4
	var i TOPJ_INT32 = (*Topj_dwt_t)(unsafe.Pointer(h)).Fsn
	for libc.PostDecInt32(&i, 1) != 0 {
		*(*TOPJ_INT32)(unsafe.Pointer(bi)) = *(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&ai, 4)))
		bi += 4 * uintptr(2)
	}
	ai = a + uintptr((*Topj_dwt_t)(unsafe.Pointer(h)).Fsn)*4
	bi = (*Topj_dwt_t)(unsafe.Pointer(h)).Fmem + uintptr(1)*4 - uintptr((*Topj_dwt_t)(unsafe.Pointer(h)).Fcas)*4
	i = (*Topj_dwt_t)(unsafe.Pointer(h)).Fdn
	for libc.PostDecInt32(&i, 1) != 0 {
		*(*TOPJ_INT32)(unsafe.Pointer(bi)) = *(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&ai, 4)))
		bi += 4 * uintptr(2)
	}
}

// <summary>
// Inverse lazy transform (vertical).
// </summary>
func opj_dwt_interleave_v(tls *libc.TLS, v uintptr, a uintptr, x TOPJ_INT32) { /* dwt.c:278:13: */
	var ai uintptr = a
	var bi uintptr = (*Topj_dwt_t)(unsafe.Pointer(v)).Fmem + uintptr((*Topj_dwt_t)(unsafe.Pointer(v)).Fcas)*4
	var i TOPJ_INT32 = (*Topj_dwt_t)(unsafe.Pointer(v)).Fsn
	for libc.PostDecInt32(&i, 1) != 0 {
		*(*TOPJ_INT32)(unsafe.Pointer(bi)) = *(*TOPJ_INT32)(unsafe.Pointer(ai))
		bi += 4 * uintptr(2)
		ai += 4 * uintptr(x)
	}
	ai = a + uintptr(TOPJ_SIZE_T((*Topj_dwt_t)(unsafe.Pointer(v)).Fsn)*TOPJ_SIZE_T(x))*4
	bi = (*Topj_dwt_t)(unsafe.Pointer(v)).Fmem + uintptr(1)*4 - uintptr((*Topj_dwt_t)(unsafe.Pointer(v)).Fcas)*4
	i = (*Topj_dwt_t)(unsafe.Pointer(v)).Fdn
	for libc.PostDecInt32(&i, 1) != 0 {
		*(*TOPJ_INT32)(unsafe.Pointer(bi)) = *(*TOPJ_INT32)(unsafe.Pointer(ai))
		bi += 4 * uintptr(2)
		ai += 4 * uintptr(x)
	}
}

// <summary>
// Inverse 5-3 wavelet transform in 1-D.
// </summary>
func opj_dwt_decode_1_(tls *libc.TLS, a uintptr, dn TOPJ_INT32, sn TOPJ_INT32, cas TOPJ_INT32) { /* dwt.c:304:13: */
	var i TOPJ_INT32

	if !(cas != 0) {
		if dn > 0 || sn > 1 { // NEW :  CASE ONE ELEMENT
			for i = 0; i < sn; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4)) -= (func() int32 {
					if i-1 < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
					}
					return func() int32 {
						if i-1 >= dn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(dn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(i-1)*2)*4))
					}()
				}() + func() int32 {
					if i < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
					}
					return func() int32 {
						if i >= dn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(dn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4))
					}()
				}() + 2) >> 2
			}
			for i = 0; i < dn; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4)) += (func() int32 {
					if i < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a))
					}
					return func() int32 {
						if i >= sn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((sn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4))
					}()
				}() + func() int32 {
					if i+1 < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a))
					}
					return func() int32 {
						if i+1 >= sn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((sn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((i+1)*2)*4))
					}()
				}()) >> 1
			}
		}
	} else {
		if !(sn != 0) && dn == 1 { // NEW :  CASE ONE ELEMENT
			*(*TOPJ_INT32)(unsafe.Pointer(a)) /= 2
		} else {
			for i = 0; i < sn; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4)) -= (func() int32 {
					if i < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a))
					}
					return func() int32 {
						if i >= dn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((dn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4))
					}()
				}() + func() int32 {
					if i+1 < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a))
					}
					return func() int32 {
						if i+1 >= dn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((dn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((i+1)*2)*4))
					}()
				}() + 2) >> 2
			}
			for i = 0; i < dn; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4)) += (func() int32 {
					if i < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
					}
					return func() int32 {
						if i >= sn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(sn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4))
					}()
				}() + func() int32 {
					if i-1 < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
					}
					return func() int32 {
						if i-1 >= sn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(sn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(i-1)*2)*4))
					}()
				}()) >> 1
			}
		}
	}
}

func opj_dwt_decode_1(tls *libc.TLS, v uintptr) { /* dwt.c:332:13: */
	opj_dwt_decode_1_(tls, (*Topj_dwt_t)(unsafe.Pointer(v)).Fmem, (*Topj_dwt_t)(unsafe.Pointer(v)).Fdn, (*Topj_dwt_t)(unsafe.Pointer(v)).Fsn, (*Topj_dwt_t)(unsafe.Pointer(v)).Fcas)
}

// <summary>
// Inverse 5-3 wavelet transform in 1-D for one row.
// </summary>
// Performs interleave, inverse wavelet transform and copy back to buffer
func opj_idwt53_h(tls *libc.TLS, dwt uintptr, tiledp uintptr) { /* dwt.c:485:13: */
	// For documentation purpose
	opj_dwt_interleave_h(tls, dwt, tiledp)
	opj_dwt_decode_1(tls, dwt)
	libc.Xmemcpy(tls, tiledp, (*Topj_dwt_t)(unsafe.Pointer(dwt)).Fmem, uint32(TOPJ_UINT32((*Topj_dwt_t)(unsafe.Pointer(dwt)).Fsn+(*Topj_dwt_t)(unsafe.Pointer(dwt)).Fdn))*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
}

// <summary>
// Inverse vertical 5-3 wavelet transform in 1-D for several columns.
// </summary>
// Performs interleave, inverse wavelet transform and copy back to buffer
func opj_idwt53_v(tls *libc.TLS, dwt uintptr, tiledp_col uintptr, stride TOPJ_SIZE_T, nb_cols TOPJ_INT32) { /* dwt.c:881:13: */
	// For documentation purpose
	var k TOPJ_INT32
	var c TOPJ_INT32
	for c = 0; c < nb_cols; c++ {
		opj_dwt_interleave_v(tls, dwt, tiledp_col+uintptr(c)*4, int32(stride))
		opj_dwt_decode_1(tls, dwt)
		for k = 0; k < (*Topj_dwt_t)(unsafe.Pointer(dwt)).Fsn+(*Topj_dwt_t)(unsafe.Pointer(dwt)).Fdn; k++ {
			*(*TOPJ_INT32)(unsafe.Pointer(tiledp_col + uintptr(TOPJ_SIZE_T(c)+TOPJ_SIZE_T(k)*stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer((*Topj_dwt_t)(unsafe.Pointer(dwt)).Fmem + uintptr(k)*4))
		}
	}
}

func opj_dwt_encode_step1_combined(tls *libc.TLS, fw uintptr, iters_c1 TOPJ_UINT32, iters_c2 TOPJ_UINT32, c1 TOPJ_FLOAT32, c2 TOPJ_FLOAT32) { /* dwt.c:976:13: */
	var i TOPJ_UINT32 = TOPJ_UINT32(0)
	var iters_common TOPJ_UINT32 = opj_uint_min(tls, iters_c1, iters_c2)
	if TOPJ_SIZE_T(fw)&TOPJ_SIZE_T(0xf) == TOPJ_SIZE_T(0) {
	} else {
		libc.X__assert_fail(tls, ts+826, ts+856, uint32(984), uintptr(unsafe.Pointer(&__func__22)))
	}
	if opj_int_abs(tls, TOPJ_INT32(iters_c1)-TOPJ_INT32(iters_c2)) <= 1 {
	} else {
		libc.X__assert_fail(tls, ts+881, ts+856, uint32(985), uintptr(unsafe.Pointer(&__func__22)))
	}
	for ; i+TOPJ_UINT32(3) < iters_common; i = i + TOPJ_UINT32(4) {
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw)) *= c1
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 1*4)) *= c2
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 2*4)) *= c1
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 3*4)) *= c2
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 4*4)) *= c1
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 5*4)) *= c2
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 6*4)) *= c1
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 7*4)) *= c2
		fw += 4 * uintptr(8)
	}
	for ; i < iters_common; i++ {
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw)) *= c1
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 1*4)) *= c2
		fw += 4 * uintptr(2)
	}
	if i < iters_c1 {
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw)) *= c1
	} else if i < iters_c2 {
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 1*4)) *= c2
	}
}

var __func__22 = *(*[30]int8)(unsafe.Pointer(ts + 941)) /* dwt.c:981:1 */

func opj_dwt_encode_step2(tls *libc.TLS, fl uintptr, fw uintptr, end TOPJ_UINT32, m TOPJ_UINT32, c TOPJ_FLOAT32) { /* dwt.c:1017:13: */
	var i TOPJ_UINT32
	var imax TOPJ_UINT32 = opj_uint_min(tls, end, m)
	if imax > TOPJ_UINT32(0) {
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-1)*4)) += (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fw))) * c
		fw += 4 * uintptr(2)
		i = TOPJ_UINT32(1)
		for ; i+TOPJ_UINT32(3) < imax; i = i + TOPJ_UINT32(4) {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-1)*4)) += (*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-2)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fw))) * c
			*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 1*4)) += (*(*TOPJ_FLOAT32)(unsafe.Pointer(fw)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 2*4))) * c
			*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 3*4)) += (*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 2*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 4*4))) * c
			*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 5*4)) += (*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 4*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 6*4))) * c
			fw += 4 * uintptr(8)
		}
		for ; i < imax; i++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-1)*4)) += (*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-2)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fw))) * c
			fw += 4 * uintptr(2)
		}
	}
	if m < end {
		if m+TOPJ_UINT32(1) == end {
		} else {
			libc.X__assert_fail(tls, ts+971, ts+856, uint32(1041), uintptr(unsafe.Pointer(&__func__23)))
		}
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-1)*4)) += float32(2) * *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-2)*4)) * c
	}
}

var __func__23 = *(*[21]int8)(unsafe.Pointer(ts + 984)) /* dwt.c:1021:1 */

func opj_dwt_encode_1_real(tls *libc.TLS, aIn uintptr, dn TOPJ_INT32, sn TOPJ_INT32, cas TOPJ_INT32) { /* dwt.c:1046:13: */
	var w uintptr = aIn
	var a TOPJ_INT32
	var b TOPJ_INT32
	if dn+sn > 1 {
	} else {
		libc.X__assert_fail(tls, ts+1005, ts+856, uint32(1051), uintptr(unsafe.Pointer(&__func__24)))
	}
	if cas == 0 {
		a = 0
		b = 1
	} else {
		a = 1
		b = 0
	}
	opj_dwt_encode_step2(tls, w+uintptr(a)*4, w+uintptr(b)*4+uintptr(1)*4,
		TOPJ_UINT32(dn),
		TOPJ_UINT32(opj_int_min(tls, dn, sn-b)),
		opj_dwt_alpha)
	opj_dwt_encode_step2(tls, w+uintptr(b)*4, w+uintptr(a)*4+uintptr(1)*4,
		TOPJ_UINT32(sn),
		TOPJ_UINT32(opj_int_min(tls, sn, dn-a)),
		opj_dwt_beta)
	opj_dwt_encode_step2(tls, w+uintptr(a)*4, w+uintptr(b)*4+uintptr(1)*4,
		TOPJ_UINT32(dn),
		TOPJ_UINT32(opj_int_min(tls, dn, sn-b)),
		opj_dwt_gamma)
	opj_dwt_encode_step2(tls, w+uintptr(b)*4, w+uintptr(a)*4+uintptr(1)*4,
		TOPJ_UINT32(sn),
		TOPJ_UINT32(opj_int_min(tls, sn, dn-a)),
		opj_dwt_delta)
	if a == 0 {
		opj_dwt_encode_step1_combined(tls, w,
			TOPJ_UINT32(sn),
			TOPJ_UINT32(dn),
			opj_invK,
			opj_K)
	} else {
		opj_dwt_encode_step1_combined(tls, w,
			TOPJ_UINT32(dn),
			TOPJ_UINT32(sn),
			opj_K,
			opj_invK)
	}
}

var __func__24 = *(*[22]int8)(unsafe.Pointer(ts + 1017)) /* dwt.c:1048:1 */

func opj_dwt_encode_stepsize(tls *libc.TLS, stepsize TOPJ_INT32, numbps TOPJ_INT32, bandno_stepsize uintptr) { /* dwt.c:1097:13: */
	var p TOPJ_INT32
	var n TOPJ_INT32
	p = opj_int_floorlog2(tls, stepsize) - 13
	n = 11 - opj_int_floorlog2(tls, stepsize)
	(*Topj_stepsize_t)(unsafe.Pointer(bandno_stepsize)).Fmant = func() int32 {
		if n < 0 {
			return stepsize >> -n
		}
		return stepsize << n
	}() & 0x7ff
	(*Topj_stepsize_t)(unsafe.Pointer(bandno_stepsize)).Fexpn = numbps - p
}

//
// ==========================================================
//    DWT interface
// ==========================================================

//* Process one line for the horizontal pass of the 5x3 forward transform
func opj_dwt_encode_and_deinterleave_h_one_row(tls *libc.TLS, rowIn uintptr, tmpIn uintptr, width TOPJ_UINT32, even TOPJ_BOOL) { /* dwt.c:1115:6: */
	var row uintptr = rowIn
	var tmp uintptr = tmpIn
	var sn TOPJ_INT32 = TOPJ_INT32((width + func() uint32 {
		if even != 0 {
			return uint32(1)
		}
		return uint32(0)
	}()) >> 1)
	var dn TOPJ_INT32 = TOPJ_INT32(width - TOPJ_UINT32(sn))

	if even != 0 {
		if width > TOPJ_UINT32(1) {
			var i TOPJ_INT32
			for i = 0; i < sn-1; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i+1)*4)) - (*(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(i*2)*4))+*(*TOPJ_INT32)(unsafe.Pointer(row + uintptr((i+1)*2)*4)))>>1
			}
			if width%TOPJ_UINT32(2) == TOPJ_UINT32(0) {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i+1)*4)) - *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(i*2)*4))
			}
			*(*TOPJ_INT32)(unsafe.Pointer(row)) += (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn)*4)) + 2) >> 2
			for i = 1; i < dn; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(i)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i)*4)) + (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+(i-1))*4))+*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i)*4))+2)>>2
			}
			if width%TOPJ_UINT32(2) == TOPJ_UINT32(1) {
				*(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(i)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i)*4)) + (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+(i-1))*4))+*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+(i-1))*4))+2)>>2
			}
			libc.Xmemcpy(tls, row+uintptr(sn)*4, tmp+uintptr(sn)*4, TOPJ_SIZE_T(dn)*TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_INT32(0))))
		}
	} else {
		if width == TOPJ_UINT32(1) {
			*(*TOPJ_INT32)(unsafe.Pointer(row)) *= 2
		} else {
			var i TOPJ_INT32
			*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+0)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row)) - *(*TOPJ_INT32)(unsafe.Pointer(row + 1*4))
			for i = 1; i < sn; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i)*4)) - (*(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i+1)*4))+*(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*(i-1)+1)*4)))>>1
			}
			if width%TOPJ_UINT32(2) == TOPJ_UINT32(1) {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i)*4)) - *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*(i-1)+1)*4))
			}

			for i = 0; i < dn-1; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(i)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i+1)*4)) + (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i)*4))+*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i+1)*4))+2)>>2
			}
			if width%TOPJ_UINT32(2) == TOPJ_UINT32(0) {
				*(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(i)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(row + uintptr(2*i+1)*4)) + (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i)*4))+*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(sn+i)*4))+2)>>2
			}
			libc.Xmemcpy(tls, row+uintptr(sn)*4, tmp+uintptr(sn)*4, TOPJ_SIZE_T(dn)*TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_INT32(0))))
		}
	}
}

//* Process one line for the horizontal pass of the 9x7 forward transform
func opj_dwt_encode_and_deinterleave_h_one_row_real(tls *libc.TLS, rowIn uintptr, tmpIn uintptr, width TOPJ_UINT32, even TOPJ_BOOL) { /* dwt.c:1169:6: */
	var row uintptr = rowIn
	var tmp uintptr = tmpIn
	var sn TOPJ_INT32 = TOPJ_INT32((width + func() uint32 {
		if even != 0 {
			return uint32(1)
		}
		return uint32(0)
	}()) >> 1)
	var dn TOPJ_INT32 = TOPJ_INT32(width - TOPJ_UINT32(sn))
	if width == TOPJ_UINT32(1) {
		return
	}
	libc.Xmemcpy(tls, tmp, row, uint32(width)*uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))))
	opj_dwt_encode_1_real(tls, tmp, dn, sn, func() int32 {
		if even != 0 {
			return 0
		}
		return 1
	}())
	opj_dwt_deinterleave_h(tls, tmp,
		row,
		dn, sn, func() int32 {
			if even != 0 {
				return 0
			}
			return 1
		}())
}

type Topj_dwt_encode_h_job_t = struct {
	Fh          Topj_dwt_t
	Frw         TOPJ_UINT32
	Fw          TOPJ_UINT32
	Ftiledp     uintptr
	Fmin_j      TOPJ_UINT32
	Fmax_j      TOPJ_UINT32
	Fp_function Topj_encode_and_deinterleave_h_one_row_fnptr_type
} /* dwt.c:1196:3 */

func opj_dwt_encode_h_func(tls *libc.TLS, user_data uintptr, tls1 uintptr) { /* dwt.c:1198:13: */
	var j TOPJ_UINT32
	var job uintptr
	_ = tls1

	job = user_data
	for j = (*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fmin_j; j < (*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fmax_j; j++ {
		var aj uintptr = (*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Ftiledp + uintptr(j*(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fw)*4
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL)
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fp_function})).f(tls, aj, (*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fh.Fmem, (*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Frw,
			func() int32 {
				if (*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fh.Fcas == 0 {
					return DOPJ_TRUE
				}
				return DOPJ_FALSE
			}())
	}

	Xopj_aligned_free(tls, (*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fh.Fmem)
	Xopj_free(tls, job)
}

type Topj_dwt_encode_v_job_t = struct {
	Fv                           Topj_dwt_t
	Frh                          TOPJ_UINT32
	Fw                           TOPJ_UINT32
	Ftiledp                      uintptr
	Fmin_j                       TOPJ_UINT32
	Fmax_j                       TOPJ_UINT32
	Fp_encode_and_deinterleave_v Topj_encode_and_deinterleave_v_fnptr_type
} /* dwt.c:1223:3 */

func opj_dwt_encode_v_func(tls *libc.TLS, user_data uintptr, tls1 uintptr) { /* dwt.c:1225:13: */
	var j TOPJ_UINT32
	var job uintptr
	_ = tls1

	job = user_data
	for j = (*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fmin_j; j+TOPJ_UINT32(DNB_ELTS_V8)-TOPJ_UINT32(1) < (*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fmax_j; j = j + TOPJ_UINT32(DNB_ELTS_V8) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL, TOPJ_UINT32, TOPJ_UINT32)
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fp_encode_and_deinterleave_v})).f(tls, (*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Ftiledp+uintptr(j)*4,
			(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fmem,
			(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Frh,
			libc.Bool32((*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fcas == 0),
			(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fw,
			uint32(DNB_ELTS_V8))
	}
	if j < (*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fmax_j {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL, TOPJ_UINT32, TOPJ_UINT32)
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fp_encode_and_deinterleave_v})).f(tls, (*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Ftiledp+uintptr(j)*4,
			(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fmem,
			(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Frh,
			libc.Bool32((*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fcas == 0),
			(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fw,
			(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fmax_j-j)
	}

	Xopj_aligned_free(tls, (*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fmem)
	Xopj_free(tls, job)
}

//* Fetch up to cols <= NB_ELTS_V8 for each line, and put them in tmpOut
// that has a NB_ELTS_V8 interleave factor.
func opj_dwt_fetch_cols_vertical_pass(tls *libc.TLS, arrayIn uintptr, tmpOut uintptr, height TOPJ_UINT32, stride_width TOPJ_UINT32, cols TOPJ_UINT32) { /* dwt.c:1255:13: */
	var array uintptr = arrayIn
	var tmp uintptr = tmpOut
	if cols == TOPJ_UINT32(DNB_ELTS_V8) {
		var k TOPJ_UINT32
		for k = TOPJ_UINT32(0); k < height; k++ {
			libc.Xmemcpy(tls, tmp+uintptr(TOPJ_UINT32(DNB_ELTS_V8)*k)*4,
				array+uintptr(k*stride_width)*4,
				uint32(DNB_ELTS_V8)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
		}
	} else {
		var k TOPJ_UINT32
		for k = TOPJ_UINT32(0); k < height; k++ {
			var c TOPJ_UINT32
			for c = TOPJ_UINT32(0); c < cols; c++ {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(TOPJ_UINT32(DNB_ELTS_V8)*k+c)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(array + uintptr(c+k*stride_width)*4))
			}
			for ; c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(TOPJ_UINT32(DNB_ELTS_V8)*k+c)*4)) = 0
			}
		}
	}
}

// Deinterleave result of forward transform, where cols <= NB_ELTS_V8
// and src contains NB_ELTS_V8 consecutive values for up to NB_ELTS_V8
// columns.
func opj_dwt_deinterleave_v_cols(tls *libc.TLS, src uintptr, dst uintptr, dn TOPJ_INT32, sn TOPJ_INT32, stride_width TOPJ_UINT32, cas TOPJ_INT32, cols TOPJ_UINT32) { /* dwt.c:1287:20: */
	var k TOPJ_INT32
	var i TOPJ_INT32 = sn
	var l_dest uintptr = dst
	var l_src uintptr = src + uintptr(cas*DNB_ELTS_V8)*4
	var c TOPJ_UINT32

	for k = 0; k < 2; k++ {
		for libc.PostDecInt32(&i, 1) != 0 {
			if cols == TOPJ_UINT32(DNB_ELTS_V8) {
				libc.Xmemcpy(tls, l_dest, l_src, uint32(DNB_ELTS_V8)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
			} else {
				c = TOPJ_UINT32(0)
				switch cols {
				case TOPJ_UINT32(7):
					*(*TOPJ_INT32)(unsafe.Pointer(l_dest + uintptr(c)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(l_src + uintptr(c)*4))
					c++
					fallthrough // fallthru
				case TOPJ_UINT32(6):
					*(*TOPJ_INT32)(unsafe.Pointer(l_dest + uintptr(c)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(l_src + uintptr(c)*4))
					c++
					fallthrough // fallthru
				case TOPJ_UINT32(5):
					*(*TOPJ_INT32)(unsafe.Pointer(l_dest + uintptr(c)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(l_src + uintptr(c)*4))
					c++
					fallthrough // fallthru
				case TOPJ_UINT32(4):
					*(*TOPJ_INT32)(unsafe.Pointer(l_dest + uintptr(c)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(l_src + uintptr(c)*4))
					c++
					fallthrough // fallthru
				case TOPJ_UINT32(3):
					*(*TOPJ_INT32)(unsafe.Pointer(l_dest + uintptr(c)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(l_src + uintptr(c)*4))
					c++
					fallthrough // fallthru
				case TOPJ_UINT32(2):
					*(*TOPJ_INT32)(unsafe.Pointer(l_dest + uintptr(c)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(l_src + uintptr(c)*4))
					c++
					fallthrough // fallthru
				default:
					*(*TOPJ_INT32)(unsafe.Pointer(l_dest + uintptr(c)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(l_src + uintptr(c)*4))
					break
				}
			}
			l_dest += 4 * uintptr(stride_width)
			l_src += 4 * uintptr(2*DNB_ELTS_V8)
		}

		l_dest = dst + uintptr(TOPJ_SIZE_T(sn)*TOPJ_SIZE_T(stride_width))*4
		l_src = src + uintptr((1-cas)*DNB_ELTS_V8)*4
		i = dn
	}
}

// Forward 5-3 transform, for the vertical pass, processing cols columns
// where cols <= NB_ELTS_V8
func opj_dwt_encode_and_deinterleave_v(tls *libc.TLS, arrayIn uintptr, tmpIn uintptr, height TOPJ_UINT32, even TOPJ_BOOL, stride_width TOPJ_UINT32, cols TOPJ_UINT32) { /* dwt.c:1345:13: */
	var array uintptr = arrayIn
	var tmp uintptr = tmpIn
	var sn TOPJ_UINT32 = (height + func() uint32 {
		if even != 0 {
			return uint32(1)
		}
		return uint32(0)
	}()) >> 1
	var dn TOPJ_UINT32 = height - sn

	opj_dwt_fetch_cols_vertical_pass(tls, arrayIn, tmpIn, height, stride_width, cols)

	if even != 0 {
		var c TOPJ_UINT32
		if height > TOPJ_UINT32(1) {
			var i TOPJ_UINT32
			for i = TOPJ_UINT32(0); i+TOPJ_UINT32(1) < sn; i++ {
				for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
					*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+i*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) -= (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((i+TOPJ_UINT32(1))*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4))) >> 1
				}
			}
			if height%TOPJ_UINT32(2) == TOPJ_UINT32(0) {
				for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
					*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+i*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) -= *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4))
				}
			}
			for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(TOPJ_UINT32(0*2*DNB_ELTS_V8)+c)*4)) += (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(TOPJ_UINT32((1+0*2)*DNB_ELTS_V8)+c)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(TOPJ_UINT32((1+0*2)*DNB_ELTS_V8)+c)*4)) + 2) >> 2
			}
			for i = TOPJ_UINT32(1); i < dn; i++ {
				for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
					*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) += (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+(i-TOPJ_UINT32(1))*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+i*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + 2) >> 2
				}
			}
			if height%TOPJ_UINT32(2) == TOPJ_UINT32(1) {
				for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
					*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) += (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+(i-TOPJ_UINT32(1))*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+(i-TOPJ_UINT32(1))*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + 2) >> 2
				}
			}
		}
	} else {
		var c TOPJ_UINT32
		if height == TOPJ_UINT32(1) {
			for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(TOPJ_UINT32(0*2*DNB_ELTS_V8)+c)*4)) *= 2
			}
		} else {
			var i TOPJ_UINT32
			for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
				*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(TOPJ_UINT32(0*2*DNB_ELTS_V8)+c)*4)) -= *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(TOPJ_UINT32((1+0*2)*DNB_ELTS_V8)+c)*4))
			}
			for i = TOPJ_UINT32(1); i < sn; i++ {
				for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
					*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) -= (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+i*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+(i-TOPJ_UINT32(1))*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4))) >> 1
				}
			}
			if height%TOPJ_UINT32(2) == TOPJ_UINT32(1) {
				for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
					*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) -= *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+(i-TOPJ_UINT32(1))*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4))
				}
			}
			for i = TOPJ_UINT32(0); i+TOPJ_UINT32(1) < dn; i++ {
				for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
					*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+i*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) += (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((i+TOPJ_UINT32(1))*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + 2) >> 2
				}
			}
			if height%TOPJ_UINT32(2) == TOPJ_UINT32(0) {
				for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
					*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr((TOPJ_UINT32(1)+i*TOPJ_UINT32(2))*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) += (*(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(tmp + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) + 2) >> 2
				}
			}
		}
	}

	if cols == TOPJ_UINT32(DNB_ELTS_V8) {
		opj_dwt_deinterleave_v_cols(tls, tmp, array, TOPJ_INT32(dn), TOPJ_INT32(sn),
			stride_width, func() int32 {
				if even != 0 {
					return 0
				}
				return 1
			}(), uint32(DNB_ELTS_V8))
	} else {
		opj_dwt_deinterleave_v_cols(tls, tmp, array, TOPJ_INT32(dn), TOPJ_INT32(sn),
			stride_width, func() int32 {
				if even != 0 {
					return 0
				}
				return 1
			}(), cols)
	}
}

func opj_v8dwt_encode_step1(tls *libc.TLS, fw uintptr, end TOPJ_UINT32, cst TOPJ_FLOAT32) { /* dwt.c:1575:13: */
	var i TOPJ_UINT32
	var c TOPJ_UINT32
	for i = TOPJ_UINT32(0); i < end; i++ {
		for c = TOPJ_UINT32(0); c < TOPJ_UINT32(DNB_ELTS_V8); c++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8)+c)*4)) *= cst
		}
	}
}

func opj_v8dwt_encode_step2(tls *libc.TLS, fl uintptr, fw uintptr, end TOPJ_UINT32, m TOPJ_UINT32, cst TOPJ_FLOAT32) { /* dwt.c:1598:13: */
	var i TOPJ_UINT32
	var imax TOPJ_UINT32 = opj_uint_min(tls, end, m)
	var c TOPJ_INT32
	if imax > TOPJ_UINT32(0) {
		for c = 0; c < DNB_ELTS_V8; c++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(-1*DNB_ELTS_V8+c)*4)) += (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl + uintptr(0*DNB_ELTS_V8+c)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(0*DNB_ELTS_V8+c)*4))) * cst
		}
		fw += 4 * uintptr(2*DNB_ELTS_V8)
		i = TOPJ_UINT32(1)
		for ; i < imax; i++ {
			for c = 0; c < DNB_ELTS_V8; c++ {
				*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(-1*DNB_ELTS_V8+c)*4)) += (*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(-2*DNB_ELTS_V8+c)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(0*DNB_ELTS_V8+c)*4))) * cst
			}
			fw += 4 * uintptr(2*DNB_ELTS_V8)
		}
	}
	if m < end {
		if m+TOPJ_UINT32(1) == end {
		} else {
			libc.X__assert_fail(tls, ts+971, ts+856, uint32(1645), uintptr(unsafe.Pointer(&__func__25)))
		}
		for c = 0; c < DNB_ELTS_V8; c++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(-1*DNB_ELTS_V8+c)*4)) += float32(2) * *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(-2*DNB_ELTS_V8+c)*4)) * cst
		}
	}
}

var __func__25 = *(*[23]int8)(unsafe.Pointer(ts + 1039)) /* dwt.c:1602:1 */

// Forward 9-7 transform, for the vertical pass, processing cols columns
// where cols <= NB_ELTS_V8
func opj_dwt_encode_and_deinterleave_v_real(tls *libc.TLS, arrayIn uintptr, tmpIn uintptr, height TOPJ_UINT32, even TOPJ_BOOL, stride_width TOPJ_UINT32, cols TOPJ_UINT32) { /* dwt.c:1655:13: */
	var array uintptr = arrayIn
	var tmp uintptr = tmpIn
	var sn TOPJ_INT32 = TOPJ_INT32((height + func() uint32 {
		if even != 0 {
			return uint32(1)
		}
		return uint32(0)
	}()) >> 1)
	var dn TOPJ_INT32 = TOPJ_INT32(height - TOPJ_UINT32(sn))
	var a TOPJ_INT32
	var b TOPJ_INT32

	if height == TOPJ_UINT32(1) {
		return
	}

	opj_dwt_fetch_cols_vertical_pass(tls, arrayIn, tmpIn, height, stride_width, cols)

	if even != 0 {
		a = 0
		b = 1
	} else {
		a = 1
		b = 0
	}
	opj_v8dwt_encode_step2(tls, tmp+uintptr(a*DNB_ELTS_V8)*4,
		tmp+uintptr((b+1)*DNB_ELTS_V8)*4,
		TOPJ_UINT32(dn),
		TOPJ_UINT32(opj_int_min(tls, dn, sn-b)),
		opj_dwt_alpha)
	opj_v8dwt_encode_step2(tls, tmp+uintptr(b*DNB_ELTS_V8)*4,
		tmp+uintptr((a+1)*DNB_ELTS_V8)*4,
		TOPJ_UINT32(sn),
		TOPJ_UINT32(opj_int_min(tls, sn, dn-a)),
		opj_dwt_beta)
	opj_v8dwt_encode_step2(tls, tmp+uintptr(a*DNB_ELTS_V8)*4,
		tmp+uintptr((b+1)*DNB_ELTS_V8)*4,
		TOPJ_UINT32(dn),
		TOPJ_UINT32(opj_int_min(tls, dn, sn-b)),
		opj_dwt_gamma)
	opj_v8dwt_encode_step2(tls, tmp+uintptr(b*DNB_ELTS_V8)*4,
		tmp+uintptr((a+1)*DNB_ELTS_V8)*4,
		TOPJ_UINT32(sn),
		TOPJ_UINT32(opj_int_min(tls, sn, dn-a)),
		opj_dwt_delta)
	opj_v8dwt_encode_step1(tls, tmp+uintptr(b*DNB_ELTS_V8)*4, TOPJ_UINT32(dn),
		opj_K)
	opj_v8dwt_encode_step1(tls, tmp+uintptr(a*DNB_ELTS_V8)*4, TOPJ_UINT32(sn),
		opj_invK)

	if cols == TOPJ_UINT32(DNB_ELTS_V8) {
		opj_dwt_deinterleave_v_cols(tls, tmp,
			array,
			dn, sn,
			stride_width, func() int32 {
				if even != 0 {
					return 0
				}
				return 1
			}(), uint32(DNB_ELTS_V8))
	} else {
		opj_dwt_deinterleave_v_cols(tls, tmp,
			array,
			dn, sn,
			stride_width, func() int32 {
				if even != 0 {
					return 0
				}
				return 1
			}(), cols)
	}
}

// <summary>
// Forward 5-3 wavelet transform in 2-D.
// </summary>
func opj_dwt_encode_procedure(tls *libc.TLS, tp uintptr, tilec uintptr, p_encode_and_deinterleave_v Topj_encode_and_deinterleave_v_fnptr_type, p_encode_and_deinterleave_h_one_row Topj_encode_and_deinterleave_h_one_row_fnptr_type) TOPJ_BOOL { /* dwt.c:1725:24: */
	var i TOPJ_INT32
	var bj uintptr = uintptr(00)
	var w TOPJ_UINT32
	var l TOPJ_INT32
	var l_data_size TOPJ_SIZE_T

	var l_cur_res uintptr = uintptr(0)
	var l_last_res uintptr = uintptr(0)
	var num_threads int32 = Xopj_thread_pool_get_thread_count(tls, tp)
	var tiledp uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata

	w = TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx1 - (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx0)
	l = TOPJ_INT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions) - 1

	l_cur_res = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(l)*192
	l_last_res = l_cur_res - uintptr(1)*192

	l_data_size = TOPJ_SIZE_T(opj_dwt_max_resolution(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions))
	// overflow check
	if uint64(l_data_size) > libc.Uint64(18446744073709551615)/uint64(uint32(DNB_ELTS_V8)*uint32(unsafe.Sizeof(TOPJ_INT32(0)))) {
		// FIXME event manager error callback
		return DOPJ_FALSE
	}
	l_data_size = l_data_size * (uint32(DNB_ELTS_V8) * uint32(unsafe.Sizeof(TOPJ_INT32(0))))
	bj = Xopj_aligned_32_malloc(tls, l_data_size)
	// l_data_size is equal to 0 when numresolutions == 1 but bj is not used
	// in that case, so do not error out
	if l_data_size != TOPJ_SIZE_T(0) && !(bj != 0) {
		return DOPJ_FALSE
	}
	i = l

	for libc.PostDecInt32(&i, 1) != 0 {
		var j TOPJ_UINT32
		var rw TOPJ_UINT32     // width of the resolution level computed
		var rh TOPJ_UINT32     // height of the resolution level computed
		var rw1 TOPJ_UINT32    // width of the resolution level once lower than computed one
		var rh1 TOPJ_UINT32    // height of the resolution level once lower than computed one
		var cas_col TOPJ_INT32 // 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering
		var cas_row TOPJ_INT32 // 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering
		var dn TOPJ_INT32
		var sn TOPJ_INT32

		rw = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_cur_res)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_cur_res)).Fx0)
		rh = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_cur_res)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_cur_res)).Fy0)
		rw1 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_last_res)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_last_res)).Fx0)
		rh1 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_last_res)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_last_res)).Fy0)

		cas_row = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_cur_res)).Fx0 & 1
		cas_col = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_cur_res)).Fy0 & 1

		sn = TOPJ_INT32(rh1)
		dn = TOPJ_INT32(rh - rh1)

		// Perform vertical pass
		if num_threads <= 1 || rw < TOPJ_UINT32(2*DNB_ELTS_V8) {
			for j = TOPJ_UINT32(0); j+TOPJ_UINT32(DNB_ELTS_V8)-TOPJ_UINT32(1) < rw; j = j + TOPJ_UINT32(DNB_ELTS_V8) {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL, TOPJ_UINT32, TOPJ_UINT32)
				})(unsafe.Pointer(&struct{ uintptr }{p_encode_and_deinterleave_v})).f(tls, tiledp+uintptr(j)*4,
					bj,
					rh,
					libc.Bool32(cas_col == 0),
					w,
					uint32(DNB_ELTS_V8))
			}
			if j < rw {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL, TOPJ_UINT32, TOPJ_UINT32)
				})(unsafe.Pointer(&struct{ uintptr }{p_encode_and_deinterleave_v})).f(tls, tiledp+uintptr(j)*4,
					bj,
					rh,
					libc.Bool32(cas_col == 0),
					w,
					rw-j)
			}
		} else {
			var num_jobs TOPJ_UINT32 = TOPJ_UINT32(num_threads)
			var step_j TOPJ_UINT32

			if rw < num_jobs {
				num_jobs = rw
			}
			step_j = rw / num_jobs / TOPJ_UINT32(DNB_ELTS_V8) * TOPJ_UINT32(DNB_ELTS_V8)

			for j = TOPJ_UINT32(0); j < num_jobs; j++ {
				var job uintptr

				job = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_dwt_encode_v_job_t{})))
				if !(job != 0) {
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_aligned_free(tls, bj)
					return DOPJ_FALSE
				}
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fmem = Xopj_aligned_32_malloc(tls, l_data_size)
				if !(int32((*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fmem) != 0) {
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_free(tls, job)
					Xopj_aligned_free(tls, bj)
					return DOPJ_FALSE
				}
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fdn = dn
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fsn = sn
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fv.Fcas = cas_col
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Frh = rh
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fw = w
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Ftiledp = tiledp
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fmin_j = j * step_j
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fmax_j = func() uint32 {
					if j+TOPJ_UINT32(1) == num_jobs {
						return rw
					}
					return (j + TOPJ_UINT32(1)) * step_j
				}()
				(*Topj_dwt_encode_v_job_t)(unsafe.Pointer(job)).Fp_encode_and_deinterleave_v = p_encode_and_deinterleave_v
				Xopj_thread_pool_submit_job(tls, tp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr)
				}{opj_dwt_encode_v_func})), job)
			}
			Xopj_thread_pool_wait_completion(tls, tp, 0)
		}

		sn = TOPJ_INT32(rw1)
		dn = TOPJ_INT32(rw - rw1)

		// Perform horizontal pass
		if num_threads <= 1 || rh <= TOPJ_UINT32(1) {
			for j = TOPJ_UINT32(0); j < rh; j++ {
				var aj uintptr = tiledp + uintptr(j*w)*4
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL)
				})(unsafe.Pointer(&struct{ uintptr }{p_encode_and_deinterleave_h_one_row})).f(tls, aj, bj, rw,
					func() int32 {
						if cas_row == 0 {
							return DOPJ_TRUE
						}
						return DOPJ_FALSE
					}())
			}
		} else {
			var num_jobs TOPJ_UINT32 = TOPJ_UINT32(num_threads)
			var step_j TOPJ_UINT32

			if rh < num_jobs {
				num_jobs = rh
			}
			step_j = rh / num_jobs

			for j = TOPJ_UINT32(0); j < num_jobs; j++ {
				var job uintptr

				job = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_dwt_encode_h_job_t{})))
				if !(job != 0) {
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_aligned_free(tls, bj)
					return DOPJ_FALSE
				}
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fh.Fmem = Xopj_aligned_32_malloc(tls, l_data_size)
				if !(int32((*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fh.Fmem) != 0) {
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_free(tls, job)
					Xopj_aligned_free(tls, bj)
					return DOPJ_FALSE
				}
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fh.Fdn = dn
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fh.Fsn = sn
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fh.Fcas = cas_row
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Frw = rw
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fw = w
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Ftiledp = tiledp
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fmin_j = j * step_j
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fmax_j = (j + 1) * step_j // this can overflow
				if j == num_jobs-1 {                                                      // this will take care of the overflow
					(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fmax_j = rh
				}
				(*Topj_dwt_encode_h_job_t)(unsafe.Pointer(job)).Fp_function = p_encode_and_deinterleave_h_one_row
				Xopj_thread_pool_submit_job(tls, tp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr)
				}{opj_dwt_encode_h_func})), job)
			}
			Xopj_thread_pool_wait_completion(tls, tp, 0)
		}

		l_cur_res = l_last_res

		l_last_res -= 192
	}

	Xopj_aligned_free(tls, bj)
	return DOPJ_TRUE
}

// Forward 5-3 wavelet transform in 2-D.
// </summary>
func Xopj_dwt_encode(tls *libc.TLS, p_tcd uintptr, tilec uintptr) TOPJ_BOOL { /* dwt.c:1907:10: */
	return opj_dwt_encode_procedure(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fthread_pool, tilec,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL, TOPJ_UINT32, TOPJ_UINT32)
		}{opj_dwt_encode_and_deinterleave_v})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL)
		}{opj_dwt_encode_and_deinterleave_h_one_row})))
}

// <summary>
// Inverse 5-3 wavelet transform in 2-D.
// </summary>
func Xopj_dwt_decode(tls *libc.TLS, p_tcd uintptr, tilec uintptr, numres TOPJ_UINT32) TOPJ_BOOL { /* dwt.c:1918:10: */
	if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
		return opj_dwt_decode_tile(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fthread_pool, tilec, numres)
	} else {
		return opj_dwt_decode_partial_tile(tls, tilec, numres)
	}
	return TOPJ_BOOL(0)
}

// <summary>
// Get norm of 5-3 wavelet.
// </summary>
func Xopj_dwt_getnorm(tls *libc.TLS, level TOPJ_UINT32, orient TOPJ_UINT32) TOPJ_FLOAT64 { /* dwt.c:1931:13: */
	// FIXME ! This is just a band-aid to avoid a buffer overflow
	// but the array should really be extended up to 33 resolution levels
	// See https://github.com/uclouvain/openjpeg/issues/493
	if orient == TOPJ_UINT32(0) && level >= TOPJ_UINT32(10) {
		level = TOPJ_UINT32(9)
	} else if orient > TOPJ_UINT32(0) && level >= TOPJ_UINT32(9) {
		level = TOPJ_UINT32(8)
	}
	return *(*TOPJ_FLOAT64)(unsafe.Pointer(uintptr(unsafe.Pointer(&opj_dwt_norms)) + uintptr(orient)*80 + uintptr(level)*8))
}

// <summary>
// Forward 9-7 wavelet transform in 2-D.
// </summary>
func Xopj_dwt_encode_real(tls *libc.TLS, p_tcd uintptr, tilec uintptr) TOPJ_BOOL { /* dwt.c:1947:10: */
	return opj_dwt_encode_procedure(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fthread_pool, tilec,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL, TOPJ_UINT32, TOPJ_UINT32)
		}{opj_dwt_encode_and_deinterleave_v_real})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, TOPJ_BOOL)
		}{opj_dwt_encode_and_deinterleave_h_one_row_real})))
}

// <summary>
// Get norm of 9-7 wavelet.
// </summary>
func Xopj_dwt_getnorm_real(tls *libc.TLS, level TOPJ_UINT32, orient TOPJ_UINT32) TOPJ_FLOAT64 { /* dwt.c:1958:13: */
	// FIXME ! This is just a band-aid to avoid a buffer overflow
	// but the array should really be extended up to 33 resolution levels
	// See https://github.com/uclouvain/openjpeg/issues/493
	if orient == TOPJ_UINT32(0) && level >= TOPJ_UINT32(10) {
		level = TOPJ_UINT32(9)
	} else if orient > TOPJ_UINT32(0) && level >= TOPJ_UINT32(9) {
		level = TOPJ_UINT32(8)
	}
	return *(*TOPJ_FLOAT64)(unsafe.Pointer(uintptr(unsafe.Pointer(&opj_dwt_norms_real)) + uintptr(orient)*80 + uintptr(level)*8))
}

func Xopj_dwt_calc_explicit_stepsizes(tls *libc.TLS, tccp uintptr, prec TOPJ_UINT32) { /* dwt.c:1971:6: */
	var numbands TOPJ_UINT32
	var bandno TOPJ_UINT32
	numbands = TOPJ_UINT32(3)*(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumresolutions - TOPJ_UINT32(2)
	for bandno = TOPJ_UINT32(0); bandno < numbands; bandno++ {
		var stepsize TOPJ_FLOAT64
		var resno TOPJ_UINT32
		var level TOPJ_UINT32
		var orient TOPJ_UINT32
		var gain TOPJ_UINT32

		if bandno == TOPJ_UINT32(0) {
			resno = uint32(0)
		} else {
			resno = (bandno-TOPJ_UINT32(1))/TOPJ_UINT32(3) + TOPJ_UINT32(1)
		}
		if bandno == TOPJ_UINT32(0) {
			orient = uint32(0)
		} else {
			orient = (bandno-TOPJ_UINT32(1))%TOPJ_UINT32(3) + TOPJ_UINT32(1)
		}
		level = (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumresolutions - TOPJ_UINT32(1) - resno
		if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fqmfbid == TOPJ_UINT32(0) {
			gain = uint32(0)
		} else {
			gain = func() uint32 {
				if orient == TOPJ_UINT32(0) {
					return uint32(0)
				}
				return func() uint32 {
					if orient == TOPJ_UINT32(1) || orient == TOPJ_UINT32(2) {
						return uint32(1)
					}
					return uint32(2)
				}()
			}()
		}
		if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_NOQNT) {
			stepsize = 1.0
		} else {
			var norm TOPJ_FLOAT64 = Xopj_dwt_getnorm_real(tls, level, orient)
			stepsize = float64(int32(1)<<gain) / norm
		}
		opj_dwt_encode_stepsize(tls, libc.Int32FromFloat64(libc.Xfloor(tls, stepsize*8192.0)),
			TOPJ_INT32(prec+gain), tccp+28+uintptr(bandno)*8)
	}
}

// <summary>
// Determine maximum computed resolution level for inverse wavelet transform
// </summary>
func opj_dwt_max_resolution(tls *libc.TLS, r uintptr, i TOPJ_UINT32) TOPJ_UINT32 { /* dwt.c:1998:19: */
	var mr TOPJ_UINT32 = TOPJ_UINT32(0)
	var w TOPJ_UINT32
	for libc.PreDecUint32(&i, 1) != 0 {
		r += 192
		if mr < libc.AssignUint32(&w, TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(r)).Fx1-(*Topj_tcd_resolution_t)(unsafe.Pointer(r)).Fx0)) {
			mr = w
		}
		if mr < libc.AssignUint32(&w, TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(r)).Fy1-(*Topj_tcd_resolution_t)(unsafe.Pointer(r)).Fy0)) {
			mr = w
		}
	}
	return mr
}

type Topj_dwt_decode_h_job_t = struct {
	Fh      Topj_dwt_t
	Frw     TOPJ_UINT32
	Fw      TOPJ_UINT32
	Ftiledp uintptr
	Fmin_j  TOPJ_UINT32
	Fmax_j  TOPJ_UINT32
} /* dwt.c:2022:3 */

func opj_dwt_decode_h_func(tls *libc.TLS, user_data uintptr, tls1 uintptr) { /* dwt.c:2024:13: */
	var j TOPJ_UINT32
	var job uintptr
	_ = tls1

	job = user_data
	for j = (*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fmin_j; j < (*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fmax_j; j++ {
		opj_idwt53_h(tls, job, (*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Ftiledp+uintptr(j*(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fw)*4)
	}

	Xopj_aligned_free(tls, (*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fmem)
	Xopj_free(tls, job)
}

type Topj_dwt_decode_v_job_t = struct {
	Fv      Topj_dwt_t
	Frh     TOPJ_UINT32
	Fw      TOPJ_UINT32
	Ftiledp uintptr
	Fmin_j  TOPJ_UINT32
	Fmax_j  TOPJ_UINT32
} /* dwt.c:2046:3 */

func opj_dwt_decode_v_func(tls *libc.TLS, user_data uintptr, tls1 uintptr) { /* dwt.c:2048:13: */
	var j TOPJ_UINT32
	var job uintptr
	_ = tls1

	job = user_data
	for j = (*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fmin_j; j+TOPJ_UINT32(2*DVREG_INT_COUNT) <= (*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fmax_j; j = j + TOPJ_UINT32(2*DVREG_INT_COUNT) {
		opj_idwt53_v(tls, job, (*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Ftiledp+uintptr(j)*4, TOPJ_SIZE_T((*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fw),
			2*DVREG_INT_COUNT)
	}
	if j < (*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fmax_j {
		opj_idwt53_v(tls, job, (*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Ftiledp+uintptr(j)*4, TOPJ_SIZE_T((*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fw),
			TOPJ_INT32((*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fmax_j-j))
	}

	Xopj_aligned_free(tls, (*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fmem)
	Xopj_free(tls, job)
}

// <summary>
// Inverse wavelet transform in 2-D.
// </summary>
func opj_dwt_decode_tile(tls *libc.TLS, tp uintptr, tilec uintptr, numres TOPJ_UINT32) TOPJ_BOOL { /* dwt.c:2072:17: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var h Topj_dwt_t at bp, 24

	// var v Topj_dwt_t at bp+24, 24

	var tr uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions

	var rw TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0) // width of the resolution level computed
	var rh TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0) // height of the resolution level computed

	var w TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx0)
	var h_mem_size TOPJ_SIZE_T
	var num_threads int32

	if numres == 1 {
		return DOPJ_TRUE
	}
	num_threads = Xopj_thread_pool_get_thread_count(tls, tp)
	h_mem_size = TOPJ_SIZE_T(opj_dwt_max_resolution(tls, tr, numres))
	// overflow check
	if uint64(h_mem_size) > libc.Uint64(18446744073709551615)/uint64(2*DVREG_INT_COUNT)/uint64(unsafe.Sizeof(TOPJ_INT32(0))) {
		// FIXME event manager error callback
		return DOPJ_FALSE
	}
	// We need PARALLEL_COLS_53 times the height of the array,
	// since for the vertical pass
	// we process PARALLEL_COLS_53 columns at a time
	h_mem_size = h_mem_size * (uint32(2*DVREG_INT_COUNT) * uint32(unsafe.Sizeof(TOPJ_INT32(0))))
	(*Topj_dwt_t)(unsafe.Pointer(bp /* &h */)).Fmem = Xopj_aligned_32_malloc(tls, h_mem_size)
	if !(int32((*Topj_dwt_t)(unsafe.Pointer(bp)).Fmem) != 0) {
		// FIXME event manager error callback
		return DOPJ_FALSE
	}

	(*Topj_dwt_t)(unsafe.Pointer(bp + 24 /* &v */)).Fmem = (*Topj_dwt_t)(unsafe.Pointer(bp /* &h */)).Fmem

	for libc.PreDecUint32(&numres, 1) != 0 {
		var tiledp uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata
		var j TOPJ_UINT32

		tr += 192
		(*Topj_dwt_t)(unsafe.Pointer(bp /* &h */)).Fsn = TOPJ_INT32(rw)
		(*Topj_dwt_t)(unsafe.Pointer(bp + 24 /* &v */)).Fsn = TOPJ_INT32(rh)

		rw = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0)
		rh = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0)

		(*Topj_dwt_t)(unsafe.Pointer(bp /* &h */)).Fdn = TOPJ_INT32(rw - TOPJ_UINT32((*Topj_dwt_t)(unsafe.Pointer(bp)).Fsn))
		(*Topj_dwt_t)(unsafe.Pointer(bp /* &h */)).Fcas = (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0 % 2

		if num_threads <= 1 || rh <= TOPJ_UINT32(1) {
			for j = TOPJ_UINT32(0); j < rh; j++ {
				opj_idwt53_h(tls, bp, tiledp+uintptr(TOPJ_SIZE_T(j)*TOPJ_SIZE_T(w))*4)
			}
		} else {
			var num_jobs TOPJ_UINT32 = TOPJ_UINT32(num_threads)
			var step_j TOPJ_UINT32

			if rh < num_jobs {
				num_jobs = rh
			}
			step_j = rh / num_jobs

			for j = TOPJ_UINT32(0); j < num_jobs; j++ {
				var job uintptr

				job = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_dwt_decode_h_job_t{})))
				if !(job != 0) {
					// It would be nice to fallback to single thread case, but
					// unfortunately some jobs may be launched and have modified
					// tiledp, so it is not practical to recover from that error
					// FIXME event manager error callback
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_aligned_free(tls, (*Topj_dwt_t)(unsafe.Pointer(bp /* &h */)).Fmem)
					return DOPJ_FALSE
				}
				(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fh = *(*Topj_dwt_t)(unsafe.Pointer(bp /* h */))
				(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Frw = rw
				(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fw = w
				(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Ftiledp = tiledp
				(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fmin_j = j * step_j
				(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fmax_j = (j + 1) * step_j // this can overflow
				if j == num_jobs-1 {                                                      // this will take care of the overflow
					(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fmax_j = rh
				}
				(*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fmem = Xopj_aligned_32_malloc(tls, h_mem_size)
				if !(int32((*Topj_dwt_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fmem) != 0) {
					// FIXME event manager error callback
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_free(tls, job)
					Xopj_aligned_free(tls, (*Topj_dwt_t)(unsafe.Pointer(bp /* &h */)).Fmem)
					return DOPJ_FALSE
				}
				Xopj_thread_pool_submit_job(tls, tp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr)
				}{opj_dwt_decode_h_func})), job)
			}
			Xopj_thread_pool_wait_completion(tls, tp, 0)
		}

		(*Topj_dwt_t)(unsafe.Pointer(bp + 24 /* &v */)).Fdn = TOPJ_INT32(rh - TOPJ_UINT32((*Topj_dwt_t)(unsafe.Pointer(bp+24)).Fsn))
		(*Topj_dwt_t)(unsafe.Pointer(bp + 24 /* &v */)).Fcas = (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0 % 2

		if num_threads <= 1 || rw <= TOPJ_UINT32(1) {
			for j = TOPJ_UINT32(0); j+TOPJ_UINT32(2*DVREG_INT_COUNT) <= rw; j = j + TOPJ_UINT32(2*DVREG_INT_COUNT) {
				opj_idwt53_v(tls, bp+24, tiledp+uintptr(j)*4, TOPJ_SIZE_T(w), 2*DVREG_INT_COUNT)
			}
			if j < rw {
				opj_idwt53_v(tls, bp+24, tiledp+uintptr(j)*4, TOPJ_SIZE_T(w), TOPJ_INT32(rw-j))
			}
		} else {
			var num_jobs TOPJ_UINT32 = TOPJ_UINT32(num_threads)
			var step_j TOPJ_UINT32

			if rw < num_jobs {
				num_jobs = rw
			}
			step_j = rw / num_jobs

			for j = TOPJ_UINT32(0); j < num_jobs; j++ {
				var job uintptr

				job = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_dwt_decode_v_job_t{})))
				if !(job != 0) {
					// It would be nice to fallback to single thread case, but
					// unfortunately some jobs may be launched and have modified
					// tiledp, so it is not practical to recover from that error
					// FIXME event manager error callback
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_aligned_free(tls, (*Topj_dwt_t)(unsafe.Pointer(bp+24 /* &v */)).Fmem)
					return DOPJ_FALSE
				}
				(*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fv = *(*Topj_dwt_t)(unsafe.Pointer(bp + 24 /* v */))
				(*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Frh = rh
				(*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fw = w
				(*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Ftiledp = tiledp
				(*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fmin_j = j * step_j
				(*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fmax_j = (j + 1) * step_j // this can overflow
				if j == num_jobs-1 {                                                      // this will take care of the overflow
					(*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fmax_j = rw
				}
				(*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fmem = Xopj_aligned_32_malloc(tls, h_mem_size)
				if !(int32((*Topj_dwt_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fmem) != 0) {
					// FIXME event manager error callback
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_free(tls, job)
					Xopj_aligned_free(tls, (*Topj_dwt_t)(unsafe.Pointer(bp+24 /* &v */)).Fmem)
					return DOPJ_FALSE
				}
				Xopj_thread_pool_submit_job(tls, tp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr)
				}{opj_dwt_decode_v_func})), job)
			}
			Xopj_thread_pool_wait_completion(tls, tp, 0)
		}
	}
	Xopj_aligned_free(tls, (*Topj_dwt_t)(unsafe.Pointer(bp /* &h */)).Fmem)
	return DOPJ_TRUE
}

func opj_dwt_interleave_partial_h(tls *libc.TLS, dest uintptr, cas TOPJ_INT32, sa uintptr, sa_line TOPJ_UINT32, sn TOPJ_UINT32, win_l_x0 TOPJ_UINT32, win_l_x1 TOPJ_UINT32, win_h_x0 TOPJ_UINT32, win_h_x1 TOPJ_UINT32) { /* dwt.c:2234:13: */
	var ret TOPJ_BOOL
	_ = ret
	ret = Xopj_sparse_array_int32_read(tls, sa,
		win_l_x0, sa_line,
		win_l_x1, sa_line+TOPJ_UINT32(1),
		dest+uintptr(cas)*4+uintptr(TOPJ_UINT32(2)*win_l_x0)*4,
		uint32(2), uint32(0), DOPJ_TRUE)
	if ret != 0 {
	} else {
		libc.X__assert_fail(tls, ts+1062, ts+856, uint32(2250), uintptr(unsafe.Pointer(&__func__26)))
	}
	ret = Xopj_sparse_array_int32_read(tls, sa,
		sn+win_h_x0, sa_line,
		sn+win_h_x1, sa_line+TOPJ_UINT32(1),
		dest+uintptr(1)*4-uintptr(cas)*4+uintptr(TOPJ_UINT32(2)*win_h_x0)*4,
		uint32(2), uint32(0), DOPJ_TRUE)
	if ret != 0 {
	} else {
		libc.X__assert_fail(tls, ts+1062, ts+856, uint32(2256), uintptr(unsafe.Pointer(&__func__26)))
	}
	_ = ret
}

var __func__26 = *(*[29]int8)(unsafe.Pointer(ts + 1066)) /* dwt.c:2243:1 */

func opj_dwt_interleave_partial_v(tls *libc.TLS, dest uintptr, cas TOPJ_INT32, sa uintptr, sa_col TOPJ_UINT32, nb_cols TOPJ_UINT32, sn TOPJ_UINT32, win_l_y0 TOPJ_UINT32, win_l_y1 TOPJ_UINT32, win_h_y0 TOPJ_UINT32, win_h_y1 TOPJ_UINT32) { /* dwt.c:2261:13: */
	var ret TOPJ_BOOL
	_ = ret
	ret = Xopj_sparse_array_int32_read(tls, sa,
		sa_col, win_l_y0,
		sa_col+nb_cols, win_l_y1,
		dest+uintptr(cas*4)*4+uintptr(TOPJ_UINT32(2*4)*win_l_y0)*4,
		uint32(1), uint32(2*4), DOPJ_TRUE)
	if ret != 0 {
	} else {
		libc.X__assert_fail(tls, ts+1062, ts+856, uint32(2278), uintptr(unsafe.Pointer(&__func__27)))
	}
	ret = Xopj_sparse_array_int32_read(tls, sa,
		sa_col, sn+win_h_y0,
		sa_col+nb_cols, sn+win_h_y1,
		dest+uintptr((1-cas)*4)*4+uintptr(TOPJ_UINT32(2*4)*win_h_y0)*4,
		uint32(1), uint32(2*4), DOPJ_TRUE)
	if ret != 0 {
	} else {
		libc.X__assert_fail(tls, ts+1062, ts+856, uint32(2284), uintptr(unsafe.Pointer(&__func__27)))
	}
	_ = ret
}

var __func__27 = *(*[29]int8)(unsafe.Pointer(ts + 1095)) /* dwt.c:2271:1 */

func opj_dwt_decode_partial_1(tls *libc.TLS, a uintptr, dn TOPJ_INT32, sn TOPJ_INT32, cas TOPJ_INT32, win_l_x0 TOPJ_INT32, win_l_x1 TOPJ_INT32, win_h_x0 TOPJ_INT32, win_h_x1 TOPJ_INT32) { /* dwt.c:2288:13: */
	var i TOPJ_INT32

	if !(cas != 0) {
		if dn > 0 || sn > 1 { // NEW :  CASE ONE ELEMENT

			// Naive version is :
			//             for (i = win_l_x0; i < i_max; i++) {
			//                 OPJ_S(i) -= (OPJ_D_(i - 1) + OPJ_D_(i) + 2) >> 2;
			//             }
			//             for (i = win_h_x0; i < win_h_x1; i++) {
			//                 OPJ_D(i) += (OPJ_S_(i) + OPJ_S_(i + 1)) >> 1;
			//             }
			//             but the compiler doesn't manage to unroll it to avoid bound
			//             checking in OPJ_S_ and OPJ_D_ macros
			//

			i = win_l_x0
			if i < win_l_x1 {
				var i_max TOPJ_INT32

				// Left-most case
				*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4)) -= (func() int32 {
					if i-1 < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
					}
					return func() int32 {
						if i-1 >= dn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(dn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(i-1)*2)*4))
					}()
				}() + func() int32 {
					if i < 0 {
						return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
					}
					return func() int32 {
						if i >= dn {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(dn-1)*2)*4))
						}
						return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4))
					}()
				}() + 2) >> 2
				i++

				i_max = win_l_x1
				if i_max > dn {
					i_max = dn
				}
				for ; i < i_max; i++ {
					// No bound checking
					*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4)) -= (*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(i-1)*2)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4)) + 2) >> 2
				}
				for ; i < win_l_x1; i++ {
					// Right-most case
					*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4)) -= (func() int32 {
						if i-1 < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
						}
						return func() int32 {
							if i-1 >= dn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(dn-1)*2)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(i-1)*2)*4))
						}()
					}() + func() int32 {
						if i < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
						}
						return func() int32 {
							if i >= dn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(dn-1)*2)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4))
						}()
					}() + 2) >> 2
				}
			}

			i = win_h_x0
			if i < win_h_x1 {
				var i_max TOPJ_INT32 = win_h_x1
				if i_max >= sn {
					i_max = sn - 1
				}
				for ; i < i_max; i++ {
					// No bound checking
					*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4)) += (*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((i+1)*2)*4))) >> 1
				}
				for ; i < win_h_x1; i++ {
					// Right-most case
					*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4)) += (func() int32 {
						if i < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a))
						}
						return func() int32 {
							if i >= sn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((sn-1)*2)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4))
						}()
					}() + func() int32 {
						if i+1 < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a))
						}
						return func() int32 {
							if i+1 >= sn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((sn-1)*2)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((i+1)*2)*4))
						}()
					}()) >> 1
				}
			}
		}
	} else {
		if !(sn != 0) && dn == 1 { // NEW :  CASE ONE ELEMENT
			*(*TOPJ_INT32)(unsafe.Pointer(a)) /= 2
		} else {
			for i = win_l_x0; i < win_l_x1; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4)) = opj_int_sub_no_overflow(tls, *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4)),
					opj_int_add_no_overflow(tls, opj_int_add_no_overflow(tls, func() int32 {
						if i < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a))
						}
						return func() int32 {
							if i >= dn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((dn-1)*2)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4))
						}()
					}(), func() int32 {
						if i+1 < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a))
						}
						return func() int32 {
							if i+1 >= dn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((dn-1)*2)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((i+1)*2)*4))
						}()
					}()),
						2)>>2)
			}
			for i = win_h_x0; i < win_h_x1; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4)) = opj_int_add_no_overflow(tls, *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(i*2)*4)),
					opj_int_add_no_overflow(tls, func() int32 {
						if i < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
						}
						return func() int32 {
							if i >= sn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(sn-1)*2)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+i*2)*4))
						}()
					}(), func() int32 {
						if i-1 < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + 1*4))
						}
						return func() int32 {
							if i-1 >= sn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(sn-1)*2)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(1+(i-1)*2)*4))
						}()
					}())>>1)
			}
		}
	}
}

func opj_dwt_decode_partial_1_parallel(tls *libc.TLS, a uintptr, nb_cols TOPJ_UINT32, dn TOPJ_INT32, sn TOPJ_INT32, cas TOPJ_INT32, win_l_x0 TOPJ_INT32, win_l_x1 TOPJ_INT32, win_h_x0 TOPJ_INT32, win_h_x1 TOPJ_INT32) { /* dwt.c:2373:13: */
	var i TOPJ_INT32
	var off TOPJ_UINT32

	_ = nb_cols

	if !(cas != 0) {
		if dn > 0 || sn > 1 { // NEW :  CASE ONE ELEMENT

			// Naive version is :
			//             for (i = win_l_x0; i < i_max; i++) {
			//                 OPJ_S(i) -= (OPJ_D_(i - 1) + OPJ_D_(i) + 2) >> 2;
			//             }
			//             for (i = win_h_x0; i < win_h_x1; i++) {
			//                 OPJ_D(i) += (OPJ_S_(i) + OPJ_S_(i + 1)) >> 1;
			//             }
			//             but the compiler doesn't manage to unroll it to avoid bound
			//             checking in OPJ_S_ and OPJ_D_ macros
			//

			i = win_l_x0
			if i < win_l_x1 {
				var i_max TOPJ_INT32

				// Left-most case
				for off = TOPJ_UINT32(0); off < TOPJ_UINT32(4); off++ {
					*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4)) -= (func() int32 {
						if i-1 < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(0)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
						}
						return func() int32 {
							if i-1 >= dn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(dn-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
						}()
					}() + func() int32 {
						if i < 0 {
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(0)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
						}
						return func() int32 {
							if i >= dn {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(dn-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}
							return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
						}()
					}() + 2) >> 2
				}
				i++

				i_max = win_l_x1
				if i_max > dn {
					i_max = dn
				}

				for ; i < i_max; i++ {
					// No bound checking
					for off = TOPJ_UINT32(0); off < TOPJ_UINT32(4); off++ {
						*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4)) -= (*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4)) + 2) >> 2
					}
				}
				for ; i < win_l_x1; i++ {
					// Right-most case
					for off = TOPJ_UINT32(0); off < TOPJ_UINT32(4); off++ {
						*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4)) -= (func() int32 {
							if i-1 < 0 {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(0)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}
							return func() int32 {
								if i-1 >= dn {
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(dn-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
								}
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}()
						}() + func() int32 {
							if i < 0 {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(0)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}
							return func() int32 {
								if i >= dn {
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(dn-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
								}
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}()
						}() + 2) >> 2
					}
				}
			}

			i = win_h_x0
			if i < win_h_x1 {
				var i_max TOPJ_INT32 = win_h_x1
				if i_max >= sn {
					i_max = sn - 1
				}

				for ; i < i_max; i++ {
					// No bound checking
					for off = TOPJ_UINT32(0); off < TOPJ_UINT32(4); off++ {
						*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4)) += (*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4)) + *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i+1)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))) >> 1
					}
				}
				for ; i < win_h_x1; i++ {
					// Right-most case
					for off = TOPJ_UINT32(0); off < TOPJ_UINT32(4); off++ {
						*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4)) += (func() int32 {
							if i < 0 {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(0)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
							}
							return func() int32 {
								if i >= sn {
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(sn-1)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
								}
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
							}()
						}() + func() int32 {
							if i+1 < 0 {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(0)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
							}
							return func() int32 {
								if i+1 >= sn {
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(sn-1)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
								}
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i+1)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
							}()
						}()) >> 1
					}
				}
			}
		}
	} else {
		if !(sn != 0) && dn == 1 { // NEW :  CASE ONE ELEMENT
			for off = TOPJ_UINT32(0); off < TOPJ_UINT32(4); off++ {
				*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(0)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4)) /= 2
			}
		} else {
			for i = win_l_x0; i < win_l_x1; i++ {
				for off = TOPJ_UINT32(0); off < TOPJ_UINT32(4); off++ {
					*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4)) = opj_int_sub_no_overflow(tls,
						*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4)),
						opj_int_add_no_overflow(tls,
							opj_int_add_no_overflow(tls, func() int32 {
								if i < 0 {
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(0)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
								}
								return func() int32 {
									if i >= dn {
										return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(dn-1)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
									}
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
								}()
							}(), func() int32 {
								if i+1 < 0 {
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(0)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
								}
								return func() int32 {
									if i+1 >= dn {
										return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(dn-1)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
									}
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i+1)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4))
								}()
							}()), 2)>>2)
				}
			}
			for i = win_h_x0; i < win_h_x1; i++ {
				for off = TOPJ_UINT32(0); off < TOPJ_UINT32(4); off++ {
					*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4)) = opj_int_add_no_overflow(tls,
						*(*TOPJ_INT32)(unsafe.Pointer(a + uintptr(TOPJ_UINT32(i)*TOPJ_UINT32(2)*TOPJ_UINT32(4)+off)*4)),
						opj_int_add_no_overflow(tls, func() int32 {
							if i < 0 {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(0)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}
							return func() int32 {
								if i >= sn {
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(sn-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
								}
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}()
						}(), func() int32 {
							if i-1 < 0 {
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(0)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}
							return func() int32 {
								if i-1 >= sn {
									return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(sn-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
								}
								return *(*TOPJ_INT32)(unsafe.Pointer(a + uintptr((TOPJ_UINT32(1)+TOPJ_UINT32(i-1)*TOPJ_UINT32(2))*TOPJ_UINT32(4)+off)*4))
							}()
						}())>>1)
				}
			}
		}
	}
}

func opj_dwt_get_band_coordinates(tls *libc.TLS, tilec uintptr, resno TOPJ_UINT32, bandno TOPJ_UINT32, tcx0 TOPJ_UINT32, tcy0 TOPJ_UINT32, tcx1 TOPJ_UINT32, tcy1 TOPJ_UINT32, tbx0 uintptr, tby0 uintptr, tbx1 uintptr, tby1 uintptr) { /* dwt.c:2515:13: */
	// Compute number of decomposition for this band. See table F-1
	var nb TOPJ_UINT32
	if resno == TOPJ_UINT32(0) {
		nb = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions - TOPJ_UINT32(1)
	} else {
		nb = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions - resno
	}
	// Map above tile-based coordinates to sub-band-based coordinates per
	// equation B-15 of the standard
	var x0b TOPJ_UINT32 = bandno & TOPJ_UINT32(1)
	var y0b TOPJ_UINT32 = bandno >> 1
	if tbx0 != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(tbx0)) = func() uint32 {
			if nb == TOPJ_UINT32(0) {
				return tcx0
			}
			return func() uint32 {
				if tcx0 <= uint32(1)<<(nb-TOPJ_UINT32(1))*x0b {
					return uint32(0)
				}
				return opj_uint_ceildivpow2(tls, tcx0-uint32(1)<<(nb-TOPJ_UINT32(1))*x0b, nb)
			}()
		}()
	}
	if tby0 != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(tby0)) = func() uint32 {
			if nb == TOPJ_UINT32(0) {
				return tcy0
			}
			return func() uint32 {
				if tcy0 <= uint32(1)<<(nb-TOPJ_UINT32(1))*y0b {
					return uint32(0)
				}
				return opj_uint_ceildivpow2(tls, tcy0-uint32(1)<<(nb-TOPJ_UINT32(1))*y0b, nb)
			}()
		}()
	}
	if tbx1 != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(tbx1)) = func() uint32 {
			if nb == TOPJ_UINT32(0) {
				return tcx1
			}
			return func() uint32 {
				if tcx1 <= uint32(1)<<(nb-TOPJ_UINT32(1))*x0b {
					return uint32(0)
				}
				return opj_uint_ceildivpow2(tls, tcx1-uint32(1)<<(nb-TOPJ_UINT32(1))*x0b, nb)
			}()
		}()
	}
	if tby1 != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(tby1)) = func() uint32 {
			if nb == TOPJ_UINT32(0) {
				return tcy1
			}
			return func() uint32 {
				if tcy1 <= uint32(1)<<(nb-TOPJ_UINT32(1))*y0b {
					return uint32(0)
				}
				return opj_uint_ceildivpow2(tls, tcy1-uint32(1)<<(nb-TOPJ_UINT32(1))*y0b, nb)
			}()
		}()
	}
}

func opj_dwt_segment_grow(tls *libc.TLS, filter_width TOPJ_UINT32, max_size TOPJ_UINT32, start uintptr, end uintptr) { /* dwt.c:2557:13: */
	*(*TOPJ_UINT32)(unsafe.Pointer(start)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(start)), filter_width)
	*(*TOPJ_UINT32)(unsafe.Pointer(end)) = opj_uint_adds(tls, *(*TOPJ_UINT32)(unsafe.Pointer(end)), filter_width)
	*(*TOPJ_UINT32)(unsafe.Pointer(end)) = opj_uint_min(tls, *(*TOPJ_UINT32)(unsafe.Pointer(end)), max_size)
}

func opj_dwt_init_sparse_array(tls *libc.TLS, tilec uintptr, numres TOPJ_UINT32) uintptr { /* dwt.c:2568:32: */
	var tr_max uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(numres-TOPJ_UINT32(1))*192
	var w TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0)
	var h TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0)
	var resno TOPJ_UINT32
	var bandno TOPJ_UINT32
	var precno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var sa uintptr = Xopj_sparse_array_int32_create(tls,
		w, h, opj_uint_min(tls, w, uint32(64)), opj_uint_min(tls, h, uint32(64)))
	if sa == uintptr(0) {
		return uintptr(0)
	}

	for resno = TOPJ_UINT32(0); resno < numres; resno++ {
		var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno)*192

		for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands; bandno++ {
			var band uintptr = res + 32 + uintptr(bandno)*48

			for precno = TOPJ_UINT32(0); precno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph; precno++ {
				var precinct uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56
				for cblkno = TOPJ_UINT32(0); cblkno < (*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fcw*(*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fch; cblkno++ {
					var cblk uintptr = *(*uintptr)(unsafe.Pointer(precinct + 24)) + uintptr(cblkno)*80
					if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != uintptr(0) {
						var x TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0 - (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fx0)
						var y TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0 - (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fy0)
						var cblk_w TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx1 - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0)
						var cblk_h TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy1 - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0)

						if (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno&TOPJ_UINT32(1) != 0 {
							var pres uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno-TOPJ_UINT32(1))*192
							x = x + TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fx1-(*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fx0)
						}
						if (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno&TOPJ_UINT32(2) != 0 {
							var pres uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno-TOPJ_UINT32(1))*192
							y = y + TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fy1-(*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fy0)
						}

						if !(Xopj_sparse_array_int32_write(tls, sa, x, y,
							x+cblk_w, y+cblk_h,
							(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data,
							uint32(1), cblk_w, DOPJ_TRUE) != 0) {
							Xopj_sparse_array_int32_free(tls, sa)
							return uintptr(0)
						}
					}
				}
			}
		}
	}

	return sa
}

func opj_dwt_decode_partial_tile(tls *libc.TLS, tilec uintptr, numres TOPJ_UINT32) TOPJ_BOOL { /* dwt.c:2624:17: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var sa uintptr
	var h Topj_dwt_t
	var v Topj_dwt_t
	var resno TOPJ_UINT32
	// This value matches the maximum left/right extension given in tables
	// F.2 and F.3 of the standard.
	var filter_width TOPJ_UINT32 = 2

	var tr uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions
	var tr_max uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(numres-TOPJ_UINT32(1))*192

	var rw TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0) // width of the resolution level computed
	var rh TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0) // height of the resolution level computed

	var h_mem_size TOPJ_SIZE_T

	// Compute the intersection of the area of interest, expressed in tile coordinates
	// with the tile coordinates
	var win_tcx0 TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x0
	var win_tcy0 TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y0
	var win_tcx1 TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x1
	var win_tcy1 TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y1

	if (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0 == (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx1 || (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0 == (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy1 {
		return DOPJ_TRUE
	}

	sa = opj_dwt_init_sparse_array(tls, tilec, numres)
	if sa == uintptr(0) {
		return DOPJ_FALSE
	}

	if numres == 1 {
		var ret TOPJ_BOOL = Xopj_sparse_array_int32_read(tls, sa,
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x0-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_y0-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x1-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_y1-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0),
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_win,
			uint32(1), (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x1-(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x0,
			DOPJ_TRUE)
		_ = ret
		if ret != 0 {
		} else {
			libc.X__assert_fail(tls, ts+1062, ts+856, uint32(2671), uintptr(unsafe.Pointer(&__func__28)))
		}
		_ = ret
		Xopj_sparse_array_int32_free(tls, sa)
		return DOPJ_TRUE
	}
	h_mem_size = TOPJ_SIZE_T(opj_dwt_max_resolution(tls, tr, numres))
	// overflow check
	// in vertical pass, we process 4 columns at a time
	if uint64(h_mem_size) > libc.Uint64(18446744073709551615)/uint64(uint32(4)*uint32(unsafe.Sizeof(TOPJ_INT32(0)))) {
		// FIXME event manager error callback
		Xopj_sparse_array_int32_free(tls, sa)
		return DOPJ_FALSE
	}

	h_mem_size = h_mem_size * (uint32(4) * uint32(unsafe.Sizeof(TOPJ_INT32(0))))
	h.Fmem = Xopj_aligned_32_malloc(tls, h_mem_size)
	if !(int32(h.Fmem) != 0) {
		// FIXME event manager error callback
		Xopj_sparse_array_int32_free(tls, sa)
		return DOPJ_FALSE
	}

	v.Fmem = h.Fmem

	for resno = TOPJ_UINT32(1); resno < numres; resno++ {
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		// Window of interest subband-based coordinates
		// var win_ll_x0 TOPJ_UINT32 at bp, 4

		// var win_ll_y0 TOPJ_UINT32 at bp+4, 4

		// var win_ll_x1 TOPJ_UINT32 at bp+8, 4

		// var win_ll_y1 TOPJ_UINT32 at bp+12, 4

		// var win_hl_x0 TOPJ_UINT32 at bp+16, 4

		// var win_hl_x1 TOPJ_UINT32 at bp+20, 4

		// var win_lh_y0 TOPJ_UINT32 at bp+24, 4

		// var win_lh_y1 TOPJ_UINT32 at bp+28, 4

		// Window of interest tile-resolution-based coordinates
		var win_tr_x0 TOPJ_UINT32
		var win_tr_x1 TOPJ_UINT32
		var win_tr_y0 TOPJ_UINT32
		var win_tr_y1 TOPJ_UINT32
		// Tile-resolution subband-based coordinates
		var tr_ll_x0 TOPJ_UINT32
		var tr_ll_y0 TOPJ_UINT32
		var tr_hl_x0 TOPJ_UINT32
		var tr_lh_y0 TOPJ_UINT32

		tr += 192

		h.Fsn = TOPJ_INT32(rw)
		v.Fsn = TOPJ_INT32(rh)

		rw = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0)
		rh = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0)

		h.Fdn = TOPJ_INT32(rw - TOPJ_UINT32(h.Fsn))
		h.Fcas = (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0 % 2

		v.Fdn = TOPJ_INT32(rh - TOPJ_UINT32(v.Fsn))
		v.Fcas = (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0 % 2

		// Get the subband coordinates for the window of interest
		// LL band
		opj_dwt_get_band_coordinates(tls, tilec, resno, uint32(0),
			win_tcx0, win_tcy0, win_tcx1, win_tcy1,
			bp, bp+4,
			bp+8, bp+12)

		// HL band
		opj_dwt_get_band_coordinates(tls, tilec, resno, uint32(1),
			win_tcx0, win_tcy0, win_tcx1, win_tcy1,
			bp+16, uintptr(0), bp+20, uintptr(0))

		// LH band
		opj_dwt_get_band_coordinates(tls, tilec, resno, uint32(2),
			win_tcx0, win_tcy0, win_tcx1, win_tcy1,
			uintptr(0), bp+24, uintptr(0), bp+28)

		// Beware: band index for non-LL0 resolution are 0=HL, 1=LH and 2=HH
		tr_ll_x0 = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(tr + 32 + 1*48)).Fx0)
		tr_ll_y0 = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(tr + 32)).Fy0)
		tr_hl_x0 = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(tr + 32)).Fx0)
		tr_lh_y0 = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(tr + 32 + 1*48)).Fy0)

		// Subtract the origin of the bands for this tile, to the subwindow
		// of interest band coordinates, so as to get them relative to the
		// tile
		*(*TOPJ_UINT32)(unsafe.Pointer(bp /* win_ll_x0 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp /* win_ll_x0 */)), tr_ll_x0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* win_ll_y0 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* win_ll_y0 */)), tr_ll_y0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* win_ll_x1 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* win_ll_x1 */)), tr_ll_x0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* win_ll_y1 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* win_ll_y1 */)), tr_ll_y0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* win_hl_x0 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* win_hl_x0 */)), tr_hl_x0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* win_hl_x1 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* win_hl_x1 */)), tr_hl_x0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* win_lh_y0 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* win_lh_y0 */)), tr_lh_y0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* win_lh_y1 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* win_lh_y1 */)), tr_lh_y0)

		opj_dwt_segment_grow(tls, filter_width, TOPJ_UINT32(h.Fsn), bp, bp+8)
		opj_dwt_segment_grow(tls, filter_width, TOPJ_UINT32(h.Fdn), bp+16, bp+20)

		opj_dwt_segment_grow(tls, filter_width, TOPJ_UINT32(v.Fsn), bp+4, bp+12)
		opj_dwt_segment_grow(tls, filter_width, TOPJ_UINT32(v.Fdn), bp+24, bp+28)

		// Compute the tile-resolution-based coordinates for the window of interest
		if h.Fcas == 0 {
			win_tr_x0 = opj_uint_min(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 16))+TOPJ_UINT32(1))
			win_tr_x1 = opj_uint_min(tls, opj_uint_max(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 20))+TOPJ_UINT32(1)), rw)
		} else {
			win_tr_x0 = opj_uint_min(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp))+TOPJ_UINT32(1))
			win_tr_x1 = opj_uint_min(tls, opj_uint_max(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 20)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 8))+TOPJ_UINT32(1)), rw)
		}

		if v.Fcas == 0 {
			win_tr_y0 = opj_uint_min(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 24))+TOPJ_UINT32(1))
			win_tr_y1 = opj_uint_min(tls, opj_uint_max(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 28))+TOPJ_UINT32(1)), rh)
		} else {
			win_tr_y0 = opj_uint_min(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))+TOPJ_UINT32(1))
			win_tr_y1 = opj_uint_min(tls, opj_uint_max(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 28)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))+TOPJ_UINT32(1)), rh)
		}

		for j = TOPJ_UINT32(0); j < rh; j++ {
			if j >= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) && j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) || j >= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24))+TOPJ_UINT32(v.Fsn) && j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28))+TOPJ_UINT32(v.Fsn) {

				// Avoids dwt.c:1584:44 (in opj_dwt_decode_partial_1): runtime error:
				// signed integer overflow: -1094795586 + -1094795586 cannot be represented in type 'int'
				// on opj_decompress -i  ../../openjpeg/MAPA.jp2 -o out.tif -d 0,0,256,256
				// This is less extreme than memsetting the whole buffer to 0
				// although we could potentially do better with better handling of edge conditions
				if win_tr_x1 >= TOPJ_UINT32(1) && win_tr_x1 < rw {
					*(*TOPJ_INT32)(unsafe.Pointer(h.Fmem + uintptr(win_tr_x1-TOPJ_UINT32(1))*4)) = 0
				}
				if win_tr_x1 < rw {
					*(*TOPJ_INT32)(unsafe.Pointer(h.Fmem + uintptr(win_tr_x1)*4)) = 0
				}

				opj_dwt_interleave_partial_h(tls, h.Fmem,
					h.Fcas,
					sa,
					j,
					TOPJ_UINT32(h.Fsn),
					*(*TOPJ_UINT32)(unsafe.Pointer(bp /* win_ll_x0 */)),
					*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* win_ll_x1 */)),
					*(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* win_hl_x0 */)),
					*(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* win_hl_x1 */)))
				opj_dwt_decode_partial_1(tls, h.Fmem, h.Fdn, h.Fsn, h.Fcas,
					TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* win_ll_x0 */))),
					TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* win_ll_x1 */))),
					TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* win_hl_x0 */))),
					TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* win_hl_x1 */))))
				if !(Xopj_sparse_array_int32_write(tls, sa,
					win_tr_x0, j,
					win_tr_x1, j+TOPJ_UINT32(1),
					h.Fmem+uintptr(win_tr_x0)*4,
					uint32(1), uint32(0), DOPJ_TRUE) != 0) {
					// FIXME event manager error callback
					Xopj_sparse_array_int32_free(tls, sa)
					Xopj_aligned_free(tls, h.Fmem)
					return DOPJ_FALSE
				}
			}
		}

		for i = win_tr_x0; i < win_tr_x1; {
			var nb_cols TOPJ_UINT32 = opj_uint_min(tls, 4, win_tr_x1-i)
			opj_dwt_interleave_partial_v(tls, v.Fmem,
				v.Fcas,
				sa,
				i,
				nb_cols,
				TOPJ_UINT32(v.Fsn),
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* win_ll_y0 */)),
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* win_ll_y1 */)),
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* win_lh_y0 */)),
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* win_lh_y1 */)))
			opj_dwt_decode_partial_1_parallel(tls, v.Fmem, nb_cols, v.Fdn, v.Fsn, v.Fcas,
				TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* win_ll_y0 */))),
				TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* win_ll_y1 */))),
				TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* win_lh_y0 */))),
				TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* win_lh_y1 */))))
			if !(Xopj_sparse_array_int32_write(tls, sa,
				i, win_tr_y0,
				i+nb_cols, win_tr_y1,
				v.Fmem+uintptr(TOPJ_UINT32(4)*win_tr_y0)*4,
				uint32(1), uint32(4), DOPJ_TRUE) != 0) {
				// FIXME event manager error callback
				Xopj_sparse_array_int32_free(tls, sa)
				Xopj_aligned_free(tls, h.Fmem)
				return DOPJ_FALSE
			}

			i = i + nb_cols
		}
	}
	Xopj_aligned_free(tls, h.Fmem)

	{
		var ret TOPJ_BOOL = Xopj_sparse_array_int32_read(tls, sa,
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x0-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_y0-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x1-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_y1-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0),
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_win,
			uint32(1), (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x1-(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x0,
			DOPJ_TRUE)
		_ = ret
		if ret != 0 {
		} else {
			libc.X__assert_fail(tls, ts+1062, ts+856, uint32(2863), uintptr(unsafe.Pointer(&__func__28)))
		}
		_ = ret

	}
	Xopj_sparse_array_int32_free(tls, sa)
	return DOPJ_TRUE
}

var __func__28 = *(*[28]int8)(unsafe.Pointer(ts + 1124)) /* dwt.c:2627:1 */

func opj_v8dwt_interleave_h(tls *libc.TLS, dwt uintptr, a uintptr, width TOPJ_UINT32, remaining_height TOPJ_UINT32) { /* dwt.c:2870:13: */
	var bi uintptr = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet + uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas)*32
	var i TOPJ_UINT32
	var k TOPJ_UINT32
	var x0 TOPJ_UINT32 = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0
	var x1 TOPJ_UINT32 = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x1

	for k = TOPJ_UINT32(0); k < TOPJ_UINT32(2); k++ {
		if remaining_height >= TOPJ_UINT32(DNB_ELTS_V8) && TOPJ_SIZE_T(a)&TOPJ_SIZE_T(0x0f) == TOPJ_SIZE_T(0) && TOPJ_SIZE_T(bi)&TOPJ_SIZE_T(0x0f) == TOPJ_SIZE_T(0) {
			// Fast code path
			for i = x0; i < x1; i++ {
				var j TOPJ_UINT32 = i
				var dst uintptr = bi + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8))*4
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 1*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 2*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 3*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 4*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 5*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 6*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 7*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
			}
		} else {
			// Slow code path
			for i = x0; i < x1; i++ {
				var j TOPJ_UINT32 = i
				var dst uintptr = bi + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(DNB_ELTS_V8))*4
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				if remaining_height == TOPJ_UINT32(1) {
					continue
				}
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 1*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				if remaining_height == TOPJ_UINT32(2) {
					continue
				}
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 2*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				if remaining_height == TOPJ_UINT32(3) {
					continue
				}
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 3*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				if remaining_height == TOPJ_UINT32(4) {
					continue
				}
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 4*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				if remaining_height == TOPJ_UINT32(5) {
					continue
				}
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 5*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				if remaining_height == TOPJ_UINT32(6) {
					continue
				}
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 6*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
				j = j + width
				if remaining_height == TOPJ_UINT32(7) {
					continue
				}
				*(*TOPJ_FLOAT32)(unsafe.Pointer(dst + 7*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(a + uintptr(j)*4))
			}
		}

		bi = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet + uintptr(1)*32 - uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas)*32
		a += 4 * uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn)
		x0 = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0
		x1 = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x1
	}
}

func opj_v8dwt_interleave_partial_h(tls *libc.TLS, dwt uintptr, sa uintptr, sa_line TOPJ_UINT32, remaining_height TOPJ_UINT32) { /* dwt.c:2954:13: */
	var i TOPJ_UINT32
	for i = TOPJ_UINT32(0); i < remaining_height; i++ {
		var ret TOPJ_BOOL
		_ = ret
		ret = Xopj_sparse_array_int32_read(tls, sa,
			(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0, sa_line+i,
			(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x1, sa_line+i+TOPJ_UINT32(1),

			(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas)*32+uintptr(TOPJ_UINT32(2)*(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0)*32+uintptr(i)*4,
			uint32(2*DNB_ELTS_V8), uint32(0), DOPJ_TRUE)
		if ret != 0 {
		} else {
			libc.X__assert_fail(tls, ts+1062, ts+856, uint32(2968), uintptr(unsafe.Pointer(&__func__29)))
		}
		ret = Xopj_sparse_array_int32_read(tls, sa,
			TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn)+(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0, sa_line+i,
			TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn)+(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x1, sa_line+i+TOPJ_UINT32(1),

			(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(1)*32-uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas)*32+uintptr(TOPJ_UINT32(2)*(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0)*32+uintptr(i)*4,
			uint32(2*DNB_ELTS_V8), uint32(0), DOPJ_TRUE)
		if ret != 0 {
		} else {
			libc.X__assert_fail(tls, ts+1062, ts+856, uint32(2975), uintptr(unsafe.Pointer(&__func__29)))
		}
		_ = ret
	}
}

var __func__29 = *(*[31]int8)(unsafe.Pointer(ts + 1152)) /* dwt.c:2958:1 */

func opj_v8dwt_interleave_v(tls *libc.TLS, dwt uintptr, a uintptr, width TOPJ_UINT32, nb_elts_read TOPJ_UINT32) { /* dwt.c:2980:20: */
	var bi uintptr = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet + uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas)*32
	var i TOPJ_UINT32

	for i = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0; i < (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x1; i++ {
		libc.Xmemcpy(tls, bi+uintptr(i*TOPJ_UINT32(2))*32, a+uintptr(TOPJ_SIZE_T(i)*TOPJ_SIZE_T(width))*4,
			TOPJ_SIZE_T(nb_elts_read)*TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_FLOAT32(0))))
	}

	a += 4 * uintptr(TOPJ_SIZE_T(TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn))*TOPJ_SIZE_T(width))
	bi = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet + uintptr(1)*32 - uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas)*32

	for i = (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0; i < (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x1; i++ {
		libc.Xmemcpy(tls, bi+uintptr(i*TOPJ_UINT32(2))*32, a+uintptr(TOPJ_SIZE_T(i)*TOPJ_SIZE_T(width))*4,
			TOPJ_SIZE_T(nb_elts_read)*TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_FLOAT32(0))))
	}
}

func opj_v8dwt_interleave_partial_v(tls *libc.TLS, dwt uintptr, sa uintptr, sa_col TOPJ_UINT32, nb_elts_read TOPJ_UINT32) { /* dwt.c:3002:13: */
	var ret TOPJ_BOOL
	_ = ret
	ret = Xopj_sparse_array_int32_read(tls, sa,
		sa_col, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0,
		sa_col+nb_elts_read, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x1,
		(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas)*32+uintptr(TOPJ_UINT32(2)*(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0)*32,
		uint32(1), uint32(2*DNB_ELTS_V8), DOPJ_TRUE)
	if ret != 0 {
	} else {
		libc.X__assert_fail(tls, ts+1062, ts+856, uint32(3013), uintptr(unsafe.Pointer(&__func__30)))
	}
	ret = Xopj_sparse_array_int32_read(tls, sa,
		sa_col, TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn)+(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0,
		sa_col+nb_elts_read, TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn)+(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x1,
		(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(1)*32-uintptr((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas)*32+uintptr(TOPJ_UINT32(2)*(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0)*32,
		uint32(1), uint32(2*DNB_ELTS_V8), DOPJ_TRUE)
	if ret != 0 {
	} else {
		libc.X__assert_fail(tls, ts+1062, ts+856, uint32(3019), uintptr(unsafe.Pointer(&__func__30)))
	}
	_ = ret
}

var __func__30 = *(*[31]int8)(unsafe.Pointer(ts + 1183)) /* dwt.c:3006:1 */

func opj_v8dwt_decode_step1(tls *libc.TLS, w uintptr, start TOPJ_UINT32, end TOPJ_UINT32, c TOPJ_FLOAT32) { /* dwt.c:3080:13: */
	var fw uintptr = w
	var i TOPJ_UINT32
	// To be adapted if NB_ELTS_V8 changes
	for i = start; i < end; i++ {
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8))*4)) * c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(1))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(1))*4)) * c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(2))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(2))*4)) * c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(3))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(3))*4)) * c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(4))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(4))*4)) * c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(5))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(5))*4)) * c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(6))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(6))*4)) * c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(7))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + uintptr(i*TOPJ_UINT32(2)*TOPJ_UINT32(8)+TOPJ_UINT32(7))*4)) * c
	}
}

func opj_v8dwt_decode_step2(tls *libc.TLS, l uintptr, w uintptr, start TOPJ_UINT32, end TOPJ_UINT32, m TOPJ_UINT32, c TOPJ_FLOAT32) { /* dwt.c:3100:13: */
	var fl uintptr = l
	var fw uintptr = w
	var i TOPJ_UINT32
	var imax TOPJ_UINT32 = opj_uint_min(tls, end, m)
	if start > TOPJ_UINT32(0) {
		fw += 4 * uintptr(TOPJ_UINT32(2*DNB_ELTS_V8)*start)
		fl = fw - uintptr(2*DNB_ELTS_V8)*4
	}
	// To be adapted if NB_ELTS_V8 changes
	for i = start; i < imax; i++ {
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-8)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-8)*4)) + (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl))+*(*TOPJ_FLOAT32)(unsafe.Pointer(fw)))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-7)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-7)*4)) + (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 1*4))+*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 1*4)))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-6)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-6)*4)) + (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 2*4))+*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 2*4)))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-5)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-5)*4)) + (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 3*4))+*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 3*4)))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-4)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-4)*4)) + (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 4*4))+*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 4*4)))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-3)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-3)*4)) + (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 5*4))+*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 5*4)))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-2)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-2)*4)) + (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 6*4))+*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 6*4)))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-1)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-1)*4)) + (*(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 7*4))+*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + 7*4)))*c
		fl = fw
		fw += 4 * uintptr(2*DNB_ELTS_V8)
	}
	if m < end {
		if m+TOPJ_UINT32(1) == end {
		} else {
			libc.X__assert_fail(tls, ts+971, ts+856, uint32(3128), uintptr(unsafe.Pointer(&__func__31)))
		}
		c = c + c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-8)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-8)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fl))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-7)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-7)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 1*4))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-6)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-6)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 2*4))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-5)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-5)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 3*4))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-4)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-4)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 4*4))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-3)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-3)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 5*4))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-2)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-2)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 6*4))*c
		*(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-1)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(fw + libc.UintptrFromInt32(-1)*4)) + *(*TOPJ_FLOAT32)(unsafe.Pointer(fl + 7*4))*c
	}
}

var __func__31 = *(*[23]int8)(unsafe.Pointer(ts + 1214)) /* dwt.c:3105:1 */

// <summary>
// Inverse 9-7 wavelet transform in 1-D.
// </summary>
func opj_v8dwt_decode(tls *libc.TLS, dwt uintptr) { /* dwt.c:3146:13: */
	var a TOPJ_INT32
	var b TOPJ_INT32
	// BUG_WEIRD_TWO_INVK (look for this identifier in tcd.c)
	// Historic value for 2 / opj_invK
	// Normally, we should use invK, but if we do so, we have failures in the
	// conformance test, due to MSE and peak errors significantly higher than
	// accepted value
	// Due to using two_invK instead of invK, we have to compensate in tcd.c
	// the computation of the stepsize for the non LL subbands
	var two_invK float32 = 1.625732422
	if (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fcas == 0 {
		if !((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fdn > 0 || (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn > 1) {
			return
		}
		a = 0
		b = 1
	} else {
		if !((*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn > 0 || (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fdn > 1) {
			return
		}
		a = 1
		b = 0
	}
	opj_v8dwt_decode_step1(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(a)*32, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x1,
		opj_K)
	opj_v8dwt_decode_step1(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(b)*32, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x1,
		two_invK)
	opj_v8dwt_decode_step2(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(b)*32, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(a)*32+uintptr(1)*32,
		(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x1,
		TOPJ_UINT32(opj_int_min(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fdn-a)),
		-opj_dwt_delta)
	opj_v8dwt_decode_step2(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(a)*32, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(b)*32+uintptr(1)*32,
		(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x1,
		TOPJ_UINT32(opj_int_min(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fdn, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn-b)),
		-opj_dwt_gamma)
	opj_v8dwt_decode_step2(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(b)*32, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(a)*32+uintptr(1)*32,
		(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x0, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_l_x1,
		TOPJ_UINT32(opj_int_min(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fdn-a)),
		-opj_dwt_beta)
	opj_v8dwt_decode_step2(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(a)*32, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwavelet+uintptr(b)*32+uintptr(1)*32,
		(*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x0, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fwin_h_x1,
		TOPJ_UINT32(opj_int_min(tls, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fdn, (*Topj_v8dwt_t)(unsafe.Pointer(dwt)).Fsn-b)),
		-opj_dwt_alpha)
}

type Topj_dwt97_decode_h_job_t = struct {
	Fh           Topj_v8dwt_t
	Frw          TOPJ_UINT32
	Fw           TOPJ_UINT32
	Faj          uintptr
	Fnb_rows     TOPJ_UINT32
	F__ccgo_pad1 [4]byte
} /* dwt.c:3221:3 */

func opj_dwt97_decode_h_func(tls *libc.TLS, user_data uintptr, tls1 uintptr) { /* dwt.c:3223:13: */
	var j TOPJ_UINT32
	var job uintptr
	var aj uintptr
	var w TOPJ_UINT32
	_ = tls1

	job = user_data
	w = (*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fw

	if (*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fnb_rows%TOPJ_UINT32(DNB_ELTS_V8) == TOPJ_UINT32(0) {
	} else {
		libc.X__assert_fail(tls, ts+1237, ts+856, uint32(3234), uintptr(unsafe.Pointer(&__func__32)))
	}

	aj = (*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Faj
	for j = TOPJ_UINT32(0); j+TOPJ_UINT32(DNB_ELTS_V8) <= (*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fnb_rows; j = j + TOPJ_UINT32(DNB_ELTS_V8) {
		var k TOPJ_UINT32
		opj_v8dwt_interleave_h(tls, job, aj, (*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fw, uint32(DNB_ELTS_V8))
		opj_v8dwt_decode(tls, job)

		// To be adapted if NB_ELTS_V8 changes
		for k = TOPJ_UINT32(0); k < (*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Frw; k++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(k)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet + uintptr(k)*32))
			*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet + uintptr(k)*32 + 1*4))
			*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(2))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet + uintptr(k)*32 + 2*4))
			*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(3))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet + uintptr(k)*32 + 3*4))
		}
		for k = TOPJ_UINT32(0); k < (*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Frw; k++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(4))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet + uintptr(k)*32 + 4*4))
			*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(5))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet + uintptr(k)*32 + 5*4))
			*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(6))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet + uintptr(k)*32 + 6*4))
			*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(7))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet + uintptr(k)*32 + 7*4))
		}

		aj += 4 * uintptr(w*TOPJ_UINT32(DNB_ELTS_V8))
	}

	Xopj_aligned_free(tls, (*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet)
	Xopj_free(tls, job)
}

var __func__32 = *(*[24]int8)(unsafe.Pointer(ts + 1270)) /* dwt.c:3224:1 */

type Topj_dwt97_decode_v_job_t = struct {
	Fv           Topj_v8dwt_t
	Frh          TOPJ_UINT32
	Fw           TOPJ_UINT32
	Faj          uintptr
	Fnb_columns  TOPJ_UINT32
	F__ccgo_pad1 [4]byte
} /* dwt.c:3270:3 */

func opj_dwt97_decode_v_func(tls *libc.TLS, user_data uintptr, tls1 uintptr) { /* dwt.c:3272:13: */
	var j TOPJ_UINT32
	var job uintptr
	var aj uintptr
	_ = tls1

	job = user_data

	if (*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fnb_columns%TOPJ_UINT32(DNB_ELTS_V8) == TOPJ_UINT32(0) {
	} else {
		libc.X__assert_fail(tls, ts+1294, ts+856, uint32(3281), uintptr(unsafe.Pointer(&__func__33)))
	}

	aj = (*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Faj
	for j = TOPJ_UINT32(0); j+TOPJ_UINT32(DNB_ELTS_V8) <= (*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fnb_columns; j = j + TOPJ_UINT32(DNB_ELTS_V8) {
		var k TOPJ_UINT32

		opj_v8dwt_interleave_v(tls, job, aj, (*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fw, uint32(DNB_ELTS_V8))
		opj_v8dwt_decode(tls, job)

		for k = TOPJ_UINT32(0); k < (*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Frh; k++ {
			libc.Xmemcpy(tls, aj+uintptr(TOPJ_SIZE_T(k)*TOPJ_SIZE_T((*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fw))*4, (*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fwavelet+uintptr(k)*32,
				uint32(DNB_ELTS_V8)*uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))))
		}
		aj += 4 * uintptr(DNB_ELTS_V8)
	}

	Xopj_aligned_free(tls, (*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fwavelet)
	Xopj_free(tls, job)
}

var __func__33 = *(*[24]int8)(unsafe.Pointer(ts + 1330)) /* dwt.c:3273:1 */

// <summary>
// Inverse 9-7 wavelet transform in 2-D.
// </summary>
func opj_dwt_decode_tile_97(tls *libc.TLS, tp uintptr, tilec uintptr, numres TOPJ_UINT32) TOPJ_BOOL { /* dwt.c:3306:10: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var h Topj_v8dwt_t at bp, 40

	// var v Topj_v8dwt_t at bp+40, 40

	var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions

	var rw TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fx0) // width of the resolution level computed
	var rh TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fy0) // height of the resolution level computed

	var w TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx0)
	var l_data_size TOPJ_SIZE_T
	var num_threads int32 = Xopj_thread_pool_get_thread_count(tls, tp)

	if numres == TOPJ_UINT32(1) {
		return DOPJ_TRUE
	}

	l_data_size = TOPJ_SIZE_T(opj_dwt_max_resolution(tls, res, numres))
	// overflow check
	if uint64(l_data_size) > libc.Uint64(18446744073709551615)/uint64(unsafe.Sizeof(Topj_v8_t{})) {
		// FIXME event manager error callback
		return DOPJ_FALSE
	}
	(*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwavelet = Xopj_aligned_malloc(tls, l_data_size*TOPJ_SIZE_T(unsafe.Sizeof(Topj_v8_t{})))
	if !(int32((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet) != 0) {
		// FIXME event manager error callback
		return DOPJ_FALSE
	}
	(*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwavelet = (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwavelet

	for libc.PreDecUint32(&numres, 1) != 0 {
		var aj uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata
		var j TOPJ_UINT32

		(*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fsn = TOPJ_INT32(rw)
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fsn = TOPJ_INT32(rh)

		res += 192

		rw = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fx0) // width of the resolution level computed
		rh = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fy0) // height of the resolution level computed

		(*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fdn = TOPJ_INT32(rw - TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fsn))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fcas = (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fx0 % 2

		(*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwin_l_x0 = TOPJ_UINT32(0)
		(*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwin_l_x1 = TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fsn)
		(*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwin_h_x0 = TOPJ_UINT32(0)
		(*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwin_h_x1 = TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fdn)

		if num_threads <= 1 || rh < TOPJ_UINT32(2*DNB_ELTS_V8) {
			for j = TOPJ_UINT32(0); j+TOPJ_UINT32(DNB_ELTS_V8-1) < rh; j = j + TOPJ_UINT32(DNB_ELTS_V8) {
				var k TOPJ_UINT32
				opj_v8dwt_interleave_h(tls, bp, aj, w, uint32(DNB_ELTS_V8))
				opj_v8dwt_decode(tls, bp)

				// To be adapted if NB_ELTS_V8 changes
				for k = TOPJ_UINT32(0); k < rw; k++ {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(k)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32))
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32 + 1*4))
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(2))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32 + 2*4))
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(3))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32 + 3*4))
				}
				for k = TOPJ_UINT32(0); k < rw; k++ {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(4))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32 + 4*4))
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(5))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32 + 5*4))
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(6))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32 + 6*4))
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(7))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32 + 7*4))
				}

				aj += 4 * uintptr(w*TOPJ_UINT32(DNB_ELTS_V8))
			}
		} else {
			var num_jobs TOPJ_UINT32 = TOPJ_UINT32(num_threads)
			var step_j TOPJ_UINT32

			if rh/TOPJ_UINT32(DNB_ELTS_V8) < num_jobs {
				num_jobs = rh / TOPJ_UINT32(DNB_ELTS_V8)
			}
			step_j = rh / num_jobs / TOPJ_UINT32(DNB_ELTS_V8) * TOPJ_UINT32(DNB_ELTS_V8)
			for j = TOPJ_UINT32(0); j < num_jobs; j++ {
				var job uintptr

				job = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_dwt97_decode_h_job_t{})))
				if !(job != 0) {
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwavelet)
					return DOPJ_FALSE
				}
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet = Xopj_aligned_malloc(tls, l_data_size*TOPJ_SIZE_T(unsafe.Sizeof(Topj_v8_t{})))
				if !(int32((*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwavelet) != 0) {
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_free(tls, job)
					Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwavelet)
					return DOPJ_FALSE
				}
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fdn = (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fdn
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fsn = (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fsn
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fcas = (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fcas
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwin_l_x0 = (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwin_l_x0
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwin_l_x1 = (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwin_l_x1
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwin_h_x0 = (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwin_h_x0
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fh.Fwin_h_x1 = (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwin_h_x1
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Frw = rw
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fw = w
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Faj = aj
				(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fnb_rows = func() uint32 {
					if j+TOPJ_UINT32(1) == num_jobs {
						return rh&libc.Uint32(libc.Uint32FromInt32(libc.CplInt32(DNB_ELTS_V8-1))) - j*step_j
					}
					return step_j
				}()
				aj += 4 * uintptr(w*(*Topj_dwt97_decode_h_job_t)(unsafe.Pointer(job)).Fnb_rows)
				Xopj_thread_pool_submit_job(tls, tp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr)
				}{opj_dwt97_decode_h_func})), job)
			}
			Xopj_thread_pool_wait_completion(tls, tp, 0)
			j = rh & libc.Uint32(libc.Uint32FromInt32(libc.CplInt32(DNB_ELTS_V8-1)))
		}

		if j < rh {
			var k TOPJ_UINT32
			opj_v8dwt_interleave_h(tls, bp, aj, w, rh-j)
			opj_v8dwt_decode(tls, bp)
			for k = TOPJ_UINT32(0); k < rw; k++ {
				var l TOPJ_UINT32
				for l = TOPJ_UINT32(0); l < rh-j; l++ {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(aj + uintptr(TOPJ_SIZE_T(k)+TOPJ_SIZE_T(w)*TOPJ_SIZE_T(l))*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer((*Topj_v8dwt_t)(unsafe.Pointer(bp)).Fwavelet + uintptr(k)*32 + uintptr(l)*4))
				}
			}
		}

		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fdn = TOPJ_INT32(rh - TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+40)).Fsn))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fcas = (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fy0 % 2
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwin_l_x0 = TOPJ_UINT32(0)
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwin_l_x1 = TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fsn)
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwin_h_x0 = TOPJ_UINT32(0)
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwin_h_x1 = TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fdn)

		aj = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata
		if num_threads <= 1 || rw < TOPJ_UINT32(2*DNB_ELTS_V8) {
			for j = rw; j > TOPJ_UINT32(DNB_ELTS_V8-1); j = j - TOPJ_UINT32(DNB_ELTS_V8) {
				var k TOPJ_UINT32

				opj_v8dwt_interleave_v(tls, bp+40, aj, w, uint32(DNB_ELTS_V8))
				opj_v8dwt_decode(tls, bp+40)

				for k = TOPJ_UINT32(0); k < rh; k++ {
					libc.Xmemcpy(tls, aj+uintptr(TOPJ_SIZE_T(k)*TOPJ_SIZE_T(w))*4, (*Topj_v8dwt_t)(unsafe.Pointer(bp+40)).Fwavelet+uintptr(k)*32, uint32(DNB_ELTS_V8)*uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))))
				}
				aj += 4 * uintptr(DNB_ELTS_V8)
			}
		} else {
			// "bench_dwt -I" shows that scaling is poor, likely due to RAM
			//                 transfer being the limiting factor. So limit the number of
			//                 threads.
			//
			var num_jobs TOPJ_UINT32 = opj_uint_max(tls, TOPJ_UINT32(num_threads)/TOPJ_UINT32(2), 2)
			var step_j TOPJ_UINT32

			if rw/TOPJ_UINT32(DNB_ELTS_V8) < num_jobs {
				num_jobs = rw / TOPJ_UINT32(DNB_ELTS_V8)
			}
			step_j = rw / num_jobs / TOPJ_UINT32(DNB_ELTS_V8) * TOPJ_UINT32(DNB_ELTS_V8)
			for j = TOPJ_UINT32(0); j < num_jobs; j++ {
				var job uintptr

				job = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_dwt97_decode_v_job_t{})))
				if !(job != 0) {
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwavelet)
					return DOPJ_FALSE
				}
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fwavelet = Xopj_aligned_malloc(tls, l_data_size*TOPJ_SIZE_T(unsafe.Sizeof(Topj_v8_t{})))
				if !(int32((*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fwavelet) != 0) {
					Xopj_thread_pool_wait_completion(tls, tp, 0)
					Xopj_free(tls, job)
					Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwavelet)
					return DOPJ_FALSE
				}
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fdn = (*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fdn
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fsn = (*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fsn
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fcas = (*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fcas
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fwin_l_x0 = (*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwin_l_x0
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fwin_l_x1 = (*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwin_l_x1
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fwin_h_x0 = (*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwin_h_x0
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fv.Fwin_h_x1 = (*Topj_v8dwt_t)(unsafe.Pointer(bp + 40 /* &v */)).Fwin_h_x1
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Frh = rh
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fw = w
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Faj = aj
				(*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fnb_columns = func() uint32 {
					if j+TOPJ_UINT32(1) == num_jobs {
						return rw&libc.Uint32(libc.Uint32FromInt32(libc.CplInt32(DNB_ELTS_V8-1))) - j*step_j
					}
					return step_j
				}()
				aj += 4 * uintptr((*Topj_dwt97_decode_v_job_t)(unsafe.Pointer(job)).Fnb_columns)
				Xopj_thread_pool_submit_job(tls, tp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr)
				}{opj_dwt97_decode_v_func})), job)
			}
			Xopj_thread_pool_wait_completion(tls, tp, 0)
		}

		if rw&TOPJ_UINT32(DNB_ELTS_V8-1) != 0 {
			var k TOPJ_UINT32

			j = rw & TOPJ_UINT32(DNB_ELTS_V8-1)

			opj_v8dwt_interleave_v(tls, bp+40, aj, w, j)
			opj_v8dwt_decode(tls, bp+40)

			for k = TOPJ_UINT32(0); k < rh; k++ {
				libc.Xmemcpy(tls, aj+uintptr(TOPJ_SIZE_T(k)*TOPJ_SIZE_T(w))*4, (*Topj_v8dwt_t)(unsafe.Pointer(bp+40)).Fwavelet+uintptr(k)*32,
					TOPJ_SIZE_T(j)*TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_FLOAT32(0))))
			}
		}
	}

	Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp /* &h */)).Fwavelet)
	return DOPJ_TRUE
}

func opj_dwt_decode_partial_97(tls *libc.TLS, tilec uintptr, numres TOPJ_UINT32) TOPJ_BOOL { /* dwt.c:3529:10: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var sa uintptr
	// var h Topj_v8dwt_t at bp+32, 40

	// var v Topj_v8dwt_t at bp+72, 40

	var resno TOPJ_UINT32
	// This value matches the maximum left/right extension given in tables
	// F.2 and F.3 of the standard. Note: in opj_tcd_is_subband_area_of_interest()
	// we currently use 3.
	var filter_width TOPJ_UINT32 = 4

	var tr uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions
	var tr_max uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(numres-TOPJ_UINT32(1))*192

	var rw TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0) // width of the resolution level computed
	var rh TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0) // height of the resolution level computed

	var l_data_size TOPJ_SIZE_T

	// Compute the intersection of the area of interest, expressed in tile coordinates
	// with the tile coordinates
	var win_tcx0 TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x0
	var win_tcy0 TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y0
	var win_tcx1 TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x1
	var win_tcy1 TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y1

	if (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0 == (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx1 || (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0 == (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy1 {
		return DOPJ_TRUE
	}

	sa = opj_dwt_init_sparse_array(tls, tilec, numres)
	if sa == uintptr(0) {
		return DOPJ_FALSE
	}

	if numres == 1 {
		var ret TOPJ_BOOL = Xopj_sparse_array_int32_read(tls, sa,
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x0-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_y0-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x1-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_y1-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0),
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_win,
			uint32(1), (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x1-(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x0,
			DOPJ_TRUE)
		_ = ret
		if ret != 0 {
		} else {
			libc.X__assert_fail(tls, ts+1062, ts+856, uint32(3576), uintptr(unsafe.Pointer(&__func__34)))
		}
		_ = ret
		Xopj_sparse_array_int32_free(tls, sa)
		return DOPJ_TRUE
	}

	l_data_size = TOPJ_SIZE_T(opj_dwt_max_resolution(tls, tr, numres))
	// overflow check
	if uint64(l_data_size) > libc.Uint64(18446744073709551615)/uint64(unsafe.Sizeof(Topj_v8_t{})) {
		// FIXME event manager error callback
		Xopj_sparse_array_int32_free(tls, sa)
		return DOPJ_FALSE
	}
	(*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fwavelet = Xopj_aligned_malloc(tls, l_data_size*TOPJ_SIZE_T(unsafe.Sizeof(Topj_v8_t{})))
	if !(int32((*Topj_v8dwt_t)(unsafe.Pointer(bp+32)).Fwavelet) != 0) {
		// FIXME event manager error callback
		Xopj_sparse_array_int32_free(tls, sa)
		return DOPJ_FALSE
	}
	(*Topj_v8dwt_t)(unsafe.Pointer(bp + 72 /* &v */)).Fwavelet = (*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fwavelet

	for resno = TOPJ_UINT32(1); resno < numres; resno++ {
		var j TOPJ_UINT32
		// Window of interest subband-based coordinates
		// var win_ll_x0 TOPJ_UINT32 at bp, 4

		// var win_ll_y0 TOPJ_UINT32 at bp+4, 4

		// var win_ll_x1 TOPJ_UINT32 at bp+8, 4

		// var win_ll_y1 TOPJ_UINT32 at bp+12, 4

		// var win_hl_x0 TOPJ_UINT32 at bp+16, 4

		// var win_hl_x1 TOPJ_UINT32 at bp+20, 4

		// var win_lh_y0 TOPJ_UINT32 at bp+24, 4

		// var win_lh_y1 TOPJ_UINT32 at bp+28, 4

		// Window of interest tile-resolution-based coordinates
		var win_tr_x0 TOPJ_UINT32
		var win_tr_x1 TOPJ_UINT32
		var win_tr_y0 TOPJ_UINT32
		var win_tr_y1 TOPJ_UINT32
		// Tile-resolution subband-based coordinates
		var tr_ll_x0 TOPJ_UINT32
		var tr_ll_y0 TOPJ_UINT32
		var tr_hl_x0 TOPJ_UINT32
		var tr_lh_y0 TOPJ_UINT32

		tr += 192

		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fsn = TOPJ_INT32(rw)
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 72 /* &v */)).Fsn = TOPJ_INT32(rh)

		rw = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0)
		rh = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0)

		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fdn = TOPJ_INT32(rw - TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+32)).Fsn))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fcas = (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fx0 % 2

		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 72 /* &v */)).Fdn = TOPJ_INT32(rh - TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+72)).Fsn))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 72 /* &v */)).Fcas = (*Topj_tcd_resolution_t)(unsafe.Pointer(tr)).Fy0 % 2

		// Get the subband coordinates for the window of interest
		// LL band
		opj_dwt_get_band_coordinates(tls, tilec, resno, uint32(0),
			win_tcx0, win_tcy0, win_tcx1, win_tcy1,
			bp, bp+4,
			bp+8, bp+12)

		// HL band
		opj_dwt_get_band_coordinates(tls, tilec, resno, uint32(1),
			win_tcx0, win_tcy0, win_tcx1, win_tcy1,
			bp+16, uintptr(0), bp+20, uintptr(0))

		// LH band
		opj_dwt_get_band_coordinates(tls, tilec, resno, uint32(2),
			win_tcx0, win_tcy0, win_tcx1, win_tcy1,
			uintptr(0), bp+24, uintptr(0), bp+28)

		// Beware: band index for non-LL0 resolution are 0=HL, 1=LH and 2=HH
		tr_ll_x0 = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(tr + 32 + 1*48)).Fx0)
		tr_ll_y0 = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(tr + 32)).Fy0)
		tr_hl_x0 = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(tr + 32)).Fx0)
		tr_lh_y0 = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(tr + 32 + 1*48)).Fy0)

		// Subtract the origin of the bands for this tile, to the subwindow
		// of interest band coordinates, so as to get them relative to the
		// tile
		*(*TOPJ_UINT32)(unsafe.Pointer(bp /* win_ll_x0 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp /* win_ll_x0 */)), tr_ll_x0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* win_ll_y0 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* win_ll_y0 */)), tr_ll_y0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* win_ll_x1 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* win_ll_x1 */)), tr_ll_x0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* win_ll_y1 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* win_ll_y1 */)), tr_ll_y0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* win_hl_x0 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* win_hl_x0 */)), tr_hl_x0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* win_hl_x1 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* win_hl_x1 */)), tr_hl_x0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* win_lh_y0 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* win_lh_y0 */)), tr_lh_y0)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* win_lh_y1 */)) = opj_uint_subs(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* win_lh_y1 */)), tr_lh_y0)

		opj_dwt_segment_grow(tls, filter_width, TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+32 /* &h */)).Fsn), bp, bp+8)
		opj_dwt_segment_grow(tls, filter_width, TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+32 /* &h */)).Fdn), bp+16, bp+20)

		opj_dwt_segment_grow(tls, filter_width, TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+72 /* &v */)).Fsn), bp+4, bp+12)
		opj_dwt_segment_grow(tls, filter_width, TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+72 /* &v */)).Fdn), bp+24, bp+28)

		// Compute the tile-resolution-based coordinates for the window of interest
		if (*Topj_v8dwt_t)(unsafe.Pointer(bp+32)).Fcas == 0 {
			win_tr_x0 = opj_uint_min(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 16))+TOPJ_UINT32(1))
			win_tr_x1 = opj_uint_min(tls, opj_uint_max(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 20))+TOPJ_UINT32(1)), rw)
		} else {
			win_tr_x0 = opj_uint_min(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp))+TOPJ_UINT32(1))
			win_tr_x1 = opj_uint_min(tls, opj_uint_max(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 20)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 8))+TOPJ_UINT32(1)), rw)
		}

		if (*Topj_v8dwt_t)(unsafe.Pointer(bp+72)).Fcas == 0 {
			win_tr_y0 = opj_uint_min(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 24))+TOPJ_UINT32(1))
			win_tr_y1 = opj_uint_min(tls, opj_uint_max(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 28))+TOPJ_UINT32(1)), rh)
		} else {
			win_tr_y0 = opj_uint_min(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))+TOPJ_UINT32(1))
			win_tr_y1 = opj_uint_min(tls, opj_uint_max(tls, TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 28)), TOPJ_UINT32(2)**(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))+TOPJ_UINT32(1)), rh)
		}

		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fwin_l_x0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp /* win_ll_x0 */))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fwin_l_x1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* win_ll_x1 */))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fwin_h_x0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* win_hl_x0 */))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 32 /* &h */)).Fwin_h_x1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* win_hl_x1 */))
		for j = TOPJ_UINT32(0); j+TOPJ_UINT32(DNB_ELTS_V8-1) < rh; j = j + TOPJ_UINT32(DNB_ELTS_V8) {
			if j+TOPJ_UINT32(DNB_ELTS_V8-1) >= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) && j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) || j+TOPJ_UINT32(DNB_ELTS_V8-1) >= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24))+TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+72)).Fsn) && j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28))+TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+72)).Fsn) {
				opj_v8dwt_interleave_partial_h(tls, bp+32, sa, j, opj_uint_min(tls, uint32(DNB_ELTS_V8), rh-j))
				opj_v8dwt_decode(tls, bp+32)
				if !(Xopj_sparse_array_int32_write(tls, sa,
					win_tr_x0, j,
					win_tr_x1, j+TOPJ_UINT32(DNB_ELTS_V8),
					(*Topj_v8dwt_t)(unsafe.Pointer(bp+32)).Fwavelet+uintptr(win_tr_x0)*32,
					uint32(DNB_ELTS_V8), uint32(1), DOPJ_TRUE) != 0) {
					// FIXME event manager error callback
					Xopj_sparse_array_int32_free(tls, sa)
					Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp+32 /* &h */)).Fwavelet)
					return DOPJ_FALSE
				}
			}
		}

		if j < rh && (j+TOPJ_UINT32(DNB_ELTS_V8-1) >= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) && j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) || j+TOPJ_UINT32(DNB_ELTS_V8-1) >= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24))+TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+72)).Fsn) && j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28))+TOPJ_UINT32((*Topj_v8dwt_t)(unsafe.Pointer(bp+72)).Fsn)) {
			opj_v8dwt_interleave_partial_h(tls, bp+32, sa, j, rh-j)
			opj_v8dwt_decode(tls, bp+32)
			if !(Xopj_sparse_array_int32_write(tls, sa,
				win_tr_x0, j,
				win_tr_x1, rh,
				(*Topj_v8dwt_t)(unsafe.Pointer(bp+32)).Fwavelet+uintptr(win_tr_x0)*32,
				uint32(DNB_ELTS_V8), uint32(1), DOPJ_TRUE) != 0) {
				// FIXME event manager error callback
				Xopj_sparse_array_int32_free(tls, sa)
				Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp+32 /* &h */)).Fwavelet)
				return DOPJ_FALSE
			}
		}

		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 72 /* &v */)).Fwin_l_x0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* win_ll_y0 */))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 72 /* &v */)).Fwin_l_x1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* win_ll_y1 */))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 72 /* &v */)).Fwin_h_x0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* win_lh_y0 */))
		(*Topj_v8dwt_t)(unsafe.Pointer(bp + 72 /* &v */)).Fwin_h_x1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* win_lh_y1 */))
		for j = win_tr_x0; j < win_tr_x1; j = j + TOPJ_UINT32(DNB_ELTS_V8) {
			var nb_elts TOPJ_UINT32 = opj_uint_min(tls, uint32(DNB_ELTS_V8), win_tr_x1-j)

			opj_v8dwt_interleave_partial_v(tls, bp+72, sa, j, nb_elts)
			opj_v8dwt_decode(tls, bp+72)

			if !(Xopj_sparse_array_int32_write(tls, sa,
				j, win_tr_y0,
				j+nb_elts, win_tr_y1,
				(*Topj_v8dwt_t)(unsafe.Pointer(bp+32)).Fwavelet+uintptr(win_tr_y0)*32,
				uint32(1), uint32(DNB_ELTS_V8), DOPJ_TRUE) != 0) {
				// FIXME event manager error callback
				Xopj_sparse_array_int32_free(tls, sa)
				Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp+32 /* &h */)).Fwavelet)
				return DOPJ_FALSE
			}
		}
	}

	{
		var ret TOPJ_BOOL = Xopj_sparse_array_int32_read(tls, sa,
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x0-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_y0-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x1-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fx0),
			(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_y1-TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fy0),
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_win,
			uint32(1), (*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x1-(*Topj_tcd_resolution_t)(unsafe.Pointer(tr_max)).Fwin_x0,
			DOPJ_TRUE)
		_ = ret
		if ret != 0 {
		} else {
			libc.X__assert_fail(tls, ts+1062, ts+856, uint32(3753), uintptr(unsafe.Pointer(&__func__34)))
		}
		_ = ret

	}
	Xopj_sparse_array_int32_free(tls, sa)

	Xopj_aligned_free(tls, (*Topj_v8dwt_t)(unsafe.Pointer(bp+32 /* &h */)).Fwavelet)
	return DOPJ_TRUE
}

var __func__34 = *(*[26]int8)(unsafe.Pointer(ts + 1354)) /* dwt.c:3531:1 */

func Xopj_dwt_decode_real(tls *libc.TLS, p_tcd uintptr, tilec uintptr, numres TOPJ_UINT32) TOPJ_BOOL { /* dwt.c:3763:10: */
	if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
		return opj_dwt_decode_tile_97(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fthread_pool, tilec, numres)
	} else {
		return opj_dwt_decode_partial_97(tls, tilec, numres)
	}
	return TOPJ_BOOL(0)
}

// ==========================================================
//      Utility functions
//    ==========================================================

// -----------------------------------------------------------------------
// *
// Default callback function.
// Do nothing.
func opj_default_callback(tls *libc.TLS, msg uintptr, client_data uintptr) { /* event.c:81:13: */
	_ = msg
	_ = client_data
}

// -----------------------------------------------------------------------

// -----------------------------------------------------------------------
func Xopj_event_msg(tls *libc.TLS, p_event_mgr uintptr, event_type TOPJ_INT32, fmt uintptr, va uintptr) TOPJ_BOOL { /* event.c:91:10: */
	bp := tls.Alloc(512)
	defer tls.Free(512)

	var msg_handler Topj_msg_callback = uintptr(00)
	var l_data uintptr = uintptr(00)

	if p_event_mgr != uintptr(00) {
		switch event_type {
		case DEVT_ERROR:
			msg_handler = (*Topj_event_mgr_t)(unsafe.Pointer(p_event_mgr)).Ferror_handler
			l_data = (*Topj_event_mgr_t)(unsafe.Pointer(p_event_mgr)).Fm_error_data
			break
			fallthrough
		case DEVT_WARNING:
			msg_handler = (*Topj_event_mgr_t)(unsafe.Pointer(p_event_mgr)).Fwarning_handler
			l_data = (*Topj_event_mgr_t)(unsafe.Pointer(p_event_mgr)).Fm_warning_data
			break
			fallthrough
		case DEVT_INFO:
			msg_handler = (*Topj_event_mgr_t)(unsafe.Pointer(p_event_mgr)).Finfo_handler
			l_data = (*Topj_event_mgr_t)(unsafe.Pointer(p_event_mgr)).Fm_info_data
			break
			fallthrough
		default:
			break
		}
		if msg_handler == uintptr(00) {
			return DOPJ_FALSE
		}
	} else {
		return DOPJ_FALSE
	}

	if fmt != uintptr(00) && p_event_mgr != uintptr(00) {
		var arg Tva_list
		_ = arg
		// var message [512]int8 at bp, 512

		libc.Xmemset(tls, bp, 0, uint32(DOPJ_MSG_SIZE))
		// initialize the optional parameter list
		arg = va
		// parse the format string and put the result in 'message'
		libc.Xvsnprintf(tls, bp, uint32(DOPJ_MSG_SIZE), fmt, arg)
		// force zero termination for Windows _vsnprintf() of old MSVC
		*(*int8)(unsafe.Pointer(bp + 511)) = int8(0)
		// deinitialize the optional parameter list
		_ = arg

		// output the message to the user program
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{msg_handler})).f(tls, bp /* &message[0] */, l_data)
	}

	return DOPJ_TRUE
}

func Xopj_set_default_event_handler(tls *libc.TLS, p_manager uintptr) { /* event.c:142:6: */
	(*Topj_event_mgr_t)(unsafe.Pointer(p_manager)).Fm_error_data = uintptr(00)
	(*Topj_event_mgr_t)(unsafe.Pointer(p_manager)).Fm_warning_data = uintptr(00)
	(*Topj_event_mgr_t)(unsafe.Pointer(p_manager)).Fm_info_data = uintptr(00)
	(*Topj_event_mgr_t)(unsafe.Pointer(p_manager)).Ferror_handler = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{opj_default_callback}))
	(*Topj_event_mgr_t)(unsafe.Pointer(p_manager)).Finfo_handler = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{opj_default_callback}))
	(*Topj_event_mgr_t)(unsafe.Pointer(p_manager)).Fwarning_handler = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{opj_default_callback}))
}

// *
// Default size of the validation list, if not sufficient, data will be reallocated with a double size.

func Xopj_procedure_list_create(tls *libc.TLS) uintptr { /* function_list.c:39:22: */
	// memory allocation
	var l_validation uintptr = Xopj_calloc(tls, uint32(1),
		uint32(unsafe.Sizeof(Topj_procedure_list_t{})))
	if !(l_validation != 0) {
		return uintptr(00)
	}
	// initialization
	(*Topj_procedure_list_t)(unsafe.Pointer(l_validation)).Fm_nb_max_procedures = TOPJ_UINT32(DOPJ_VALIDATION_SIZE)
	(*Topj_procedure_list_t)(unsafe.Pointer(l_validation)).Fm_procedures = Xopj_calloc(tls, uint32(DOPJ_VALIDATION_SIZE),
		uint32(unsafe.Sizeof(Topj_procedure(0))))
	if !(int32((*Topj_procedure_list_t)(unsafe.Pointer(l_validation)).Fm_procedures) != 0) {
		Xopj_free(tls, l_validation)
		return uintptr(00)
	}
	return l_validation
}

func Xopj_procedure_list_destroy(tls *libc.TLS, p_list uintptr) { /* function_list.c:58:7: */
	if !(p_list != 0) {
		return
	}
	// initialization
	if (*Topj_procedure_list_t)(unsafe.Pointer(p_list)).Fm_procedures != 0 {
		Xopj_free(tls, (*Topj_procedure_list_t)(unsafe.Pointer(p_list)).Fm_procedures)
	}
	Xopj_free(tls, p_list)
}

func Xopj_procedure_list_add_procedure(tls *libc.TLS, p_validation_list uintptr, p_procedure Topj_procedure, p_manager uintptr) TOPJ_BOOL { /* function_list.c:70:10: */

	if p_manager != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1380, ts+1398, uint32(74), uintptr(unsafe.Pointer(&__func__43)))
	}

	if (*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_max_procedures == (*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_procedures {
		var new_procedures uintptr

		*(*TOPJ_UINT32)(unsafe.Pointer(p_validation_list + 4)) += TOPJ_UINT32(DOPJ_VALIDATION_SIZE)
		new_procedures = Xopj_realloc(tls,
			(*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_procedures,
			uint32((*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_max_procedures)*uint32(unsafe.Sizeof(Topj_procedure(0))))
		if !(new_procedures != 0) {
			Xopj_free(tls, (*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_procedures)
			(*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_max_procedures = TOPJ_UINT32(0)
			(*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_procedures = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+1433, 0)
			return DOPJ_FALSE
		} else {
			(*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_procedures = new_procedures
		}
	}
	*(*Topj_procedure)(unsafe.Pointer((*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_procedures + uintptr((*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_procedures)*8)) = p_procedure
	(*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_procedures++

	return DOPJ_TRUE
}

var __func__43 = *(*[33]int8)(unsafe.Pointer(ts + 1486)) /* function_list.c:72:1 */

func Xopj_procedure_list_get_nb_procedures(tls *libc.TLS, p_validation_list uintptr) TOPJ_UINT32 { /* function_list.c:102:12: */
	return (*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_procedures
}

func Xopj_procedure_list_get_first_procedure(tls *libc.TLS, p_validation_list uintptr) uintptr { /* function_list.c:108:14: */
	return (*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_procedures
}

func Xopj_procedure_list_clear(tls *libc.TLS, p_validation_list uintptr) { /* function_list.c:114:6: */
	(*Topj_procedure_list_t)(unsafe.Pointer(p_validation_list)).Fm_nb_procedures = TOPJ_UINT32(0)
}

func Xopj_stream_create_buffer_stream(tls *libc.TLS, buf uintptr, buf_size TOPJ_SIZE_T, p_size TOPJ_SIZE_T, p_is_read_stream TOPJ_BOOL) uintptr { /* helper.c:5:13: */
	var l_stream uintptr = uintptr(00)
	var mode uintptr
	_ = mode

	if !(buf != 0) {
		return uintptr(0)
	}

	if p_is_read_stream != 0 {
		mode = ts + 1519 /* "rb" */
	} else {
		mode = ts + 1522 /* "wb" */
	}

	l_stream = Xopj_stream_create(tls, p_size, p_is_read_stream)
	if !(l_stream != 0) {
		return uintptr(0)
	}

	Xopj_stream_set_user_data(tls, l_stream, uintptr(0), uintptr(0))
	Xopj_stream_set_user_data_length(tls, l_stream, buf_size)
	Xopj_stream_set_current_data(tls, l_stream, buf, buf_size)
	return l_stream
}

func Xopj_stream_create_default_buffer_stream(tls *libc.TLS, buf uintptr, buf_size TOPJ_SIZE_T, p_is_read_stream TOPJ_BOOL) uintptr { /* helper.c:35:13: */
	return Xopj_stream_create_buffer_stream(tls, buf, buf_size, uint32(DOPJ_J2K_STREAM_CHUNK_SIZE),
		p_is_read_stream)
}

type Topj_precision_mode = uint32 /* helper.c:46:3 */

type Sopj_prec = struct {
	Fprec TOPJ_UINT32
	Fmode Topj_precision_mode
} /* helper.c:48:9 */

type Topj_precision = Sopj_prec /* helper.c:51:3 */

type Sopj_decompress_params = struct {
	Fcore              Topj_dparameters_t
	Finfile            [4096]int8
	Foutfile           [4096]int8
	Fdecod_format      int32
	Fcod_format        int32
	Findexfilename     [4096]int8
	FDA_x0             TOPJ_UINT32
	FDA_x1             TOPJ_UINT32
	FDA_y0             TOPJ_UINT32
	FDA_y1             TOPJ_UINT32
	Fm_verbose         TOPJ_BOOL
	Ftile_index        TOPJ_UINT32
	Fnb_tile_to_decode TOPJ_UINT32
	Fprecision         uintptr
	Fnb_precision      TOPJ_UINT32
	Fforce_rgb         int32
	Fupsample          int32
	Fsplit_pnm         int32
	Fnum_threads       int32
	Fquiet             int32
	Fallow_partial     int32
	Fnumcomps          TOPJ_UINT32
	Fcomps_indices     uintptr
} /* helper.c:53:9 */

type Topj_decompress_parameters = Sopj_decompress_params /* helper.c:103:3 */

func set_default_parameters(tls *libc.TLS, parameters uintptr) { /* helper.c:105:13: */
	if parameters != 0 {
		libc.Xmemset(tls, parameters, 0, uint32(unsafe.Sizeof(Topj_decompress_parameters{})))

		// default decoding parameters (command line specific)
		(*Topj_decompress_parameters)(unsafe.Pointer(parameters)).Fdecod_format = -1
		(*Topj_decompress_parameters)(unsafe.Pointer(parameters)).Fcod_format = -1

		// default decoding parameters (core)
		Xopj_set_default_decoder_parameters(tls, parameters)
	}
}

func Xopj_decompress(tls *libc.TLS, buf uintptr, buf_size Tsize_t, decod_format int32, cod_format int32) uintptr { /* helper.c:119:12: */
	bp := tls.Alloc(20632)
	defer tls.Free(20632)

	*(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)) = uintptr(0)
	var l_stream uintptr = uintptr(0) // Stream
	var l_codec uintptr = uintptr(0)  // Handle to a decompressor
	// var parameters Topj_decompress_parameters at bp, 20624
	// decompression parameters

	// set decoding parameters to default values
	set_default_parameters(tls, bp)

	l_stream = Xopj_stream_create_default_buffer_stream(tls, buf, buf_size, 1)
	if !(l_stream != 0) {
		libc.Xfprintf(tls, libc.Xstderr, ts+1525, 0)
		return uintptr(0)
	}

	// decode the JPEG2000 stream
	// ----------------------

	l_codec = Xopj_create_decompress(tls, OPJ_CODEC_J2K)
	if !(Xopj_setup_decoder(tls, l_codec, bp) != 0) {
		libc.Xfprintf(tls, libc.Xstderr, ts+1575, 0)
		Xopj_stream_destroy(tls, l_stream)
		Xopj_destroy_codec(tls, l_codec)
		return uintptr(0)
	}

	// Read the main header of the codestream and if necessary the JP2 boxes
	if !(Xopj_read_header(tls, l_stream, l_codec, bp+20624) != 0) {
		libc.Xfprintf(tls, libc.Xstderr, ts+1629, 0)
		Xopj_stream_destroy(tls, l_stream)
		Xopj_destroy_codec(tls, l_codec)
		Xopj_image_destroy(tls, *(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)))
		return uintptr(0)
	}
	// Optional if you want decode the entire image
	if !(Xopj_set_decode_area(tls, l_codec, *(*uintptr)(unsafe.Pointer(bp + 20624)), 0,
		0, 0,
		0) != 0) {
		libc.Xfprintf(tls, libc.Xstderr, ts+1679, 0)
		Xopj_stream_destroy(tls, l_stream)
		Xopj_destroy_codec(tls, l_codec)
		Xopj_image_destroy(tls, *(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)))
		return uintptr(0)
	}

	// Get the decoded image
	if !(Xopj_decode(tls, l_codec, l_stream, *(*uintptr)(unsafe.Pointer(bp + 20624))) != 0 && Xopj_end_decompress(tls, l_codec, l_stream) != 0) {
		libc.Xfprintf(tls, libc.Xstderr, ts+1736, 0)
		Xopj_destroy_codec(tls, l_codec)
		Xopj_stream_destroy(tls, l_stream)
		Xopj_image_destroy(tls, *(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)))
		return uintptr(0)
	}

	if (*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fcolor_space != OPJ_CLRSPC_SYCC &&
		(*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fnumcomps == TOPJ_UINT32(3) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fcomps)).Fdx == (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fcomps)).Fdy &&
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fcomps+1*64)).Fdx != TOPJ_UINT32(1) {
		(*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)))).Fcolor_space = OPJ_CLRSPC_SYCC
	} else if (*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fnumcomps <= TOPJ_UINT32(2) {
		(*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)))).Fcolor_space = OPJ_CLRSPC_GRAY
	}

	if (*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fcolor_space == OPJ_CLRSPC_SYCC {
		Xcolor_sycc_to_rgb(tls, *(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)))
	} else if (*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fcolor_space == OPJ_CLRSPC_CMYK && (*Topj_decompress_parameters)(unsafe.Pointer(bp)).Fcod_format != DTIF_DFMT {
		Xcolor_cmyk_to_rgb(tls, *(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)))
	} else if (*Topj_image_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20624)))).Fcolor_space == OPJ_CLRSPC_EYCC {
		Xcolor_esycc_to_rgb(tls, *(*uintptr)(unsafe.Pointer(bp + 20624 /* image */)))
	}

	// free remaining structures
	if l_codec != 0 {
		Xopj_destroy_codec(tls, l_codec)
	}
	return *(*uintptr)(unsafe.Pointer(bp + 20624 /* image */))
}

func Xdecode_j2k(tls *libc.TLS, buf uintptr, buf_size Tsize_t) uintptr { /* helper.c:204:12: */
	return Xopj_decompress(tls, buf, buf_size, DJ2K_CFMT, DPXM_DFMT)
}

var vlc_tbl0 = [1024]TOPJ_UINT16{
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0083), TOPJ_UINT16(0xa8ee), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xd8df),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x10be), TOPJ_UINT16(0x0043), TOPJ_UINT16(0xf5ff), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x207e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x515f),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0xc4ce), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xcccf),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0xe2fe), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x99ff), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x313f),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x445e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0xc8ce), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x11df),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0xf4fe), TOPJ_UINT16(0x0043), TOPJ_UINT16(0xfcff), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0043), TOPJ_UINT16(0xf1ff), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x88ae), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x0043), TOPJ_UINT16(0xe4ef), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x111f),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0083), TOPJ_UINT16(0xa8ee), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x54df),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x10be), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x22ef), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x207e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x227f),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0xc4ce), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x11bf),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0xe2fe), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x00f7), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x223f),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x445e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0xc8ce), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x00d7),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0xf4fe), TOPJ_UINT16(0x0043), TOPJ_UINT16(0xbaff), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0043), TOPJ_UINT16(0xe6ff), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x88ae), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xa2af),
	TOPJ_UINT16(0x0023), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x00e7), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x222f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x207e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0xc4ce), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x00f7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa2fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x00d7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x10be), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88ae), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x11df),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa8ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x111f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x006e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88ce), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x88ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xb8fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xe4fe), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x445e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x00e7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x54de), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x003e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x207e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0xc4ce), TOPJ_UINT16(0x0024), TOPJ_UINT16(0xf1ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa2fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x11bf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x10be), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88ae), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x22ef),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa8ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x227f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x006e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88ce), TOPJ_UINT16(0x0024), TOPJ_UINT16(0xe4ef),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xb8fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xa2af),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xe4fe), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x445e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0024), TOPJ_UINT16(0xd8df),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x54de), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x003e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x515f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88de), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x32ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x11fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00ae), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x317e), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x515e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x00d7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x20ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x545e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x44ce), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x00e7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf1fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x555f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x74fe), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x113e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x20be), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x747f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xc4de), TOPJ_UINT16(0x0044), TOPJ_UINT16(0xf8ff), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x222f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88de), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x00f7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x11fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00ae), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x888f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x317e), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x515e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0024), TOPJ_UINT16(0xc8cf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x20ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x545e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x44ce), TOPJ_UINT16(0x0024), TOPJ_UINT16(0xd1df),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf1fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x227f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x74fe), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x113e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x20be), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x22bf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xc4de), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x22ef), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x323f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xd4de), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0xfcff), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x113e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x888f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x32be), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x00e7), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x515e), TOPJ_UINT16(0xaafe), TOPJ_UINT16(0x727f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x44ce), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x44ef), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x647e), TOPJ_UINT16(0x0045), TOPJ_UINT16(0xa2af),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x555d), TOPJ_UINT16(0x99df), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x0036), TOPJ_UINT16(0xf5fe), TOPJ_UINT16(0x626f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xd1de), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0xe6ff), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x717e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0xb1bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x88ae), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xd5df), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x444e), TOPJ_UINT16(0xf2fe), TOPJ_UINT16(0x667f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0xe2ef), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x545e), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x119f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x555d), TOPJ_UINT16(0xc8cf), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x111e), TOPJ_UINT16(0xc8ee), TOPJ_UINT16(0x0067),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xd4de), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0xf3ff), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x113e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x11bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x32be), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xd8df), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x515e), TOPJ_UINT16(0xaafe), TOPJ_UINT16(0x222f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x44ce), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x00f7), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x647e), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x989f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x555d), TOPJ_UINT16(0x00d7), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x0036), TOPJ_UINT16(0xf5fe), TOPJ_UINT16(0x446f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xd1de), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0xb9ff), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x717e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x88ae), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xdcdf), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x444e), TOPJ_UINT16(0xf2fe), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0xe4ef), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x545e), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x737f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x555d), TOPJ_UINT16(0xb8bf), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x111e), TOPJ_UINT16(0xc8ee), TOPJ_UINT16(0x323f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x407e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x10de), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x11df),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x72fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa8ae), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xb2bf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x00e7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xc8ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x006e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88ce), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x00f7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x91fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa2ae), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xaaaf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xb8fe), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x005e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00be), TOPJ_UINT16(0x0024), TOPJ_UINT16(0xc4cf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x44ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0xf4ff), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x223e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x111f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x407e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x10de), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x99ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x72fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa8ae), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x00d7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xc8ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x444f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x006e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88ce), TOPJ_UINT16(0x0024), TOPJ_UINT16(0xe2ef),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x91fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa2ae), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x447f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xb8fe), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x005e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00be), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x009f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x44ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x76ff), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x223e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x313f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xd9ff), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0x647e), TOPJ_UINT16(0xf1fe), TOPJ_UINT16(0x99bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xa2ae), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x66ef), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0x0056), TOPJ_UINT16(0xe2ee), TOPJ_UINT16(0x737f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x98be), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x00f7), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x76fe), TOPJ_UINT16(0x889f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x0015), TOPJ_UINT16(0xd5df), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x98de), TOPJ_UINT16(0x444f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xb2be), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xfcff), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0x226e), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xaaae), TOPJ_UINT16(0x0025), TOPJ_UINT16(0xd1df), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0x0036), TOPJ_UINT16(0xd4de), TOPJ_UINT16(0x646f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xa8ae), TOPJ_UINT16(0x0045), TOPJ_UINT16(0xeaef), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x445e), TOPJ_UINT16(0xe8ee), TOPJ_UINT16(0x717f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x323e), TOPJ_UINT16(0x0015), TOPJ_UINT16(0xc4cf), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0xfaff), TOPJ_UINT16(0x88ce), TOPJ_UINT16(0x313f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x77ff), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0x647e), TOPJ_UINT16(0xf1fe), TOPJ_UINT16(0xb3bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xa2ae), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x00e7), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0x0056), TOPJ_UINT16(0xe2ee), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x98be), TOPJ_UINT16(0x0045), TOPJ_UINT16(0xe4ef), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x76fe), TOPJ_UINT16(0x667f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x00d7), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x98de), TOPJ_UINT16(0x333f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xb2be), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x75ff), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0x226e), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x919f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xaaae), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x99df), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0x0036), TOPJ_UINT16(0xd4de), TOPJ_UINT16(0x515f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xa8ae), TOPJ_UINT16(0x0045), TOPJ_UINT16(0xecef), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x445e), TOPJ_UINT16(0xe8ee), TOPJ_UINT16(0x727f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x323e), TOPJ_UINT16(0x0015), TOPJ_UINT16(0xb1bf), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0xf3ff), TOPJ_UINT16(0x88ce), TOPJ_UINT16(0x111f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x54de), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x647e), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0xcccf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x91be), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x22ef), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x222e), TOPJ_UINT16(0xf3fe), TOPJ_UINT16(0x888f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x00f7), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x115e), TOPJ_UINT16(0xfcfe), TOPJ_UINT16(0xa8af),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0035), TOPJ_UINT16(0xc8df), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x313e), TOPJ_UINT16(0x66fe), TOPJ_UINT16(0x646f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xc8ce), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0xf5ff), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0066), TOPJ_UINT16(0xf4fe), TOPJ_UINT16(0xbabf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x22ae), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x00e7), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x323e), TOPJ_UINT16(0xeafe), TOPJ_UINT16(0x737f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xb2be), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x55df), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x717e), TOPJ_UINT16(0x119f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0035), TOPJ_UINT16(0xc4cf), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x333e), TOPJ_UINT16(0xe8ee), TOPJ_UINT16(0x444f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x54de), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x647e), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x99bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x91be), TOPJ_UINT16(0x0045), TOPJ_UINT16(0xe2ef), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x222e), TOPJ_UINT16(0xf3fe), TOPJ_UINT16(0x667f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xe4ef), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x115e), TOPJ_UINT16(0xfcfe), TOPJ_UINT16(0x989f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x00d7), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x313e), TOPJ_UINT16(0x66fe), TOPJ_UINT16(0x226f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xc8ce), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0xb9ff), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0066), TOPJ_UINT16(0xf4fe), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x22ae), TOPJ_UINT16(0x0045), TOPJ_UINT16(0xd1df), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x323e), TOPJ_UINT16(0xeafe), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xb2be), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xecef), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x717e), TOPJ_UINT16(0x727f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0035), TOPJ_UINT16(0xb8bf), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x333e), TOPJ_UINT16(0xe8ee), TOPJ_UINT16(0x545f),
	TOPJ_UINT16(0xf1fc), TOPJ_UINT16(0xd1de), TOPJ_UINT16(0xfafd), TOPJ_UINT16(0x00d7), TOPJ_UINT16(0xf8fc), TOPJ_UINT16(0x0016), TOPJ_UINT16(0xfffd), TOPJ_UINT16(0x747f),
	TOPJ_UINT16(0xf4fc), TOPJ_UINT16(0x717e), TOPJ_UINT16(0xf3fd), TOPJ_UINT16(0xb3bf), TOPJ_UINT16(0xf2fc), TOPJ_UINT16(0xeaef), TOPJ_UINT16(0xe8ee), TOPJ_UINT16(0x444f),
	TOPJ_UINT16(0xf1fc), TOPJ_UINT16(0x22ae), TOPJ_UINT16(0x0005), TOPJ_UINT16(0xb8bf), TOPJ_UINT16(0xf8fc), TOPJ_UINT16(0x00f7), TOPJ_UINT16(0xfcfe), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0xf4fc), TOPJ_UINT16(0x115e), TOPJ_UINT16(0xf5fd), TOPJ_UINT16(0x757f), TOPJ_UINT16(0xf2fc), TOPJ_UINT16(0xd8df), TOPJ_UINT16(0xe2ee), TOPJ_UINT16(0x333f),
	TOPJ_UINT16(0xf1fc), TOPJ_UINT16(0xb2be), TOPJ_UINT16(0xfafd), TOPJ_UINT16(0x88cf), TOPJ_UINT16(0xf8fc), TOPJ_UINT16(0xfbff), TOPJ_UINT16(0xfffd), TOPJ_UINT16(0x737f),
	TOPJ_UINT16(0xf4fc), TOPJ_UINT16(0x006e), TOPJ_UINT16(0xf3fd), TOPJ_UINT16(0x00b7), TOPJ_UINT16(0xf2fc), TOPJ_UINT16(0x66ef), TOPJ_UINT16(0xf9fe), TOPJ_UINT16(0x313f),
	TOPJ_UINT16(0xf1fc), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0005), TOPJ_UINT16(0xbabf), TOPJ_UINT16(0xf8fc), TOPJ_UINT16(0xfdff), TOPJ_UINT16(0xf6fe), TOPJ_UINT16(0x0067),
	TOPJ_UINT16(0xf4fc), TOPJ_UINT16(0x0026), TOPJ_UINT16(0xf5fd), TOPJ_UINT16(0x888f), TOPJ_UINT16(0xf2fc), TOPJ_UINT16(0xdcdf), TOPJ_UINT16(0xd4de), TOPJ_UINT16(0x222f),
	TOPJ_UINT16(0xf1fc), TOPJ_UINT16(0xd1de), TOPJ_UINT16(0xfafd), TOPJ_UINT16(0xc4cf), TOPJ_UINT16(0xf8fc), TOPJ_UINT16(0x0016), TOPJ_UINT16(0xfffd), TOPJ_UINT16(0x727f),
	TOPJ_UINT16(0xf4fc), TOPJ_UINT16(0x717e), TOPJ_UINT16(0xf3fd), TOPJ_UINT16(0x99bf), TOPJ_UINT16(0xf2fc), TOPJ_UINT16(0xecef), TOPJ_UINT16(0xe8ee), TOPJ_UINT16(0x0047),
	TOPJ_UINT16(0xf1fc), TOPJ_UINT16(0x22ae), TOPJ_UINT16(0x0005), TOPJ_UINT16(0x00a7), TOPJ_UINT16(0xf8fc), TOPJ_UINT16(0xf7ff), TOPJ_UINT16(0xfcfe), TOPJ_UINT16(0x0057),
	TOPJ_UINT16(0xf4fc), TOPJ_UINT16(0x115e), TOPJ_UINT16(0xf5fd), TOPJ_UINT16(0x0097), TOPJ_UINT16(0xf2fc), TOPJ_UINT16(0xd5df), TOPJ_UINT16(0xe2ee), TOPJ_UINT16(0x0037),
	TOPJ_UINT16(0xf1fc), TOPJ_UINT16(0xb2be), TOPJ_UINT16(0xfafd), TOPJ_UINT16(0x00c7), TOPJ_UINT16(0xf8fc), TOPJ_UINT16(0xfeff), TOPJ_UINT16(0xfffd), TOPJ_UINT16(0x667f),
	TOPJ_UINT16(0xf4fc), TOPJ_UINT16(0x006e), TOPJ_UINT16(0xf3fd), TOPJ_UINT16(0xa8af), TOPJ_UINT16(0xf2fc), TOPJ_UINT16(0x00e7), TOPJ_UINT16(0xf9fe), TOPJ_UINT16(0x323f),
	TOPJ_UINT16(0xf1fc), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0005), TOPJ_UINT16(0xb1bf), TOPJ_UINT16(0xf8fc), TOPJ_UINT16(0xe4ef), TOPJ_UINT16(0xf6fe), TOPJ_UINT16(0x545f),
	TOPJ_UINT16(0xf4fc), TOPJ_UINT16(0x0026), TOPJ_UINT16(0xf5fd), TOPJ_UINT16(0x0087), TOPJ_UINT16(0xf2fc), TOPJ_UINT16(0x99df), TOPJ_UINT16(0xd4de), TOPJ_UINT16(0x111f),
} /* t1_ht_luts.h:1:25 */

var vlc_tbl1 = [1024]TOPJ_UINT16{
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x0065), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x00de), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x888d), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x444e),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x88ae), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x00d7),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x222e),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x0095), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x007e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x10fe), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x0065), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x88ce), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x888d), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x111e),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x005e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x00e7),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x00be), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x11ff),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x0095), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x003e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x40ee), TOPJ_UINT16(0x0023), TOPJ_UINT16(0xa2af),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x0065), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x00de), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x888d), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x444e),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x88ae), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x44ef),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x222e),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x0095), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x007e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x10fe), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x0065), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x88ce), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x888d), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x111e),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x005e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0023), TOPJ_UINT16(0xc4cf),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x00be), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x00f7),
	TOPJ_UINT16(0x0013), TOPJ_UINT16(0x0095), TOPJ_UINT16(0x0043), TOPJ_UINT16(0x003e), TOPJ_UINT16(0x0083), TOPJ_UINT16(0x40ee), TOPJ_UINT16(0x0023), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00d7),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x888f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00f7), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x222f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x40fe), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00bf), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0067),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x444f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00e7), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x113f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00cf),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x009f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00ef), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x323f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x40fe), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00af),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x44ff), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x005f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x007f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00df), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x111f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00bf),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00f7), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xf8ff), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x007f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00df), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x313f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x44ef), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xa2ae), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0067),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x51ff), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0097),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00cf), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x223f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xb2bf),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x40ef), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x72ff), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x009f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00d7), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x444f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xa8af),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00e7), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xa2ae), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x005f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x44ff), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x888f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xaaaf), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x111f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00b6), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x66ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00ce), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0035), TOPJ_UINT16(0xa8af),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00f6), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x313e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0045), TOPJ_UINT16(0xb3bf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xb2be), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xf5ff), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x517e), TOPJ_UINT16(0x545f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf2fe), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x22ae), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x44ef),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xf4ff), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0076), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x447f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x40de), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x323e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x00d7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88be), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xfaff), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x115e), TOPJ_UINT16(0xf1fe), TOPJ_UINT16(0x444f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00b6), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xc8ef),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00ce), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x888f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00f6), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x313e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0045), TOPJ_UINT16(0x44df),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xb2be), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xa8ff), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x517e), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf2fe), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x222e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x22ae), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x00e7),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xe2ef), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0076), TOPJ_UINT16(0x0035), TOPJ_UINT16(0x727f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x40de), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x323e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x0045), TOPJ_UINT16(0xb1bf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x88be), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x73ff), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x115e), TOPJ_UINT16(0xf1fe), TOPJ_UINT16(0x333f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x20ee), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xc4cf),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x32ff), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x888f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00af),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x22ef), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x005f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xcccf),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00f7), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x009f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00df), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x30fe), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x222f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x20ee), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0001), TOPJ_UINT16(0xc8cf),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x11ff), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0077),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x007f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00e7), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0037),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00b7),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00bf), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x003f),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0084), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0056), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0097),
	TOPJ_UINT16(0x0001), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x00d7), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x30fe), TOPJ_UINT16(0x0001), TOPJ_UINT16(0x111f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa8ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00d6), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0xf3ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xfcfe), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x003e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00b6), TOPJ_UINT16(0x0055), TOPJ_UINT16(0xd8df),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x207e), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x99ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00e6), TOPJ_UINT16(0x00f5), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x009f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf2fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0076), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x44ce), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x76ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf1fe), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00ae), TOPJ_UINT16(0x0055), TOPJ_UINT16(0xc8cf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf4fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x445e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x10be), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xe4ef),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x54de), TOPJ_UINT16(0x00f5), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x222f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xa8ee), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00d6), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0xfaff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xfcfe), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x003e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00b6), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x11bf),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x207e), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x22ef),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00e6), TOPJ_UINT16(0x00f5), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x227f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf2fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0076), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x44ce), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0xd5ff),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf1fe), TOPJ_UINT16(0x0025), TOPJ_UINT16(0x444e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x00ae), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0xf4fe), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x445e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x10be), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x11df),
	TOPJ_UINT16(0x0002), TOPJ_UINT16(0x54de), TOPJ_UINT16(0x00f5), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0002), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0015), TOPJ_UINT16(0x515f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00f6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0xd4df),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xa2ae), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x76ff), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x223e), TOPJ_UINT16(0x00b6), TOPJ_UINT16(0xaaaf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00e6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xf5ff), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xcccf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x44ef), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0036), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x317f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xe8ee), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xf1ff), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0076), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0xc4cf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x227e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0xd1df), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x444e), TOPJ_UINT16(0xf4fe), TOPJ_UINT16(0x515f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00d6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xe2ef), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x445e), TOPJ_UINT16(0x0085), TOPJ_UINT16(0x22bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0xc8df), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x222e), TOPJ_UINT16(0xf2fe), TOPJ_UINT16(0x226f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00f6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x888e), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0xb1bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xa2ae), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x33ff), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x223e), TOPJ_UINT16(0x00b6), TOPJ_UINT16(0xa8af),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00e6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xb9ff), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0066), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xa8bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x009e), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0xe4ef), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x0036), TOPJ_UINT16(0xf8fe), TOPJ_UINT16(0x646f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0xe8ee), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xfcff), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x0076), TOPJ_UINT16(0x00a5), TOPJ_UINT16(0xc8cf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x227e), TOPJ_UINT16(0x0055), TOPJ_UINT16(0xeaef), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x444e), TOPJ_UINT16(0xf4fe), TOPJ_UINT16(0x747f),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x00d6), TOPJ_UINT16(0x0014), TOPJ_UINT16(0xfaff), TOPJ_UINT16(0x0044), TOPJ_UINT16(0x445e), TOPJ_UINT16(0x0085), TOPJ_UINT16(0xb2bf),
	TOPJ_UINT16(0x0003), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x00c5), TOPJ_UINT16(0x44df), TOPJ_UINT16(0x0024), TOPJ_UINT16(0x222e), TOPJ_UINT16(0xf2fe), TOPJ_UINT16(0x313f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0xfafe), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0004), TOPJ_UINT16(0x32be), TOPJ_UINT16(0x0075), TOPJ_UINT16(0x11df),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x54de), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0xe4ef), TOPJ_UINT16(0x00d5), TOPJ_UINT16(0x717e), TOPJ_UINT16(0xfcfe), TOPJ_UINT16(0x737f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0xf3fe), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0004), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0055), TOPJ_UINT16(0xb1bf),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x00ce), TOPJ_UINT16(0x00b5), TOPJ_UINT16(0xd8df), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0x0066), TOPJ_UINT16(0xb9fe), TOPJ_UINT16(0x545f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x76fe), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x0026), TOPJ_UINT16(0x0004), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0075), TOPJ_UINT16(0x009f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x00ae), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0xf7ff), TOPJ_UINT16(0x00d5), TOPJ_UINT16(0x0046), TOPJ_UINT16(0xf5fe), TOPJ_UINT16(0x747f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x00e6), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x0016), TOPJ_UINT16(0x0004), TOPJ_UINT16(0x0086), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x888f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x00b5), TOPJ_UINT16(0xe2ef), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0x115e), TOPJ_UINT16(0xa8ee), TOPJ_UINT16(0x113f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0xfafe), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x0036), TOPJ_UINT16(0x0004), TOPJ_UINT16(0x32be), TOPJ_UINT16(0x0075), TOPJ_UINT16(0xd1df),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x54de), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0xfbff), TOPJ_UINT16(0x00d5), TOPJ_UINT16(0x717e), TOPJ_UINT16(0xfcfe), TOPJ_UINT16(0x447f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0xf3fe), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x111e), TOPJ_UINT16(0x0004), TOPJ_UINT16(0x0096), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x727f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x00ce), TOPJ_UINT16(0x00b5), TOPJ_UINT16(0x22ef), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0x0066), TOPJ_UINT16(0xb9fe), TOPJ_UINT16(0x444f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x76fe), TOPJ_UINT16(0xf1fd), TOPJ_UINT16(0x0026), TOPJ_UINT16(0x0004), TOPJ_UINT16(0x00a6), TOPJ_UINT16(0x0075), TOPJ_UINT16(0x11bf),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x00ae), TOPJ_UINT16(0xf2fd), TOPJ_UINT16(0xffff), TOPJ_UINT16(0x00d5), TOPJ_UINT16(0x0046), TOPJ_UINT16(0xf5fe), TOPJ_UINT16(0x323f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x00e6), TOPJ_UINT16(0xf8fd), TOPJ_UINT16(0x0016), TOPJ_UINT16(0x0004), TOPJ_UINT16(0x0086), TOPJ_UINT16(0x0055), TOPJ_UINT16(0x006f),
	TOPJ_UINT16(0x00f3), TOPJ_UINT16(0x00c6), TOPJ_UINT16(0x00b5), TOPJ_UINT16(0xb8bf), TOPJ_UINT16(0xf4fd), TOPJ_UINT16(0x115e), TOPJ_UINT16(0xa8ee), TOPJ_UINT16(0x222f),
} /* t1_ht_luts.h:132:25 */

/////////////////////////////////////////////////////////////////////////////
// compiler detection
/////////////////////////////////////////////////////////////////////////////

//************************************************************************/
// * @brief Displays the error message for disabling the decoding of SPP and
// MRP passes
var only_cleanup_pass_is_decoded TOPJ_BOOL = DOPJ_FALSE /* ht_dec.c:62:17 */

//************************************************************************/
// * @brief Generates population count (i.e., the number of set bits)
//
//   @param [in]  val is the value for which population count is sought
func population_count(tls *libc.TLS, val TOPJ_UINT32) TOPJ_UINT32 { /* ht_dec.c:70:12: */
	return TOPJ_UINT32(libc.X__builtin_popcount(tls, val))
}

//************************************************************************/
// * @brief Counts the number of leading zeros
//
//   @param [in]  val is the value for which leading zero count is sought
func count_leading_zeros(tls *libc.TLS, val TOPJ_UINT32) TOPJ_UINT32 { /* ht_dec.c:95:12: */
	return TOPJ_UINT32(libc.X__builtin_clz(tls, val))
}

//************************************************************************/
// * @brief Read a little-endian serialized UINT32.
//
//   @param [in]  dataIn pointer to byte stream to read from
func read_le_uint32(tls *libc.TLS, dataIn uintptr) TOPJ_UINT32 { /* ht_dec.c:118:26: */
	return *(*TOPJ_UINT32)(unsafe.Pointer(dataIn))
}

//************************************************************************/
// * @brief MEL state structure for reading and decoding the MEL bitstream
//
//  A number of events is decoded from the MEL bitstream ahead of time
//  and stored in run/num_runs.
//  Each run represents the number of zero events before a one event.
type Sdec_mel = struct {
	Fdata        uintptr
	Ftmp         TOPJ_UINT64
	Fbits        int32
	Fsize        int32
	Funstuff     TOPJ_BOOL
	Fk           int32
	Fnum_runs    int32
	Fruns        TOPJ_UINT64
	F__ccgo_pad1 [4]byte
} /* ht_dec.c:138:9 */

//************************************************************************/
// * @brief MEL state structure for reading and decoding the MEL bitstream
//
//  A number of events is decoded from the MEL bitstream ahead of time
//  and stored in run/num_runs.
//  Each run represents the number of zero events before a one event.
type Tdec_mel_t = Sdec_mel /* ht_dec.c:150:3 */

//************************************************************************/
// * @brief Reads and unstuffs the MEL bitstream
//
//  This design needs more bytes in the codeblock buffer than the length
//  of the cleanup pass by up to 2 bytes.
//
//  Unstuffing removes the MSB of the byte following a byte whose
//  value is 0xFF; this prevents sequences larger than 0xFF7F in value
//  from appearing the bitstream.
//
//  @param [in]  melp is a pointer to dec_mel_t structure
func mel_read(tls *libc.TLS, melp uintptr) { /* ht_dec.c:165:6: */
	var val TOPJ_UINT32
	var bits int32
	var t TOPJ_UINT32
	var unstuff TOPJ_BOOL

	if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fbits > 32 { //there are enough bits in the tmp variable
		return // return without reading new data
	}

	val = 0xFFFFFFFF                                   // feed in 0xFF if buffer is exhausted
	if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize > 4 { // if there is more than 4 bytes the MEL segment
		val = read_le_uint32(tls, (*Tdec_mel_t)(unsafe.Pointer(melp)).Fdata) // read 32 bits from MEL data
		*(*uintptr)(unsafe.Pointer(melp)) += uintptr(4)                      // advance pointer
		*(*int32)(unsafe.Pointer(melp + 16)) -= 4                            // reduce counter
	} else if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize > 0 { // 4 or less
		var m TOPJ_UINT32
		var v TOPJ_UINT32
		var i int32 = 0
		for (*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize > 1 {
			var v TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostIncUintptr(&(*Tdec_mel_t)(unsafe.Pointer(melp)).Fdata, 1)))) // read one byte at a time
			var m TOPJ_UINT32 = ^(uint32(0xFF) << i)                                                                                            // mask of location
			val = val&m | v<<i                                                                                                                  // put byte in its correct location
			(*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize--
			i = i + 8
		}
		// size equal to 1
		v = TOPJ_UINT32(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostIncUintptr(&(*Tdec_mel_t)(unsafe.Pointer(melp)).Fdata, 1)))) // the one before the last is different
		v = v | TOPJ_UINT32(0xF)                                                                                            // MEL and VLC segments can overlap
		m = ^(uint32(0xFF) << i)
		val = val&m | v<<i
		(*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize--
	}

	// next we unstuff them before adding them to the buffer
	bits = 32 - (*Tdec_mel_t)(unsafe.Pointer(melp)).Funstuff // number of bits in val, subtract 1 if
	// the previously read byte requires
	// unstuffing

	// data is unstuffed and accumulated in t
	// bits has the number of bits in t
	t = val & TOPJ_UINT32(0xFF)
	unstuff = libc.Bool32(val&TOPJ_UINT32(0xFF) == TOPJ_UINT32(0xFF)) // true if the byte needs unstuffing
	bits = bits - unstuff                                             // there is one less bit in t if unstuffing is needed
	t = t << (8 - unstuff)                                            // move up to make room for the next byte

	//this is a repeat of the above
	t = t | val>>8&TOPJ_UINT32(0xFF)
	unstuff = libc.Bool32(val>>8&TOPJ_UINT32(0xFF) == TOPJ_UINT32(0xFF))
	bits = bits - unstuff
	t = t << (8 - unstuff)

	t = t | val>>16&TOPJ_UINT32(0xFF)
	unstuff = libc.Bool32(val>>16&TOPJ_UINT32(0xFF) == TOPJ_UINT32(0xFF))
	bits = bits - unstuff
	t = t << (8 - unstuff)

	t = t | val>>24&TOPJ_UINT32(0xFF)
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Funstuff = libc.Bool32(val>>24&TOPJ_UINT32(0xFF) == TOPJ_UINT32(0xFF))

	// move t to tmp, and push the result all the way up, so we read from
	// the MSB
	*(*TOPJ_UINT64)(unsafe.Pointer(melp + 8)) |= TOPJ_UINT64(t) << (64 - bits - (*Tdec_mel_t)(unsafe.Pointer(melp)).Fbits)
	*(*int32)(unsafe.Pointer(melp + 12)) += bits //increment the number of bits in tmp
}

//************************************************************************/
// * @brief Decodes unstuffed MEL segment bits stored in tmp to runs
//
//  Runs are stored in "runs" and the number of runs in "num_runs".
//  Each run represents a number of zero events that may or may not
//  terminate in a 1 event.
//  Each run is stored in 7 bits.  The LSB is 1 if the run terminates in
//  a 1 event, 0 otherwise.  The next 6 bits, for the case terminating
//  with 1, contain the number of consecutive 0 zero events * 2; for the
//  case terminating with 0, they store (number of consecutive 0 zero
//  events - 1) * 2.
//  A total of 6 bits (made up of 1 + 5) should have been enough.
//
//  @param [in]  melp is a pointer to dec_mel_t structure
func mel_decode(tls *libc.TLS, melp uintptr) { /* ht_dec.c:247:6: */

	if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fbits < 6 { // if there are less than 6 bits in tmp
		mel_read(tls, melp) // then read from the MEL bitstream
	}
	// 6 bits is the largest decodable MEL cwd

	//repeat so long that there is enough decodable bits in tmp,
	// and the runs store is not full (num_runs < 8)
	for (*Tdec_mel_t)(unsafe.Pointer(melp)).Fbits >= 6 && (*Tdec_mel_t)(unsafe.Pointer(melp)).Fnum_runs < 8 {
		var eval int32 = mel_exp[(*Tdec_mel_t)(unsafe.Pointer(melp)).Fk] // number of bits associated with state
		var run int32 = 0
		if uint64((*Tdec_mel_t)(unsafe.Pointer(melp)).Ftmp)&(uint64(1)<<63) != 0 { //The next bit to decode (stored in MSB)
			//one is found
			run = int32(1) << eval
			run-- // consecutive runs of 0 events - 1
			(*Tdec_mel_t)(unsafe.Pointer(melp)).Fk = func() int32 {
				if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fk+1 < 12 {
					return (*Tdec_mel_t)(unsafe.Pointer(melp)).Fk + 1
				}
				return 12
			}() //increment, max is 12
			libc.AssignShlPtrUint32(melp+8, int(1)) // consume one bit from tmp
			*(*int32)(unsafe.Pointer(melp + 12)) -= 1
			run = run << 1 // a stretch of zeros not terminating in one
		} else {
			//0 is found
			run = int32((*Tdec_mel_t)(unsafe.Pointer(melp)).Ftmp>>(63-eval)) & (int32(1)<<eval - 1)
			(*Tdec_mel_t)(unsafe.Pointer(melp)).Fk = func() int32 {
				if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fk-1 > 0 {
					return (*Tdec_mel_t)(unsafe.Pointer(melp)).Fk - 1
				}
				return 0
			}() //decrement, min is 0
			libc.AssignShlPtrUint32(melp+8, int(eval+1)) //consume eval + 1 bits (max is 6)
			*(*int32)(unsafe.Pointer(melp + 12)) -= eval + 1
			run = run<<1 + 1 // a stretch of zeros terminating with one
		}
		eval = (*Tdec_mel_t)(unsafe.Pointer(melp)).Fnum_runs * 7                                // 7 bits per run
		*(*TOPJ_UINT64)(unsafe.Pointer(melp + 32)) &= ^(TOPJ_UINT64(TOPJ_UINT64(0x3F)) << eval) // 6 bits are sufficient
		*(*TOPJ_UINT64)(unsafe.Pointer(melp + 32)) |= TOPJ_UINT64(run) << eval                  // store the value in runs
		(*Tdec_mel_t)(unsafe.Pointer(melp)).Fnum_runs++                                         // increment count
	}
}

var mel_exp = [13]int32{ //MEL exponents
	0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 4, 5,
} /* ht_dec.c:249:22 */

//************************************************************************/
// * @brief Initiates a dec_mel_t structure for MEL decoding and reads
//         some bytes in order to get the read address to a multiple
//         of 4
//
//  @param [in]  melp is a pointer to dec_mel_t structure
//  @param [in]  bbuf is a pointer to byte buffer
//  @param [in]  lcup is the length of MagSgn+MEL+VLC segments
//  @param [in]  scup is the length of MEL+VLC segments
func mel_init(tls *libc.TLS, melp uintptr, bbuf uintptr, lcup int32, scup int32) { /* ht_dec.c:297:6: */
	var num int32
	var i int32

	(*Tdec_mel_t)(unsafe.Pointer(melp)).Fdata = bbuf + uintptr(lcup) - uintptr(scup) // move the pointer to the start of MEL
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Fbits = 0                                    // 0 bits in tmp
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Ftmp = TOPJ_UINT64(0)                        //
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Funstuff = DOPJ_FALSE                        // no unstuffing
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize = scup - 1                             // size is the length of MEL+VLC-1
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Fk = 0                                       // 0 for state
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Fnum_runs = 0                                // num_runs is 0
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Fruns = TOPJ_UINT64(0)                       //

	//This code is borrowed; original is for a different architecture
	//These few lines take care of the case where data is not at a multiple
	// of 4 boundary.  It reads 1,2,3 up to 4 bytes from the MEL segment
	num = 4 - int32(Tintptr_t((*Tdec_mel_t)(unsafe.Pointer(melp)).Fdata)&0x3)
	for i = 0; i < num; i++ { // this code is similar to mel_read
		var d TOPJ_UINT64
		var d_bits int32

		if (*Tdec_mel_t)(unsafe.Pointer(melp)).Funstuff == DOPJ_FALSE || int32(*(*TOPJ_UINT8)(unsafe.Pointer((*Tdec_mel_t)(unsafe.Pointer(melp)).Fdata))) <= 0x8F {
		} else {
			libc.X__assert_fail(tls, ts+1786, ts+1838, uint32(319), uintptr(unsafe.Pointer(&__func__52)))
		}
		if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize > 0 {
			d = uint32(*(*TOPJ_UINT8)(unsafe.Pointer((*Tdec_mel_t)(unsafe.Pointer(melp)).Fdata)))
		} else {
			d = uint32(0xFF)
		} // if buffer is consumed
		// set data to 0xFF
		if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize == 1 {
			d = d | TOPJ_UINT64(0xF) //if this is MEL+VLC-1, set LSBs to 0xF
		}
		// see the standard
		*(*uintptr)(unsafe.Pointer(melp)) += uintptr(libc.Bool32(libc.PostDecInt32(&(*Tdec_mel_t)(unsafe.Pointer(melp)).Fsize, 1) > 0)) //increment if the end is not reached
		d_bits = 8 - (*Tdec_mel_t)(unsafe.Pointer(melp)).Funstuff                                                                       //if unstuffing is needed, reduce by 1
		(*Tdec_mel_t)(unsafe.Pointer(melp)).Ftmp = (*Tdec_mel_t)(unsafe.Pointer(melp)).Ftmp<<d_bits | d                                 //store bits in tmp
		*(*int32)(unsafe.Pointer(melp + 12)) += d_bits                                                                                  //increment tmp by number of bits
		(*Tdec_mel_t)(unsafe.Pointer(melp)).Funstuff = libc.Bool32(d&TOPJ_UINT64(0xFF) == TOPJ_UINT64(0xFF))                            //true of next byte needs
		//unstuffing
	}
	libc.AssignShlPtrUint32(melp+8, int(64-(*Tdec_mel_t)(unsafe.Pointer(melp)).Fbits)) //push all the way up so the first bit
	// is the MSB
}

var __func__52 = *(*[9]int8)(unsafe.Pointer(ts + 1866)) /* ht_dec.c:298:1 */

//************************************************************************/
// * @brief Retrieves one run from dec_mel_t; if there are no runs stored
//         MEL segment is decoded
//
// @param [in]  melp is a pointer to dec_mel_t structure
func mel_get_run(tls *libc.TLS, melp uintptr) int32 { /* ht_dec.c:344:5: */
	var t int32
	if (*Tdec_mel_t)(unsafe.Pointer(melp)).Fnum_runs == 0 { //if no runs, decode more bit from MEL segment
		mel_decode(tls, melp)
	}

	t = int32((*Tdec_mel_t)(unsafe.Pointer(melp)).Fruns & TOPJ_UINT64(0x7F)) //retrieve one run
	libc.AssignShrPtrUint32(melp+32, int(7))                                 // remove the retrieved run
	(*Tdec_mel_t)(unsafe.Pointer(melp)).Fnum_runs--
	return t // return run
}

//************************************************************************/
// * @brief A structure for reading and unstuffing a segment that grows
//         backward, such as VLC and MRP
type Srev_struct = struct {
	Fdata    uintptr
	Ftmp     TOPJ_UINT64
	Fbits    TOPJ_UINT32
	Fsize    int32
	Funstuff TOPJ_BOOL
} /* ht_dec.c:361:9 */

//************************************************************************/
// * @brief A structure for reading and unstuffing a segment that grows
//         backward, such as VLC and MRP
type Trev_struct_t = Srev_struct /* ht_dec.c:369:3 */

//************************************************************************/
// * @brief Read and unstuff data from a backwardly-growing segment
//
//  This reader can read up to 8 bytes from before the VLC segment.
//  Care must be taken not read from unreadable memory, causing a
//  segmentation fault.
//
//  Note that there is another subroutine rev_read_mrp that is slightly
//  different.  The other one fills zeros when the buffer is exhausted.
//  This one basically does not care if the bytes are consumed, because
//  any extra data should not be used in the actual decoding.
//
//  Unstuffing is needed to prevent sequences more than 0xFF8F from
//  appearing in the bits stream; since we are reading backward, we keep
//  watch when a value larger than 0x8F appears in the bitstream.
//  If the byte following this is 0x7F, we unstuff this byte (ignore the
//  MSB of that byte, which should be 0).
//
//  @param [in]  vlcp is a pointer to rev_struct_t structure
func rev_read(tls *libc.TLS, vlcp uintptr) { /* ht_dec.c:392:6: */
	var val TOPJ_UINT32
	var tmp TOPJ_UINT32
	var bits TOPJ_UINT32
	var unstuff TOPJ_BOOL

	//process 4 bytes at a time
	if (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fbits > TOPJ_UINT32(32) { // if there are more than 32 bits in tmp, then
		return // reading 32 bits can overflow vlcp->tmp
	}
	val = TOPJ_UINT32(0)
	//the next line (the if statement) needs to be tested first
	if (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fsize > 3 { // if there are more than 3 bytes left in VLC
		// (vlcp->data - 3) move pointer back to read 32 bits at once
		val = read_le_uint32(tls, (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fdata-uintptr(3)) // then read 32 bits
		*(*uintptr)(unsafe.Pointer(vlcp)) -= uintptr(4)                                    // move data pointer back by 4
		*(*int32)(unsafe.Pointer(vlcp + 16)) -= 4                                          // reduce available byte by 4
	} else if (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fsize > 0 { // 4 or less
		var i int32 = 24
		for (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fsize > 0 {
			var v TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostDecUintptr(&(*Trev_struct_t)(unsafe.Pointer(vlcp)).Fdata, 1)))) // read one byte at a time
			val = val | v<<i                                                                                                                       // put byte in its correct location
			(*Trev_struct_t)(unsafe.Pointer(vlcp)).Fsize--
			i = i - 8
		}
	}

	//accumulate in tmp, number of bits in tmp are stored in bits
	tmp = val >> 24 //start with the MSB byte

	// test unstuff (previous byte is >0x8F), and this byte is 0x7F
	bits = 8 - func() uint32 {
		if (*Trev_struct_t)(unsafe.Pointer(vlcp)).Funstuff != 0 && val>>24&TOPJ_UINT32(0x7F) == TOPJ_UINT32(0x7F) {
			return 1
		}
		return 0
	}()
	unstuff = libc.Bool32(val>>24 > TOPJ_UINT32(0x8F)) //this is for the next byte

	tmp = tmp | val>>16&TOPJ_UINT32(0xFF)<<bits //process the next byte
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 && val>>16&TOPJ_UINT32(0x7F) == TOPJ_UINT32(0x7F) {
			return 1
		}
		return 0
	}())
	unstuff = libc.Bool32(val>>16&TOPJ_UINT32(0xFF) > TOPJ_UINT32(0x8F))

	tmp = tmp | val>>8&TOPJ_UINT32(0xFF)<<bits
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 && val>>8&TOPJ_UINT32(0x7F) == TOPJ_UINT32(0x7F) {
			return 1
		}
		return 0
	}())
	unstuff = libc.Bool32(val>>8&TOPJ_UINT32(0xFF) > TOPJ_UINT32(0x8F))

	tmp = tmp | val&TOPJ_UINT32(0xFF)<<bits
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 && val&TOPJ_UINT32(0x7F) == TOPJ_UINT32(0x7F) {
			return 1
		}
		return 0
	}())
	unstuff = libc.Bool32(val&TOPJ_UINT32(0xFF) > TOPJ_UINT32(0x8F))

	// now move the read and unstuffed bits into vlcp->tmp
	*(*TOPJ_UINT64)(unsafe.Pointer(vlcp + 8)) |= TOPJ_UINT64(tmp) << (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fbits
	*(*TOPJ_UINT32)(unsafe.Pointer(vlcp + 12)) += bits
	(*Trev_struct_t)(unsafe.Pointer(vlcp)).Funstuff = unstuff // this for the next read
}

//************************************************************************/
// * @brief Initiates the rev_struct_t structure and reads a few bytes to
//         move the read address to multiple of 4
//
//  There is another similar rev_init_mrp subroutine.  The difference is
//  that this one, rev_init, discards the first 12 bits (they have the
//  sum of the lengths of VLC and MEL segments), and first unstuff depends
//  on first 4 bits.
//
//  @param [in]  vlcp is a pointer to rev_struct_t structure
//  @param [in]  data is a pointer to byte at the start of the cleanup pass
//  @param [in]  lcup is the length of MagSgn+MEL+VLC segments
//  @param [in]  scup is the length of MEL+VLC segments
func rev_init(tls *libc.TLS, vlcp uintptr, data uintptr, lcup int32, scup int32) { /* ht_dec.c:460:6: */
	var d TOPJ_UINT32
	var num int32
	var tnum int32
	var i int32

	//first byte has only the upper 4 bits
	(*Trev_struct_t)(unsafe.Pointer(vlcp)).Fdata = data + uintptr(lcup) - uintptr(2)

	//size can not be larger than this, in fact it should be smaller
	(*Trev_struct_t)(unsafe.Pointer(vlcp)).Fsize = scup - 2

	d = TOPJ_UINT32(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostDecUintptr(&(*Trev_struct_t)(unsafe.Pointer(vlcp)).Fdata, 1))))                                    // read one byte (this is a half byte)
	(*Trev_struct_t)(unsafe.Pointer(vlcp)).Ftmp = TOPJ_UINT64(d >> 4)                                                                                         // both initialize and set
	(*Trev_struct_t)(unsafe.Pointer(vlcp)).Fbits = TOPJ_UINT32(4 - libc.Bool32((*Trev_struct_t)(unsafe.Pointer(vlcp)).Ftmp&TOPJ_UINT64(7) == TOPJ_UINT64(7))) //check standard
	(*Trev_struct_t)(unsafe.Pointer(vlcp)).Funstuff = libc.Bool32(d|TOPJ_UINT32(0xF) > TOPJ_UINT32(0x8F))                                                     //this is useful for the next byte

	//This code is designed for an architecture that read address should
	// align to the read size (address multiple of 4 if read size is 4)
	//These few lines take care of the case where data is not at a multiple
	// of 4 boundary. It reads 1,2,3 up to 4 bytes from the VLC bitstream.
	// To read 32 bits, read from (vlcp->data - 3)
	num = 1 + int32(Tintptr_t((*Trev_struct_t)(unsafe.Pointer(vlcp)).Fdata)&0x3)
	if num < (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fsize {
		tnum = num
	} else {
		tnum = (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fsize
	}
	for i = 0; i < tnum; i++ {
		var d TOPJ_UINT64
		var d_bits TOPJ_UINT32
		d = TOPJ_UINT64(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostDecUintptr(&(*Trev_struct_t)(unsafe.Pointer(vlcp)).Fdata, 1)))) // read one byte and move read pointer
		//check if the last byte was >0x8F (unstuff == true) and this is 0x7F
		d_bits = 8 - func() uint32 {
			if (*Trev_struct_t)(unsafe.Pointer(vlcp)).Funstuff != 0 && d&TOPJ_UINT64(0x7F) == TOPJ_UINT64(0x7F) {
				return 1
			}
			return 0
		}()
		*(*TOPJ_UINT64)(unsafe.Pointer(vlcp + 8)) |= d << (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fbits // move data to vlcp->tmp
		*(*TOPJ_UINT32)(unsafe.Pointer(vlcp + 12)) += d_bits
		(*Trev_struct_t)(unsafe.Pointer(vlcp)).Funstuff = libc.Bool32(d > TOPJ_UINT64(0x8F)) // for next byte
	}
	*(*int32)(unsafe.Pointer(vlcp + 16)) -= tnum
	rev_read(tls, vlcp) // read another 32 buts
}

//************************************************************************/
// * @brief Retrieves 32 bits from the head of a rev_struct structure
//
//  By the end of this call, vlcp->tmp must have no less than 33 bits
//
//  @param [in]  vlcp is a pointer to rev_struct structure
func rev_fetch(tls *libc.TLS, vlcp uintptr) TOPJ_UINT32 { /* ht_dec.c:505:12: */
	if (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fbits < TOPJ_UINT32(32) { // if there are less then 32 bits, read more
		rev_read(tls, vlcp)                                                 // read 32 bits, but unstuffing might reduce this
		if (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fbits < TOPJ_UINT32(32) { // if there is still space in vlcp->tmp for 32 bits
			rev_read(tls, vlcp) // read another 32
		}
	}
	return TOPJ_UINT32((*Trev_struct_t)(unsafe.Pointer(vlcp)).Ftmp) // return the head (bottom-most) of vlcp->tmp
}

//************************************************************************/
// * @brief Consumes num_bits from a rev_struct structure
//
//  @param [in]  vlcp is a pointer to rev_struct structure
//  @param [in]  num_bits is the number of bits to be removed
func rev_advance(tls *libc.TLS, vlcp uintptr, num_bits TOPJ_UINT32) TOPJ_UINT32 { /* ht_dec.c:523:12: */
	if num_bits <= (*Trev_struct_t)(unsafe.Pointer(vlcp)).Fbits {
	} else {
		libc.X__assert_fail(tls, ts+1875, ts+1838, uint32(525), uintptr(unsafe.Pointer(&__func__53)))
	} // vlcp->tmp must have more than num_bits
	libc.AssignShrPtrUint32(vlcp+8, int(num_bits))         // remove bits
	*(*TOPJ_UINT32)(unsafe.Pointer(vlcp + 12)) -= num_bits // decrement the number of bits
	return TOPJ_UINT32((*Trev_struct_t)(unsafe.Pointer(vlcp)).Ftmp)
}

var __func__53 = *(*[12]int8)(unsafe.Pointer(ts + 1898)) /* ht_dec.c:524:1 */

//************************************************************************/
// * @brief Reads and unstuffs from rev_struct
//
//  This is different than rev_read in that this fills in zeros when the
//  the available data is consumed.  The other does not care about the
//  values when all data is consumed.
//
//  See rev_read for more information about unstuffing
//
//  @param [in]  mrp is a pointer to rev_struct structure
func rev_read_mrp(tls *libc.TLS, mrp uintptr) { /* ht_dec.c:543:6: */
	var val TOPJ_UINT32
	var tmp TOPJ_UINT32
	var bits TOPJ_UINT32
	var unstuff TOPJ_BOOL

	//process 4 bytes at a time
	if (*Trev_struct_t)(unsafe.Pointer(mrp)).Fbits > TOPJ_UINT32(32) {
		return
	}
	val = TOPJ_UINT32(0)
	if (*Trev_struct_t)(unsafe.Pointer(mrp)).Fsize > 3 { // If there are 3 byte or more
		// (mrp->data - 3) move pointer back to read 32 bits at once
		val = read_le_uint32(tls, (*Trev_struct_t)(unsafe.Pointer(mrp)).Fdata-uintptr(3)) // read 32 bits
		*(*uintptr)(unsafe.Pointer(mrp)) -= uintptr(4)                                    // move back pointer
		*(*int32)(unsafe.Pointer(mrp + 16)) -= 4                                          // reduce count
	} else if (*Trev_struct_t)(unsafe.Pointer(mrp)).Fsize > 0 {
		var i int32 = 24
		for (*Trev_struct_t)(unsafe.Pointer(mrp)).Fsize > 0 {
			var v TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostDecUintptr(&(*Trev_struct_t)(unsafe.Pointer(mrp)).Fdata, 1)))) // read one byte at a time
			val = val | v<<i                                                                                                                      // put byte in its correct location
			(*Trev_struct_t)(unsafe.Pointer(mrp)).Fsize--
			i = i - 8
		}
	}

	//accumulate in tmp, and keep count in bits
	tmp = val >> 24

	//test if the last byte > 0x8F (unstuff must be true) and this is 0x7F
	bits = 8 - func() uint32 {
		if (*Trev_struct_t)(unsafe.Pointer(mrp)).Funstuff != 0 && val>>24&TOPJ_UINT32(0x7F) == TOPJ_UINT32(0x7F) {
			return 1
		}
		return 0
	}()
	unstuff = libc.Bool32(val>>24 > TOPJ_UINT32(0x8F))

	//process the next byte
	tmp = tmp | val>>16&TOPJ_UINT32(0xFF)<<bits
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 && val>>16&TOPJ_UINT32(0x7F) == TOPJ_UINT32(0x7F) {
			return 1
		}
		return 0
	}())
	unstuff = libc.Bool32(val>>16&TOPJ_UINT32(0xFF) > TOPJ_UINT32(0x8F))

	tmp = tmp | val>>8&TOPJ_UINT32(0xFF)<<bits
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 && val>>8&TOPJ_UINT32(0x7F) == TOPJ_UINT32(0x7F) {
			return 1
		}
		return 0
	}())
	unstuff = libc.Bool32(val>>8&TOPJ_UINT32(0xFF) > TOPJ_UINT32(0x8F))

	tmp = tmp | val&TOPJ_UINT32(0xFF)<<bits
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 && val&TOPJ_UINT32(0x7F) == TOPJ_UINT32(0x7F) {
			return 1
		}
		return 0
	}())
	unstuff = libc.Bool32(val&TOPJ_UINT32(0xFF) > TOPJ_UINT32(0x8F))

	*(*TOPJ_UINT64)(unsafe.Pointer(mrp + 8)) |= TOPJ_UINT64(tmp) << (*Trev_struct_t)(unsafe.Pointer(mrp)).Fbits // move data to mrp pointer
	*(*TOPJ_UINT32)(unsafe.Pointer(mrp + 12)) += bits
	(*Trev_struct_t)(unsafe.Pointer(mrp)).Funstuff = unstuff // next byte
}

//************************************************************************/
// * @brief Initialized rev_struct structure for MRP segment, and reads
//         a number of bytes such that the next 32 bits read are from
//         an address that is a multiple of 4. Note this is designed for
//         an architecture that read size must be compatible with the
//         alignment of the read address
//
//  There is another similar subroutine rev_init.  This subroutine does
//  NOT skip the first 12 bits, and starts with unstuff set to true.
//
//  @param [in]  mrp is a pointer to rev_struct structure
//  @param [in]  data is a pointer to byte at the start of the cleanup pass
//  @param [in]  lcup is the length of MagSgn+MEL+VLC segments
//  @param [in]  len2 is the length of SPP+MRP segments
func rev_init_mrp(tls *libc.TLS, mrp uintptr, data uintptr, lcup int32, len2 int32) { /* ht_dec.c:612:6: */
	var num int32
	var i int32

	(*Trev_struct_t)(unsafe.Pointer(mrp)).Fdata = data + uintptr(lcup) + uintptr(len2) - uintptr(1)
	(*Trev_struct_t)(unsafe.Pointer(mrp)).Fsize = len2
	(*Trev_struct_t)(unsafe.Pointer(mrp)).Funstuff = DOPJ_TRUE
	(*Trev_struct_t)(unsafe.Pointer(mrp)).Fbits = TOPJ_UINT32(0)
	(*Trev_struct_t)(unsafe.Pointer(mrp)).Ftmp = TOPJ_UINT64(0)

	//This code is designed for an architecture that read address should
	// align to the read size (address multiple of 4 if read size is 4)
	//These few lines take care of the case where data is not at a multiple
	// of 4 boundary.  It reads 1,2,3 up to 4 bytes from the MRP stream
	num = 1 + int32(Tintptr_t((*Trev_struct_t)(unsafe.Pointer(mrp)).Fdata)&0x3)
	for i = 0; i < num; i++ {
		var d TOPJ_UINT64
		var d_bits TOPJ_UINT32

		//read a byte, 0 if no more data
		if libc.PostDecInt32(&(*Trev_struct_t)(unsafe.Pointer(mrp)).Fsize, 1) > 0 {
			d = uint32(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostDecUintptr(&(*Trev_struct_t)(unsafe.Pointer(mrp)).Fdata, 1))))
		} else {
			d = uint32(0)
		}
		//check if unstuffing is needed
		d_bits = 8 - func() uint32 {
			if (*Trev_struct_t)(unsafe.Pointer(mrp)).Funstuff != 0 && d&TOPJ_UINT64(0x7F) == TOPJ_UINT64(0x7F) {
				return 1
			}
			return 0
		}()
		*(*TOPJ_UINT64)(unsafe.Pointer(mrp + 8)) |= d << (*Trev_struct_t)(unsafe.Pointer(mrp)).Fbits // move data to vlcp->tmp
		*(*TOPJ_UINT32)(unsafe.Pointer(mrp + 12)) += d_bits
		(*Trev_struct_t)(unsafe.Pointer(mrp)).Funstuff = libc.Bool32(d > TOPJ_UINT64(0x8F)) // for next byte
	}
	rev_read_mrp(tls, mrp)
}

//************************************************************************/
// * @brief Retrieves 32 bits from the head of a rev_struct structure
//
//  By the end of this call, mrp->tmp must have no less than 33 bits
//
//  @param [in]  mrp is a pointer to rev_struct structure
func rev_fetch_mrp(tls *libc.TLS, mrp uintptr) TOPJ_UINT32 { /* ht_dec.c:650:12: */
	if (*Trev_struct_t)(unsafe.Pointer(mrp)).Fbits < TOPJ_UINT32(32) { // if there are less than 32 bits in mrp->tmp
		rev_read_mrp(tls, mrp)                                             // read 30-32 bits from mrp
		if (*Trev_struct_t)(unsafe.Pointer(mrp)).Fbits < TOPJ_UINT32(32) { // if there is a space of 32 bits
			rev_read_mrp(tls, mrp) // read more
		}
	}
	return TOPJ_UINT32((*Trev_struct_t)(unsafe.Pointer(mrp)).Ftmp) // return the head of mrp->tmp
}

//************************************************************************/
// * @brief Consumes num_bits from a rev_struct structure
//
//  @param [in]  mrp is a pointer to rev_struct structure
//  @param [in]  num_bits is the number of bits to be removed
func rev_advance_mrp(tls *libc.TLS, mrp uintptr, num_bits TOPJ_UINT32) TOPJ_UINT32 { /* ht_dec.c:668:12: */
	if num_bits <= (*Trev_struct_t)(unsafe.Pointer(mrp)).Fbits {
	} else {
		libc.X__assert_fail(tls, ts+1910, ts+1838, uint32(670), uintptr(unsafe.Pointer(&__func__54)))
	} // we must not consume more than mrp->bits
	libc.AssignShrPtrUint32(mrp+8, int(num_bits)) // discard the lowest num_bits bits
	*(*TOPJ_UINT32)(unsafe.Pointer(mrp + 12)) -= num_bits
	return TOPJ_UINT32((*Trev_struct_t)(unsafe.Pointer(mrp)).Ftmp) // return data after consumption
}

var __func__54 = *(*[16]int8)(unsafe.Pointer(ts + 1932)) /* ht_dec.c:669:1 */

//************************************************************************/
// * @brief Decode initial UVLC to get the u value (or u_q)
//
//  @param [in]  vlc is the head of the VLC bitstream
//  @param [in]  mode is 0, 1, 2, 3, or 4. Values in 0 to 3 are composed of
//               u_off of 1st quad and 2nd quad of a quad pair.  The value
//               4 occurs when both bits are 1, and the event decoded
//               from MEL bitstream is also 1.
//  @param [out] u is the u value (or u_q) + 1.  Note: we produce u + 1;
//               this value is a partial calculation of u + kappa.
func decode_init_uvlc(tls *libc.TLS, vlc TOPJ_UINT32, mode TOPJ_UINT32, u uintptr) TOPJ_UINT32 { /* ht_dec.c:688:12: */

	var consumed_bits TOPJ_UINT32 = TOPJ_UINT32(0)
	if mode == TOPJ_UINT32(0) { // both u_off are 0
		*(*TOPJ_UINT32)(unsafe.Pointer(u)) = libc.AssignPtrUint32(u+1*4, TOPJ_UINT32(1)) //Kappa is 1 for initial line
	} else if mode <= TOPJ_UINT32(2) { // u_off are either 01 or 10
		var d TOPJ_UINT32
		var suffix_len TOPJ_UINT32

		d = TOPJ_UINT32(dec[vlc&TOPJ_UINT32(0x7)]) //look at the least significant 3 bits
		vlc >>= d & TOPJ_UINT32(0x3)               //prefix length
		consumed_bits = consumed_bits + d&TOPJ_UINT32(0x3)

		suffix_len = d >> 2 & TOPJ_UINT32(0x7)
		consumed_bits = consumed_bits + suffix_len

		d = d>>5 + vlc&(uint32(1)<<suffix_len-uint32(1)) // u value
		*(*TOPJ_UINT32)(unsafe.Pointer(u)) = func() uint32 {
			if mode == TOPJ_UINT32(1) {
				return d + TOPJ_UINT32(1)
			}
			return uint32(1)
		}() // kappa is 1 for initial line
		*(*TOPJ_UINT32)(unsafe.Pointer(u + 1*4)) = func() uint32 {
			if mode == TOPJ_UINT32(1) {
				return uint32(1)
			}
			return d + TOPJ_UINT32(1)
		}() // kappa is 1 for initial line
	} else if mode == TOPJ_UINT32(3) { // both u_off are 1, and MEL event is 0
		var d1 TOPJ_UINT32 = TOPJ_UINT32(dec[vlc&TOPJ_UINT32(0x7)]) // LSBs of VLC are prefix codeword
		vlc >>= d1 & TOPJ_UINT32(0x3)                               // Consume bits
		consumed_bits = consumed_bits + d1&TOPJ_UINT32(0x3)

		if d1&TOPJ_UINT32(0x3) > TOPJ_UINT32(2) {
			var suffix_len TOPJ_UINT32

			//u_{q_2} prefix
			*(*TOPJ_UINT32)(unsafe.Pointer(u + 1*4)) = vlc&TOPJ_UINT32(1) + TOPJ_UINT32(1) + TOPJ_UINT32(1) //Kappa is 1 for initial line
			consumed_bits++
			vlc >>= 1

			suffix_len = d1 >> 2 & TOPJ_UINT32(0x7)
			consumed_bits = consumed_bits + suffix_len
			d1 = d1>>5 + vlc&(uint32(1)<<suffix_len-uint32(1))       // u value
			*(*TOPJ_UINT32)(unsafe.Pointer(u)) = d1 + TOPJ_UINT32(1) //Kappa is 1 for initial line
		} else {
			var d2 TOPJ_UINT32
			var suffix_len TOPJ_UINT32

			d2 = TOPJ_UINT32(dec[vlc&TOPJ_UINT32(0x7)]) // LSBs of VLC are prefix codeword
			vlc >>= d2 & TOPJ_UINT32(0x3)               // Consume bits
			consumed_bits = consumed_bits + d2&TOPJ_UINT32(0x3)

			suffix_len = d1 >> 2 & TOPJ_UINT32(0x7)
			consumed_bits = consumed_bits + suffix_len

			d1 = d1>>5 + vlc&(uint32(1)<<suffix_len-uint32(1))       // u value
			*(*TOPJ_UINT32)(unsafe.Pointer(u)) = d1 + TOPJ_UINT32(1) //Kappa is 1 for initial line
			vlc >>= suffix_len

			suffix_len = d2 >> 2 & TOPJ_UINT32(0x7)
			consumed_bits = consumed_bits + suffix_len

			d2 = d2>>5 + vlc&(uint32(1)<<suffix_len-uint32(1))             // u value
			*(*TOPJ_UINT32)(unsafe.Pointer(u + 1*4)) = d2 + TOPJ_UINT32(1) //Kappa is 1 for initial line
		}
	} else if mode == TOPJ_UINT32(4) { // both u_off are 1, and MEL event is 1
		var d1 TOPJ_UINT32
		var d2 TOPJ_UINT32
		var suffix_len TOPJ_UINT32

		d1 = TOPJ_UINT32(dec[vlc&TOPJ_UINT32(0x7)]) // LSBs of VLC are prefix codeword
		vlc >>= d1 & TOPJ_UINT32(0x3)               // Consume bits
		consumed_bits = consumed_bits + d1&TOPJ_UINT32(0x3)

		d2 = TOPJ_UINT32(dec[vlc&TOPJ_UINT32(0x7)]) // LSBs of VLC are prefix codeword
		vlc >>= d2 & TOPJ_UINT32(0x3)               // Consume bits
		consumed_bits = consumed_bits + d2&TOPJ_UINT32(0x3)

		suffix_len = d1 >> 2 & TOPJ_UINT32(0x7)
		consumed_bits = consumed_bits + suffix_len

		d1 = d1>>5 + vlc&(uint32(1)<<suffix_len-uint32(1))       // u value
		*(*TOPJ_UINT32)(unsafe.Pointer(u)) = d1 + TOPJ_UINT32(3) // add 2+kappa
		vlc >>= suffix_len

		suffix_len = d2 >> 2 & TOPJ_UINT32(0x7)
		consumed_bits = consumed_bits + suffix_len

		d2 = d2>>5 + vlc&(uint32(1)<<suffix_len-uint32(1))             // u value
		*(*TOPJ_UINT32)(unsafe.Pointer(u + 1*4)) = d2 + TOPJ_UINT32(3) // add 2+kappa
	}
	return consumed_bits
}

var dec = [8]TOPJ_UINT8{ // the index is the prefix codeword
	TOPJ_UINT8(3 | int32(5)<<2 | int32(5)<<5),
	TOPJ_UINT8(1 | int32(0)<<2 | int32(1)<<5),
	TOPJ_UINT8(2 | int32(0)<<2 | int32(2)<<5),
	TOPJ_UINT8(1 | int32(0)<<2 | int32(1)<<5),
	TOPJ_UINT8(3 | int32(1)<<2 | int32(3)<<5),
	TOPJ_UINT8(1 | int32(0)<<2 | int32(1)<<5),
	TOPJ_UINT8(2 | int32(0)<<2 | int32(2)<<5),
	TOPJ_UINT8(1 | int32(0)<<2 | int32(1)<<5),
} /* ht_dec.c:696:28 */

//************************************************************************/
// * @brief Decode non-initial UVLC to get the u value (or u_q)
//
//  @param [in]  vlc is the head of the VLC bitstream
//  @param [in]  mode is 0, 1, 2, or 3. The 1st bit is u_off of 1st quad
//               and 2nd for 2nd quad of a quad pair
//  @param [out] u is the u value (or u_q) + 1.  Note: we produce u + 1;
//               this value is a partial calculation of u + kappa.
func decode_noninit_uvlc(tls *libc.TLS, vlc TOPJ_UINT32, mode TOPJ_UINT32, u uintptr) TOPJ_UINT32 { /* ht_dec.c:801:12: */

	var consumed_bits TOPJ_UINT32 = TOPJ_UINT32(0)
	if mode == TOPJ_UINT32(0) {
		*(*TOPJ_UINT32)(unsafe.Pointer(u)) = libc.AssignPtrUint32(u+1*4, TOPJ_UINT32(1)) //for kappa
	} else if mode <= TOPJ_UINT32(2) { //u_off are either 01 or 10
		var d TOPJ_UINT32
		var suffix_len TOPJ_UINT32

		d = TOPJ_UINT32(dec1[vlc&TOPJ_UINT32(0x7)]) //look at the least significant 3 bits
		vlc >>= d & TOPJ_UINT32(0x3)                //prefix length
		consumed_bits = consumed_bits + d&TOPJ_UINT32(0x3)

		suffix_len = d >> 2 & TOPJ_UINT32(0x7)
		consumed_bits = consumed_bits + suffix_len

		d = d>>5 + vlc&(uint32(1)<<suffix_len-uint32(1)) // u value
		*(*TOPJ_UINT32)(unsafe.Pointer(u)) = func() uint32 {
			if mode == TOPJ_UINT32(1) {
				return d + TOPJ_UINT32(1)
			}
			return uint32(1)
		}() //for kappa
		*(*TOPJ_UINT32)(unsafe.Pointer(u + 1*4)) = func() uint32 {
			if mode == TOPJ_UINT32(1) {
				return uint32(1)
			}
			return d + TOPJ_UINT32(1)
		}() //for kappa
	} else if mode == TOPJ_UINT32(3) { // both u_off are 1
		var d1 TOPJ_UINT32
		var d2 TOPJ_UINT32
		var suffix_len TOPJ_UINT32

		d1 = TOPJ_UINT32(dec1[vlc&TOPJ_UINT32(0x7)]) // LSBs of VLC are prefix codeword
		vlc >>= d1 & TOPJ_UINT32(0x3)                // Consume bits
		consumed_bits = consumed_bits + d1&TOPJ_UINT32(0x3)

		d2 = TOPJ_UINT32(dec1[vlc&TOPJ_UINT32(0x7)]) // LSBs of VLC are prefix codeword
		vlc >>= d2 & TOPJ_UINT32(0x3)                // Consume bits
		consumed_bits = consumed_bits + d2&TOPJ_UINT32(0x3)

		suffix_len = d1 >> 2 & TOPJ_UINT32(0x7)
		consumed_bits = consumed_bits + suffix_len

		d1 = d1>>5 + vlc&(uint32(1)<<suffix_len-uint32(1))       // u value
		*(*TOPJ_UINT32)(unsafe.Pointer(u)) = d1 + TOPJ_UINT32(1) //1 for kappa
		vlc >>= suffix_len

		suffix_len = d2 >> 2 & TOPJ_UINT32(0x7)
		consumed_bits = consumed_bits + suffix_len

		d2 = d2>>5 + vlc&(uint32(1)<<suffix_len-uint32(1))             // u value
		*(*TOPJ_UINT32)(unsafe.Pointer(u + 1*4)) = d2 + TOPJ_UINT32(1) //1 for kappa
	}
	return consumed_bits
}

var dec1 = [8]TOPJ_UINT8{
	TOPJ_UINT8(3 | int32(5)<<2 | int32(5)<<5),
	TOPJ_UINT8(1 | int32(0)<<2 | int32(1)<<5),
	TOPJ_UINT8(2 | int32(0)<<2 | int32(2)<<5),
	TOPJ_UINT8(1 | int32(0)<<2 | int32(1)<<5),
	TOPJ_UINT8(3 | int32(1)<<2 | int32(3)<<5),
	TOPJ_UINT8(1 | int32(0)<<2 | int32(1)<<5),
	TOPJ_UINT8(2 | int32(0)<<2 | int32(2)<<5),
	TOPJ_UINT8(1 | int32(0)<<2 | int32(1)<<5),
} /* ht_dec.c:809:28 */

//************************************************************************/
// * @brief State structure for reading and unstuffing of forward-growing
//         bitstreams; these are: MagSgn and SPP bitstreams
type Sfrwd_struct = struct {
	Fdata        uintptr
	Ftmp         TOPJ_UINT64
	Fbits        TOPJ_UINT32
	Funstuff     TOPJ_BOOL
	Fsize        int32
	FX           TOPJ_UINT32
	F__ccgo_pad1 [4]byte
} /* ht_dec.c:870:9 */

//************************************************************************/
// * @brief State structure for reading and unstuffing of forward-growing
//         bitstreams; these are: MagSgn and SPP bitstreams
type Tfrwd_struct_t = Sfrwd_struct /* ht_dec.c:877:3 */

//************************************************************************/
// * @brief Read and unstuffs 32 bits from forward-growing bitstream
//
//  A subroutine to read from both the MagSgn or SPP bitstreams;
//  in particular, when MagSgn bitstream is consumed, 0xFF's are fed,
//  while when SPP is exhausted 0's are fed in.
//  X controls this value.
//
//  Unstuffing prevent sequences that are more than 0xFF7F from appearing
//  in the conpressed sequence.  So whenever a value of 0xFF is coded, the
//  MSB of the next byte is set 0 and must be ignored during decoding.
//
//  Reading can go beyond the end of buffer by up to 3 bytes.
//
//  @param  [in]  msp is a pointer to frwd_struct_t structure
//
func frwd_read(tls *libc.TLS, msp uintptr) { /* ht_dec.c:897:6: */
	var val TOPJ_UINT32
	var bits TOPJ_UINT32
	var t TOPJ_UINT32
	var unstuff TOPJ_BOOL

	if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fbits <= TOPJ_UINT32(32) {
	} else {
		libc.X__assert_fail(tls, ts+1948, ts+1838, uint32(904), uintptr(unsafe.Pointer(&__func__55)))
	} // assert that there is a space for 32 bits

	val = 0
	if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fsize > 3 {
		val = read_le_uint32(tls, (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fdata) // read 32 bits
		*(*uintptr)(unsafe.Pointer(msp)) += uintptr(4)                          // increment pointer
		*(*int32)(unsafe.Pointer(msp + 20)) -= 4                                // reduce size
	} else if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fsize > 0 {
		var i int32 = 0
		if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).FX != TOPJ_UINT32(0) {
			val = 0xFFFFFFFF
		} else {
			val = uint32(0)
		}
		for (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fsize > 0 {
			var v TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostIncUintptr(&(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fdata, 1)))) // read one byte at a time
			var m TOPJ_UINT32 = ^(uint32(0xFF) << i)                                                                                               // mask of location
			val = val&m | v<<i                                                                                                                     // put one byte in its correct location
			(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fsize--
			i = i + 8
		}
	} else {
		if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).FX != TOPJ_UINT32(0) {
			val = 0xFFFFFFFF
		} else {
			val = uint32(0)
		}
	}

	// we accumulate in t and keep a count of the number of bits in bits
	bits = 8 - func() uint32 {
		if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Funstuff != 0 {
			return 1
		}
		return 0
	}()
	t = val & TOPJ_UINT32(0xFF)
	unstuff = libc.Bool32(val&TOPJ_UINT32(0xFF) == TOPJ_UINT32(0xFF)) // Do we need unstuffing next?

	t = t | val>>8&TOPJ_UINT32(0xFF)<<bits
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 {
			return 1
		}
		return 0
	}())
	unstuff = libc.Bool32(val>>8&TOPJ_UINT32(0xFF) == TOPJ_UINT32(0xFF))

	t = t | val>>16&TOPJ_UINT32(0xFF)<<bits
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 {
			return 1
		}
		return 0
	}())
	unstuff = libc.Bool32(val>>16&TOPJ_UINT32(0xFF) == TOPJ_UINT32(0xFF))

	t = t | val>>24&TOPJ_UINT32(0xFF)<<bits
	bits = bits + (8 - func() uint32 {
		if unstuff != 0 {
			return 1
		}
		return 0
	}())
	(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Funstuff = libc.Bool32(val>>24&TOPJ_UINT32(0xFF) == TOPJ_UINT32(0xFF)) // for next byte

	*(*TOPJ_UINT64)(unsafe.Pointer(msp + 8)) |= TOPJ_UINT64(t) << (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fbits // move data to msp->tmp
	*(*TOPJ_UINT32)(unsafe.Pointer(msp + 12)) += bits
}

var __func__55 = *(*[10]int8)(unsafe.Pointer(ts + 1964)) /* ht_dec.c:898:1 */

//************************************************************************/
// * @brief Initialize frwd_struct_t struct and reads some bytes
//
//  @param [in]  msp is a pointer to frwd_struct_t
//  @param [in]  data is a pointer to the start of data
//  @param [in]  size is the number of byte in the bitstream
//  @param [in]  X is the value fed in when the bitstream is exhausted.
//               See frwd_read.
func frwd_init(tls *libc.TLS, msp uintptr, data uintptr, size int32, X TOPJ_UINT32) { /* ht_dec.c:956:6: */
	var num int32
	var i int32

	(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fdata = data
	(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Ftmp = TOPJ_UINT64(0)
	(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fbits = TOPJ_UINT32(0)
	(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Funstuff = DOPJ_FALSE
	(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fsize = size
	(*Tfrwd_struct_t)(unsafe.Pointer(msp)).FX = X
	if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).FX == TOPJ_UINT32(0) || (*Tfrwd_struct_t)(unsafe.Pointer(msp)).FX == TOPJ_UINT32(0xFF) {
	} else {
		libc.X__assert_fail(tls, ts+1974, ts+1838, uint32(967), uintptr(unsafe.Pointer(&__func__56)))
	}

	//This code is designed for an architecture that read address should
	// align to the read size (address multiple of 4 if read size is 4)
	//These few lines take care of the case where data is not at a multiple
	// of 4 boundary.  It reads 1,2,3 up to 4 bytes from the bitstream
	num = 4 - int32(Tintptr_t((*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fdata)&0x3)
	for i = 0; i < num; i++ {
		var d TOPJ_UINT64
		//read a byte if the buffer is not exhausted, otherwise set it to X
		if libc.PostDecInt32(&(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fsize, 1) > 0 {
			d = uint32(*(*TOPJ_UINT8)(unsafe.Pointer(libc.PostIncUintptr(&(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fdata, 1))))
		} else {
			d = uint32((*Tfrwd_struct_t)(unsafe.Pointer(msp)).FX)
		}
		*(*TOPJ_UINT64)(unsafe.Pointer(msp + 8)) |= d << (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fbits // store data in msp->tmp
		*(*TOPJ_UINT32)(unsafe.Pointer(msp + 12)) += 8 - func() uint32 {
			if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Funstuff != 0 {
				return 1
			}
			return 0
		}() // number of bits added to msp->tmp
		(*Tfrwd_struct_t)(unsafe.Pointer(msp)).Funstuff = libc.Bool32(d&TOPJ_UINT64(0xFF) == TOPJ_UINT64(0xFF)) // unstuffing for next byte
	}
	frwd_read(tls, msp) // read 32 bits more
}

var __func__56 = *(*[10]int8)(unsafe.Pointer(ts + 2004)) /* ht_dec.c:958:1 */

//************************************************************************/
// * @brief Consume num_bits bits from the bitstream of frwd_struct_t
//
//  @param [in]  msp is a pointer to frwd_struct_t
//  @param [in]  num_bits is the number of bit to consume
func frwd_advance(tls *libc.TLS, msp uintptr, num_bits TOPJ_UINT32) { /* ht_dec.c:992:6: */
	if num_bits <= (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fbits {
	} else {
		libc.X__assert_fail(tls, ts+2014, ts+1838, uint32(994), uintptr(unsafe.Pointer(&__func__57)))
	}
	libc.AssignShrPtrUint32(msp+8, int(num_bits)) // consume num_bits
	*(*TOPJ_UINT32)(unsafe.Pointer(msp + 12)) -= num_bits
}

var __func__57 = *(*[13]int8)(unsafe.Pointer(ts + 2036)) /* ht_dec.c:993:1 */

//************************************************************************/
// * @brief Fetches 32 bits from the frwd_struct_t bitstream
//
//  @param [in]  msp is a pointer to frwd_struct_t
func frwd_fetch(tls *libc.TLS, msp uintptr) TOPJ_UINT32 { /* ht_dec.c:1005:12: */
	if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fbits < TOPJ_UINT32(32) {
		frwd_read(tls, msp)
		if (*Tfrwd_struct_t)(unsafe.Pointer(msp)).Fbits < TOPJ_UINT32(32) { //need to test
			frwd_read(tls, msp)
		}
	}
	return TOPJ_UINT32((*Tfrwd_struct_t)(unsafe.Pointer(msp)).Ftmp)
}

//************************************************************************/
// * @brief Allocates T1 buffers
//
//  @param [in, out]  t1 is codeblock cofficients storage
//  @param [in]       w is codeblock width
//  @param [in]       h is codeblock height
func opj_t1_allocate_buffers(tls *libc.TLS, t1 uintptr, w TOPJ_UINT32, h TOPJ_UINT32) TOPJ_BOOL { /* ht_dec.c:1023:17: */
	var flagssize TOPJ_UINT32

	// No risk of overflow. Prior checks ensure those assert are met
	// They are per the specification
	if w <= TOPJ_UINT32(1024) {
	} else {
		libc.X__assert_fail(tls, ts+2049, ts+1838, uint32(1032), uintptr(unsafe.Pointer(&__func__58)))
	}
	if h <= TOPJ_UINT32(1024) {
	} else {
		libc.X__assert_fail(tls, ts+2059, ts+1838, uint32(1033), uintptr(unsafe.Pointer(&__func__58)))
	}
	if w*h <= TOPJ_UINT32(4096) {
	} else {
		libc.X__assert_fail(tls, ts+2069, ts+1838, uint32(1034), uintptr(unsafe.Pointer(&__func__58)))
	}

	/* encoder uses tile buffer, so no need to allocate */
	{
		var datasize TOPJ_UINT32 = w * h

		if datasize > (*Topj_t1_t)(unsafe.Pointer(t1)).Fdatasize {
			Xopj_aligned_free(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata)
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fdata = Xopj_aligned_malloc(tls, uint32(datasize)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
			if !(int32((*Topj_t1_t)(unsafe.Pointer(t1)).Fdata) != 0) {
				// FIXME event manager error callback
				return DOPJ_FALSE
			}
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fdatasize = datasize
		}
		// memset first arg is declared to never be null by gcc
		if (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata != uintptr(0) {
			libc.Xmemset(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata, 0, uint32(datasize)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
		}

	}

	// We expand these buffers to multiples of 16 bytes.
	// We need 4 buffers of 129 integers each, expanded to 132 integers each
	// We also need 514 bytes of buffer, expanded to 528 bytes
	flagssize = 132 * uint32(unsafe.Sizeof(TOPJ_UINT32(0))) * 4 // expanded to multiple of 16
	flagssize = flagssize + 528                                 // 514 expanded to multiples of 16

	{
		if flagssize > (*Topj_t1_t)(unsafe.Pointer(t1)).Fflagssize {

			Xopj_aligned_free(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags)
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fflags = Xopj_aligned_malloc(tls, uint32(flagssize)*uint32(unsafe.Sizeof(Topj_flag_t(0))))
			if !(int32((*Topj_t1_t)(unsafe.Pointer(t1)).Fflags) != 0) {
				// FIXME event manager error callback
				return DOPJ_FALSE
			}
		}
		(*Topj_t1_t)(unsafe.Pointer(t1)).Fflagssize = flagssize

		libc.Xmemset(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags, 0, uint32(flagssize)*uint32(unsafe.Sizeof(Topj_flag_t(0))))

	}

	(*Topj_t1_t)(unsafe.Pointer(t1)).Fw = w
	(*Topj_t1_t)(unsafe.Pointer(t1)).Fh = h

	return DOPJ_TRUE
}

var __func__58 = *(*[24]int8)(unsafe.Pointer(ts + 2083)) /* ht_dec.c:1027:1 */

//************************************************************************/
// * @brief Decodes one codeblock, processing the cleanup, siginificance
//         propagation, and magnitude refinement pass
//
//  @param [in, out]  t1 is codeblock cofficients storage
//  @param [in]       cblk is codeblock properties
//  @param [in]       orient is the subband to which the codeblock belongs (not needed)
//  @param [in]       roishift is region of interest shift
//  @param [in]       cblksty is codeblock style
//  @param [in]       p_manager is events print manager
//  @param [in]       p_manager_mutex a mutex to control access to p_manager
//  @param [in]       check_pterm: check termination (not used)
func Xopj_t1_ht_decode_cblk(tls *libc.TLS, t1 uintptr, cblk uintptr, orient TOPJ_UINT32, roishift TOPJ_UINT32, cblksty TOPJ_UINT32, p_manager uintptr, p_manager_mutex uintptr, check_pterm TOPJ_BOOL) TOPJ_BOOL { /* ht_dec.c:1096:10: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var cblkdata uintptr = uintptr(0)
	var coded_data uintptr
	var decoded_data uintptr
	var zero_bplanes TOPJ_UINT32
	var num_passes TOPJ_UINT32
	var lengths1 TOPJ_UINT32
	var lengths2 TOPJ_UINT32
	var width TOPJ_INT32
	var height TOPJ_INT32
	var stride TOPJ_INT32
	var pflags uintptr
	var sigma1 uintptr
	var sigma2 uintptr
	var mbr1 uintptr
	var mbr2 uintptr
	var sip uintptr
	var sip_shift TOPJ_UINT32
	var p TOPJ_UINT32
	var zero_bplanes_p1 TOPJ_UINT32
	var lcup int32
	var scup int32
	// var mel Tdec_mel_t at bp+40, 40

	// var vlc Trev_struct_t at bp+80, 24

	// var magsgn Tfrwd_struct_t at bp+104, 32

	// var sigprop Tfrwd_struct_t at bp+136, 32

	// var magref Trev_struct_t at bp+168, 24

	var lsp uintptr
	var line_state uintptr
	var run int32
	var vlc_val TOPJ_UINT32 // fetched data from VLC bitstream
	// var qinf [2]TOPJ_UINT32 at bp+192, 8

	var c_q TOPJ_UINT32
	var sp uintptr
	var x TOPJ_INT32
	var y TOPJ_INT32 // loop indices
	var stripe_causal TOPJ_BOOL = libc.Bool32(cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_VSC) != TOPJ_UINT32(0))
	var cblk_len TOPJ_UINT32 = TOPJ_UINT32(0)

	_ = orient      // stops unused parameter message
	_ = check_pterm // stops unused parameter message

	// We ignor orient, because the same decoder is used for all subbands
	// We also ignore check_pterm, because I am not sure how it applies
	if roishift != TOPJ_UINT32(0) {
		if p_manager_mutex != 0 {
			Xopj_mutex_lock(tls, p_manager_mutex)
		}
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+2107, 0)
		if p_manager_mutex != 0 {
			Xopj_mutex_unlock(tls, p_manager_mutex)
		}
		return DOPJ_FALSE
	}

	if !(opj_t1_allocate_buffers(tls,
		t1,
		TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx1-(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0),
		TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy1-(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0)) != 0) {
		return DOPJ_FALSE
	}

	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).FMb == TOPJ_UINT32(0) {
		return DOPJ_TRUE
	}

	// numbps = Mb + 1 - zero_bplanes, Mb = Kmax, zero_bplanes = missing_msbs
	zero_bplanes = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).FMb + TOPJ_UINT32(1) - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumbps

	// Compute whole codeblock length from chunk lengths
	cblk_len = TOPJ_UINT32(0)
	{
		var i TOPJ_UINT32
		for i = TOPJ_UINT32(0); i < (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumchunks; i++ {
			cblk_len = cblk_len + (*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks+uintptr(i)*16)).Flen
		}

	}

	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumchunks > TOPJ_UINT32(1) || (*Topj_t1_t)(unsafe.Pointer(t1)).Fmustuse_cblkdatabuffer != 0 {
		var i TOPJ_UINT32

		// Allocate temporary memory if needed
		if cblk_len > (*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffersize {
			cblkdata = Xopj_realloc(tls,
				(*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffer, uint32(cblk_len))
			if cblkdata == uintptr(0) {
				return DOPJ_FALSE
			}
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffer = cblkdata
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffersize = cblk_len
		}

		// Concatenate all chunks
		cblkdata = (*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffer
		cblk_len = TOPJ_UINT32(0)
		for i = TOPJ_UINT32(0); i < (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumchunks; i++ {
			libc.Xmemcpy(tls, cblkdata+uintptr(cblk_len), (*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks+uintptr(i)*16)).Fdata, uint32((*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks+uintptr(i)*16)).Flen))
			cblk_len = cblk_len + (*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks+uintptr(i)*16)).Flen
		}
	} else if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumchunks == TOPJ_UINT32(1) {
		cblkdata = (*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks)).Fdata
	} else {
		// Not sure if that can happen in practice, but avoid Coverity to
		// think we will dereference a null cblkdta pointer
		return DOPJ_TRUE
	}

	// OPJ_BYTE* coded_data is a pointer to bitstream
	coded_data = cblkdata
	// OPJ_UINT32* decoded_data is a pointer to decoded codeblock data buf.
	decoded_data = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
	// OPJ_UINT32 num_passes is the number of passes: 1 if CUP only, 2 for
	// CUP+SPP, and 3 for CUP+SPP+MRP
	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumsegs > TOPJ_UINT32(0) {
		num_passes = (*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fsegs)).Freal_num_passes
	} else {
		num_passes = uint32(0)
	}
	num_passes = num_passes + func() uint32 {
		if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumsegs > TOPJ_UINT32(1) {
			return (*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fsegs + 1*24)).Freal_num_passes
		}
		return uint32(0)
	}()
	// OPJ_UINT32 lengths1 is the length of cleanup pass
	if num_passes > TOPJ_UINT32(0) {
		lengths1 = (*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fsegs)).Flen
	} else {
		lengths1 = uint32(0)
	}
	// OPJ_UINT32 lengths2 is the length of refinement passes (either SPP only or SPP+MRP)
	if num_passes > TOPJ_UINT32(1) {
		lengths2 = (*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fsegs + 1*24)).Flen
	} else {
		lengths2 = uint32(0)
	}
	// OPJ_INT32 width is the decoded codeblock width
	width = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx1 - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0
	// OPJ_INT32 height is the decoded codeblock height
	height = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy1 - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0
	// OPJ_INT32 stride is the decoded codeblock buffer stride
	stride = width

	// sigma1 and sigma2 contains significant (i.e., non-zero) pixel
	//  locations.  The buffers are used interchangeably, because we need
	//  more than 4 rows of significance information at a given time.
	//  Each 32 bits contain significance information for 4 rows of 8
	//  columns each.  If we denote 32 bits by 0xaaaaaaaa, the each "a" is
	//  called a nibble and has significance information for 4 rows.
	//  The least significant nibble has information for the first column,
	//  and so on. The nibble's LSB is for the first row, and so on.
	//  Since, at most, we can have 1024 columns in a quad, we need 128
	//  entries; we added 1 for convenience when propagation of signifcance
	//  goes outside the structure
	//  To work in OpenJPEG these buffers has been expanded to 132.
	// OPJ_UINT32 *pflags, *sigma1, *sigma2, *mbr1, *mbr2, *sip, sip_shift;
	pflags = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags
	sigma1 = pflags
	sigma2 = sigma1 + uintptr(132)*4
	// mbr arrangement is similar to sigma; mbr contains locations
	// that become significant during significance propagation pass
	mbr1 = sigma2 + uintptr(132)*4
	mbr2 = mbr1 + uintptr(132)*4
	//a pointer to sigma
	sip = sigma1               //pointers to arrays to be used interchangeably
	sip_shift = TOPJ_UINT32(0) //the amount of shift needed for sigma

	if num_passes > TOPJ_UINT32(1) && lengths2 == TOPJ_UINT32(0) {
		if p_manager_mutex != 0 {
			Xopj_mutex_lock(tls, p_manager_mutex)
		}
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+2156, 0)
		if p_manager_mutex != 0 {
			Xopj_mutex_unlock(tls, p_manager_mutex)
		}
		num_passes = TOPJ_UINT32(1)
	}
	if num_passes > TOPJ_UINT32(3) {
		if p_manager_mutex != 0 {
			Xopj_mutex_lock(tls, p_manager_mutex)
		}
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+2288, libc.VaList(bp, num_passes))
		if p_manager_mutex != 0 {
			Xopj_mutex_unlock(tls, p_manager_mutex)
		}
		return DOPJ_FALSE
	}

	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).FMb > TOPJ_UINT32(30) {
		// This check is better moved to opj_t2_read_packet_header() in t2.c
		//            We do not have enough precision to decode any passes
		//            The design of openjpeg assumes that the bits of a 32-bit integer are
		//            assigned as follows:
		//            bit 31 is for sign
		//            bits 30-1 are for magnitude
		//            bit 0 is for the center of the quantization bin
		//            Therefore we can only do values of cblk->Mb <= 30
		//
		if p_manager_mutex != 0 {
			Xopj_mutex_lock(tls, p_manager_mutex)
		}
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+2384, libc.VaList(bp+8, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).FMb))
		if p_manager_mutex != 0 {
			Xopj_mutex_unlock(tls, p_manager_mutex)
		}
		return DOPJ_FALSE
	}
	if zero_bplanes > (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).FMb {
		// This check is better moved to opj_t2_read_packet_header() in t2.c,
		//            in the line "l_cblk->numbps = (OPJ_UINT32)l_band->numbps + 1 - i;"
		//            where i is the zero bitplanes, and should be no larger than cblk->Mb
		//            We cannot have more zero bitplanes than there are planes.
		if p_manager_mutex != 0 {
			Xopj_mutex_lock(tls, p_manager_mutex)
		}
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+2487,
			libc.VaList(bp+16, zero_bplanes, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).FMb))

		if p_manager_mutex != 0 {
			Xopj_mutex_unlock(tls, p_manager_mutex)
		}
		return DOPJ_FALSE
	} else if zero_bplanes == (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).FMb && num_passes > TOPJ_UINT32(1) {
		// When the number of zero bitplanes is equal to the number of bitplanes,
		//            only the cleanup pass makes sense
		if only_cleanup_pass_is_decoded == DOPJ_FALSE {
			if p_manager_mutex != 0 {
				Xopj_mutex_lock(tls, p_manager_mutex)
			}
			// We have a second check to prevent the possibility of an overrun condition,
			//                in the very unlikely event of a second thread discovering that
			//                only_cleanup_pass_is_decoded is false before the first thread changing
			//                the condition.
			if only_cleanup_pass_is_decoded == DOPJ_FALSE {
				only_cleanup_pass_is_decoded = DOPJ_TRUE
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,

					ts+2593,
					libc.VaList(bp+32, num_passes))
			}
			if p_manager_mutex != 0 {
				Xopj_mutex_unlock(tls, p_manager_mutex)
			}
		}
		num_passes = TOPJ_UINT32(1)
	}

	// OPJ_UINT32
	p = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumbps

	// OPJ_UINT32 zero planes plus 1
	zero_bplanes_p1 = zero_bplanes + TOPJ_UINT32(1)

	if lengths1 < TOPJ_UINT32(2) || lengths1 > cblk_len || lengths1+lengths2 > cblk_len {
		if p_manager_mutex != 0 {
			Xopj_mutex_lock(tls, p_manager_mutex)
		}
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+2864, 0)

		if p_manager_mutex != 0 {
			Xopj_mutex_unlock(tls, p_manager_mutex)
		}
		return DOPJ_FALSE
	}
	// read scup and fix the bytes there
	lcup = int32(lengths1) // length of CUP
	//scup is the length of MEL + VLC
	scup = int32(*(*TOPJ_UINT8)(unsafe.Pointer(coded_data + uintptr(lcup-1))))<<4 + int32(*(*TOPJ_UINT8)(unsafe.Pointer(coded_data + uintptr(lcup-2))))&0xF
	if scup < 2 || scup > lcup || scup > 4079 { //something is wrong
		// The standard stipulates 2 <= Scup <= min(Lcup, 4079)
		if p_manager_mutex != 0 {
			Xopj_mutex_lock(tls, p_manager_mutex)
		}
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+2922, 0)

		if p_manager_mutex != 0 {
			Xopj_mutex_unlock(tls, p_manager_mutex)
		}
		return DOPJ_FALSE
	}

	// init structures
	mel_init(tls, bp+40, coded_data, lcup, scup)
	rev_init(tls, bp+80, coded_data, lcup, scup)
	frwd_init(tls, bp+104, coded_data, lcup-scup, uint32(0xFF))
	if num_passes > TOPJ_UINT32(1) { // needs to be tested
		frwd_init(tls, bp+136, coded_data+uintptr(lengths1), int32(lengths2), uint32(0))
	}
	if num_passes > TOPJ_UINT32(2) {
		rev_init_mrp(tls, bp+168, coded_data, int32(lengths1), int32(lengths2))
	}

	// * State storage
	//  One byte per quad; for 1024 columns, or 512 quads, we need
	//  512 bytes. We are using 2 extra bytes one on the left and one on
	//  the right for convenience.
	//
	//  The MSB bit in each byte is (\sigma^nw | \sigma^n), and the 7 LSBs
	//  contain max(E^nw | E^n)

	// 514 is enough for a block width of 1024, +2 extra
	// here expanded to 528
	line_state = mbr2 + uintptr(132)*4

	//initial 2 lines
	/////////////////
	lsp = line_state                                    // point to line state
	*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(0) // for initial row of quad, we set to 0
	run = mel_get_run(tls, bp+40 /* &mel */)            // decode runs of events from MEL bitstrm
	// data represented as runs of 0 events
	// See mel_decode description
	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192)) = libc.AssignPtrUint32(bp+192+1*4, TOPJ_UINT32(0)) // quad info decoded from VLC bitstream
	c_q = TOPJ_UINT32(0)                                                                         // context for quad q
	sp = decoded_data                                                                            // decoded codeblock samples
	// vlc_val;                 // fetched data from VLC bitstream

	for x = 0; x < width; x = x + 4 { // one iteration per quad pair
		// var U_q [2]TOPJ_UINT32 at bp+200, 8
		// u values for the quad pair
		var uvlc_mode TOPJ_UINT32
		var consumed_bits TOPJ_UINT32
		var m_n TOPJ_UINT32
		var v_n TOPJ_UINT32
		var ms_val TOPJ_UINT32
		var locs TOPJ_UINT32

		// decode VLC
		/////////////

		//first quad
		// Get the head of the VLC bitstream. One fetch is enough for two
		// quads, since the largest VLC code is 7 bits, and maximum number of
		// bits used for u is 8.  Therefore for two quads we need 30 bits
		// (if we include unstuffing, then 32 bits are enough, since we have
		// a maximum of one stuffing per two bytes)
		vlc_val = rev_fetch(tls, bp+80)

		//decode VLC using the context c_q and the head of the VLC bitstream
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192)) = TOPJ_UINT32(vlc_tbl0[c_q<<7|vlc_val&TOPJ_UINT32(0x7F)])

		if c_q == TOPJ_UINT32(0) { // if zero context, we need to use one MEL event
			run = run - 2 //the number of 0 events is multiplied by 2, so subtract 2

			// Is the run terminated in 1? if so, use decoded VLC code,
			// otherwise, discard decoded data, since we will decoded again
			// using a different context
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192)) = func() uint32 {
				if run == -1 {
					return *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))
				}
				return uint32(0)
			}()

			// is run -1 or -2? this means a run has been consumed
			if run < 0 {
				run = mel_get_run(tls, bp+40) // get another run
			}
		}

		// prepare context for the next quad; eqn. 1 in ITU T.814
		c_q = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x10)>>4 | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0xE0)>>5

		//remove data from vlc stream (0 bits are removed if qinf is not used)
		vlc_val = rev_advance(tls, bp+80, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x7))

		//update sigma
		// The update depends on the value of x; consider one OPJ_UINT32
		// if x is 0, 8, 16 and so on, then this line update c locations
		//      nibble (4 bits) number   0 1 2 3 4 5 6 7
		//                         LSB   c c 0 0 0 0 0 0
		//                               c c 0 0 0 0 0 0
		//                               0 0 0 0 0 0 0 0
		//                               0 0 0 0 0 0 0 0
		// if x is 4, 12, 20, then this line update locations c
		//      nibble (4 bits) number   0 1 2 3 4 5 6 7
		//                         LSB   0 0 0 0 c c 0 0
		//                               0 0 0 0 c c 0 0
		//                               0 0 0 0 0 0 0 0
		//                               0 0 0 0 0 0 0 0
		*(*TOPJ_UINT32)(unsafe.Pointer(sip)) |= (*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x30)>>4 | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0xC0)>>2) << sip_shift

		//second quad
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4)) = TOPJ_UINT32(0)
		if x+2 < width { // do not run if codeblock is narrower
			//decode VLC using the context c_q and the head of the VLC bitstream
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4)) = TOPJ_UINT32(vlc_tbl0[c_q<<7|vlc_val&TOPJ_UINT32(0x7F)])

			// if context is zero, use one MEL event
			if c_q == TOPJ_UINT32(0) { //zero context
				run = run - 2 //subtract 2, since events number if multiplied by 2

				// if event is 0, discard decoded qinf
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4)) = func() uint32 {
					if run == -1 {
						return *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))
					}
					return uint32(0)
				}()

				if run < 0 { // have we consumed all events in a run
					run = mel_get_run(tls, bp+40) // if yes, then get another run
				}
			}

			//prepare context for the next quad, eqn. 1 in ITU T.814
			c_q = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x10)>>4 | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0xE0)>>5

			//remove data from vlc stream, if qinf is not used, cwdlen is 0
			vlc_val = rev_advance(tls, bp+80, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x7))
		}

		//update sigma
		// The update depends on the value of x; consider one OPJ_UINT32
		// if x is 0, 8, 16 and so on, then this line update c locations
		//      nibble (4 bits) number   0 1 2 3 4 5 6 7
		//                         LSB   0 0 c c 0 0 0 0
		//                               0 0 c c 0 0 0 0
		//                               0 0 0 0 0 0 0 0
		//                               0 0 0 0 0 0 0 0
		// if x is 4, 12, 20, then this line update locations c
		//      nibble (4 bits) number   0 1 2 3 4 5 6 7
		//                         LSB   0 0 0 0 0 0 c c
		//                               0 0 0 0 0 0 c c
		//                               0 0 0 0 0 0 0 0
		//                               0 0 0 0 0 0 0 0
		*(*TOPJ_UINT32)(unsafe.Pointer(sip)) |= (*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x30) | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0xC0)<<2) << (TOPJ_UINT32(4) + sip_shift)

		sip += 4 * func() uintptr {
			if x&0x7 != 0 {
				return uintptr(1)
			}
			return uintptr(0)
		}() // move sigma pointer to next entry
		sip_shift = sip_shift ^ TOPJ_UINT32(0x10) // increment/decrement sip_shift by 16

		// retrieve u
		/////////////

		// uvlc_mode is made up of u_offset bits from the quad pair
		uvlc_mode = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x8)>>3 | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x8)>>2
		if uvlc_mode == TOPJ_UINT32(3) { // if both u_offset are set, get an event from
			// the MEL run of events
			run = run - 2 //subtract 2, since events number if multiplied by 2
			uvlc_mode = uvlc_mode + func() uint32 {
				if run == -1 {
					return uint32(1)
				}
				return uint32(0)
			}() //increment uvlc_mode if event is 1
			if run < 0 { // if run is consumed (run is -1 or -2), get another run
				run = mel_get_run(tls, bp+40)
			}
		}
		//decode uvlc_mode to get u for both quads
		consumed_bits = decode_init_uvlc(tls, vlc_val, uvlc_mode, bp+200)
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200)) > zero_bplanes_p1 || *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200 + 1*4)) > zero_bplanes_p1 {
			if p_manager_mutex != 0 {
				Xopj_mutex_lock(tls, p_manager_mutex)
			}
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,

				ts+3019, 0)
			if p_manager_mutex != 0 {
				Xopj_mutex_unlock(tls, p_manager_mutex)
			}
			return DOPJ_FALSE
		}

		//consume u bits in the VLC code
		vlc_val = rev_advance(tls, bp+80, consumed_bits)

		//decode magsgn and update line_state
		/////////////////////////////////////

		//We obtain a mask for the samples locations that needs evaluation
		locs = TOPJ_UINT32(0xFF)
		if x+4 > width {
			locs >>= (x + 4 - width) << 1 // limits width
		}
		if height > 1 {
			locs = locs
		} else {
			locs = locs & TOPJ_UINT32(0x55)
		} // limits height

		if (*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0xF0)>>4|*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0xF0)) & ^locs != 0 {
			if p_manager_mutex != 0 {
				Xopj_mutex_lock(tls, p_manager_mutex)
			}
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,

				ts+3119, 0)
			if p_manager_mutex != 0 {
				Xopj_mutex_unlock(tls, p_manager_mutex)
			}
			return DOPJ_FALSE
		}

		//first quad, starting at first sample in quad and moving on
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x10) != 0 { //is it significant? (sigma_n)
			var val TOPJ_UINT32

			ms_val = frwd_fetch(tls, bp+104)                                                                               //get 32 bits of magsgn data
			m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))>>12&TOPJ_UINT32(1) //evaluate m_n (number of bits
			// to read from bitstream), using EMB e_k
			frwd_advance(tls, bp+104, m_n)                                                   //consume m_n
			val = ms_val << 31                                                               //get sign bit
			v_n = ms_val & (uint32(1)<<m_n - uint32(1))                                      //keep only m_n bits
			v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x100)>>8<<m_n //add EMB e_1 as MSB
			v_n = v_n | TOPJ_UINT32(1)                                                       //add center of bin
			//v_n now has 2 * (\mu - 1) + 0.5 with correct sign bit
			//add 2 to make it 2*\mu+0.5, shift it up to missing MSBs
			*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))
		} else if locs&TOPJ_UINT32(0x1) != 0 { // if this is inside the codeblock, set the
			*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = TOPJ_UINT32(0) // sample to zero
		}

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x20) != 0 { //sigma_n
			var val TOPJ_UINT32
			var t TOPJ_UINT32

			ms_val = frwd_fetch(tls, bp+104)                                                                               //get 32 bits
			m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))>>13&TOPJ_UINT32(1) //m_n, uses EMB e_k
			frwd_advance(tls, bp+104, m_n)                                                                                 //consume m_n
			val = ms_val << 31                                                                                             //get sign bit
			v_n = ms_val & (uint32(1)<<m_n - uint32(1))                                                                    //keep only m_n bits
			v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x200)>>9<<m_n                               //add EMB e_1
			v_n = v_n | TOPJ_UINT32(1)                                                                                     //bin center
			//v_n now has 2 * (\mu - 1) + 0.5 with correct sign bit
			//add 2 to make it 2*\mu+0.5, shift it up to missing MSBs
			*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))

			//update line_state: bit 7 (\sigma^N), and E^N
			t = TOPJ_UINT32(int32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp))) & 0x7F) // keep E^NW
			v_n = TOPJ_UINT32(32) - count_leading_zeros(tls, v_n)
			*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(TOPJ_UINT32(0x80) | func() uint32 {
				if t > v_n {
					return t
				}
				return v_n
			}()) //max(E^NW, E^N) | s
		} else if locs&TOPJ_UINT32(0x2) != 0 { // if this is inside the codeblock, set the
			*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = TOPJ_UINT32(0) // sample to zero
		}

		lsp++   // move to next quad information
		sp += 4 // move to next column of samples

		//this is similar to the above two samples
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x40) != 0 {
			var val TOPJ_UINT32

			ms_val = frwd_fetch(tls, bp+104)
			m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))>>14&TOPJ_UINT32(1)
			frwd_advance(tls, bp+104, m_n)
			val = ms_val << 31
			v_n = ms_val & (uint32(1)<<m_n - uint32(1))
			v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x400)>>10<<m_n
			v_n = v_n | TOPJ_UINT32(1)
			*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))
		} else if locs&TOPJ_UINT32(0x4) != 0 {
			*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = TOPJ_UINT32(0)
		}

		*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(0)
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x80) != 0 {
			var val TOPJ_UINT32
			ms_val = frwd_fetch(tls, bp+104)
			m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))>>15&TOPJ_UINT32(1) //m_n
			frwd_advance(tls, bp+104, m_n)
			val = ms_val << 31
			v_n = ms_val & (uint32(1)<<m_n - uint32(1))
			v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x800)>>11<<m_n
			v_n = v_n | TOPJ_UINT32(1) //center of bin
			*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))

			//line_state: bit 7 (\sigma^NW), and E^NW for next quad
			*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(TOPJ_UINT32(0x80) | (TOPJ_UINT32(32) - count_leading_zeros(tls, v_n)))
		} else if locs&TOPJ_UINT32(0x8) != 0 { //if outside set to 0
			*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = TOPJ_UINT32(0)
		}

		sp += 4 //move to next column

		//second quad
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x10) != 0 {
			var val TOPJ_UINT32

			ms_val = frwd_fetch(tls, bp+104)
			m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200 + 1*4)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))>>12&TOPJ_UINT32(1) //m_n
			frwd_advance(tls, bp+104, m_n)
			val = ms_val << 31
			v_n = ms_val & (uint32(1)<<m_n - uint32(1))
			v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x100)>>8<<m_n
			v_n = v_n | TOPJ_UINT32(1)
			*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))
		} else if locs&TOPJ_UINT32(0x10) != 0 {
			*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = TOPJ_UINT32(0)
		}

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x20) != 0 {
			var val TOPJ_UINT32
			var t TOPJ_UINT32

			ms_val = frwd_fetch(tls, bp+104)
			m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200 + 1*4)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))>>13&TOPJ_UINT32(1) //m_n
			frwd_advance(tls, bp+104, m_n)
			val = ms_val << 31
			v_n = ms_val & (uint32(1)<<m_n - uint32(1))
			v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x200)>>9<<m_n
			v_n = v_n | TOPJ_UINT32(1)
			*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))

			//update line_state: bit 7 (\sigma^N), and E^N
			t = TOPJ_UINT32(int32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp))) & 0x7F) //E^NW
			v_n = TOPJ_UINT32(32) - count_leading_zeros(tls, v_n)              //E^N
			*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(TOPJ_UINT32(0x80) | func() uint32 {
				if t > v_n {
					return t
				}
				return v_n
			}()) //max(E^NW, E^N) | s
		} else if locs&TOPJ_UINT32(0x20) != 0 {
			*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = TOPJ_UINT32(0) //no need to update line_state
		}

		lsp++   //move line state to next quad
		sp += 4 //move to next sample

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x40) != 0 {
			var val TOPJ_UINT32

			ms_val = frwd_fetch(tls, bp+104)
			m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200 + 1*4)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))>>14&TOPJ_UINT32(1) //m_n
			frwd_advance(tls, bp+104, m_n)
			val = ms_val << 31
			v_n = ms_val & (uint32(1)<<m_n - uint32(1))
			v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x400)>>10<<m_n
			v_n = v_n | TOPJ_UINT32(1)
			*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))
		} else if locs&TOPJ_UINT32(0x40) != 0 {
			*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = TOPJ_UINT32(0)
		}

		*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(0)
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x80) != 0 {
			var val TOPJ_UINT32

			ms_val = frwd_fetch(tls, bp+104)
			m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 200 + 1*4)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))>>15&TOPJ_UINT32(1) //m_n
			frwd_advance(tls, bp+104, m_n)
			val = ms_val << 31
			v_n = ms_val & (uint32(1)<<m_n - uint32(1))
			v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x800)>>11<<m_n
			v_n = v_n | TOPJ_UINT32(1) //center of bin
			*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))

			//line_state: bit 7 (\sigma^NW), and E^NW for next quad
			*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(TOPJ_UINT32(0x80) | (TOPJ_UINT32(32) - count_leading_zeros(tls, v_n)))
		} else if locs&TOPJ_UINT32(0x80) != 0 {
			*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = TOPJ_UINT32(0)
		}

		sp += 4
	}

	//non-initial lines
	//////////////////////////
	for y = 2; y < height; {
		var sip uintptr
		var ls0 TOPJ_UINT8
		var x TOPJ_INT32

		sip_shift = sip_shift ^ TOPJ_UINT32(0x2) // shift sigma to the upper half od the nibble
		sip_shift = sip_shift & 0xFFFFFFEF       //move back to 0 (it might have been at 0x10)
		if y&0x4 != 0 {
			sip = sigma2
		} else {
			sip = sigma1
		} //choose sigma array

		lsp = line_state
		ls0 = *(*TOPJ_UINT8)(unsafe.Pointer(lsp))           // read the line state value
		*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(0) // and set it to zero
		sp = decoded_data + uintptr(y*stride)*4             // generated samples
		c_q = TOPJ_UINT32(0)                                // context
		for x = 0; x < width; x = x + 4 {
			// var U_q [2]TOPJ_UINT32 at bp+208, 8

			var uvlc_mode TOPJ_UINT32
			var consumed_bits TOPJ_UINT32
			var m_n TOPJ_UINT32
			var v_n TOPJ_UINT32
			var ms_val TOPJ_UINT32
			var locs TOPJ_UINT32

			// decode vlc
			/////////////

			//first quad
			// get context, eqn. 2 ITU T.814
			// c_q has \sigma^W | \sigma^SW
			c_q = c_q | TOPJ_UINT32(int32(ls0)>>7)                                         //\sigma^NW | \sigma^N
			c_q = c_q | TOPJ_UINT32(int32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 1)))>>5&0x4) //\sigma^NE | \sigma^NF

			//the following is very similar to previous code, so please refer to
			// that
			vlc_val = rev_fetch(tls, bp+80)
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192)) = TOPJ_UINT32(vlc_tbl1[c_q<<7|vlc_val&TOPJ_UINT32(0x7F)])
			if c_q == TOPJ_UINT32(0) { //zero context
				run = run - 2
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192)) = func() uint32 {
					if run == -1 {
						return *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))
					}
					return uint32(0)
				}()
				if run < 0 {
					run = mel_get_run(tls, bp+40)
				}
			}
			//prepare context for the next quad, \sigma^W | \sigma^SW
			c_q = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x40)>>5 | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x80)>>6

			//remove data from vlc stream
			vlc_val = rev_advance(tls, bp+80, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x7))

			//update sigma
			// The update depends on the value of x and y; consider one OPJ_UINT32
			// if x is 0, 8, 16 and so on, and y is 2, 6, etc., then this
			// line update c locations
			//      nibble (4 bits) number   0 1 2 3 4 5 6 7
			//                         LSB   0 0 0 0 0 0 0 0
			//                               0 0 0 0 0 0 0 0
			//                               c c 0 0 0 0 0 0
			//                               c c 0 0 0 0 0 0
			*(*TOPJ_UINT32)(unsafe.Pointer(sip)) |= (*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x30)>>4 | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0xC0)>>2) << sip_shift

			//second quad
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4)) = TOPJ_UINT32(0)
			if x+2 < width {
				c_q = c_q | TOPJ_UINT32(int32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 1)))>>7)
				c_q = c_q | TOPJ_UINT32(int32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 2)))>>5&0x4)
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4)) = TOPJ_UINT32(vlc_tbl1[c_q<<7|vlc_val&TOPJ_UINT32(0x7F)])
				if c_q == TOPJ_UINT32(0) { //zero context
					run = run - 2
					*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4)) = func() uint32 {
						if run == -1 {
							return *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))
						}
						return uint32(0)
					}()
					if run < 0 {
						run = mel_get_run(tls, bp+40)
					}
				}
				//prepare context for the next quad
				c_q = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x40)>>5 | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x80)>>6
				//remove data from vlc stream
				vlc_val = rev_advance(tls, bp+80, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x7))
			}

			//update sigma
			*(*TOPJ_UINT32)(unsafe.Pointer(sip)) |= (*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x30) | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0xC0)<<2) << (TOPJ_UINT32(4) + sip_shift)

			sip += 4 * func() uintptr {
				if x&0x7 != 0 {
					return uintptr(1)
				}
				return uintptr(0)
			}()
			sip_shift = sip_shift ^ TOPJ_UINT32(0x10)

			//retrieve u
			////////////
			uvlc_mode = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x8)>>3 | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x8)>>2
			consumed_bits = decode_noninit_uvlc(tls, vlc_val, uvlc_mode, bp+208)
			vlc_val = rev_advance(tls, bp+80, consumed_bits)

			//calculate E^max and add it to U_q, eqns 5 and 6 in ITU T.814
			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0xF0)&(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0xF0)-TOPJ_UINT32(1)) != 0 { // is \gamma_q 1?
				var E TOPJ_UINT32 = uint32(ls0) & 0x7F
				if E > uint32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 1)))&0x7F {
					E = E
				} else {
					E = uint32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 1))) & 0x7F
				} //max(E, E^NE, E^NF)
				//since U_q already has u_q + 1, we subtract 2 instead of 1
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 208)) += func() uint32 {
					if E > TOPJ_UINT32(2) {
						return E - TOPJ_UINT32(2)
					}
					return uint32(0)
				}()
			}

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0xF0)&(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0xF0)-TOPJ_UINT32(1)) != 0 { //is \gamma_q 1?
				var E TOPJ_UINT32 = uint32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 1))) & 0x7F
				if E > uint32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 2)))&0x7F {
					E = E
				} else {
					E = uint32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 2))) & 0x7F
				} //max(E, E^NE, E^NF)
				//since U_q already has u_q + 1, we subtract 2 instead of 1
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 208 + 1*4)) += func() uint32 {
					if E > TOPJ_UINT32(2) {
						return E - TOPJ_UINT32(2)
					}
					return uint32(0)
				}()
			}

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208)) > zero_bplanes_p1 || *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208 + 1*4)) > zero_bplanes_p1 {
				if p_manager_mutex != 0 {
					Xopj_mutex_lock(tls, p_manager_mutex)
				}
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,

					ts+3210, 0)
				if p_manager_mutex != 0 {
					Xopj_mutex_unlock(tls, p_manager_mutex)
				}
				return DOPJ_FALSE
			}

			ls0 = *(*TOPJ_UINT8)(unsafe.Pointer(lsp + 2)) //for next double quad
			*(*TOPJ_UINT8)(unsafe.Pointer(lsp + 1)) = libc.AssignPtrUint8(lsp+2, TOPJ_UINT8(0))

			//decode magsgn and update line_state
			/////////////////////////////////////

			//locations where samples need update
			locs = TOPJ_UINT32(0xFF)
			if x+4 > width {
				locs >>= (x + 4 - width) << 1
			}
			if y+2 <= height {
				locs = locs
			} else {
				locs = locs & TOPJ_UINT32(0x55)
			}

			if (*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0xF0)>>4|*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0xF0)) & ^locs != 0 {
				if p_manager_mutex != 0 {
					Xopj_mutex_lock(tls, p_manager_mutex)
				}
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,

					ts+3119, 0)
				if p_manager_mutex != 0 {
					Xopj_mutex_unlock(tls, p_manager_mutex)
				}
				return DOPJ_FALSE
			}

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x10) != 0 { //sigma_n
				var val TOPJ_UINT32

				ms_val = frwd_fetch(tls, bp+104)
				m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))>>12&TOPJ_UINT32(1) //m_n
				frwd_advance(tls, bp+104, m_n)
				val = ms_val << 31
				v_n = ms_val & (uint32(1)<<m_n - uint32(1))
				v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x100)>>8<<m_n
				v_n = v_n | TOPJ_UINT32(1) //center of bin
				*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))
			} else if locs&TOPJ_UINT32(0x1) != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = TOPJ_UINT32(0)
			}

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x20) != 0 { //sigma_n
				var val TOPJ_UINT32
				var t TOPJ_UINT32

				ms_val = frwd_fetch(tls, bp+104)
				m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))>>13&TOPJ_UINT32(1) //m_n
				frwd_advance(tls, bp+104, m_n)
				val = ms_val << 31
				v_n = ms_val & (uint32(1)<<m_n - uint32(1))
				v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x200)>>9<<m_n
				v_n = v_n | TOPJ_UINT32(1) //center of bin
				*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))

				//update line_state: bit 7 (\sigma^N), and E^N
				t = TOPJ_UINT32(int32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp))) & 0x7F) //E^NW
				v_n = TOPJ_UINT32(32) - count_leading_zeros(tls, v_n)
				*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(TOPJ_UINT32(0x80) | func() uint32 {
					if t > v_n {
						return t
					}
					return v_n
				}())
			} else if locs&TOPJ_UINT32(0x2) != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = TOPJ_UINT32(0) //no need to update line_state
			}

			lsp++
			sp += 4

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x40) != 0 { //sigma_n
				var val TOPJ_UINT32

				ms_val = frwd_fetch(tls, bp+104)
				m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))>>14&TOPJ_UINT32(1) //m_n
				frwd_advance(tls, bp+104, m_n)
				val = ms_val << 31
				v_n = ms_val & (uint32(1)<<m_n - uint32(1))
				v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x400)>>10<<m_n
				v_n = v_n | TOPJ_UINT32(1) //center of bin
				*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))
			} else if locs&TOPJ_UINT32(0x4) != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = TOPJ_UINT32(0)
			}

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x80) != 0 { //sigma_n
				var val TOPJ_UINT32

				ms_val = frwd_fetch(tls, bp+104)
				m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))>>15&TOPJ_UINT32(1) //m_n
				frwd_advance(tls, bp+104, m_n)
				val = ms_val << 31
				v_n = ms_val & (uint32(1)<<m_n - uint32(1))
				v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192))&TOPJ_UINT32(0x800)>>11<<m_n
				v_n = v_n | TOPJ_UINT32(1) //center of bin
				*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))

				//update line_state: bit 7 (\sigma^NW), and E^NW for next quad
				*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(TOPJ_UINT32(0x80) | (TOPJ_UINT32(32) - count_leading_zeros(tls, v_n)))
			} else if locs&TOPJ_UINT32(0x8) != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = TOPJ_UINT32(0)
			}

			sp += 4

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x10) != 0 { //sigma_n
				var val TOPJ_UINT32

				ms_val = frwd_fetch(tls, bp+104)
				m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208 + 1*4)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))>>12&TOPJ_UINT32(1) //m_n
				frwd_advance(tls, bp+104, m_n)
				val = ms_val << 31
				v_n = ms_val & (uint32(1)<<m_n - uint32(1))
				v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x100)>>8<<m_n
				v_n = v_n | TOPJ_UINT32(1) //center of bin
				*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))
			} else if locs&TOPJ_UINT32(0x10) != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = TOPJ_UINT32(0)
			}

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x20) != 0 { //sigma_n
				var val TOPJ_UINT32
				var t TOPJ_UINT32

				ms_val = frwd_fetch(tls, bp+104)
				m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208 + 1*4)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))>>13&TOPJ_UINT32(1) //m_n
				frwd_advance(tls, bp+104, m_n)
				val = ms_val << 31
				v_n = ms_val & (uint32(1)<<m_n - uint32(1))
				v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x200)>>9<<m_n
				v_n = v_n | TOPJ_UINT32(1) //center of bin
				*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))

				//update line_state: bit 7 (\sigma^N), and E^N
				t = TOPJ_UINT32(int32(*(*TOPJ_UINT8)(unsafe.Pointer(lsp))) & 0x7F) //E^NW
				v_n = TOPJ_UINT32(32) - count_leading_zeros(tls, v_n)
				*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(TOPJ_UINT32(0x80) | func() uint32 {
					if t > v_n {
						return t
					}
					return v_n
				}())
			} else if locs&TOPJ_UINT32(0x20) != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = TOPJ_UINT32(0) //no need to update line_state
			}

			lsp++
			sp += 4

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x40) != 0 { //sigma_n
				var val TOPJ_UINT32

				ms_val = frwd_fetch(tls, bp+104)
				m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208 + 1*4)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))>>14&TOPJ_UINT32(1) //m_n
				frwd_advance(tls, bp+104, m_n)
				val = ms_val << 31
				v_n = ms_val & (uint32(1)<<m_n - uint32(1))
				v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x400)>>10<<m_n
				v_n = v_n | TOPJ_UINT32(1) //center of bin
				*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))
			} else if locs&TOPJ_UINT32(0x40) != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(sp)) = TOPJ_UINT32(0)
			}

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x80) != 0 { //sigma_n
				var val TOPJ_UINT32

				ms_val = frwd_fetch(tls, bp+104)
				m_n = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 208 + 1*4)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))>>15&TOPJ_UINT32(1) //m_n
				frwd_advance(tls, bp+104, m_n)
				val = ms_val << 31
				v_n = ms_val & (uint32(1)<<m_n - uint32(1))
				v_n = v_n | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 + 1*4))&TOPJ_UINT32(0x800)>>11<<m_n
				v_n = v_n | TOPJ_UINT32(1) //center of bin
				*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = val | (v_n+TOPJ_UINT32(2))<<(p-TOPJ_UINT32(1))

				//update line_state: bit 7 (\sigma^NW), and E^NW for next quad
				*(*TOPJ_UINT8)(unsafe.Pointer(lsp)) = TOPJ_UINT8(TOPJ_UINT32(0x80) | (TOPJ_UINT32(32) - count_leading_zeros(tls, v_n)))
			} else if locs&TOPJ_UINT32(0x80) != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(sp + uintptr(stride)*4)) = TOPJ_UINT32(0)
			}

			sp += 4
		}

		y = y + 2
		if num_passes > TOPJ_UINT32(1) && y&3 == 0 { //executed at multiples of 4
			// This is for SPP and potentially MRP

			if num_passes > TOPJ_UINT32(2) { //do MRP
				// select the current stripe
				var cur_sig uintptr
				if y&0x4 != 0 {
					cur_sig = sigma1
				} else {
					cur_sig = sigma2
				}
				// the address of the data that needs updating
				var dpp uintptr = decoded_data + uintptr((y-4)*stride)*4
				var half TOPJ_UINT32 = uint32(1) << (p - TOPJ_UINT32(2)) // half the center of the bin
				var i TOPJ_INT32
				for i = 0; i < width; i = i + 8 {
					//Process one entry from sigma array at a time
					// Each nibble (4 bits) in the sigma array represents 4 rows,
					// and the 32 bits contain 8 columns
					var cwd TOPJ_UINT32 = rev_fetch_mrp(tls, bp+168)                                        // get 32 bit data
					var sig TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&cur_sig, 4))) // 32 bit that will be processed now
					var col_mask TOPJ_UINT32 = 0xF                                                          // a mask for a column in sig
					var dp uintptr = dpp + uintptr(i)*4                                                     // next column in decode samples
					if sig != 0 {                                                                           // if any of the 32 bits are set
						var j int32
						j = 0
					__1:
						if !(j < 8) {
							goto __3
						}
						{ //one column at a time
							if sig&col_mask != 0 { // lowest nibble
								var sample_mask TOPJ_UINT32 = 0x11111111 & col_mask //LSB

								if sig&sample_mask != 0 { //if LSB is set
									var sym TOPJ_UINT32

									if *(*TOPJ_UINT32)(unsafe.Pointer(dp)) != TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3304, ts+1838, uint32(2046), uintptr(unsafe.Pointer(&__func__59)))
									} // decoded value cannot be zero
									sym = cwd & TOPJ_UINT32(1) // get it value
									// remove center of bin if sym is 0
									*(*TOPJ_UINT32)(unsafe.Pointer(dp)) ^= (TOPJ_UINT32(1) - sym) << (p - TOPJ_UINT32(1))
									*(*TOPJ_UINT32)(unsafe.Pointer(dp)) |= half // put half the center of bin
									cwd >>= 1                                   //consume word
								}
								sample_mask = sample_mask + sample_mask //next row

								if sig&sample_mask != 0 {
									var sym TOPJ_UINT32

									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) != TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3315, ts+1838, uint32(2058), uintptr(unsafe.Pointer(&__func__59)))
									}
									sym = cwd & TOPJ_UINT32(1)
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) ^= (TOPJ_UINT32(1) - sym) << (p - TOPJ_UINT32(1))
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) |= half
									cwd >>= 1
								}
								sample_mask = sample_mask + sample_mask

								if sig&sample_mask != 0 {
									var sym TOPJ_UINT32

									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) != TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3331, ts+1838, uint32(2069), uintptr(unsafe.Pointer(&__func__59)))
									}
									sym = cwd & TOPJ_UINT32(1)
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) ^= (TOPJ_UINT32(1) - sym) << (p - TOPJ_UINT32(1))
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) |= half
									cwd >>= 1
								}
								sample_mask = sample_mask + sample_mask

								if sig&sample_mask != 0 {
									var sym TOPJ_UINT32

									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) != TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3351, ts+1838, uint32(2080), uintptr(unsafe.Pointer(&__func__59)))
									}
									sym = cwd & TOPJ_UINT32(1)
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) ^= (TOPJ_UINT32(1) - sym) << (p - TOPJ_UINT32(1))
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) |= half
									cwd >>= 1
								}
								sample_mask = sample_mask + sample_mask
							}
							col_mask <<= 4 //next column

						}
						goto __2
					__2:
						j++
						dp += 4
						goto __1
						goto __3
					__3:
					}
					// consume data according to the number of bits set
					rev_advance_mrp(tls, bp+168, population_count(tls, sig))
				}
			}

			if y >= 4 { // update mbr array at the end of each stripe
				//generate mbr corresponding to a stripe
				var sig uintptr
				if y&0x4 != 0 {
					sig = sigma1
				} else {
					sig = sigma2
				}
				var mbr uintptr
				if y&0x4 != 0 {
					mbr = mbr1
				} else {
					mbr = mbr2
				}

				//data is processed in patches of 8 columns, each
				// each 32 bits in sigma1 or mbr1 represent 4 rows

				//integrate horizontally
				var prev TOPJ_UINT32 = TOPJ_UINT32(0) // previous columns
				var i TOPJ_INT32
				i = 0
			__4:
				if !(i < width) {
					goto __6
				}
				{
					var t TOPJ_UINT32
					var z TOPJ_UINT32

					*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) = *(*TOPJ_UINT32)(unsafe.Pointer(sig))              //start with significant samples
					*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) |= prev >> 28                                       //for first column, left neighbors
					*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) |= *(*TOPJ_UINT32)(unsafe.Pointer(sig)) << 4        //left neighbors
					*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) |= *(*TOPJ_UINT32)(unsafe.Pointer(sig)) >> 4        //right neighbors
					*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) |= *(*TOPJ_UINT32)(unsafe.Pointer(sig + 1*4)) << 28 //for last column, right neighbors
					prev = *(*TOPJ_UINT32)(unsafe.Pointer(sig))                                              // for next group of columns

					//integrate vertically
					t = *(*TOPJ_UINT32)(unsafe.Pointer(mbr))
					z = *(*TOPJ_UINT32)(unsafe.Pointer(mbr))
					z = z | t&TOPJ_UINT32(0x77777777)<<1                                             //above neighbors
					z = z | t&0xEEEEEEEE>>1                                                          //below neighbors
					*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) = z & ^*(*TOPJ_UINT32)(unsafe.Pointer(sig)) //remove already significance samples

				}
				goto __5
			__5:
				i = i + 8
				mbr += 4
				sig += 4
				goto __4
				goto __6
			__6:
			}

			if y >= 8 { //wait until 8 rows has been processed
				var cur_sig uintptr
				var cur_mbr uintptr
				var nxt_sig uintptr
				var nxt_mbr uintptr
				var prev TOPJ_UINT32
				var val TOPJ_UINT32
				var i TOPJ_INT32

				// add membership from the next stripe, obtained above
				if y&0x4 != 0 {
					cur_sig = sigma2
				} else {
					cur_sig = sigma1
				}
				if y&0x4 != 0 {
					cur_mbr = mbr2
				} else {
					cur_mbr = mbr1
				}
				if y&0x4 != 0 {
					nxt_sig = sigma1
				} else {
					nxt_sig = sigma2
				} //future samples
				prev = TOPJ_UINT32(0) // the columns before these group of 8 columns
				i = 0
			__7:
				if !(i < width) {
					goto __9
				}
				{
					var t TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))
					t = t | prev>>28                                           //for first column, left neighbors
					t = t | *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))<<4        //left neighbors
					t = t | *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))>>4        //right neighbors
					t = t | *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig + 1*4))<<28 //for last column, right neighbors
					prev = *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))            // for next group of columns

					if !(stripe_causal != 0) {
						*(*TOPJ_UINT32)(unsafe.Pointer(cur_mbr)) |= t & 0x11111111 << 3 //propagate up to cur_mbr
					}
					*(*TOPJ_UINT32)(unsafe.Pointer(cur_mbr)) &= ^*(*TOPJ_UINT32)(unsafe.Pointer(cur_sig)) //remove already significance samples

				}
				goto __8
			__8:
				i = i + 8
				cur_mbr += 4
				cur_sig += 4
				nxt_sig += 4
				goto __7
				goto __9
			__9:
				;

				//find new locations and get signs
				if y&0x4 != 0 {
					cur_sig = sigma2
				} else {
					cur_sig = sigma1
				}
				if y&0x4 != 0 {
					cur_mbr = mbr2
				} else {
					cur_mbr = mbr1
				}
				if y&0x4 != 0 {
					nxt_sig = sigma1
				} else {
					nxt_sig = sigma2
				} //future samples
				if y&0x4 != 0 {
					nxt_mbr = mbr1
				} else {
					nxt_mbr = mbr2
				} //future samples
				val = uint32(3) << (p - TOPJ_UINT32(2)) // sample values for newly discovered
				// significant samples including the bin center
				i = 0
			__10:
				if !(i < width) {
					goto __12
				}
				{
					var ux TOPJ_UINT32
					var tx TOPJ_UINT32
					var mbr TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(cur_mbr))
					var new_sig TOPJ_UINT32 = TOPJ_UINT32(0)
					if mbr != 0 { //are there any samples that might be significant
						var n TOPJ_INT32
						for n = 0; n < 8; n = n + 4 {
							var col_mask TOPJ_UINT32
							var inv_sig TOPJ_UINT32
							var end TOPJ_INT32
							var j TOPJ_INT32

							var cwd TOPJ_UINT32 = frwd_fetch(tls, bp+136) //get 32 bits
							var cnt TOPJ_UINT32 = TOPJ_UINT32(0)

							var dp uintptr = decoded_data + uintptr((y-8)*stride)*4
							dp += 4 * uintptr(i+n) //address for decoded samples

							col_mask = uint32(0xF) << (4 * n) //a mask to select a column

							inv_sig = ^*(*TOPJ_UINT32)(unsafe.Pointer(cur_sig)) // insignificant samples

							//find the last sample we operate on
							if n+4+i < width {
								end = n + 4
							} else {
								end = width - i
							}

							j = n
						__13:
							if !(j < end) {
								goto __15
							}
							{
								var sample_mask TOPJ_UINT32

								if col_mask&mbr == TOPJ_UINT32(0) { //no samples need checking
									goto __14
								}

								//scan mbr to find a new significant sample
								sample_mask = 0x11111111 & col_mask // LSB
								if mbr&sample_mask != 0 {
									if *(*TOPJ_UINT32)(unsafe.Pointer(dp)) == TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3371, ts+1838, uint32(2193), uintptr(unsafe.Pointer(&__func__59)))
									} // the sample must have been 0
									if cwd&TOPJ_UINT32(1) != 0 { //if this sample has become significant
										// must propagate it to nearby samples
										var t TOPJ_UINT32
										new_sig = new_sig | sample_mask // new significant samples
										t = uint32(0x32) << (j * 4)     // propagation to neighbors
										mbr = mbr | t&inv_sig           //remove already significant samples
									}
									cwd >>= 1
									cnt++ //consume bit and increment number of
									//consumed bits
								}

								sample_mask = sample_mask + sample_mask // next row
								if mbr&sample_mask != 0 {
									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) == TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3382, ts+1838, uint32(2208), uintptr(unsafe.Pointer(&__func__59)))
									}
									if cwd&TOPJ_UINT32(1) != 0 {
										var t TOPJ_UINT32
										new_sig = new_sig | sample_mask
										t = uint32(0x74) << (j * 4)
										mbr = mbr | t&inv_sig
									}
									cwd >>= 1
									cnt++
								}

								sample_mask = sample_mask + sample_mask
								if mbr&sample_mask != 0 {
									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) == TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3398, ts+1838, uint32(2221), uintptr(unsafe.Pointer(&__func__59)))
									}
									if cwd&TOPJ_UINT32(1) != 0 {
										var t TOPJ_UINT32
										new_sig = new_sig | sample_mask
										t = uint32(0xE8) << (j * 4)
										mbr = mbr | t&inv_sig
									}
									cwd >>= 1
									cnt++
								}

								sample_mask = sample_mask + sample_mask
								if mbr&sample_mask != 0 {
									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) == TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3418, ts+1838, uint32(2234), uintptr(unsafe.Pointer(&__func__59)))
									}
									if cwd&TOPJ_UINT32(1) != 0 {
										var t TOPJ_UINT32
										new_sig = new_sig | sample_mask
										t = uint32(0xC0) << (j * 4)
										mbr = mbr | t&inv_sig
									}
									cwd >>= 1
									cnt++
								}

							}
							goto __14
						__14:
							j++
							dp += 4
							col_mask <<= 4
							goto __13
							goto __15
						__15:
							;

							//obtain signs here
							if new_sig&(uint32(0xFFFF)<<(4*n)) != 0 { //if any
								var col_mask TOPJ_UINT32
								var j TOPJ_INT32
								var dp uintptr = decoded_data + uintptr((y-8)*stride)*4
								dp += 4 * uintptr(i+n)            // decoded samples address
								col_mask = uint32(0xF) << (4 * n) //mask to select a column

								j = n
							__16:
								if !(j < end) {
									goto __18
								}
								{
									var sample_mask TOPJ_UINT32

									if col_mask&new_sig == TOPJ_UINT32(0) { //if non is significant
										goto __17
									}

									//scan 4 signs
									sample_mask = 0x11111111 & col_mask
									if new_sig&sample_mask != 0 {
										if *(*TOPJ_UINT32)(unsafe.Pointer(dp)) == TOPJ_UINT32(0) {
										} else {
											libc.X__assert_fail(tls, ts+3371, ts+1838, uint32(2264), uintptr(unsafe.Pointer(&__func__59)))
										}
										*(*TOPJ_UINT32)(unsafe.Pointer(dp)) |= cwd&TOPJ_UINT32(1)<<31 | val //put value and sign
										cwd >>= 1
										cnt++ //consume bit and increment number
										//of consumed bits
									}

									sample_mask = sample_mask + sample_mask
									if new_sig&sample_mask != 0 {
										if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) == TOPJ_UINT32(0) {
										} else {
											libc.X__assert_fail(tls, ts+3382, ts+1838, uint32(2273), uintptr(unsafe.Pointer(&__func__59)))
										}
										*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) |= cwd&TOPJ_UINT32(1)<<31 | val
										cwd >>= 1
										cnt++
									}

									sample_mask = sample_mask + sample_mask
									if new_sig&sample_mask != 0 {
										if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) == TOPJ_UINT32(0) {
										} else {
											libc.X__assert_fail(tls, ts+3398, ts+1838, uint32(2281), uintptr(unsafe.Pointer(&__func__59)))
										}
										*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) |= cwd&TOPJ_UINT32(1)<<31 | val
										cwd >>= 1
										cnt++
									}

									sample_mask = sample_mask + sample_mask
									if new_sig&sample_mask != 0 {
										if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) == TOPJ_UINT32(0) {
										} else {
											libc.X__assert_fail(tls, ts+3418, ts+1838, uint32(2289), uintptr(unsafe.Pointer(&__func__59)))
										}
										*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) |= cwd&TOPJ_UINT32(1)<<31 | val
										cwd >>= 1
										cnt++
									}

								}
								goto __17
							__17:
								j++
								dp += 4
								col_mask <<= 4
								goto __16
								goto __18
							__18:
							}
							frwd_advance(tls, bp+136, cnt) //consume the bits from bitstrm
							cnt = TOPJ_UINT32(0)

							//update the next 8 columns
							if n == 4 {
								//horizontally
								var t TOPJ_UINT32 = new_sig >> 28
								t = t | (t&TOPJ_UINT32(0xE)>>1 | t&TOPJ_UINT32(7)<<1)
								*(*TOPJ_UINT32)(unsafe.Pointer(cur_mbr + 1*4)) |= t & ^*(*TOPJ_UINT32)(unsafe.Pointer(cur_sig + 1*4))
							}
						}
					}
					//update the next stripe (vertically propagation)
					new_sig = new_sig | *(*TOPJ_UINT32)(unsafe.Pointer(cur_sig))
					ux = new_sig & 0x88888888 >> 3
					tx = ux | ux<<4 | ux>>4 //left and right neighbors
					if i > 0 {
						*(*TOPJ_UINT32)(unsafe.Pointer(nxt_mbr + libc.UintptrFromInt32(-1)*4)) |= ux << 28 & ^*(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig + libc.UintptrFromInt32(-1)*4))
					}
					*(*TOPJ_UINT32)(unsafe.Pointer(nxt_mbr)) |= tx & ^*(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))
					*(*TOPJ_UINT32)(unsafe.Pointer(nxt_mbr + 1*4)) |= ux >> 28 & ^*(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig + 1*4))

				}
				goto __11
			__11:
				i = i + 8
				cur_sig += 4
				cur_mbr += 4
				nxt_sig += 4
				nxt_mbr += 4
				goto __10
				goto __12
			__12:
				;

				//clear current sigma
				//mbr need not be cleared because it is overwritten
				if y&0x4 != 0 {
					cur_sig = sigma2
				} else {
					cur_sig = sigma1
				}
				libc.Xmemset(tls, cur_sig, 0, uint32(((TOPJ_UINT32(width)+7)>>3+1)<<2))
			}
		}
	}

	//terminating
	if num_passes > TOPJ_UINT32(1) {
		var st TOPJ_INT32
		var y TOPJ_INT32

		if num_passes > TOPJ_UINT32(2) && (height&3 == 1 || height&3 == 2) {
			//do magref
			var cur_sig uintptr
			if height&0x4 != 0 {
				cur_sig = sigma2
			} else {
				cur_sig = sigma1
			} //reversed
			var dpp uintptr = decoded_data + uintptr(height&0xFFFFFC*stride)*4
			var half TOPJ_UINT32 = uint32(1) << (p - TOPJ_UINT32(2))
			var i TOPJ_INT32
			for i = 0; i < width; i = i + 8 {
				var cwd TOPJ_UINT32 = rev_fetch_mrp(tls, bp+168)
				var sig TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&cur_sig, 4)))
				var col_mask TOPJ_UINT32 = TOPJ_UINT32(0xF)
				var dp uintptr = dpp + uintptr(i)*4
				if sig != 0 {
					var j int32
					j = 0
				__19:
					if !(j < 8) {
						goto __21
					}
					{
						if sig&col_mask != 0 {
							var sample_mask TOPJ_UINT32 = TOPJ_UINT32(0x11111111) & col_mask

							if sig&sample_mask != 0 {
								var sym TOPJ_UINT32
								if *(*TOPJ_UINT32)(unsafe.Pointer(dp)) != TOPJ_UINT32(0) {
								} else {
									libc.X__assert_fail(tls, ts+3304, ts+1838, uint32(2351), uintptr(unsafe.Pointer(&__func__59)))
								}
								sym = cwd & TOPJ_UINT32(1)
								*(*TOPJ_UINT32)(unsafe.Pointer(dp)) ^= (TOPJ_UINT32(1) - sym) << (p - TOPJ_UINT32(1))
								*(*TOPJ_UINT32)(unsafe.Pointer(dp)) |= half
								cwd >>= 1
							}
							sample_mask = sample_mask + sample_mask

							if sig&sample_mask != 0 {
								var sym TOPJ_UINT32
								if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) != TOPJ_UINT32(0) {
								} else {
									libc.X__assert_fail(tls, ts+3315, ts+1838, uint32(2361), uintptr(unsafe.Pointer(&__func__59)))
								}
								sym = cwd & TOPJ_UINT32(1)
								*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) ^= (TOPJ_UINT32(1) - sym) << (p - TOPJ_UINT32(1))
								*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) |= half
								cwd >>= 1
							}
							sample_mask = sample_mask + sample_mask

							if sig&sample_mask != 0 {
								var sym TOPJ_UINT32
								if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) != TOPJ_UINT32(0) {
								} else {
									libc.X__assert_fail(tls, ts+3331, ts+1838, uint32(2371), uintptr(unsafe.Pointer(&__func__59)))
								}
								sym = cwd & TOPJ_UINT32(1)
								*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) ^= (TOPJ_UINT32(1) - sym) << (p - TOPJ_UINT32(1))
								*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) |= half
								cwd >>= 1
							}
							sample_mask = sample_mask + sample_mask

							if sig&sample_mask != 0 {
								var sym TOPJ_UINT32
								if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) != TOPJ_UINT32(0) {
								} else {
									libc.X__assert_fail(tls, ts+3351, ts+1838, uint32(2381), uintptr(unsafe.Pointer(&__func__59)))
								}
								sym = cwd & TOPJ_UINT32(1)
								*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) ^= (TOPJ_UINT32(1) - sym) << (p - TOPJ_UINT32(1))
								*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) |= half
								cwd >>= 1
							}
							sample_mask = sample_mask + sample_mask
						}
						col_mask <<= 4

					}
					goto __20
				__20:
					j++
					dp += 4
					goto __19
					goto __21
				__21:
				}
				rev_advance_mrp(tls, bp+168, population_count(tls, sig))
			}
		}

		//do the last incomplete stripe
		// for cases of (height & 3) == 0 and 3
		// the should have been processed previously
		if height&3 == 1 || height&3 == 2 {
			//generate mbr of first stripe
			var sig uintptr
			if height&0x4 != 0 {
				sig = sigma2
			} else {
				sig = sigma1
			}
			var mbr uintptr
			if height&0x4 != 0 {
				mbr = mbr2
			} else {
				mbr = mbr1
			}
			//integrate horizontally
			var prev TOPJ_UINT32 = TOPJ_UINT32(0)
			var i TOPJ_INT32
			i = 0
		__22:
			if !(i < width) {
				goto __24
			}
			{
				var t TOPJ_UINT32
				var z TOPJ_UINT32

				*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) = *(*TOPJ_UINT32)(unsafe.Pointer(sig))
				*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) |= prev >> 28                                       //for first column, left neighbors
				*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) |= *(*TOPJ_UINT32)(unsafe.Pointer(sig)) << 4        //left neighbors
				*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) |= *(*TOPJ_UINT32)(unsafe.Pointer(sig)) >> 4        //left neighbors
				*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) |= *(*TOPJ_UINT32)(unsafe.Pointer(sig + 1*4)) << 28 //for last column, right neighbors
				prev = *(*TOPJ_UINT32)(unsafe.Pointer(sig))

				//integrate vertically
				t = *(*TOPJ_UINT32)(unsafe.Pointer(mbr))
				z = *(*TOPJ_UINT32)(unsafe.Pointer(mbr))
				z = z | t&TOPJ_UINT32(0x77777777)<<1                                             //above neighbors
				z = z | t&0xEEEEEEEE>>1                                                          //below neighbors
				*(*TOPJ_UINT32)(unsafe.Pointer(mbr)) = z & ^*(*TOPJ_UINT32)(unsafe.Pointer(sig)) //remove already significance samples

			}
			goto __23
		__23:
			i = i + 8
			mbr += 4
			sig += 4
			goto __22
			goto __24
		__24:
		}

		st = height
		st = st - func() int32 {
			if height > 6 {
				return (height+1)&3 + 3
			}
			return height
		}()
		for y = st; y < height; y = y + 4 {
			var cur_sig uintptr
			var cur_mbr uintptr
			var nxt_sig uintptr
			var nxt_mbr uintptr
			var val TOPJ_UINT32
			var i TOPJ_INT32

			var pattern TOPJ_UINT32 = 0xFFFFFFFF // a pattern needed samples
			if height-y == 3 {
				pattern = 0x77777777
			} else if height-y == 2 {
				pattern = 0x33333333
			} else if height-y == 1 {
				pattern = 0x11111111
			}

			//add membership from the next stripe, obtained above
			if height-y > 4 {
				var prev TOPJ_UINT32 = TOPJ_UINT32(0)
				var i TOPJ_INT32
				if y&0x4 != 0 {
					cur_sig = sigma2
				} else {
					cur_sig = sigma1
				}
				if y&0x4 != 0 {
					cur_mbr = mbr2
				} else {
					cur_mbr = mbr1
				}
				if y&0x4 != 0 {
					nxt_sig = sigma1
				} else {
					nxt_sig = sigma2
				}
				i = 0
			__25:
				if !(i < width) {
					goto __27
				}
				{
					var t TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))
					t = t | prev>>28                                           //for first column, left neighbors
					t = t | *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))<<4        //left neighbors
					t = t | *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))>>4        //left neighbors
					t = t | *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig + 1*4))<<28 //for last column, right neighbors
					prev = *(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))

					if !(stripe_causal != 0) {
						*(*TOPJ_UINT32)(unsafe.Pointer(cur_mbr)) |= t & 0x11111111 << 3
					}
					//remove already significance samples
					*(*TOPJ_UINT32)(unsafe.Pointer(cur_mbr)) &= ^*(*TOPJ_UINT32)(unsafe.Pointer(cur_sig))

				}
				goto __26
			__26:
				i = i + 8
				cur_mbr += 4
				cur_sig += 4
				nxt_sig += 4
				goto __25
				goto __27
			__27:
			}

			//find new locations and get signs
			if y&0x4 != 0 {
				cur_sig = sigma2
			} else {
				cur_sig = sigma1
			}
			if y&0x4 != 0 {
				cur_mbr = mbr2
			} else {
				cur_mbr = mbr1
			}
			if y&0x4 != 0 {
				nxt_sig = sigma1
			} else {
				nxt_sig = sigma2
			}
			if y&0x4 != 0 {
				nxt_mbr = mbr1
			} else {
				nxt_mbr = mbr2
			}
			val = uint32(3) << (p - TOPJ_UINT32(2))
			i = 0
		__28:
			if !(i < width) {
				goto __30
			}
			{
				var mbr TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(cur_mbr)) & pattern //skip unneeded samples
				var new_sig TOPJ_UINT32 = TOPJ_UINT32(0)
				var ux TOPJ_UINT32
				var tx TOPJ_UINT32
				if mbr != 0 {
					var n TOPJ_INT32
					for n = 0; n < 8; n = n + 4 {
						var col_mask TOPJ_UINT32
						var inv_sig TOPJ_UINT32
						var end TOPJ_INT32
						var j TOPJ_INT32

						var cwd TOPJ_UINT32 = frwd_fetch(tls, bp+136)
						var cnt TOPJ_UINT32 = TOPJ_UINT32(0)

						var dp uintptr = decoded_data + uintptr(y*stride)*4
						dp += 4 * uintptr(i+n)

						col_mask = uint32(0xF) << (4 * n)

						inv_sig = ^*(*TOPJ_UINT32)(unsafe.Pointer(cur_sig)) & pattern

						if n+4+i < width {
							end = n + 4
						} else {
							end = width - i
						}
						j = n
					__31:
						if !(j < end) {
							goto __33
						}
						{
							var sample_mask TOPJ_UINT32

							if col_mask&mbr == TOPJ_UINT32(0) {
								goto __32
							}

							//scan 4 mbr
							sample_mask = 0x11111111 & col_mask
							if mbr&sample_mask != 0 {
								if *(*TOPJ_UINT32)(unsafe.Pointer(dp)) == TOPJ_UINT32(0) {
								} else {
									libc.X__assert_fail(tls, ts+3371, ts+1838, uint32(2503), uintptr(unsafe.Pointer(&__func__59)))
								}
								if cwd&TOPJ_UINT32(1) != 0 {
									var t TOPJ_UINT32
									new_sig = new_sig | sample_mask
									t = uint32(0x32) << (j * 4)
									mbr = mbr | t&inv_sig
								}
								cwd >>= 1
								cnt++
							}

							sample_mask = sample_mask + sample_mask
							if mbr&sample_mask != 0 {
								if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) == TOPJ_UINT32(0) {
								} else {
									libc.X__assert_fail(tls, ts+3382, ts+1838, uint32(2516), uintptr(unsafe.Pointer(&__func__59)))
								}
								if cwd&TOPJ_UINT32(1) != 0 {
									var t TOPJ_UINT32
									new_sig = new_sig | sample_mask
									t = uint32(0x74) << (j * 4)
									mbr = mbr | t&inv_sig
								}
								cwd >>= 1
								cnt++
							}

							sample_mask = sample_mask + sample_mask
							if mbr&sample_mask != 0 {
								if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) == TOPJ_UINT32(0) {
								} else {
									libc.X__assert_fail(tls, ts+3398, ts+1838, uint32(2529), uintptr(unsafe.Pointer(&__func__59)))
								}
								if cwd&TOPJ_UINT32(1) != 0 {
									var t TOPJ_UINT32
									new_sig = new_sig | sample_mask
									t = uint32(0xE8) << (j * 4)
									mbr = mbr | t&inv_sig
								}
								cwd >>= 1
								cnt++
							}

							sample_mask = sample_mask + sample_mask
							if mbr&sample_mask != 0 {
								if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) == TOPJ_UINT32(0) {
								} else {
									libc.X__assert_fail(tls, ts+3418, ts+1838, uint32(2542), uintptr(unsafe.Pointer(&__func__59)))
								}
								if cwd&TOPJ_UINT32(1) != 0 {
									var t TOPJ_UINT32
									new_sig = new_sig | sample_mask
									t = uint32(0xC0) << (j * 4)
									mbr = mbr | t&inv_sig
								}
								cwd >>= 1
								cnt++
							}

						}
						goto __32
					__32:
						j++
						dp += 4
						col_mask <<= 4
						goto __31
						goto __33
					__33:
						;

						//signs here
						if new_sig&(uint32(0xFFFF)<<(4*n)) != 0 {
							var col_mask TOPJ_UINT32
							var j TOPJ_INT32
							var dp uintptr = decoded_data + uintptr(y*stride)*4
							dp += 4 * uintptr(i+n)
							col_mask = uint32(0xF) << (4 * n)

							j = n
						__34:
							if !(j < end) {
								goto __36
							}
							{
								var sample_mask TOPJ_UINT32
								if col_mask&new_sig == TOPJ_UINT32(0) {
									goto __35
								}

								//scan 4 signs
								sample_mask = 0x11111111 & col_mask
								if new_sig&sample_mask != 0 {
									if *(*TOPJ_UINT32)(unsafe.Pointer(dp)) == TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3371, ts+1838, uint32(2571), uintptr(unsafe.Pointer(&__func__59)))
									}
									*(*TOPJ_UINT32)(unsafe.Pointer(dp)) |= cwd&TOPJ_UINT32(1)<<31 | val
									cwd >>= 1
									cnt++
								}

								sample_mask = sample_mask + sample_mask
								if new_sig&sample_mask != 0 {
									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) == TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3382, ts+1838, uint32(2579), uintptr(unsafe.Pointer(&__func__59)))
									}
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(stride)*4)) |= cwd&TOPJ_UINT32(1)<<31 | val
									cwd >>= 1
									cnt++
								}

								sample_mask = sample_mask + sample_mask
								if new_sig&sample_mask != 0 {
									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) == TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3398, ts+1838, uint32(2587), uintptr(unsafe.Pointer(&__func__59)))
									}
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(2*stride)*4)) |= cwd&TOPJ_UINT32(1)<<31 | val
									cwd >>= 1
									cnt++
								}

								sample_mask = sample_mask + sample_mask
								if new_sig&sample_mask != 0 {
									if *(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) == TOPJ_UINT32(0) {
									} else {
										libc.X__assert_fail(tls, ts+3418, ts+1838, uint32(2595), uintptr(unsafe.Pointer(&__func__59)))
									}
									*(*TOPJ_UINT32)(unsafe.Pointer(dp + uintptr(3*stride)*4)) |= cwd&TOPJ_UINT32(1)<<31 | val
									cwd >>= 1
									cnt++
								}

							}
							goto __35
						__35:
							j++
							dp += 4
							col_mask <<= 4
							goto __34
							goto __36
						__36:
						}
						frwd_advance(tls, bp+136, cnt)
						cnt = TOPJ_UINT32(0)

						//update next columns
						if n == 4 {
							//horizontally
							var t TOPJ_UINT32 = new_sig >> 28
							t = t | (t&TOPJ_UINT32(0xE)>>1 | t&TOPJ_UINT32(7)<<1)
							*(*TOPJ_UINT32)(unsafe.Pointer(cur_mbr + 1*4)) |= t & ^*(*TOPJ_UINT32)(unsafe.Pointer(cur_sig + 1*4))
						}
					}
				}
				//propagate down (vertically propagation)
				new_sig = new_sig | *(*TOPJ_UINT32)(unsafe.Pointer(cur_sig))
				ux = new_sig & 0x88888888 >> 3
				tx = ux | ux<<4 | ux>>4
				if i > 0 {
					*(*TOPJ_UINT32)(unsafe.Pointer(nxt_mbr + libc.UintptrFromInt32(-1)*4)) |= ux << 28 & ^*(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig + libc.UintptrFromInt32(-1)*4))
				}
				*(*TOPJ_UINT32)(unsafe.Pointer(nxt_mbr)) |= tx & ^*(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig))
				*(*TOPJ_UINT32)(unsafe.Pointer(nxt_mbr + 1*4)) |= ux >> 28 & ^*(*TOPJ_UINT32)(unsafe.Pointer(nxt_sig + 1*4))

			}
			goto __29
		__29:
			i = i + 8
			cur_sig += 4
			cur_mbr += 4
			nxt_sig += 4
			nxt_mbr += 4
			goto __28
			goto __30
		__30:
		}
	}

	{
		var x TOPJ_INT32
		var y TOPJ_INT32
		for y = 0; y < height; y++ {
			var sp uintptr = decoded_data + uintptr(y*stride)*4
			x = 0
		__37:
			if !(x < width) {
				goto __39
			}
			{
				var val TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(sp)) & 0x7FFFFFFF
				*(*TOPJ_INT32)(unsafe.Pointer(sp)) = func() int32 {
					if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(sp)))&0x80000000 != 0 {
						return -val
					}
					return val
				}()

			}
			goto __38
		__38:
			x++
			sp += 4
			goto __37
			goto __39
		__39:
		}

	}

	return DOPJ_TRUE
}

var __func__59 = *(*[22]int8)(unsafe.Pointer(ts + 3438)) /* ht_dec.c:1104:1 */

func Xopj_image_create0(tls *libc.TLS) uintptr { /* image.c:34:12: */
	var image uintptr = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_image_t{})))
	return image
}

func Xopj_image_create(tls *libc.TLS, numcmpts TOPJ_UINT32, cmptparms uintptr, clrspc TOPJ_COLOR_SPACE) uintptr { /* image.c:40:12: */
	var compno TOPJ_UINT32
	var image uintptr = uintptr(0)

	image = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_image_t{})))
	if image != 0 {
		(*Topj_image_t)(unsafe.Pointer(image)).Fcolor_space = clrspc
		(*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps = numcmpts
		// allocate memory for the per-component information
		(*Topj_image_t)(unsafe.Pointer(image)).Fcomps = Xopj_calloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps),
			uint32(unsafe.Sizeof(Topj_image_comp_t{})))
		if !(int32((*Topj_image_t)(unsafe.Pointer(image)).Fcomps) != 0) {
			// TODO replace with event manager, breaks API
			// fprintf(stderr,"Unable to allocate memory for image.\n");
			Xopj_image_destroy(tls, image)
			return uintptr(0)
		}
		// create the individual image components
		for compno = TOPJ_UINT32(0); compno < numcmpts; compno++ {
			var comp uintptr = (*Topj_image_t)(unsafe.Pointer(image)).Fcomps + uintptr(compno)*64
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fdx = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fdx
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fdy = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fdy
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fw = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fw
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fh = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fh
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fx0 = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fx0
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fy0 = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fy0
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fprec = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fprec
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fsgnd = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fsgnd
			if (*Topj_image_comp_t)(unsafe.Pointer(comp)).Fh != TOPJ_UINT32(0) && uint64(TOPJ_SIZE_T((*Topj_image_comp_t)(unsafe.Pointer(comp)).Fw)) > libc.Uint64(18446744073709551615)/uint64((*Topj_image_comp_t)(unsafe.Pointer(comp)).Fh)/uint64(unsafe.Sizeof(TOPJ_INT32(0))) {
				// TODO event manager
				Xopj_image_destroy(tls, image)
				return uintptr(0)
			}
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fdata = Xopj_image_data_alloc(tls,
				Tsize_t((*Topj_image_comp_t)(unsafe.Pointer(comp)).Fw)*Tsize_t((*Topj_image_comp_t)(unsafe.Pointer(comp)).Fh)*Tsize_t(unsafe.Sizeof(TOPJ_INT32(0))))
			if !(int32((*Topj_image_comp_t)(unsafe.Pointer(comp)).Fdata) != 0) {
				// TODO replace with event manager, breaks API
				// fprintf(stderr,"Unable to allocate memory for image.\n");
				Xopj_image_destroy(tls, image)
				return uintptr(0)
			}
			libc.Xmemset(tls, (*Topj_image_comp_t)(unsafe.Pointer(comp)).Fdata, 0, Tsize_t((*Topj_image_comp_t)(unsafe.Pointer(comp)).Fw)*Tsize_t((*Topj_image_comp_t)(unsafe.Pointer(comp)).Fh)*Tsize_t(unsafe.Sizeof(TOPJ_INT32(0))))
		}
	}

	return image
}

func Xopj_image_destroy(tls *libc.TLS, image uintptr) { /* image.c:91:19: */
	if image != 0 {
		if (*Topj_image_t)(unsafe.Pointer(image)).Fcomps != 0 {
			var compno TOPJ_UINT32

			// image components
			for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; compno++ {
				var image_comp uintptr = (*Topj_image_t)(unsafe.Pointer(image)).Fcomps + uintptr(compno)*64
				if (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdata != 0 {
					Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdata)
				}
			}
			Xopj_free(tls, (*Topj_image_t)(unsafe.Pointer(image)).Fcomps)
		}

		if (*Topj_image_t)(unsafe.Pointer(image)).Ficc_profile_buf != 0 {
			Xopj_free(tls, (*Topj_image_t)(unsafe.Pointer(image)).Ficc_profile_buf)
		}

		Xopj_free(tls, image)
	}
}

// *
// Updates the components characteristics of the image from the coding parameters.
//
// @param p_image_header    the image header to update.
// @param p_cp              the coding parameters from which to update the image.
func Xopj_image_comp_header_update(tls *libc.TLS, p_image_header uintptr, p_cp uintptr) { /* image.c:121:6: */
	var i TOPJ_UINT32
	var l_width TOPJ_UINT32
	var l_height TOPJ_UINT32
	var l_x0 TOPJ_UINT32
	var l_y0 TOPJ_UINT32
	var l_x1 TOPJ_UINT32
	var l_y1 TOPJ_UINT32
	var l_comp_x0 TOPJ_UINT32
	var l_comp_y0 TOPJ_UINT32
	var l_comp_x1 TOPJ_UINT32
	var l_comp_y1 TOPJ_UINT32
	var l_img_comp uintptr = uintptr(0)

	l_x0 = opj_uint_max(tls, (*Sopj_cp)(unsafe.Pointer(p_cp)).Ftx0, (*Topj_image_t)(unsafe.Pointer(p_image_header)).Fx0)
	l_y0 = opj_uint_max(tls, (*Sopj_cp)(unsafe.Pointer(p_cp)).Fty0, (*Topj_image_t)(unsafe.Pointer(p_image_header)).Fy0)
	l_x1 = (*Sopj_cp)(unsafe.Pointer(p_cp)).Ftx0 + ((*Sopj_cp)(unsafe.Pointer(p_cp)).Ftw-1)*(*Sopj_cp)(unsafe.Pointer(p_cp)).Ftdx // validity of p_cp members used here checked in opj_j2k_read_siz. Can't overflow.
	l_y1 = (*Sopj_cp)(unsafe.Pointer(p_cp)).Fty0 + ((*Sopj_cp)(unsafe.Pointer(p_cp)).Fth-1)*(*Sopj_cp)(unsafe.Pointer(p_cp)).Ftdy // can't overflow
	l_x1 = opj_uint_min(tls, opj_uint_adds(tls, l_x1, (*Sopj_cp)(unsafe.Pointer(p_cp)).Ftdx),
		(*Topj_image_t)(unsafe.Pointer(p_image_header)).Fx1) // use add saturated to prevent overflow
	l_y1 = opj_uint_min(tls, opj_uint_adds(tls, l_y1, (*Sopj_cp)(unsafe.Pointer(p_cp)).Ftdy),
		(*Topj_image_t)(unsafe.Pointer(p_image_header)).Fy1) // use add saturated to prevent overflow

	l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image_header)).Fcomps
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(p_image_header)).Fnumcomps; i++ {
		l_comp_x0 = opj_uint_ceildiv(tls, l_x0, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)
		l_comp_y0 = opj_uint_ceildiv(tls, l_y0, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)
		l_comp_x1 = opj_uint_ceildiv(tls, l_x1, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)
		l_comp_y1 = opj_uint_ceildiv(tls, l_y1, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)
		l_width = opj_uint_ceildivpow2(tls, l_comp_x1-l_comp_x0, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor)
		l_height = opj_uint_ceildivpow2(tls, l_comp_y1-l_comp_y0, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor)
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fw = l_width
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fh = l_height
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fx0 = l_comp_x0
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fy0 = l_comp_y0
		l_img_comp += 64
	}
}

// *
// Copy only header of image and its component header (no data are copied)
// if dest image have data, they will be freed
//
// @param   p_image_src     the src image
// @param   p_image_dest    the dest image
//
func Xopj_copy_image_header(tls *libc.TLS, p_image_src uintptr, p_image_dest uintptr) { /* image.c:164:6: */
	var compno TOPJ_UINT32

	// preconditions
	if p_image_src != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3460, ts+3478, uint32(170), uintptr(unsafe.Pointer(&__func__64)))
	}
	if p_image_dest != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3505, ts+3478, uint32(171), uintptr(unsafe.Pointer(&__func__64)))
	}

	(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fx0 = (*Topj_image_t)(unsafe.Pointer(p_image_src)).Fx0
	(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fy0 = (*Topj_image_t)(unsafe.Pointer(p_image_src)).Fy0
	(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fx1 = (*Topj_image_t)(unsafe.Pointer(p_image_src)).Fx1
	(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fy1 = (*Topj_image_t)(unsafe.Pointer(p_image_src)).Fy1

	if (*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps != 0 {
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fnumcomps; compno++ {
			var image_comp uintptr = (*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps + uintptr(compno)*64
			if (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdata != 0 {
				Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdata)
			}
		}
		Xopj_free(tls, (*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps)
		(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps = uintptr(0)
	}

	(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fnumcomps = (*Topj_image_t)(unsafe.Pointer(p_image_src)).Fnumcomps

	(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps = Xopj_malloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fnumcomps)*uint32(unsafe.Sizeof(Topj_image_comp_t{})))
	if !(int32((*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps) != 0) {
		(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps = uintptr(0)
		(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fnumcomps = TOPJ_UINT32(0)
		return
	}

	for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fnumcomps; compno++ {
		libc.Xmemcpy(tls, (*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps+uintptr(compno)*64,
			(*Topj_image_t)(unsafe.Pointer(p_image_src)).Fcomps+uintptr(compno)*64,
			uint32(unsafe.Sizeof(Topj_image_comp_t{})))
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcomps + uintptr(compno)*64)).Fdata = uintptr(0)
	}

	(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Fcolor_space = (*Topj_image_t)(unsafe.Pointer(p_image_src)).Fcolor_space
	(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_len = (*Topj_image_t)(unsafe.Pointer(p_image_src)).Ficc_profile_len

	if (*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_len != 0 {
		(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_buf = Xopj_malloc(tls,
			uint32((*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_len))
		if !(int32((*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_buf) != 0) {
			(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_buf = uintptr(0)
			(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_len = TOPJ_UINT32(0)
			return
		}
		libc.Xmemcpy(tls, (*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_buf,
			(*Topj_image_t)(unsafe.Pointer(p_image_src)).Ficc_profile_buf,
			uint32((*Topj_image_t)(unsafe.Pointer(p_image_src)).Ficc_profile_len))
	} else {
		(*Topj_image_t)(unsafe.Pointer(p_image_dest)).Ficc_profile_buf = uintptr(0)
	}

	return
}

var __func__64 = *(*[22]int8)(unsafe.Pointer(ts + 3524)) /* image.c:166:1 */

func Xopj_image_tile_create(tls *libc.TLS, numcmpts TOPJ_UINT32, cmptparms uintptr, clrspc TOPJ_COLOR_SPACE) uintptr { /* image.c:227:12: */
	var compno TOPJ_UINT32
	var image uintptr = uintptr(00)

	image = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_image_t{})))
	if image != 0 {

		(*Topj_image_t)(unsafe.Pointer(image)).Fcolor_space = clrspc
		(*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps = numcmpts

		// allocate memory for the per-component information
		(*Topj_image_t)(unsafe.Pointer(image)).Fcomps = Xopj_calloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps),
			uint32(unsafe.Sizeof(Topj_image_comp_t{})))
		if !(int32((*Topj_image_t)(unsafe.Pointer(image)).Fcomps) != 0) {
			Xopj_image_destroy(tls, image)
			return uintptr(00)
		}

		// create the individual image components
		for compno = TOPJ_UINT32(0); compno < numcmpts; compno++ {
			var comp uintptr = (*Topj_image_t)(unsafe.Pointer(image)).Fcomps + uintptr(compno)*64
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fdx = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fdx
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fdy = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fdy
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fw = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fw
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fh = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fh
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fx0 = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fx0
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fy0 = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fy0
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fprec = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fprec
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fsgnd = (*Topj_image_cmptparm_t)(unsafe.Pointer(cmptparms + uintptr(compno)*36)).Fsgnd
			(*Topj_image_comp_t)(unsafe.Pointer(comp)).Fdata = uintptr(0)
		}
	}

	return image
}

//
// ==========================================================
//    Matric inversion interface
// ==========================================================
// *
// Matrix inversion.
func Xopj_matrix_inversion_f(tls *libc.TLS, pSrcMatrix uintptr, pDestMatrix uintptr, nb_compo TOPJ_UINT32) TOPJ_BOOL { /* invert.c:70:10: */
	var l_data uintptr = uintptr(00)
	var l_permutation_size TOPJ_UINT32 = nb_compo * TOPJ_UINT32(unsafe.Sizeof(TOPJ_UINT32(0)))
	var l_swap_size TOPJ_UINT32 = nb_compo * TOPJ_UINT32(unsafe.Sizeof(TOPJ_FLOAT32(0)))
	var l_total_size TOPJ_UINT32 = l_permutation_size + TOPJ_UINT32(3)*l_swap_size
	var lPermutations uintptr = uintptr(00)
	var l_double_data uintptr = uintptr(00)

	l_data = Xopj_malloc(tls, uint32(l_total_size))
	if l_data == uintptr(0) {
		return DOPJ_FALSE
	}
	lPermutations = l_data
	l_double_data = l_data + uintptr(l_permutation_size)
	libc.Xmemset(tls, lPermutations, 0, uint32(l_permutation_size))

	if !(opj_lupDecompose(tls, pSrcMatrix, lPermutations, l_double_data, nb_compo) != 0) {
		Xopj_free(tls, l_data)
		return DOPJ_FALSE
	}

	opj_lupInvert(tls, pSrcMatrix, pDestMatrix, nb_compo, lPermutations, l_double_data,
		l_double_data+uintptr(nb_compo)*4, l_double_data+uintptr(TOPJ_UINT32(2)*nb_compo)*4)
	Xopj_free(tls, l_data)

	return DOPJ_TRUE
}

//
// ==========================================================
//    Local functions
// ==========================================================
func opj_lupDecompose(tls *libc.TLS, matrix uintptr, permutations uintptr, p_swap_area uintptr, nb_compo TOPJ_UINT32) TOPJ_BOOL { /* invert.c:107:17: */
	var tmpPermutations uintptr = permutations
	var dstPermutations uintptr
	var k2 TOPJ_UINT32 = TOPJ_UINT32(0)
	var t TOPJ_UINT32
	var temp TOPJ_FLOAT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var k TOPJ_UINT32
	var p TOPJ_FLOAT32
	var lLastColum TOPJ_UINT32 = nb_compo - TOPJ_UINT32(1)
	var lSwapSize TOPJ_UINT32 = nb_compo * TOPJ_UINT32(unsafe.Sizeof(TOPJ_FLOAT32(0)))
	var lTmpMatrix uintptr = matrix
	var lColumnMatrix uintptr
	var lDestMatrix uintptr
	var offset TOPJ_UINT32 = TOPJ_UINT32(1)
	var lStride TOPJ_UINT32 = nb_compo - TOPJ_UINT32(1)

	//initialize permutations
	for i = TOPJ_UINT32(0); i < nb_compo; i++ {
		*(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&tmpPermutations, 4))) = i
	}
	// now make a pivot with column switch
	tmpPermutations = permutations
	for k = TOPJ_UINT32(0); k < lLastColum; k++ {
		p = 0.0

		// take the middle element
		lColumnMatrix = lTmpMatrix + uintptr(k)*4

		// make permutation with the biggest value in the column
		for i = k; i < nb_compo; i++ {
			temp = func() float32 {
				if *(*TOPJ_FLOAT32)(unsafe.Pointer(lColumnMatrix)) > float32(0) {
					return *(*TOPJ_FLOAT32)(unsafe.Pointer(lColumnMatrix))
				}
				return -*(*TOPJ_FLOAT32)(unsafe.Pointer(lColumnMatrix))
			}()
			if temp > p {
				p = temp
				k2 = i
			}
			// next line
			lColumnMatrix += 4 * uintptr(nb_compo)
		}

		// a whole rest of 0 -> non singular
		if float64(p) == 0.0 {
			return DOPJ_FALSE
		}

		// should we permute ?
		if k2 != k {
			//exchange of line
			// k2 > k
			dstPermutations = tmpPermutations + uintptr(k2)*4 - uintptr(k)*4
			// swap indices
			t = *(*TOPJ_UINT32)(unsafe.Pointer(tmpPermutations))
			*(*TOPJ_UINT32)(unsafe.Pointer(tmpPermutations)) = *(*TOPJ_UINT32)(unsafe.Pointer(dstPermutations))
			*(*TOPJ_UINT32)(unsafe.Pointer(dstPermutations)) = t

			// and swap entire line.
			lColumnMatrix = lTmpMatrix + uintptr((k2-k)*nb_compo)*4
			libc.Xmemcpy(tls, p_swap_area, lColumnMatrix, uint32(lSwapSize))
			libc.Xmemcpy(tls, lColumnMatrix, lTmpMatrix, uint32(lSwapSize))
			libc.Xmemcpy(tls, lTmpMatrix, p_swap_area, uint32(lSwapSize))
		}

		// now update data in the rest of the line and line after
		lDestMatrix = lTmpMatrix + uintptr(k)*4
		lColumnMatrix = lDestMatrix + uintptr(nb_compo)*4
		// take the middle element
		temp = *(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lDestMatrix, 4)))

		// now compute up data (i.e. coeff up of the diagonal).
		for i = offset; i < nb_compo; i++ {
			//lColumnMatrix;
			// divide the lower column elements by the diagonal value

			// matrix[i][k] /= matrix[k][k];
			// p = matrix[i][k]
			p = *(*TOPJ_FLOAT32)(unsafe.Pointer(lColumnMatrix)) / temp
			*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lColumnMatrix, 4))) = p

			for j = offset; j < nb_compo; j++ {
				// matrix[i][j] -= matrix[i][k] * matrix[k][j];
				*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lColumnMatrix, 4))) -= p * *(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lDestMatrix, 4)))
			}
			// come back to the k+1th element
			lDestMatrix -= 4 * uintptr(lStride)
			// go to kth element of the next line
			lColumnMatrix += 4 * uintptr(k)
		}

		// offset is now k+2
		offset++
		// 1 element less for stride
		lStride--
		// next line
		lTmpMatrix += 4 * uintptr(nb_compo)
		// next permutation element
		tmpPermutations += 4
	}
	return DOPJ_TRUE
}

func opj_lupSolve(tls *libc.TLS, pResult uintptr, pMatrix uintptr, pVector uintptr, pPermutations uintptr, nb_compo TOPJ_UINT32, p_intermediate_data uintptr) { /* invert.c:208:13: */
	var k TOPJ_INT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var sum TOPJ_FLOAT32
	var u TOPJ_FLOAT32
	var lStride TOPJ_UINT32 = nb_compo + TOPJ_UINT32(1)
	var lCurrentPtr uintptr
	var lIntermediatePtr uintptr
	var lDestPtr uintptr
	var lTmpMatrix uintptr
	var lLineMatrix uintptr = pMatrix
	var lBeginPtr uintptr = pResult + uintptr(nb_compo)*4 - uintptr(1)*4
	var lGeneratedData uintptr
	var lCurrentPermutationPtr uintptr = pPermutations

	lIntermediatePtr = p_intermediate_data
	lGeneratedData = p_intermediate_data + uintptr(nb_compo)*4 - uintptr(1)*4

	for i = TOPJ_UINT32(0); i < nb_compo; i++ {
		sum = 0.0
		lCurrentPtr = p_intermediate_data
		lTmpMatrix = lLineMatrix
		for j = TOPJ_UINT32(1); j <= i; j++ {
			// sum += matrix[i][j-1] * y[j-1];
			sum = sum + *(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lTmpMatrix, 4)))**(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lCurrentPtr, 4)))
		}
		//y[i] = pVector[pPermutations[i]] - sum;
		*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lIntermediatePtr, 4))) = *(*TOPJ_FLOAT32)(unsafe.Pointer(pVector + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&lCurrentPermutationPtr, 4))))*4)) - sum
		lLineMatrix += 4 * uintptr(nb_compo)
	}

	// we take the last point of the matrix
	lLineMatrix = pMatrix + uintptr(nb_compo*nb_compo)*4 - uintptr(1)*4

	// and we take after the last point of the destination vector
	lDestPtr = pResult + uintptr(nb_compo)*4

	if nb_compo != TOPJ_UINT32(0) {
	} else {
		libc.X__assert_fail(tls, ts+3546, ts+3560, uint32(252), uintptr(unsafe.Pointer(&__func__69)))
	}
	for k = TOPJ_INT32(nb_compo) - 1; k != -1; k-- {
		sum = 0.0
		lTmpMatrix = lLineMatrix
		u = *(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lTmpMatrix, 4)))
		lCurrentPtr = libc.PostDecUintptr(&lDestPtr, 4)
		for j = TOPJ_UINT32(k + 1); j < nb_compo; j++ {
			// sum += matrix[k][j] * x[j]
			sum = sum + *(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lTmpMatrix, 4)))**(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lCurrentPtr, 4)))
		}
		//x[k] = (y[k] - sum) / u;
		*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostDecUintptr(&lBeginPtr, 4))) = (*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostDecUintptr(&lGeneratedData, 4))) - sum) / u
		lLineMatrix -= 4 * uintptr(lStride)
	}
}

var __func__69 = *(*[13]int8)(unsafe.Pointer(ts + 3588)) /* invert.c:213:1 */

func opj_lupInvert(tls *libc.TLS, pSrcMatrix uintptr, pDestMatrix uintptr, nb_compo TOPJ_UINT32, pPermutations uintptr, p_src_temp uintptr, p_dest_temp uintptr, p_swap_area uintptr) { /* invert.c:269:13: */
	var j TOPJ_UINT32
	var i TOPJ_UINT32
	var lCurrentPtr uintptr
	var lLineMatrix uintptr = pDestMatrix
	var lSwapSize TOPJ_UINT32 = nb_compo * TOPJ_UINT32(unsafe.Sizeof(TOPJ_FLOAT32(0)))

	for j = TOPJ_UINT32(0); j < nb_compo; j++ {
		lCurrentPtr = libc.PostIncUintptr(&lLineMatrix, 4)
		libc.Xmemset(tls, p_src_temp, 0, uint32(lSwapSize))
		*(*TOPJ_FLOAT32)(unsafe.Pointer(p_src_temp + uintptr(j)*4)) = 1.0
		opj_lupSolve(tls, p_dest_temp, pSrcMatrix, p_src_temp, pPermutations, nb_compo,
			p_swap_area)

		for i = TOPJ_UINT32(0); i < nb_compo; i++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(lCurrentPtr)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(p_dest_temp + uintptr(i)*4))
			lCurrentPtr += 4 * uintptr(nb_compo)
		}
	}
}

// *
// Reads the lookup table containing all the marker, status and action, and returns the handler associated
// with the marker value.
// @param       p_id            Marker value to look up
//
// @return      the handler associated with the id.
type Sopj_dec_memory_marker_handler = struct {
	Fid      TOPJ_UINT32
	Fstates  TOPJ_UINT32
	Fhandler uintptr
} /* j2k.c:197:14 */

func opj_j2k_update_tlm(tls *libc.TLS, p_j2k uintptr, p_tile_part_size TOPJ_UINT32) { /* j2k.c:911:13: */
	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_Ttlmi_is_byte != 0 {
		Xopj_write_bytes_LE(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_current,
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, uint32(1))
		*(*uintptr)(unsafe.Pointer(p_j2k + 8 + 32)) += uintptr(1)
	} else {
		Xopj_write_bytes_LE(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_current,
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, uint32(2))
		*(*uintptr)(unsafe.Pointer(p_j2k + 8 + 32)) += uintptr(2)
	}

	Xopj_write_bytes_LE(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_current,
		p_tile_part_size, uint32(4)) // PSOT
	*(*uintptr)(unsafe.Pointer(p_j2k + 8 + 32)) += uintptr(4)
}

//@}

//@}

// -----------------------------------------------------------------------
type Sj2k_prog_order = struct {
	Fenum_prog   TOPJ_PROG_ORDER
	Fstr_prog    [5]int8
	F__ccgo_pad1 [3]byte
} /* j2k.c:1347:9 */

//@}

//@}

// -----------------------------------------------------------------------
type Tj2k_prog_order_t = Sj2k_prog_order /* j2k.c:1350:3 */

var j2k_prog_order_list = [6]Tj2k_prog_order_t{
	{Fenum_prog: OPJ_CPRL, Fstr_prog: *(*[5]int8)(unsafe.Pointer(ts + 3601))},
	{Fstr_prog: *(*[5]int8)(unsafe.Pointer(ts + 3606))},
	{Fenum_prog: OPJ_PCRL, Fstr_prog: *(*[5]int8)(unsafe.Pointer(ts + 3611))},
	{Fenum_prog: OPJ_RLCP, Fstr_prog: *(*[5]int8)(unsafe.Pointer(ts + 3616))},
	{Fenum_prog: OPJ_RPCL, Fstr_prog: *(*[5]int8)(unsafe.Pointer(ts + 3621))},
	{Fenum_prog: -1, Fstr_prog: *(*[5]int8)(unsafe.Pointer(ts + 3626))},
} /* j2k.c:1352:31 */

// *
// FIXME DOC
var sMCT_ELEMENT_SIZE = [4]TOPJ_UINT32{
	TOPJ_UINT32(2),
	TOPJ_UINT32(4),
	TOPJ_UINT32(4),
	TOPJ_UINT32(8),
} /* j2k.c:1364:25 */

type Topj_j2k_mct_function = uintptr /* j2k.c:1371:14 */

var j2k_mct_read_functions_to_float = [4]Topj_j2k_mct_function{
	0,
	0,
	0,
	0,
} /* j2k.c:1374:35 */

var j2k_mct_read_functions_to_int32 = [4]Topj_j2k_mct_function{
	0,
	0,
	0,
	0,
} /* j2k.c:1381:35 */

var j2k_mct_write_functions_from_float = [4]Topj_j2k_mct_function{
	0,
	0,
	0,
	0,
} /* j2k.c:1388:35 */

type Topj_dec_memory_marker_handler_t = Sopj_dec_memory_marker_handler /* j2k.c:1406:1 */

var j2k_memory_marker_handler_tab = [23]Topj_dec_memory_marker_handler_t{
	{Fid: TOPJ_UINT32(DJ2K_MS_SOT), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPHSOT), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_COD), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_COC), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_RGN), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_QCD), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_QCC), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_POC), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_SIZ), Fstates: J2K_STATE_MHSIZ, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_TLM), Fstates: J2K_STATE_MH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_PLM), Fstates: J2K_STATE_MH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_PLT), Fstates: J2K_STATE_TPH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_PPM), Fstates: J2K_STATE_MH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_PPT), Fstates: J2K_STATE_TPH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_SOP)},
	{Fid: TOPJ_UINT32(DJ2K_MS_CRG), Fstates: J2K_STATE_MH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_COM), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_MCT), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_CBD), Fstates: J2K_STATE_MH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_CAP), Fstates: J2K_STATE_MH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_CPF), Fstates: J2K_STATE_MH, Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_MCC), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJ2K_MS_MCO), Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH), Fhandler: 0},
	{Fstates: TOPJ_UINT32(J2K_STATE_MH | J2K_STATE_TPH)},
} /* j2k.c:1408:46 */

func opj_j2k_read_int16_to_float(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1447:14: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_src_data uintptr = p_src_data
	var l_dest_data uintptr = p_dest_data
	var i TOPJ_UINT32
	// var l_temp TOPJ_UINT32 at bp, 4

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		Xopj_read_bytes_LE(tls, l_src_data, bp, uint32(2))

		l_src_data += uintptr(unsafe.Sizeof(TOPJ_INT16(0)))

		*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_data, 4))) = TOPJ_FLOAT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_temp */)))
	}
}

func opj_j2k_read_int32_to_float(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1464:14: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_src_data uintptr = p_src_data
	var l_dest_data uintptr = p_dest_data
	var i TOPJ_UINT32
	// var l_temp TOPJ_UINT32 at bp, 4

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		Xopj_read_bytes_LE(tls, l_src_data, bp, uint32(4))

		l_src_data += uintptr(unsafe.Sizeof(TOPJ_INT32(0)))

		*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_data, 4))) = TOPJ_FLOAT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_temp */)))
	}
}

func opj_j2k_read_float32_to_float(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1481:14: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_src_data uintptr = p_src_data
	var l_dest_data uintptr = p_dest_data
	var i TOPJ_UINT32
	// var l_temp TOPJ_FLOAT32 at bp, 4

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		Xopj_read_float_LE(tls, l_src_data, bp)

		l_src_data += uintptr(unsafe.Sizeof(TOPJ_FLOAT32(0)))

		*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_data, 4))) = *(*TOPJ_FLOAT32)(unsafe.Pointer(bp /* l_temp */))
	}
}

func opj_j2k_read_float64_to_float(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1498:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var l_src_data uintptr = p_src_data
	var l_dest_data uintptr = p_dest_data
	var i TOPJ_UINT32
	// var l_temp TOPJ_FLOAT64 at bp, 8

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		Xopj_read_double_LE(tls, l_src_data, bp)

		l_src_data += uintptr(unsafe.Sizeof(TOPJ_FLOAT64(0)))

		*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_data, 4))) = TOPJ_FLOAT32(*(*TOPJ_FLOAT64)(unsafe.Pointer(bp /* l_temp */)))
	}
}

func opj_j2k_read_int16_to_int32(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1515:14: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_src_data uintptr = p_src_data
	var l_dest_data uintptr = p_dest_data
	var i TOPJ_UINT32
	// var l_temp TOPJ_UINT32 at bp, 4

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		Xopj_read_bytes_LE(tls, l_src_data, bp, uint32(2))

		l_src_data += uintptr(unsafe.Sizeof(TOPJ_INT16(0)))

		*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_data, 4))) = TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_temp */)))
	}
}

func opj_j2k_read_int32_to_int32(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1532:14: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_src_data uintptr = p_src_data
	var l_dest_data uintptr = p_dest_data
	var i TOPJ_UINT32
	// var l_temp TOPJ_UINT32 at bp, 4

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		Xopj_read_bytes_LE(tls, l_src_data, bp, uint32(4))

		l_src_data += uintptr(unsafe.Sizeof(TOPJ_INT32(0)))

		*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_data, 4))) = TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_temp */)))
	}
}

func opj_j2k_read_float32_to_int32(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1549:14: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_src_data uintptr = p_src_data
	var l_dest_data uintptr = p_dest_data
	var i TOPJ_UINT32
	// var l_temp TOPJ_FLOAT32 at bp, 4

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		Xopj_read_float_LE(tls, l_src_data, bp)

		l_src_data += uintptr(unsafe.Sizeof(TOPJ_FLOAT32(0)))

		*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_data, 4))) = TOPJ_INT32(*(*TOPJ_FLOAT32)(unsafe.Pointer(bp /* l_temp */)))
	}
}

func opj_j2k_read_float64_to_int32(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1566:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var l_src_data uintptr = p_src_data
	var l_dest_data uintptr = p_dest_data
	var i TOPJ_UINT32
	// var l_temp TOPJ_FLOAT64 at bp, 8

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		Xopj_read_double_LE(tls, l_src_data, bp)

		l_src_data += uintptr(unsafe.Sizeof(TOPJ_FLOAT64(0)))

		*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_data, 4))) = TOPJ_INT32(*(*TOPJ_FLOAT64)(unsafe.Pointer(bp /* l_temp */)))
	}
}

func opj_j2k_write_float_to_int16(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1583:14: */
	var l_dest_data uintptr = p_dest_data
	var l_src_data uintptr = p_src_data
	var i TOPJ_UINT32
	var l_temp TOPJ_UINT32

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		l_temp = TOPJ_UINT32(*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_data, 4))))

		Xopj_write_bytes_LE(tls, l_dest_data, l_temp, uint32(unsafe.Sizeof(TOPJ_INT16(0))))

		l_dest_data += uintptr(unsafe.Sizeof(TOPJ_INT16(0)))
	}
}

func opj_j2k_write_float_to_int32(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1600:13: */
	var l_dest_data uintptr = p_dest_data
	var l_src_data uintptr = p_src_data
	var i TOPJ_UINT32
	var l_temp TOPJ_UINT32

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		l_temp = TOPJ_UINT32(*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_data, 4))))

		Xopj_write_bytes_LE(tls, l_dest_data, l_temp, uint32(unsafe.Sizeof(TOPJ_INT32(0))))

		l_dest_data += uintptr(unsafe.Sizeof(TOPJ_INT32(0)))
	}
}

func opj_j2k_write_float_to_float(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1617:14: */
	var l_dest_data uintptr = p_dest_data
	var l_src_data uintptr = p_src_data
	var i TOPJ_UINT32
	var l_temp TOPJ_FLOAT32

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		l_temp = *(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_data, 4)))

		Xopj_write_float_LE(tls, l_dest_data, l_temp)

		l_dest_data += uintptr(unsafe.Sizeof(TOPJ_FLOAT32(0)))
	}
}

func opj_j2k_write_float_to_float64(tls *libc.TLS, p_src_data uintptr, p_dest_data uintptr, p_nb_elem TOPJ_UINT32) { /* j2k.c:1634:14: */
	var l_dest_data uintptr = p_dest_data
	var l_src_data uintptr = p_src_data
	var i TOPJ_UINT32
	var l_temp TOPJ_FLOAT64

	for i = TOPJ_UINT32(0); i < p_nb_elem; i++ {
		l_temp = TOPJ_FLOAT64(*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_data, 4))))

		Xopj_write_double_LE(tls, l_dest_data, l_temp)

		l_dest_data += uintptr(unsafe.Sizeof(TOPJ_FLOAT64(0)))
	}
}

func Xopj_j2k_convert_progression_order(tls *libc.TLS, prg_order TOPJ_PROG_ORDER) uintptr { /* j2k.c:1651:12: */
	var po uintptr
	for po = uintptr(unsafe.Pointer(&j2k_prog_order_list)); (*Tj2k_prog_order_t)(unsafe.Pointer(po)).Fenum_prog != -1; po += 12 {
		if (*Tj2k_prog_order_t)(unsafe.Pointer(po)).Fenum_prog == prg_order {
			return po + 4 /* &.str_prog */
		}
	}
	return po + 4 /* &.str_prog */
}

func opj_j2k_check_poc_val(tls *libc.TLS, p_pocs uintptr, tileno TOPJ_UINT32, p_nb_pocs TOPJ_UINT32, p_nb_resolutions TOPJ_UINT32, p_num_comps TOPJ_UINT32, p_num_layers TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:1662:17: */
	var packet_array uintptr
	var index TOPJ_UINT32
	var resno TOPJ_UINT32
	var compno TOPJ_UINT32
	var layno TOPJ_UINT32
	var i TOPJ_UINT32
	var step_c TOPJ_UINT32 = TOPJ_UINT32(1)
	var step_r TOPJ_UINT32 = p_num_comps * step_c
	var step_l TOPJ_UINT32 = p_nb_resolutions * step_r
	var loss TOPJ_BOOL = DOPJ_FALSE

	if p_nb_pocs > TOPJ_UINT32(0) {
	} else {
		libc.X__assert_fail(tls, ts+3631, ts+3645, uint32(1678), uintptr(unsafe.Pointer(&__func__74)))
	}

	packet_array = Xopj_calloc(tls, Tsize_t(step_l)*Tsize_t(p_num_layers),
		uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
	if packet_array == uintptr(00) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+3670, 0)
		return DOPJ_FALSE
	}

	// iterate through all the pocs that match our tile of interest.
	for i = TOPJ_UINT32(0); i < p_nb_pocs; i++ {
		var poc uintptr = p_pocs + uintptr(i)*148
		if tileno+TOPJ_UINT32(1) == (*Topj_poc_t)(unsafe.Pointer(poc)).Ftile {
			index = step_r * (*Topj_poc_t)(unsafe.Pointer(poc)).Fresno0

			// take each resolution for each poc
			for resno = (*Topj_poc_t)(unsafe.Pointer(poc)).Fresno0; resno < opj_uint_min(tls, (*Topj_poc_t)(unsafe.Pointer(poc)).Fresno1, p_nb_resolutions); resno++ {
				var res_index TOPJ_UINT32 = index + (*Topj_poc_t)(unsafe.Pointer(poc)).Fcompno0*step_c

				// take each comp of each resolution for each poc
				for compno = (*Topj_poc_t)(unsafe.Pointer(poc)).Fcompno0; compno < opj_uint_min(tls, (*Topj_poc_t)(unsafe.Pointer(poc)).Fcompno1, p_num_comps); compno++ {
					// The layer index always starts at zero for every progression.
					var layno0 TOPJ_UINT32 = TOPJ_UINT32(0)
					var comp_index TOPJ_UINT32 = res_index + layno0*step_l

					// and finally take each layer of each res of ...
					for layno = layno0; layno < opj_uint_min(tls, (*Topj_poc_t)(unsafe.Pointer(poc)).Flayno1, p_num_layers); layno++ {
						*(*TOPJ_UINT32)(unsafe.Pointer(packet_array + uintptr(comp_index)*4)) = TOPJ_UINT32(1)
						comp_index = comp_index + step_l
					}

					res_index = res_index + step_c
				}

				index = index + step_r
			}
		}
	}

	index = TOPJ_UINT32(0)
	for layno = TOPJ_UINT32(0); layno < p_num_layers; layno++ {
		for resno = TOPJ_UINT32(0); resno < p_nb_resolutions; resno++ {
			for compno = TOPJ_UINT32(0); compno < p_num_comps; compno++ {
				loss = loss | libc.Bool32(*(*TOPJ_UINT32)(unsafe.Pointer(packet_array + uintptr(index)*4)) != TOPJ_UINT32(1))
				index = index + step_c
			}
		}
	}

	if loss != 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+3718, 0)
	}

	Xopj_free(tls, packet_array)

	return libc.BoolInt32(!(loss != 0))
}

var __func__74 = *(*[22]int8)(unsafe.Pointer(ts + 3757)) /* j2k.c:1669:1 */

// -----------------------------------------------------------------------

func opj_j2k_get_num_tp(tls *libc.TLS, cp uintptr, pino TOPJ_UINT32, tileno TOPJ_UINT32) TOPJ_UINT32 { /* j2k.c:1749:19: */
	var prog uintptr = uintptr(00)
	var i TOPJ_INT32
	var tpnum TOPJ_UINT32 = TOPJ_UINT32(1)
	var tcp uintptr = uintptr(00)
	var l_current_poc uintptr = uintptr(00)

	//  preconditions
	if tileno < (*Topj_cp_t)(unsafe.Pointer(cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+3779, ts+3645, uint32(1759), uintptr(unsafe.Pointer(&__func__75)))
	}
	if pino < (*Topj_tcp_t)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps+uintptr(tileno)*5696)).Fnumpocs+TOPJ_UINT32(1) {
	} else {
		libc.X__assert_fail(tls, ts+3806, ts+3645, uint32(1760), uintptr(unsafe.Pointer(&__func__75)))
	}

	// get the given tile coding parameter
	tcp = (*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps + uintptr(tileno)*5696
	if tcp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3844, ts+3645, uint32(1764), uintptr(unsafe.Pointer(&__func__75)))
	}

	l_current_poc = tcp + 424 + uintptr(pino)*148
	if l_current_poc != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+3854, ts+3645, uint32(1767), uintptr(unsafe.Pointer(&__func__75)))
	}

	// get the progression order as a character string
	prog = Xopj_j2k_convert_progression_order(tls, (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fprg)
	if libc.Xstrlen(tls, prog) > Tsize_t(0) {
	} else {
		libc.X__assert_fail(tls, ts+3873, ts+3645, uint32(1771), uintptr(unsafe.Pointer(&__func__75)))
	}

	if int32(*(*uint8)(unsafe.Pointer(cp + 120 + 20))&0x8>>3) == 1 {
		for i = 0; i < 4; i++ {
			switch int32(*(*TOPJ_CHAR)(unsafe.Pointer(prog + uintptr(i)))) {
			// component wise
			case 'C':
				tpnum = tpnum * (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).FcompE
				break
				fallthrough
			// resolution wise
			case 'R':
				tpnum = tpnum * (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).FresE
				break
				fallthrough
			// precinct wise
			case 'P':
				tpnum = tpnum * (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).FprcE
				break
				fallthrough
			// layer wise
			case 'L':
				tpnum = tpnum * (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).FlayE
				break
			}
			// would we split here ?
			if int32((*Topj_encoding_param_t)(unsafe.Pointer(cp+120)).Fm_tp_flag) == int32(*(*TOPJ_CHAR)(unsafe.Pointer(prog + uintptr(i)))) {
				(*Topj_encoding_param_t)(unsafe.Pointer(cp + 120)).Fm_tp_pos = i
				break
			}
		}
	} else {
		tpnum = TOPJ_UINT32(1)
	}

	return tpnum
}

var __func__75 = *(*[19]int8)(unsafe.Pointer(ts + 3890)) /* j2k.c:1751:1 */

func opj_j2k_calculate_tp(tls *libc.TLS, p_j2k uintptr, cp uintptr, p_nb_tiles uintptr, image uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:1806:17: */
	var pino TOPJ_UINT32
	var tileno TOPJ_UINT32
	var l_nb_tiles TOPJ_UINT32
	var tcp uintptr

	// preconditions
	if p_nb_tiles != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3909, ts+3645, uint32(1818), uintptr(unsafe.Pointer(&__func__76)))
	}
	if cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3926, ts+3645, uint32(1819), uintptr(unsafe.Pointer(&__func__76)))
	}
	if image != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3935, ts+3645, uint32(1820), uintptr(unsafe.Pointer(&__func__76)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(1821), uintptr(unsafe.Pointer(&__func__76)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(1822), uintptr(unsafe.Pointer(&__func__76)))
	}

	_ = p_j2k
	_ = p_manager

	l_nb_tiles = (*Topj_cp_t)(unsafe.Pointer(cp)).Ftw * (*Topj_cp_t)(unsafe.Pointer(cp)).Fth
	*(*TOPJ_UINT32)(unsafe.Pointer(p_nb_tiles)) = TOPJ_UINT32(0)
	tcp = (*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps

	/* INDEX >> */
	/* TODO mergeV2: check this part which use cstr_info */
	/*if (p_j2k->cstr_info) {
	          opj_tile_info_t * l_info_tile_ptr = p_j2k->cstr_info->tile;

	          for (tileno = 0; tileno < l_nb_tiles; ++tileno) {
	                  OPJ_UINT32 cur_totnum_tp = 0;

	                  opj_pi_update_encoding_parameters(image,cp,tileno);

	                  for (pino = 0; pino <= tcp->numpocs; ++pino)
	                  {
	                          OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);

	                          *p_nb_tiles = *p_nb_tiles + tp_num;

	                          cur_totnum_tp += tp_num;
	                  }

	                  tcp->m_nb_tile_parts = cur_totnum_tp;

	                  l_info_tile_ptr->tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));
	                  if (l_info_tile_ptr->tp == 00) {
	                          return OPJ_FALSE;
	                  }

	                  memset(l_info_tile_ptr->tp,0,cur_totnum_tp * sizeof(opj_tp_info_t));

	                  l_info_tile_ptr->num_tps = cur_totnum_tp;

	                  ++l_info_tile_ptr;
	                  ++tcp;
	          }
	  }
	  else */{
		for tileno = TOPJ_UINT32(0); tileno < l_nb_tiles; tileno++ {
			var cur_totnum_tp TOPJ_UINT32 = TOPJ_UINT32(0)

			Xopj_pi_update_encoding_parameters(tls, image, cp, tileno)

			for pino = TOPJ_UINT32(0); pino <= (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fnumpocs; pino++ {
				var tp_num TOPJ_UINT32 = opj_j2k_get_num_tp(tls, cp, pino, tileno)

				*(*TOPJ_UINT32)(unsafe.Pointer(p_nb_tiles)) = *(*TOPJ_UINT32)(unsafe.Pointer(p_nb_tiles)) + tp_num

				cur_totnum_tp = cur_totnum_tp + tp_num
			}
			(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fm_nb_tile_parts = cur_totnum_tp

			tcp += 5696
		}

	}

	return DOPJ_TRUE
}

var __func__76 = *(*[21]int8)(unsafe.Pointer(ts + 3975)) /* j2k.c:1812:1 */

func opj_j2k_write_soc(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:1887:17: */
	// 2 bytes will be written
	var l_start_stream uintptr = uintptr(00)

	// preconditions
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(1895), uintptr(unsafe.Pointer(&__func__77)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(1896), uintptr(unsafe.Pointer(&__func__77)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(1897), uintptr(unsafe.Pointer(&__func__77)))
	}

	l_start_stream = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	// write SOC identifier
	Xopj_write_bytes_LE(tls, l_start_stream, uint32(DJ2K_MS_SOC), uint32(2))

	if Xopj_stream_write_data(tls, p_stream, l_start_stream, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
		return DOPJ_FALSE
	}

	// UniPG>>
	// <<UniPG

	return DOPJ_TRUE
}

var __func__77 = *(*[18]int8)(unsafe.Pointer(ts + 4011)) /* j2k.c:1890:1 */

// *
// Reads a SOC marker (Start of Codestream)
// @param       p_j2k           the jpeg2000 file codec.
// @param       p_stream        FIXME DOC
// @param       p_manager       the user event manager.
func opj_j2k_read_soc(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:1927:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var l_data [2]TOPJ_BYTE at bp+8, 2

	// var l_marker TOPJ_UINT32 at bp+12, 4

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(1936), uintptr(unsafe.Pointer(&__func__78)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(1937), uintptr(unsafe.Pointer(&__func__78)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(1938), uintptr(unsafe.Pointer(&__func__78)))
	}

	if Xopj_stream_read_data(tls, p_stream, bp+8, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, bp+8, bp+12, uint32(2))
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) != TOPJ_UINT32(DJ2K_MS_SOC) {
		return DOPJ_FALSE
	}

	// Next marker should be a SIZ marker in the main header
	(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_MHSIZ

	// FIXME move it in a index structure included in p_j2k
	(*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmain_head_start = Xopj_stream_tell(tls, p_stream) - 2

	Xopj_event_msg(tls, p_manager, DEVT_INFO,
		ts+4029,
		libc.VaList(bp, (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmain_head_start))

	// Add the marker to the codestream index
	if DOPJ_FALSE == opj_j2k_add_mhmarker(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index, uint32(DJ2K_MS_SOC),
		(*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmain_head_start, uint32(2)) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+4067, 0)
		return DOPJ_FALSE
	}
	return DOPJ_TRUE
}

var __func__78 = *(*[17]int8)(unsafe.Pointer(ts + 4103)) /* j2k.c:1931:1 */

func opj_j2k_write_siz(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:1968:17: */
	var i TOPJ_UINT32
	var l_size_len TOPJ_UINT32
	var l_current_ptr uintptr
	var l_image uintptr = uintptr(00)
	var cp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)

	// preconditions
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(1980), uintptr(unsafe.Pointer(&__func__79)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(1981), uintptr(unsafe.Pointer(&__func__79)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(1982), uintptr(unsafe.Pointer(&__func__79)))
	}

	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	cp = p_j2k + 112
	l_size_len = TOPJ_UINT32(40) + TOPJ_UINT32(3)*(*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps

	if l_size_len > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {

		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_size_len))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+4120, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_size_len
	}

	l_current_ptr = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	// write SOC identifier
	Xopj_write_bytes_LE(tls, l_current_ptr, uint32(DJ2K_MS_SIZ), uint32(2)) // SIZ
	l_current_ptr += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_ptr, l_size_len-TOPJ_UINT32(2), uint32(2)) // L_SIZ
	l_current_ptr += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_ptr, uint32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz), uint32(2)) // Rsiz (capabilities)
	l_current_ptr += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1, uint32(4)) // Xsiz
	l_current_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1, uint32(4)) // Ysiz
	l_current_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0, uint32(4)) // X0siz
	l_current_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0, uint32(4)) // Y0siz
	l_current_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_cp_t)(unsafe.Pointer(cp)).Ftdx, uint32(4)) // XTsiz
	l_current_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_cp_t)(unsafe.Pointer(cp)).Ftdy, uint32(4)) // YTsiz
	l_current_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_cp_t)(unsafe.Pointer(cp)).Ftx0, uint32(4)) // XT0siz
	l_current_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_cp_t)(unsafe.Pointer(cp)).Fty0, uint32(4)) // YT0siz
	l_current_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps, uint32(2)) // Csiz
	l_current_ptr += uintptr(2)

	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps; i++ {
		// TODO here with MCT ?
		Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec-TOPJ_UINT32(1)+(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd<<7,
			uint32(1)) // Ssiz_i
		l_current_ptr++

		Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx, uint32(1)) // XRsiz_i
		l_current_ptr++

		Xopj_write_bytes_LE(tls, l_current_ptr, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy, uint32(1)) // YRsiz_i
		l_current_ptr++

		l_img_comp += 64
	}

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_size_len),
		p_manager) != TOPJ_SIZE_T(l_size_len) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__79 = *(*[18]int8)(unsafe.Pointer(ts + 4158)) /* j2k.c:1971:1 */

// *
// Reads a SIZ marker (image and tile size)
// @param       p_j2k           the jpeg2000 file codec.
// @param       p_header_data   the data contained in the SIZ box.
// @param       p_header_size   the size of the data contained in the SIZ marker.
// @param       p_manager       the user event manager.
func opj_j2k_read_siz(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:2074:17: */
	bp := tls.Alloc(200)
	defer tls.Free(200)

	var i TOPJ_UINT32
	var l_nb_comp TOPJ_UINT32
	var l_nb_comp_remain TOPJ_UINT32
	var l_remaining_size TOPJ_UINT32
	var l_nb_tiles TOPJ_UINT32
	// var l_tmp TOPJ_UINT32 at bp+192, 4

	var l_tx1 TOPJ_UINT32
	var l_ty1 TOPJ_UINT32
	var l_prec0 TOPJ_UINT32
	var l_sgnd0 TOPJ_UINT32
	var l_image uintptr = uintptr(00)
	var l_cp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)
	var l_current_tile_param uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2093), uintptr(unsafe.Pointer(&__func__80)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(2094), uintptr(unsafe.Pointer(&__func__80)))
	}
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(2095), uintptr(unsafe.Pointer(&__func__80)))
	}

	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	l_cp = p_j2k + 112

	// minimum size == 39 - 3 (= minimum component parameter)
	if p_header_size < TOPJ_UINT32(36) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+4196, 0)
		return DOPJ_FALSE
	}

	l_remaining_size = p_header_size - TOPJ_UINT32(36)
	l_nb_comp = l_remaining_size / TOPJ_UINT32(3)
	l_nb_comp_remain = l_remaining_size % TOPJ_UINT32(3)
	if l_nb_comp_remain != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+4196, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, bp+192,
		uint32(2)) // Rsiz (capabilities)
	p_header_data += uintptr(2)
	(*Topj_cp_t)(unsafe.Pointer(l_cp)).Frsiz = TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 /* l_tmp */)))
	Xopj_read_bytes_LE(tls, p_header_data, l_image+8, uint32(4)) // Xsiz
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, l_image+12, uint32(4)) // Ysiz
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, l_image, uint32(4)) // X0siz
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, l_image+4, uint32(4)) // Y0siz
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, l_cp+12,
		uint32(4)) // XTsiz
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, l_cp+16,
		uint32(4)) // YTsiz
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, l_cp+4,
		uint32(4)) // XT0siz
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, l_cp+8,
		uint32(4)) // YT0siz
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, bp+192,
		uint32(2)) // Csiz
	p_header_data += uintptr(2)
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192)) < TOPJ_UINT32(16385) {
		(*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps = TOPJ_UINT32(TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 /* l_tmp */))))
	} else {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4224, libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 192 /* l_tmp */))))
		return DOPJ_FALSE
	}

	if (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps != l_nb_comp {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4285,
			libc.VaList(bp+8, (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps, l_nb_comp))
		return DOPJ_FALSE
	}

	// testcase 4035.pdf.SIGSEGV.d8b.3375
	// testcase issue427-null-image-size.jp2
	if (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0 >= (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1 || (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0 >= (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+4399, libc.VaList(bp+24, uint32(TOPJ_INT64((*Topj_image_t)(unsafe.Pointer(l_image)).Fx1))-uint32((*Topj_image_t)(unsafe.Pointer(l_image)).Fx0),
				uint32(TOPJ_INT64((*Topj_image_t)(unsafe.Pointer(l_image)).Fy1))-uint32((*Topj_image_t)(unsafe.Pointer(l_image)).Fy0)))
		return DOPJ_FALSE
	}
	// testcase 2539.pdf.SIGFPE.706.1712 (also 3622.pdf.SIGFPE.706.2916 and 4008.pdf.SIGFPE.706.3345 and maybe more)
	if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx == 0 || (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy == 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4463, libc.VaList(bp+40, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx,
				(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy))
		return DOPJ_FALSE
	}

	// testcase issue427-illegal-tile-offset.jp2
	l_tx1 = opj_uint_adds(tls, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx) // manage overflow
	l_ty1 = opj_uint_adds(tls, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy) // manage overflow
	if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0 > (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0 || (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0 > (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0 || l_tx1 <= (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0 || l_ty1 <= (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4524, 0)
		return DOPJ_FALSE
	}
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fdump_state) != 0) {
		var siz_w TOPJ_UINT32
		var siz_h TOPJ_UINT32

		siz_w = (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1 - (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0
		siz_h = (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1 - (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0

		if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fihdr_w > TOPJ_UINT32(0) && (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fihdr_h > TOPJ_UINT32(0) &&
			((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fihdr_w != siz_w || (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fihdr_h != siz_h) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+4568, libc.VaList(bp+56, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fihdr_w,
					(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fihdr_h, siz_w, siz_h))
			return DOPJ_FALSE
		}
	}

	// Allocate the resulting image components
	(*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps = Xopj_calloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps),
		uint32(unsafe.Sizeof(Topj_image_comp_t{})))
	if (*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps == uintptr(00) {
		(*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps = TOPJ_UINT32(0)
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4629, 0)
		return DOPJ_FALSE
	}

	l_img_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps

	l_prec0 = TOPJ_UINT32(0)
	l_sgnd0 = TOPJ_UINT32(0)
	// Read the component information
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps; i++ {
		// var tmp TOPJ_UINT32 at bp+196, 4

		Xopj_read_bytes_LE(tls, p_header_data, bp+196, uint32(1)) // Ssiz_i
		p_header_data++
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 196))&TOPJ_UINT32(0x7f) + TOPJ_UINT32(1)
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 196)) >> 7

		if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fdump_state == uint32(0) {
			if i == TOPJ_UINT32(0) {
				l_prec0 = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec
				l_sgnd0 = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd
			} else if !(int32(*(*uint8)(unsafe.Pointer(l_cp + 148))&0x4>>2) != 0) &&
				((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec != l_prec0 || (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd != l_sgnd0) {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,

					ts+4677, libc.VaList(bp+88, i, l_prec0, l_sgnd0,
						i, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd))
			}
			// TODO: we should perhaps also check against JP2 BPCC values
		}
		Xopj_read_bytes_LE(tls, p_header_data, bp+196, uint32(1)) // XRsiz_i
		p_header_data++
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 196 /* tmp */)) // should be between 1 and 255
		Xopj_read_bytes_LE(tls, p_header_data, bp+196, uint32(1))                                                  // YRsiz_i
		p_header_data++
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 196 /* tmp */)) // should be between 1 and 255
		if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx < TOPJ_UINT32(1) || (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx > TOPJ_UINT32(255) || (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy < TOPJ_UINT32(1) || (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy > TOPJ_UINT32(255) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+4822,
				libc.VaList(bp+136, i, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy))
			return DOPJ_FALSE
		}
		// Avoids later undefined shift in computation of
		// p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1
		//                     << (l_image->comps[i].prec - 1);
		if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec > TOPJ_UINT32(31) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+4927,
				libc.VaList(bp+160, i, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec))
			return DOPJ_FALSE
		}
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded = TOPJ_UINT32(0)                                          // number of resolution decoded
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor = (*Topj_decoding_param_t)(unsafe.Pointer(l_cp + 120)).Fm_reduce // reducing factor per component
		l_img_comp += 64
	}

	if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx == TOPJ_UINT32(0) || (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy == TOPJ_UINT32(0) {
		return DOPJ_FALSE
	}

	// Compute the number of tiles
	(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fx1-(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0),
		TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx)))
	(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fy1-(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0),
		TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy)))

	// Check that the number of tiles is valid
	if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw == TOPJ_UINT32(0) || (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth == TOPJ_UINT32(0) || (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw > TOPJ_UINT32(65535)/(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+5060,
			libc.VaList(bp+176, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth))
		return DOPJ_FALSE
	}
	l_nb_tiles = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw * (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth

	// Define the tiles which will be decoded
	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72))&0x2>>1)) != 0 {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_x = ((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_start_tile_x - (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0) / (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_y = ((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_start_tile_y - (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0) / (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_x = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_end_tile_x-(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0),
			TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx)))
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_y = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_end_tile_y-(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0),
			TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy)))
	} else {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_x = TOPJ_UINT32(0)
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_y = TOPJ_UINT32(0)
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_x = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_y = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth
	}

	// memory allocations
	(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps = Xopj_calloc(tls, uint32(l_nb_tiles), uint32(unsafe.Sizeof(Topj_tcp_t{})))
	if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps == uintptr(00) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4629, 0)
		return DOPJ_FALSE
	}

	(*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp)).Ftccps = Xopj_calloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps), uint32(unsafe.Sizeof(Topj_tccp_t{})))
	if (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp)).Ftccps == uintptr(00) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4629, 0)
		return DOPJ_FALSE
	}

	(*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp)).Fm_mct_records = Xopj_calloc(tls, uint32(DOPJ_J2K_MCT_DEFAULT_NB_RECORDS),
		uint32(unsafe.Sizeof(Topj_mct_data_t{})))

	if !(int32((*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp)).Fm_mct_records) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4629, 0)
		return DOPJ_FALSE
	}
	(*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp)).Fm_nb_max_mct_records = TOPJ_UINT32(DOPJ_J2K_MCT_DEFAULT_NB_RECORDS)

	(*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp)).Fm_mcc_records = Xopj_calloc(tls, uint32(DOPJ_J2K_MCC_DEFAULT_NB_RECORDS),
		uint32(unsafe.Sizeof(Topj_simple_mcc_decorrelation_data_t{})))

	if !(int32((*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp)).Fm_mcc_records) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+4629, 0)
		return DOPJ_FALSE
	}
	(*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp)).Fm_nb_max_mcc_records = TOPJ_UINT32(DOPJ_J2K_MCC_DEFAULT_NB_RECORDS)

	// set up default dc level shift
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps; i++ {
		if !(int32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps+uintptr(i)*64)).Fsgnd) != 0) {
			(*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp)).Ftccps + uintptr(i)*1080)).Fm_dc_level_shift = int32(1) <<
				((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps+uintptr(i)*64)).Fprec - TOPJ_UINT32(1))
		}
	}

	l_current_tile_param = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps
	for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
		(*Topj_tcp_t)(unsafe.Pointer(l_current_tile_param)).Ftccps = Xopj_calloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps),
			uint32(unsafe.Sizeof(Topj_tccp_t{})))
		if (*Topj_tcp_t)(unsafe.Pointer(l_current_tile_param)).Ftccps == uintptr(00) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+4629, 0)
			return DOPJ_FALSE
		}

		l_current_tile_param += 5696
	}

	(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_MH
	Xopj_image_comp_header_update(tls, l_image, l_cp)

	return DOPJ_TRUE
}

var __func__80 = *(*[17]int8)(unsafe.Pointer(ts + 5143)) /* j2k.c:2079:1 */

func opj_j2k_write_com(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:2495:17: */
	var l_comment_size TOPJ_UINT32
	var l_total_com_size TOPJ_UINT32
	var l_comment uintptr
	var l_current_ptr uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2506), uintptr(unsafe.Pointer(&__func__81)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(2507), uintptr(unsafe.Pointer(&__func__81)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(2508), uintptr(unsafe.Pointer(&__func__81)))
	}

	l_comment = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fcomment
	l_comment_size = TOPJ_UINT32(libc.Xstrlen(tls, l_comment))
	l_total_com_size = l_comment_size + TOPJ_UINT32(6)

	if l_total_com_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_total_com_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+5160, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_total_com_size
	}

	l_current_ptr = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	Xopj_write_bytes_LE(tls, l_current_ptr, uint32(DJ2K_MS_COM), uint32(2)) // COM
	l_current_ptr += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_ptr, l_total_com_size-TOPJ_UINT32(2), uint32(2)) // L_COM
	l_current_ptr += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_ptr, uint32(1),
		uint32(2)) // General use (IS 8859-15:1999 (Latin) values)
	l_current_ptr += uintptr(2)

	libc.Xmemcpy(tls, l_current_ptr, l_comment, uint32(l_comment_size))

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_total_com_size),
		p_manager) != TOPJ_SIZE_T(l_total_com_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__81 = *(*[18]int8)(unsafe.Pointer(ts + 5203)) /* j2k.c:2499:1 */

// *
// Reads a COM marker (comments)
// @param       p_j2k           the jpeg2000 file codec.
// @param       p_header_data   the data contained in the COM box.
// @param       p_header_size   the size of the data contained in the COM marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_com(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:2560:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2567), uintptr(unsafe.Pointer(&__func__82)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(2568), uintptr(unsafe.Pointer(&__func__82)))
	}
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(2569), uintptr(unsafe.Pointer(&__func__82)))
	}

	_ = p_j2k
	_ = p_header_data
	_ = p_header_size
	_ = p_manager

	return DOPJ_TRUE
}

var __func__82 = *(*[17]int8)(unsafe.Pointer(ts + 5221)) /* j2k.c:2565:1 */

func opj_j2k_write_cod(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:2579:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_code_size TOPJ_UINT32
	// var l_remaining_size TOPJ_UINT32 at bp, 4

	var l_current_data uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2589), uintptr(unsafe.Pointer(&__func__83)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(2590), uintptr(unsafe.Pointer(&__func__83)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(2591), uintptr(unsafe.Pointer(&__func__83)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	l_code_size = TOPJ_UINT32(9) + opj_j2k_get_SPCod_SPCoc_size(tls, p_j2k,
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, uint32(0))
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) = l_code_size

	if l_code_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_code_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5238, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_code_size
	}

	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_COD), uint32(2)) // COD
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_code_size-TOPJ_UINT32(2), uint32(2)) // L_COD
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fcsty, uint32(1)) // Scod
	l_current_data++

	Xopj_write_bytes_LE(tls, l_current_data, TOPJ_UINT32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fprg), uint32(1)) // SGcod (A)
	l_current_data++

	Xopj_write_bytes_LE(tls, l_current_data, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers, uint32(2)) // SGcod (B)
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fmct, uint32(1)) // SGcod (C)
	l_current_data++

	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) -= TOPJ_UINT32(9)

	if !(opj_j2k_write_SPCod_SPCoc(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, uint32(0),
		l_current_data, bp, p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5277, 0)
		return DOPJ_FALSE
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5277, 0)
		return DOPJ_FALSE
	}

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_code_size),
		p_manager) != TOPJ_SIZE_T(l_code_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__83 = *(*[18]int8)(unsafe.Pointer(ts + 5303)) /* j2k.c:2582:1 */

// *
// Reads a COD marker (Coding style defaults)
// @param       p_header_data   the data contained in the COD box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the COD marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_cod(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:2662:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) = p_header_size

	// loop
	var i TOPJ_UINT32
	// var l_tmp TOPJ_UINT32 at bp+8, 4

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_image uintptr = uintptr(00)

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(2676), uintptr(unsafe.Pointer(&__func__84)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2677), uintptr(unsafe.Pointer(&__func__84)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(2678), uintptr(unsafe.Pointer(&__func__84)))
	}

	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	l_cp = p_j2k + 112

	// If we are in the first tile-part header of the current tile
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	libc.SetBitFieldPtr8Uint32(l_tcp+5688, TOPJ_BITFIELD(1), 0, 0x1)

	// Make sure room is sufficient
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) < TOPJ_UINT32(5) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5321, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, l_tcp, uint32(1)) // Scod
	p_header_data++
	// Make sure we know how to decode this
	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fcsty&libc.CplUint32(TOPJ_UINT32(DJ2K_CP_CSTY_PRT|DJ2K_CP_CSTY_SOP|DJ2K_CP_CSTY_EPH)) != 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5347, 0)
		return DOPJ_FALSE
	}
	Xopj_read_bytes_LE(tls, p_header_data, bp+8, uint32(1)) // SGcod (A)
	p_header_data++
	(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fprg = TOPJ_PROG_ORDER(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_tmp */)))
	// Make sure progression order is valid
	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fprg > OPJ_CPRL {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+5381, 0)
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fprg = OPJ_PROG_UNKNOWN
	}
	Xopj_read_bytes_LE(tls, p_header_data, l_tcp+8, uint32(2)) // SGcod (B)
	p_header_data += uintptr(2)

	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers < 1 || (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers > 65535 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+5422,
			libc.VaList(bp, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers))
		return DOPJ_FALSE
	}

	// If user didn't set a number layer to decode take the max specify in the codestream.
	if (*Topj_decoding_param_t)(unsafe.Pointer(l_cp+120)).Fm_layer != 0 {
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnum_layers_to_decode = (*Topj_decoding_param_t)(unsafe.Pointer(l_cp + 120)).Fm_layer
	} else {
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnum_layers_to_decode = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers
	}

	Xopj_read_bytes_LE(tls, p_header_data, l_tcp+16, uint32(1)) // SGcod (C)
	p_header_data++

	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fmct > TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+5490, 0)
		return DOPJ_FALSE
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* p_header_size */)) -= TOPJ_UINT32(5)
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps; i++ {
		(*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(i)*1080)).Fcsty = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fcsty & TOPJ_UINT32(DJ2K_CCP_CSTY_PRT)
	}

	if !(opj_j2k_read_SPCod_SPCoc(tls, p_j2k, uint32(0), p_header_data, bp+12,
		p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5321, 0)
		return DOPJ_FALSE
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5321, 0)
		return DOPJ_FALSE
	}

	// Apply the coding style to other components of the current tile or the m_default_tcp
	opj_j2k_copy_tile_component_parameters(tls, p_j2k)

	// Index

	return DOPJ_TRUE
}

var __func__84 = *(*[17]int8)(unsafe.Pointer(ts + 5533)) /* j2k.c:2667:1 */

func opj_j2k_write_coc(tls *libc.TLS, p_j2k uintptr, p_comp_no TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:2789:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_coc_size TOPJ_UINT32
	// var l_remaining_size TOPJ_UINT32 at bp, 4

	var l_comp_room TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2798), uintptr(unsafe.Pointer(&__func__85)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(2799), uintptr(unsafe.Pointer(&__func__85)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(2800), uintptr(unsafe.Pointer(&__func__85)))
	}

	if (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps <= TOPJ_UINT32(256) {
		l_comp_room = uint32(1)
	} else {
		l_comp_room = uint32(2)
	}

	l_coc_size = TOPJ_UINT32(5) + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(tls, p_j2k,
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, p_comp_no)

	if l_coc_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr
		//p_j2k->m_specific_param.m_encoder.m_header_tile_data
		//                 = (OPJ_BYTE*)opj_realloc(
		//                         p_j2k->m_specific_param.m_encoder.m_header_tile_data,
		//                         l_coc_size);

		new_header_tile_data = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_coc_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5550, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_coc_size
	}

	opj_j2k_write_coc_in_memory(tls, p_j2k, p_comp_no,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, bp,
		p_manager)

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_coc_size),
		p_manager) != TOPJ_SIZE_T(l_coc_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__85 = *(*[18]int8)(unsafe.Pointer(ts + 5589)) /* j2k.c:2793:1 */

func opj_j2k_compare_coc(tls *libc.TLS, p_j2k uintptr, p_first_comp_no TOPJ_UINT32, p_second_comp_no TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:2840:17: */
	var l_cp uintptr = uintptr(0)
	var l_tcp uintptr = uintptr(0)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2847), uintptr(unsafe.Pointer(&__func__86)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696

	if (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps+uintptr(p_first_comp_no)*1080)).Fcsty != (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps+uintptr(p_second_comp_no)*1080)).Fcsty {
		return DOPJ_FALSE
	}

	return opj_j2k_compare_SPCod_SPCoc(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		p_first_comp_no, p_second_comp_no)
}

var __func__86 = *(*[20]int8)(unsafe.Pointer(ts + 5607)) /* j2k.c:2842:1 */

func opj_j2k_write_coc_in_memory(tls *libc.TLS, p_j2k uintptr, p_comp_no TOPJ_UINT32, p_data uintptr, p_data_written uintptr, p_manager uintptr) { /* j2k.c:2861:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_coc_size TOPJ_UINT32
	// var l_remaining_size TOPJ_UINT32 at bp, 4

	var l_current_data uintptr = uintptr(00)
	var l_image uintptr = uintptr(00)
	var l_comp_room TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2876), uintptr(unsafe.Pointer(&__func__87)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(2877), uintptr(unsafe.Pointer(&__func__87)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	if (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps <= TOPJ_UINT32(256) {
		l_comp_room = uint32(1)
	} else {
		l_comp_room = uint32(2)
	}

	l_coc_size = TOPJ_UINT32(5) + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(tls, p_j2k,
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, p_comp_no)
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) = l_coc_size

	l_current_data = p_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_COC),
		uint32(2)) // COC
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_coc_size-TOPJ_UINT32(2),
		uint32(2)) // L_COC
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, p_comp_no, l_comp_room) // Ccoc
	l_current_data += uintptr(l_comp_room)

	Xopj_write_bytes_LE(tls, l_current_data, (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps+uintptr(p_comp_no)*1080)).Fcsty,
		uint32(1)) // Scoc
	l_current_data++

	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) -= TOPJ_UINT32(5) + l_comp_room
	opj_j2k_write_SPCod_SPCoc(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, uint32(0),
		l_current_data, bp, p_manager)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = l_coc_size
}

var __func__87 = *(*[28]int8)(unsafe.Pointer(ts + 5627)) /* j2k.c:2867:1 */

func opj_j2k_get_max_coc_size(tls *libc.TLS, p_j2k uintptr) TOPJ_UINT32 { /* j2k.c:2911:19: */
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var l_nb_comp TOPJ_UINT32
	var l_nb_tiles TOPJ_UINT32
	var l_max TOPJ_UINT32 = TOPJ_UINT32(0)

	// preconditions

	l_nb_tiles = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth
	l_nb_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps

	for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
		for j = TOPJ_UINT32(0); j < l_nb_comp; j++ {
			l_max = opj_uint_max(tls, l_max, opj_j2k_get_SPCod_SPCoc_size(tls, p_j2k, i, j))
		}
	}

	return TOPJ_UINT32(6) + l_max
}

// *
// Reads a COC marker (Coding Style Component)
// @param       p_header_data   the data contained in the COC box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the COC marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_coc(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:2939:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) = p_header_size

	var l_cp uintptr = uintptr(0)
	var l_tcp uintptr = uintptr(0)
	var l_image uintptr = uintptr(0)
	var l_comp_room TOPJ_UINT32
	// var l_comp_no TOPJ_UINT32 at bp, 4

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(2952), uintptr(unsafe.Pointer(&__func__88)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(2953), uintptr(unsafe.Pointer(&__func__88)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(2954), uintptr(unsafe.Pointer(&__func__88)))
	}

	l_cp = p_j2k + 112
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}
	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image

	if (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps <= TOPJ_UINT32(256) {
		l_comp_room = uint32(1)
	} else {
		l_comp_room = uint32(2)
	}

	// make sure room is sufficient
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) < l_comp_room+TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5655, 0)
		return DOPJ_FALSE
	}
	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* p_header_size */)) -= l_comp_room + TOPJ_UINT32(1)

	Xopj_read_bytes_LE(tls, p_header_data, bp,
		l_comp_room) // Ccoc
	p_header_data += uintptr(l_comp_room)
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) >= (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+5681, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp)))*1080,
		uint32(1)) // Scoc
	p_header_data++

	if !(opj_j2k_read_SPCod_SPCoc(tls, p_j2k, *(*TOPJ_UINT32)(unsafe.Pointer(bp)), p_header_data, bp+4,
		p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5655, 0)
		return DOPJ_FALSE
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5655, 0)
		return DOPJ_FALSE
	}
	return DOPJ_TRUE
}

var __func__88 = *(*[17]int8)(unsafe.Pointer(ts + 5734)) /* j2k.c:2944:1 */

func opj_j2k_write_qcd(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:2998:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_qcd_size TOPJ_UINT32
	// var l_remaining_size TOPJ_UINT32 at bp, 4

	var l_current_data uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3007), uintptr(unsafe.Pointer(&__func__89)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3008), uintptr(unsafe.Pointer(&__func__89)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(3009), uintptr(unsafe.Pointer(&__func__89)))
	}

	l_qcd_size = TOPJ_UINT32(4) + opj_j2k_get_SQcd_SQcc_size(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		uint32(0))
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) = l_qcd_size

	if l_qcd_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_qcd_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5751, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_qcd_size
	}

	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_QCD), uint32(2)) // QCD
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_qcd_size-TOPJ_UINT32(2), uint32(2)) // L_QCD
	l_current_data += uintptr(2)

	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) -= TOPJ_UINT32(4)

	if !(opj_j2k_write_SQcd_SQcc(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, uint32(0),
		l_current_data, bp, p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5790, 0)
		return DOPJ_FALSE
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5790, 0)
		return DOPJ_FALSE
	}

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_qcd_size),
		p_manager) != TOPJ_SIZE_T(l_qcd_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__89 = *(*[18]int8)(unsafe.Pointer(ts + 5816)) /* j2k.c:3002:1 */

// *
// Reads a QCD marker (Quantization defaults)
// @param       p_header_data   the data contained in the QCD box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the QCD marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_qcd(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3066:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*TOPJ_UINT32)(unsafe.Pointer(bp)) = p_header_size

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(3073), uintptr(unsafe.Pointer(&__func__90)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3074), uintptr(unsafe.Pointer(&__func__90)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3075), uintptr(unsafe.Pointer(&__func__90)))
	}

	if !(opj_j2k_read_SQcd_SQcc(tls, p_j2k, uint32(0), p_header_data, bp,
		p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5834, 0)
		return DOPJ_FALSE
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5834, 0)
		return DOPJ_FALSE
	}

	// Apply the quantization parameters to other components of the current tile or the m_default_tcp
	opj_j2k_copy_tile_quantization_parameters(tls, p_j2k)

	return DOPJ_TRUE
}

var __func__90 = *(*[17]int8)(unsafe.Pointer(ts + 5860)) /* j2k.c:3071:1 */

func opj_j2k_write_qcc(tls *libc.TLS, p_j2k uintptr, p_comp_no TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3094:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_qcc_size TOPJ_UINT32
	// var l_remaining_size TOPJ_UINT32 at bp, 4

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3103), uintptr(unsafe.Pointer(&__func__91)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3104), uintptr(unsafe.Pointer(&__func__91)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(3105), uintptr(unsafe.Pointer(&__func__91)))
	}

	l_qcc_size = TOPJ_UINT32(5) + opj_j2k_get_SQcd_SQcc_size(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		p_comp_no)
	l_qcc_size = l_qcc_size + func() uint32 {
		if (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps <= TOPJ_UINT32(256) {
			return uint32(0)
		}
		return uint32(1)
	}()
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) = l_qcc_size

	if l_qcc_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_qcc_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5877, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_qcc_size
	}

	opj_j2k_write_qcc_in_memory(tls, p_j2k, p_comp_no,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, bp,
		p_manager)

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_qcc_size),
		p_manager) != TOPJ_SIZE_T(l_qcc_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__91 = *(*[18]int8)(unsafe.Pointer(ts + 5916)) /* j2k.c:3099:1 */

func opj_j2k_compare_qcc(tls *libc.TLS, p_j2k uintptr, p_first_comp_no TOPJ_UINT32, p_second_comp_no TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:3139:17: */
	return opj_j2k_compare_SQcd_SQcc(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		p_first_comp_no, p_second_comp_no)
}

func opj_j2k_write_qcc_in_memory(tls *libc.TLS, p_j2k uintptr, p_comp_no TOPJ_UINT32, p_data uintptr, p_data_written uintptr, p_manager uintptr) { /* j2k.c:3146:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_qcc_size TOPJ_UINT32
	// var l_remaining_size TOPJ_UINT32 at bp, 4

	var l_current_data uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3157), uintptr(unsafe.Pointer(&__func__92)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3158), uintptr(unsafe.Pointer(&__func__92)))
	}

	l_qcc_size = TOPJ_UINT32(6) + opj_j2k_get_SQcd_SQcc_size(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		p_comp_no)
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) = l_qcc_size

	l_current_data = p_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_QCC), uint32(2)) // QCC
	l_current_data += uintptr(2)

	if (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps <= TOPJ_UINT32(256) {
		l_qcc_size--

		Xopj_write_bytes_LE(tls, l_current_data, l_qcc_size-TOPJ_UINT32(2), uint32(2)) // L_QCC
		l_current_data += uintptr(2)

		Xopj_write_bytes_LE(tls, l_current_data, p_comp_no, uint32(1)) // Cqcc
		l_current_data++

		// in the case only one byte is sufficient the last byte allocated is useless -> still do -6 for available
		*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) -= TOPJ_UINT32(6)
	} else {
		Xopj_write_bytes_LE(tls, l_current_data, l_qcc_size-TOPJ_UINT32(2), uint32(2)) // L_QCC
		l_current_data += uintptr(2)

		Xopj_write_bytes_LE(tls, l_current_data, p_comp_no, uint32(2)) // Cqcc
		l_current_data += uintptr(2)

		*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_remaining_size */)) -= TOPJ_UINT32(6)
	}

	opj_j2k_write_SQcd_SQcc(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, p_comp_no,
		l_current_data, bp, p_manager)

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = l_qcc_size
}

var __func__92 = *(*[28]int8)(unsafe.Pointer(ts + 5934)) /* j2k.c:3152:1 */

func opj_j2k_get_max_qcc_size(tls *libc.TLS, p_j2k uintptr) TOPJ_UINT32 { /* j2k.c:3196:19: */
	return opj_j2k_get_max_coc_size(tls, p_j2k)
}

// *
// Reads a QCC marker (Quantization component)
// @param       p_header_data   the data contained in the QCC box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the QCC marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_qcc(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3208:17: */
	bp := tls.Alloc(24)
	defer tls.Free(24)
	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 20)) = p_header_size

	var l_num_comp TOPJ_UINT32
	// var l_comp_no TOPJ_UINT32 at bp+16, 4

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(3217), uintptr(unsafe.Pointer(&__func__93)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3218), uintptr(unsafe.Pointer(&__func__93)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3219), uintptr(unsafe.Pointer(&__func__93)))
	}

	l_num_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps

	if l_num_comp <= TOPJ_UINT32(256) {
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20)) < TOPJ_UINT32(1) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5962, 0)
			return DOPJ_FALSE
		}
		Xopj_read_bytes_LE(tls, p_header_data, bp+16, uint32(1))
		p_header_data++
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* p_header_size */))--
	} else {
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20)) < TOPJ_UINT32(2) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5962, 0)
			return DOPJ_FALSE
		}
		Xopj_read_bytes_LE(tls, p_header_data, bp+16, uint32(2))
		p_header_data += uintptr(2)
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* p_header_size */)) -= TOPJ_UINT32(2)
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)) >= (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+5988,
			libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_comp_no */)), (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps))
		return DOPJ_FALSE
	}

	if !(opj_j2k_read_SQcd_SQcc(tls, p_j2k, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)), p_header_data, bp+20,
		p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5962, 0)
		return DOPJ_FALSE
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+5962, 0)
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__93 = *(*[17]int8)(unsafe.Pointer(ts + 6057)) /* j2k.c:3213:1 */

func opj_j2k_write_poc(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3288:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_nb_comp TOPJ_UINT32
	var l_nb_poc TOPJ_UINT32
	var l_poc_size TOPJ_UINT32
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_written_size */)) = TOPJ_UINT32(0)
	var l_tcp uintptr = uintptr(00)
	var l_poc_room TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3301), uintptr(unsafe.Pointer(&__func__94)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3302), uintptr(unsafe.Pointer(&__func__94)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(3303), uintptr(unsafe.Pointer(&__func__94)))
	}

	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	l_nb_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps
	l_nb_poc = TOPJ_UINT32(1) + (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs

	if l_nb_comp <= TOPJ_UINT32(256) {
		l_poc_room = TOPJ_UINT32(1)
	} else {
		l_poc_room = TOPJ_UINT32(2)
	}
	l_poc_size = TOPJ_UINT32(4) + (TOPJ_UINT32(5)+TOPJ_UINT32(2)*l_poc_room)*l_nb_poc

	if l_poc_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_poc_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6074, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_poc_size
	}

	opj_j2k_write_poc_in_memory(tls, p_j2k,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, bp,
		p_manager)

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_poc_size),
		p_manager) != TOPJ_SIZE_T(l_poc_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__94 = *(*[18]int8)(unsafe.Pointer(ts + 6113)) /* j2k.c:3292:1 */

func opj_j2k_write_poc_in_memory(tls *libc.TLS, p_j2k uintptr, p_data uintptr, p_data_written uintptr, p_manager uintptr) { /* j2k.c:3343:13: */
	var i TOPJ_UINT32
	var l_current_data uintptr = uintptr(00)
	var l_nb_comp TOPJ_UINT32
	var l_nb_poc TOPJ_UINT32
	var l_poc_size TOPJ_UINT32
	var l_image uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_current_poc uintptr = uintptr(00)
	var l_poc_room TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3361), uintptr(unsafe.Pointer(&__func__95)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3362), uintptr(unsafe.Pointer(&__func__95)))
	}

	_ = p_manager

	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps
	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	l_nb_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps
	l_nb_poc = TOPJ_UINT32(1) + (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs

	if l_nb_comp <= TOPJ_UINT32(256) {
		l_poc_room = TOPJ_UINT32(1)
	} else {
		l_poc_room = TOPJ_UINT32(2)
	}

	l_poc_size = TOPJ_UINT32(4) + (TOPJ_UINT32(5)+TOPJ_UINT32(2)*l_poc_room)*l_nb_poc

	l_current_data = p_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_POC),
		uint32(2)) // POC
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_poc_size-TOPJ_UINT32(2),
		uint32(2)) // Lpoc
	l_current_data += uintptr(2)

	l_current_poc = l_tcp + 424 /* &.pocs */
	for i = TOPJ_UINT32(0); i < l_nb_poc; i++ {
		Xopj_write_bytes_LE(tls, l_current_data, (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fresno0,
			uint32(1)) // RSpoc_i
		l_current_data++

		Xopj_write_bytes_LE(tls, l_current_data, (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fcompno0,
			l_poc_room) // CSpoc_i
		l_current_data += uintptr(l_poc_room)

		Xopj_write_bytes_LE(tls, l_current_data, (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Flayno1,
			uint32(2)) // LYEpoc_i
		l_current_data += uintptr(2)

		Xopj_write_bytes_LE(tls, l_current_data, (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fresno1,
			uint32(1)) // REpoc_i
		l_current_data++

		Xopj_write_bytes_LE(tls, l_current_data, (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fcompno1,
			l_poc_room) // CEpoc_i
		l_current_data += uintptr(l_poc_room)

		Xopj_write_bytes_LE(tls, l_current_data, TOPJ_UINT32((*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fprg),
			uint32(1)) // Ppoc_i
		l_current_data++

		// change the value of the max layer according to the actual number of layers in the file, components and resolutions
		(*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Flayno1 = TOPJ_UINT32(opj_int_min(tls, TOPJ_INT32((*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Flayno1), TOPJ_INT32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers)))
		(*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fresno1 = TOPJ_UINT32(opj_int_min(tls, TOPJ_INT32((*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fresno1), TOPJ_INT32((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions)))
		(*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fcompno1 = TOPJ_UINT32(opj_int_min(tls, TOPJ_INT32((*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fcompno1), TOPJ_INT32(l_nb_comp)))

		l_current_poc += 148
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = l_poc_size
}

var __func__95 = *(*[28]int8)(unsafe.Pointer(ts + 6131)) /* j2k.c:3348:1 */

func opj_j2k_get_max_poc_size(tls *libc.TLS, p_j2k uintptr) TOPJ_UINT32 { /* j2k.c:3430:19: */
	var l_tcp uintptr = uintptr(00)
	var l_nb_tiles TOPJ_UINT32 = TOPJ_UINT32(0)
	var l_max_poc TOPJ_UINT32 = TOPJ_UINT32(0)
	var i TOPJ_UINT32

	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps
	l_nb_tiles = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw

	for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
		l_max_poc = opj_uint_max(tls, l_max_poc, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs)
		l_tcp += 5696
	}

	l_max_poc++

	return TOPJ_UINT32(4) + TOPJ_UINT32(9)*l_max_poc
}

func opj_j2k_get_max_toc_size(tls *libc.TLS, p_j2k uintptr) TOPJ_UINT32 { /* j2k.c:3450:19: */
	var i TOPJ_UINT32
	var l_nb_tiles TOPJ_UINT32
	var l_max TOPJ_UINT32 = TOPJ_UINT32(0)
	var l_tcp uintptr = uintptr(00)

	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps
	l_nb_tiles = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth

	for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
		l_max = opj_uint_max(tls, l_max, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts)

		l_tcp += 5696
	}

	return TOPJ_UINT32(12) * l_max
}

func opj_j2k_get_specific_header_sizes(tls *libc.TLS, p_j2k uintptr) TOPJ_UINT32 { /* j2k.c:3469:19: */
	var l_nb_bytes TOPJ_UINT32 = TOPJ_UINT32(0)
	var l_nb_comps TOPJ_UINT32
	var l_coc_bytes TOPJ_UINT32
	var l_qcc_bytes TOPJ_UINT32

	l_nb_comps = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps - TOPJ_UINT32(1)
	l_nb_bytes = l_nb_bytes + opj_j2k_get_max_toc_size(tls, p_j2k)

	if !(int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Frsiz) <= DOPJ_PROFILE_CINEMA_S4K) {
		l_coc_bytes = opj_j2k_get_max_coc_size(tls, p_j2k)
		l_nb_bytes = l_nb_bytes + l_nb_comps*l_coc_bytes

		l_qcc_bytes = opj_j2k_get_max_qcc_size(tls, p_j2k)
		l_nb_bytes = l_nb_bytes + l_nb_comps*l_qcc_bytes
	}

	l_nb_bytes = l_nb_bytes + opj_j2k_get_max_poc_size(tls, p_j2k)

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_PLT != 0 {
		// Reserve space for PLT markers

		var i TOPJ_UINT32
		var l_cp uintptr = p_j2k + 112
		var l_max_packet_count TOPJ_UINT32 = TOPJ_UINT32(0)
		for i = TOPJ_UINT32(0); i < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw; i++ {
			l_max_packet_count = opj_uint_max(tls, l_max_packet_count,
				Xopj_get_encoding_packet_count(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image, l_cp, i))
		}
		// Minimum 6 bytes per PLT marker, and at a minimum (taking a pessimistic
		// estimate of 4 bytes for a packet size), one can write
		// (65536-6) / 4 = 16382 paquet sizes per PLT marker
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_reserved_bytes_for_PLT = TOPJ_UINT32(6) * opj_uint_ceildiv(tls, l_max_packet_count, uint32(16382))
		// Maximum 5 bytes per packet to encode a full UINT32
		*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8 + 80)) += libc.AssignAddUint32(&l_nb_bytes, TOPJ_UINT32(5)*l_max_packet_count)
		*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8 + 80)) += TOPJ_UINT32(1)
		l_nb_bytes = l_nb_bytes + (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_reserved_bytes_for_PLT
	}

	//** DEVELOPER CORNER, Add room for your headers **

	return l_nb_bytes
}

// *
// Reads a POC marker (Progression Order Change)
//
// @param       p_header_data   the data contained in the POC box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the POC marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_poc(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3523:17: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var i TOPJ_UINT32
	var l_nb_comp TOPJ_UINT32
	// var l_tmp TOPJ_UINT32 at bp+8, 4

	var l_image uintptr = uintptr(00)
	var l_old_poc_nb TOPJ_UINT32
	var l_current_poc_nb TOPJ_UINT32
	var l_current_poc_remaining TOPJ_UINT32
	var l_chunk_size TOPJ_UINT32
	var l_comp_room TOPJ_UINT32

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_current_poc uintptr = uintptr(00)

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(3539), uintptr(unsafe.Pointer(&__func__96)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3540), uintptr(unsafe.Pointer(&__func__96)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3541), uintptr(unsafe.Pointer(&__func__96)))
	}

	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	l_nb_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps
	if l_nb_comp <= TOPJ_UINT32(256) {
		l_comp_room = TOPJ_UINT32(1)
	} else {
		l_comp_room = TOPJ_UINT32(2)
	}
	l_chunk_size = TOPJ_UINT32(5) + TOPJ_UINT32(2)*l_comp_room
	l_current_poc_nb = p_header_size / l_chunk_size
	l_current_poc_remaining = p_header_size % l_chunk_size

	if l_current_poc_nb <= TOPJ_UINT32(0) || l_current_poc_remaining != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6159, 0)
		return DOPJ_FALSE
	}

	l_cp = p_j2k + 112
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}
	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(l_tcp + 5688))&0x4>>2)) != 0 {
		l_old_poc_nb = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs + TOPJ_UINT32(1)
	} else {
		l_old_poc_nb = uint32(0)
	}
	l_current_poc_nb = l_current_poc_nb + l_old_poc_nb

	if l_current_poc_nb >= TOPJ_UINT32(DJ2K_MAX_POCS) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6185, libc.VaList(bp, l_current_poc_nb))
		return DOPJ_FALSE
	}

	// now poc is in use.
	libc.SetBitFieldPtr8Uint32(l_tcp+5688, TOPJ_BITFIELD(1), 2, 0x4)

	l_current_poc = l_tcp + 424 + uintptr(l_old_poc_nb)*148
	for i = l_old_poc_nb; i < l_current_poc_nb; i++ {
		Xopj_read_bytes_LE(tls, p_header_data, l_current_poc,
			uint32(1)) // RSpoc_i
		p_header_data++
		Xopj_read_bytes_LE(tls, p_header_data, l_current_poc+4,
			l_comp_room) // CSpoc_i
		p_header_data += uintptr(l_comp_room)
		Xopj_read_bytes_LE(tls, p_header_data, l_current_poc+8,
			uint32(2)) // LYEpoc_i
		// make sure layer end is in acceptable bounds
		(*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Flayno1 = opj_uint_min(tls, (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Flayno1, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers)
		p_header_data += uintptr(2)
		Xopj_read_bytes_LE(tls, p_header_data, l_current_poc+12,
			uint32(1)) // REpoc_i
		p_header_data++
		Xopj_read_bytes_LE(tls, p_header_data, l_current_poc+16,
			l_comp_room) // CEpoc_i
		p_header_data += uintptr(l_comp_room)
		Xopj_read_bytes_LE(tls, p_header_data, bp+8,
			uint32(1)) // Ppoc_i
		p_header_data++
		(*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fprg = TOPJ_PROG_ORDER(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_tmp */)))
		// make sure comp is in acceptable bounds
		(*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fcompno1 = opj_uint_min(tls, (*Topj_poc_t)(unsafe.Pointer(l_current_poc)).Fcompno1, l_nb_comp)
		l_current_poc += 148
	}

	(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs = l_current_poc_nb - TOPJ_UINT32(1)
	return DOPJ_TRUE
}

var __func__96 = *(*[17]int8)(unsafe.Pointer(ts + 6203)) /* j2k.c:3528:1 */

// *
// Reads a CRG marker (Component registration)
//
// @param       p_header_data   the data contained in the TLM box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the TLM marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_crg(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3614:17: */
	var l_nb_comp TOPJ_UINT32
	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(3622), uintptr(unsafe.Pointer(&__func__97)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3623), uintptr(unsafe.Pointer(&__func__97)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3624), uintptr(unsafe.Pointer(&__func__97)))
	}

	_ = p_header_data

	l_nb_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps

	if p_header_size != l_nb_comp*TOPJ_UINT32(4) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6220, 0)
		return DOPJ_FALSE
	}
	// Do not care of this at the moment since only local variables are set here
	//
	//     for
	//             (i = 0; i < l_nb_comp; ++i)
	//     {
	//             opj_read_bytes(p_header_data,&l_Xcrg_i,2);                              // Xcrg_i
	//             p_header_data+=2;
	//             opj_read_bytes(p_header_data,&l_Ycrg_i,2);                              // Xcrg_i
	//             p_header_data+=2;
	//     }
	//
	return DOPJ_TRUE
}

var __func__97 = *(*[17]int8)(unsafe.Pointer(ts + 6246)) /* j2k.c:3619:1 */

// *
// Reads a TLM marker (Tile Length Marker)
//
// @param       p_header_data   the data contained in the TLM box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the TLM marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_tlm(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3656:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var l_Ztlm TOPJ_UINT32 at bp, 4

	// var l_Stlm TOPJ_UINT32 at bp+4, 4

	var l_ST TOPJ_UINT32
	var l_SP TOPJ_UINT32
	var l_tot_num_tp_remaining TOPJ_UINT32
	var l_quotient TOPJ_UINT32
	var l_Ptlm_size TOPJ_UINT32
	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(3665), uintptr(unsafe.Pointer(&__func__98)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3666), uintptr(unsafe.Pointer(&__func__98)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3667), uintptr(unsafe.Pointer(&__func__98)))
	}

	_ = p_j2k

	if p_header_size < TOPJ_UINT32(2) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6263, 0)
		return DOPJ_FALSE
	}
	p_header_size = p_header_size - TOPJ_UINT32(2)

	Xopj_read_bytes_LE(tls, p_header_data, bp,
		uint32(1)) // Ztlm
	p_header_data++
	Xopj_read_bytes_LE(tls, p_header_data, bp+4,
		uint32(1)) // Stlm
	p_header_data++

	l_ST = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) >> 4 & TOPJ_UINT32(0x3)
	l_SP = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) >> 6 & TOPJ_UINT32(0x1)

	l_Ptlm_size = (l_SP + TOPJ_UINT32(1)) * TOPJ_UINT32(2)
	l_quotient = l_Ptlm_size + l_ST

	l_tot_num_tp_remaining = p_header_size % l_quotient

	if l_tot_num_tp_remaining != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6263, 0)
		return DOPJ_FALSE
	}
	// FIXME Do not care of this at the moment since only local variables are set here
	//
	//     for
	//             (i = 0; i < l_tot_num_tp; ++i)
	//     {
	//             opj_read_bytes(p_header_data,&l_Ttlm_i,l_ST);                           // Ttlm_i
	//             p_header_data += l_ST;
	//             opj_read_bytes(p_header_data,&l_Ptlm_i,l_Ptlm_size);            // Ptlm_i
	//             p_header_data += l_Ptlm_size;
	//     }
	return DOPJ_TRUE
}

var __func__98 = *(*[17]int8)(unsafe.Pointer(ts + 6289)) /* j2k.c:3661:1 */

// *
// Reads a PLM marker (Packet length, main header marker)
//
// @param       p_header_data   the data contained in the TLM box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the TLM marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_plm(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3717:17: */
	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(3724), uintptr(unsafe.Pointer(&__func__99)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3725), uintptr(unsafe.Pointer(&__func__99)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3726), uintptr(unsafe.Pointer(&__func__99)))
	}

	_ = p_j2k
	_ = p_header_data

	if p_header_size < TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6306, 0)
		return DOPJ_FALSE
	}
	// Do not care of this at the moment since only local variables are set here
	//
	//     opj_read_bytes(p_header_data,&l_Zplm,1);                                        // Zplm
	//     ++p_header_data;
	//     --p_header_size;
	//
	//     while
	//             (p_header_size > 0)
	//     {
	//             opj_read_bytes(p_header_data,&l_Nplm,1);                                // Nplm
	//             ++p_header_data;
	//             p_header_size -= (1+l_Nplm);
	//             if
	//                     (p_header_size < 0)
	//             {
	//                     opj_event_msg(p_manager, EVT_ERROR, "Error reading PLM marker\n");
	//                     return false;
	//             }
	//             for
	//                     (i = 0; i < l_Nplm; ++i)
	//             {
	//                     opj_read_bytes(p_header_data,&l_tmp,1);                         // Iplm_ij
	//                     ++p_header_data;
	//                     // take only the last seven bytes
	//                     l_packet_len |= (l_tmp & 0x7f);
	//                     if
	//                             (l_tmp & 0x80)
	//                     {
	//                             l_packet_len <<= 7;
	//                     }
	//                     else
	//                     {
	//             // store packet length and proceed to next packet
	//                             l_packet_len = 0;
	//                     }
	//             }
	//             if
	//                     (l_packet_len != 0)
	//             {
	//                     opj_event_msg(p_manager, EVT_ERROR, "Error reading PLM marker\n");
	//                     return false;
	//             }
	//     }
	//
	return DOPJ_TRUE
}

var __func__99 = *(*[17]int8)(unsafe.Pointer(ts + 6332)) /* j2k.c:3722:1 */

// *
// Reads a PLT marker (Packet length, tile-part header)
//
// @param       p_header_data   the data contained in the PLT box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the PLT marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_plt(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3790:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var l_Zplt TOPJ_UINT32 at bp, 4

	// var l_tmp TOPJ_UINT32 at bp+4, 4

	var l_packet_len TOPJ_UINT32 = TOPJ_UINT32(0)
	var i TOPJ_UINT32

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(3799), uintptr(unsafe.Pointer(&__func__100)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3800), uintptr(unsafe.Pointer(&__func__100)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3801), uintptr(unsafe.Pointer(&__func__100)))
	}

	_ = p_j2k

	if p_header_size < TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6349, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, bp, uint32(1)) // Zplt
	p_header_data++
	p_header_size--

	for i = TOPJ_UINT32(0); i < p_header_size; i++ {
		Xopj_read_bytes_LE(tls, p_header_data, bp+4, uint32(1)) // Iplt_ij
		p_header_data++
		// take only the last seven bytes
		l_packet_len = l_packet_len | *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))&TOPJ_UINT32(0x7f)
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))&TOPJ_UINT32(0x80) != 0 {
			l_packet_len <<= 7
		} else {
			// store packet length and proceed to next packet
			l_packet_len = TOPJ_UINT32(0)
		}
	}

	if l_packet_len != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6349, 0)
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__100 = *(*[17]int8)(unsafe.Pointer(ts + 6375)) /* j2k.c:3795:1 */

// *
// Reads a PPM marker (Packed packet headers, main header)
//
// @param       p_header_data   the data contained in the POC box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the POC marker.
// @param       p_manager               the user event manager.

func opj_j2k_read_ppm(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3844:17: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var l_cp uintptr = uintptr(00)
	// var l_Z_ppm TOPJ_UINT32 at bp+8, 4

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(3854), uintptr(unsafe.Pointer(&__func__101)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(3855), uintptr(unsafe.Pointer(&__func__101)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3856), uintptr(unsafe.Pointer(&__func__101)))
	}

	// We need to have the Z_ppm element + 1 byte of Nppm/Ippm at minimum
	if p_header_size < TOPJ_UINT32(2) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6392, 0)
		return DOPJ_FALSE
	}

	l_cp = p_j2k + 112
	libc.SetBitFieldPtr8Uint32(l_cp+148, TOPJ_BITFIELD(1), 0, 0x1)

	Xopj_read_bytes_LE(tls, p_header_data, bp+8, uint32(1)) // Z_ppm
	p_header_data++
	p_header_size--

	// check allocation needed
	if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers == uintptr(0) { // first PPM marker
		var l_newCount TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) + 1 // can't overflow, l_Z_ppm is UINT8
		if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers_count == 0 {
		} else {
			libc.X__assert_fail(tls, ts+6418, ts+3645, uint32(3874), uintptr(unsafe.Pointer(&__func__101)))
		}

		(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers = Xopj_calloc(tls, uint32(l_newCount), uint32(unsafe.Sizeof(Topj_ppx{})))
		if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers == uintptr(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6448, 0)
			return DOPJ_FALSE
		}
		(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers_count = l_newCount
	} else if (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers_count <= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) {
		var l_newCount TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) + 1 // can't overflow, l_Z_ppm is UINT8
		var new_ppm_markers uintptr
		new_ppm_markers = Xopj_realloc(tls, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers,
			uint32(l_newCount)*uint32(unsafe.Sizeof(Topj_ppx{})))
		if new_ppm_markers == uintptr(0) {
			// clean up to be done on l_cp destruction
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6448, 0)
			return DOPJ_FALSE
		}
		(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers = new_ppm_markers
		libc.Xmemset(tls, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers+uintptr((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers_count)*16, 0,
			uint32(l_newCount-(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers_count)*uint32(unsafe.Sizeof(Topj_ppx{})))
		(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers_count = l_newCount
	}

	if (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)))*16)).Fm_data != uintptr(0) {
		// clean up to be done on l_cp destruction
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6486, libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_Z_ppm */))))
		return DOPJ_FALSE
	}

	(*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_Z_ppm */)))*16)).Fm_data = Xopj_malloc(tls, uint32(p_header_size))
	if (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)))*16)).Fm_data == uintptr(0) {
		// clean up to be done on l_cp destruction
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6448, 0)
		return DOPJ_FALSE
	}
	(*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_Z_ppm */)))*16)).Fm_data_size = p_header_size
	libc.Xmemcpy(tls, (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fppm_markers+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_Z_ppm */)))*16)).Fm_data, p_header_data, uint32(p_header_size))

	return DOPJ_TRUE
}

var __func__101 = *(*[17]int8)(unsafe.Pointer(ts + 6508)) /* j2k.c:3849:1 */

// *
// Merges all PPM markers read (Packed headers, main header)
//
// @param       p_cp      main coding parameters.
// @param       p_manager the user event manager.
func opj_j2k_merge_ppm(tls *libc.TLS, p_cp uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:3922:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i TOPJ_UINT32
	var l_ppm_data_size TOPJ_UINT32
	var l_N_ppm_remaining TOPJ_UINT32

	// preconditions
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+3645, uint32(3927), uintptr(unsafe.Pointer(&__func__102)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(3928), uintptr(unsafe.Pointer(&__func__102)))
	}
	if (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer == uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+6536, ts+3645, uint32(3929), uintptr(unsafe.Pointer(&__func__102)))
	}

	if uint32(int32(*(*uint8)(unsafe.Pointer(p_cp + 148))&0x1>>0)) == 0 {
		return DOPJ_TRUE
	}

	l_ppm_data_size = 0
	l_N_ppm_remaining = 0
	for i = 0; i < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers_count; i++ {
		if (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers+uintptr(i)*16)).Fm_data != uintptr(0) { // standard doesn't seem to require contiguous Zppm
			// var l_N_ppm TOPJ_UINT32 at bp, 4

			var l_data_size TOPJ_UINT32 = (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers + uintptr(i)*16)).Fm_data_size
			var l_data uintptr = (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers + uintptr(i)*16)).Fm_data

			if l_N_ppm_remaining >= l_data_size {
				l_N_ppm_remaining = l_N_ppm_remaining - l_data_size
				l_data_size = 0
			} else {
				l_data += uintptr(l_N_ppm_remaining)
				l_data_size = l_data_size - l_N_ppm_remaining
				l_N_ppm_remaining = 0
			}

			if l_data_size > 0 {
				for __ccgo := true; __ccgo; __ccgo = l_data_size > 0 {
					// read Nppm
					if l_data_size < 4 {
						// clean up to be done on l_cp destruction
						Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6561, 0)
						return DOPJ_FALSE
					}
					Xopj_read_bytes_LE(tls, l_data, bp, uint32(4))
					l_data += uintptr(4)
					l_data_size = l_data_size - TOPJ_UINT32(4)
					l_ppm_data_size = l_ppm_data_size + *(*TOPJ_UINT32)(unsafe.Pointer(bp)) // can't overflow, max 256 markers of max 65536 bytes, that is when PPM markers are not corrupted which is checked elsewhere

					if l_data_size >= *(*TOPJ_UINT32)(unsafe.Pointer(bp)) {
						l_data_size = l_data_size - *(*TOPJ_UINT32)(unsafe.Pointer(bp))
						l_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_N_ppm */)))
					} else {
						l_N_ppm_remaining = *(*TOPJ_UINT32)(unsafe.Pointer(bp)) - l_data_size
						l_data_size = 0
					}
				}
			}
		}
	}

	if l_N_ppm_remaining != 0 {
		// clean up to be done on l_cp destruction
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6592, 0)
		return DOPJ_FALSE
	}

	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer = Xopj_malloc(tls, uint32(l_ppm_data_size))
	if (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer == uintptr(00) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6448, 0)
		return DOPJ_FALSE
	}
	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_len = l_ppm_data_size
	l_ppm_data_size = 0
	l_N_ppm_remaining = 0
	for i = 0; i < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers_count; i++ {
		if (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers+uintptr(i)*16)).Fm_data != uintptr(0) { // standard doesn't seem to require contiguous Zppm
			// var l_N_ppm TOPJ_UINT32 at bp+4, 4

			var l_data_size TOPJ_UINT32 = (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers + uintptr(i)*16)).Fm_data_size
			var l_data uintptr = (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers + uintptr(i)*16)).Fm_data

			if l_N_ppm_remaining >= l_data_size {
				libc.Xmemcpy(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer+uintptr(l_ppm_data_size), l_data, uint32(l_data_size))
				l_ppm_data_size = l_ppm_data_size + l_data_size
				l_N_ppm_remaining = l_N_ppm_remaining - l_data_size
				l_data_size = 0
			} else {
				libc.Xmemcpy(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer+uintptr(l_ppm_data_size), l_data, uint32(l_N_ppm_remaining))
				l_ppm_data_size = l_ppm_data_size + l_N_ppm_remaining
				l_data += uintptr(l_N_ppm_remaining)
				l_data_size = l_data_size - l_N_ppm_remaining
				l_N_ppm_remaining = 0
			}

			if l_data_size > 0 {
				for __ccgo1 := true; __ccgo1; __ccgo1 = l_data_size > 0 {
					// read Nppm
					if l_data_size < 4 {
						// clean up to be done on l_cp destruction
						Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6561, 0)
						return DOPJ_FALSE
					}
					Xopj_read_bytes_LE(tls, l_data, bp+4, uint32(4))
					l_data += uintptr(4)
					l_data_size = l_data_size - TOPJ_UINT32(4)

					if l_data_size >= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) {
						libc.Xmemcpy(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer+uintptr(l_ppm_data_size), l_data, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_N_ppm */))))
						l_ppm_data_size = l_ppm_data_size + *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))
						l_data_size = l_data_size - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))
						l_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_N_ppm */)))
					} else {
						libc.Xmemcpy(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer+uintptr(l_ppm_data_size), l_data, uint32(l_data_size))
						l_ppm_data_size = l_ppm_data_size + l_data_size
						l_N_ppm_remaining = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) - l_data_size
						l_data_size = 0
					}
				}
			}
			Xopj_free(tls, (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers+uintptr(i)*16)).Fm_data)
			(*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers + uintptr(i)*16)).Fm_data = uintptr(0)
			(*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers + uintptr(i)*16)).Fm_data_size = 0
		}
	}

	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_data = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer
	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_data_size = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_len

	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers_count = 0
	Xopj_free(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers)
	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers = uintptr(0)

	return DOPJ_TRUE
}

var __func__102 = *(*[18]int8)(unsafe.Pointer(ts + 6615)) /* j2k.c:3923:1 */

// *
// Reads a PPT marker (Packed packet headers, tile-part header)
//
// @param       p_header_data   the data contained in the PPT box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the PPT marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_ppt(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4062:17: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	// var l_Z_ppt TOPJ_UINT32 at bp+8, 4

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(4073), uintptr(unsafe.Pointer(&__func__103)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(4074), uintptr(unsafe.Pointer(&__func__103)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(4075), uintptr(unsafe.Pointer(&__func__103)))
	}

	// We need to have the Z_ppt element + 1 byte of Ippt at minimum
	if p_header_size < TOPJ_UINT32(2) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6633, 0)
		return DOPJ_FALSE
	}

	l_cp = p_j2k + 112
	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(l_cp + 148))&0x1>>0)) != 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+6659, 0)
		return DOPJ_FALSE
	}

	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	libc.SetBitFieldPtr8Uint32(l_tcp+5688, TOPJ_BITFIELD(1), 1, 0x2)

	Xopj_read_bytes_LE(tls, p_header_data, bp+8, uint32(1)) // Z_ppt
	p_header_data++
	p_header_size--

	// check allocation needed
	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers == uintptr(0) { // first PPT marker
		var l_newCount TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) + 1 // can't overflow, l_Z_ppt is UINT8
		if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers_count == 0 {
		} else {
			libc.X__assert_fail(tls, ts+6760, ts+3645, uint32(4100), uintptr(unsafe.Pointer(&__func__103)))
		}

		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers = Xopj_calloc(tls, uint32(l_newCount), uint32(unsafe.Sizeof(Topj_ppx{})))
		if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers == uintptr(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6791, 0)
			return DOPJ_FALSE
		}
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers_count = l_newCount
	} else if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers_count <= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) {
		var l_newCount TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) + 1 // can't overflow, l_Z_ppt is UINT8
		var new_ppt_markers uintptr
		new_ppt_markers = Xopj_realloc(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers,
			uint32(l_newCount)*uint32(unsafe.Sizeof(Topj_ppx{})))
		if new_ppt_markers == uintptr(0) {
			// clean up to be done on l_tcp destruction
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6791, 0)
			return DOPJ_FALSE
		}
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers = new_ppt_markers
		libc.Xmemset(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers+uintptr((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers_count)*16, 0,
			uint32(l_newCount-(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers_count)*uint32(unsafe.Sizeof(Topj_ppx{})))
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers_count = l_newCount
	}

	if (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)))*16)).Fm_data != uintptr(0) {
		// clean up to be done on l_tcp destruction
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6829, libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_Z_ppt */))))
		return DOPJ_FALSE
	}

	(*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_Z_ppt */)))*16)).Fm_data = Xopj_malloc(tls, uint32(p_header_size))
	if (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)))*16)).Fm_data == uintptr(0) {
		// clean up to be done on l_tcp destruction
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6791, 0)
		return DOPJ_FALSE
	}
	(*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_Z_ppt */)))*16)).Fm_data_size = p_header_size
	libc.Xmemcpy(tls, (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_markers+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_Z_ppt */)))*16)).Fm_data, p_header_data, uint32(p_header_size))
	return DOPJ_TRUE
}

var __func__103 = *(*[17]int8)(unsafe.Pointer(ts + 6851)) /* j2k.c:4067:1 */

// *
// Merges all PPT markers read (Packed packet headers, tile-part header)
//
// @param       p_tcp   the tile.
// @param       p_manager               the user event manager.
func opj_j2k_merge_ppt(tls *libc.TLS, p_tcp uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4147:17: */
	var i TOPJ_UINT32
	var l_ppt_data_size TOPJ_UINT32
	// preconditions
	if p_tcp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6868, ts+3645, uint32(4151), uintptr(unsafe.Pointer(&__func__104)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(4152), uintptr(unsafe.Pointer(&__func__104)))
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_buffer != uintptr(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+6880, 0)
		return DOPJ_FALSE
	}

	if uint32(int32(*(*uint8)(unsafe.Pointer(p_tcp + 5688))&0x2>>1)) == 0 {
		return DOPJ_TRUE
	}

	l_ppt_data_size = 0
	for i = 0; i < (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers_count; i++ {
		l_ppt_data_size = l_ppt_data_size + (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers+uintptr(i)*16)).Fm_data_size // can't overflow, max 256 markers of max 65536 bytes
	}

	(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_buffer = Xopj_malloc(tls, uint32(l_ppt_data_size))
	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_buffer == uintptr(00) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+6791, 0)
		return DOPJ_FALSE
	}
	(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_len = l_ppt_data_size
	l_ppt_data_size = 0
	for i = 0; i < (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers_count; i++ {
		if (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers+uintptr(i)*16)).Fm_data != uintptr(0) { // standard doesn't seem to require contiguous Zppt
			libc.Xmemcpy(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_buffer+uintptr(l_ppt_data_size), (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers+uintptr(i)*16)).Fm_data,
				uint32((*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers+uintptr(i)*16)).Fm_data_size))
			l_ppt_data_size = l_ppt_data_size + (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers+uintptr(i)*16)).Fm_data_size // can't overflow, max 256 markers of max 65536 bytes

			Xopj_free(tls, (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers+uintptr(i)*16)).Fm_data)
			(*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers + uintptr(i)*16)).Fm_data = uintptr(0)
			(*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers + uintptr(i)*16)).Fm_data_size = 0
		}
	}

	(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers_count = 0
	Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers)
	(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers = uintptr(0)

	(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_data = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_buffer
	(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_data_size = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_len
	return DOPJ_TRUE
}

var __func__104 = *(*[18]int8)(unsafe.Pointer(ts + 6925)) /* j2k.c:4148:1 */

func opj_j2k_write_tlm(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4200:17: */
	var l_current_data uintptr = uintptr(00)
	var l_tlm_size TOPJ_UINT32
	var size_per_tile_part TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(4210), uintptr(unsafe.Pointer(&__func__105)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(4211), uintptr(unsafe.Pointer(&__func__105)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(4212), uintptr(unsafe.Pointer(&__func__105)))
	}

	// 10921 = (65535 - header_size) / size_per_tile_part where
	// header_size = 4 and size_per_tile_part = 6
	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_total_tile_parts > TOPJ_UINT32(10921) {
		// We could do more but it would require writing several TLM markers
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+6943, 0)
		return DOPJ_FALSE
	}

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_total_tile_parts <= TOPJ_UINT32(255) {
		size_per_tile_part = TOPJ_UINT32(5)
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_Ttlmi_is_byte = DOPJ_TRUE
	} else {
		size_per_tile_part = TOPJ_UINT32(6)
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_Ttlmi_is_byte = DOPJ_FALSE
	}

	l_tlm_size = TOPJ_UINT32(2+4) + size_per_tile_part*(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_total_tile_parts

	if l_tlm_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_tlm_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+7022, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_tlm_size
	}
	libc.Xmemset(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, 0, uint32(l_tlm_size))

	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	// change the way data is written to avoid seeking if possible
	// TODO
	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_tlm_start = Xopj_stream_tell(tls, p_stream)

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_TLM),
		uint32(2)) // TLM
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_tlm_size-TOPJ_UINT32(2),
		uint32(2)) // Lpoc
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, uint32(0),
		uint32(1)) // Ztlm=0
	l_current_data++

	// Stlm 0x50= ST=1(8bits-255 tiles max),SP=1(Ptlm=32bits)
	// Stlm 0x60= ST=2(16bits-65535 tiles max),SP=1(Ptlm=32bits)
	Xopj_write_bytes_LE(tls, l_current_data,
		func() uint32 {
			if size_per_tile_part == TOPJ_UINT32(5) {
				return uint32(0x50)
			}
			return uint32(0x60)
		}(),
		uint32(1))
	l_current_data++

	// do nothing on the size_per_tile_part * l_j2k->m_specific_param.m_encoder.m_total_tile_parts remaining data
	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_tlm_size),
		p_manager) != TOPJ_SIZE_T(l_tlm_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__105 = *(*[18]int8)(unsafe.Pointer(ts + 7061)) /* j2k.c:4204:1 */

func opj_j2k_write_sot(tls *libc.TLS, p_j2k uintptr, p_data uintptr, total_data_size TOPJ_UINT32, p_data_written uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4285:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(4294), uintptr(unsafe.Pointer(&__func__106)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(4295), uintptr(unsafe.Pointer(&__func__106)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(4296), uintptr(unsafe.Pointer(&__func__106)))
	}

	_ = p_stream

	if total_data_size < TOPJ_UINT32(12) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+7079, 0)
		return DOPJ_FALSE
	}

	Xopj_write_bytes_LE(tls, p_data, uint32(DJ2K_MS_SOT),
		uint32(2)) // SOT
	p_data += uintptr(2)

	Xopj_write_bytes_LE(tls, p_data, uint32(10),
		uint32(2)) // Lsot
	p_data += uintptr(2)

	Xopj_write_bytes_LE(tls, p_data, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		uint32(2)) // Isot
	p_data += uintptr(2)

	// Psot
	p_data += uintptr(4)

	Xopj_write_bytes_LE(tls, p_data,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_current_tile_part_number,
		uint32(1)) // TPsot
	p_data++

	Xopj_write_bytes_LE(tls, p_data,
		(*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696)).Fm_nb_tile_parts,
		uint32(1)) // TNsot
	p_data++

	// UniPG>>

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = TOPJ_UINT32(12)

	return DOPJ_TRUE
}

var __func__106 = *(*[18]int8)(unsafe.Pointer(ts + 7134)) /* j2k.c:4292:1 */

func opj_j2k_get_sot_values(tls *libc.TLS, p_header_data uintptr, p_header_size TOPJ_UINT32, p_tile_no uintptr, p_tot_len uintptr, p_current_part uintptr, p_num_parts uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4345:17: */
	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(4354), uintptr(unsafe.Pointer(&__func__107)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(4355), uintptr(unsafe.Pointer(&__func__107)))
	}

	// Size of this marker is fixed = 12 (we have already read marker and its size)
	if p_header_size != TOPJ_UINT32(8) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+7152, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, p_tile_no, uint32(2)) // Isot
	p_header_data += uintptr(2)
	Xopj_read_bytes_LE(tls, p_header_data, p_tot_len, uint32(4)) // Psot
	p_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_header_data, p_current_part, uint32(1)) // TPsot
	p_header_data++
	Xopj_read_bytes_LE(tls, p_header_data, p_num_parts, uint32(1)) // TNsot
	p_header_data++
	return DOPJ_TRUE
}

var __func__107 = *(*[23]int8)(unsafe.Pointer(ts + 7178)) /* j2k.c:4352:1 */

func opj_j2k_read_sot(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4374:17: */
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	// var l_tot_len TOPJ_UINT32 at bp+96, 4

	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 104 /* l_num_parts */)) = TOPJ_UINT32(0)
	// var l_current_part TOPJ_UINT32 at bp+100, 4

	var l_tile_x TOPJ_UINT32
	var l_tile_y TOPJ_UINT32

	// preconditions

	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(4387), uintptr(unsafe.Pointer(&__func__108)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(4388), uintptr(unsafe.Pointer(&__func__108)))
	}

	if !(opj_j2k_get_sot_values(tls, p_header_data, p_header_size,
		p_j2k+288, bp+96, bp+100, bp+104,
		p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+7152, 0)
		return DOPJ_FALSE
	}

	l_cp = p_j2k + 112

	// testcase 2.pdf.SIGFPE.706.1112
	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number >= (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+7201,
			libc.VaList(bp, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number))
		return DOPJ_FALSE
	}

	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	l_tile_x = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number % (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw
	l_tile_y = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number / (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw

	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_tile_ind_to_dec < 0 || (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number == TOPJ_UINT32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_tile_ind_to_dec) {
		// Do only this check if we decode all tile part headers, or if
		// we decode one precise tile. Otherwise the m_current_tile_part_number
		// might not be valid
		// Fixes issue with id_000020,sig_06,src_001958,op_flip4,pos_149
		// of https://github.com/uclouvain/openjpeg/issues/939
		// We must avoid reading twice the same tile part number for a given tile
		// so as to avoid various issues, like opj_j2k_merge_ppt being called
		// several times.
		// ISO 15444-1 A.4.2 Start of tile-part (SOT) mandates that tile parts
		// should appear in increasing order.
		if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_current_tile_part_number+1 != TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 100))) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,

				ts+7225,
				libc.VaList(bp+8, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
					*(*TOPJ_UINT32)(unsafe.Pointer(bp + 100 /* l_current_part */)),
					(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_current_tile_part_number+1))
			return DOPJ_FALSE
		}
	}

	(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_current_tile_part_number = TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 100 /* l_current_part */)))

	// look for the tile in the list of already processed tile (in parts).
	// Optimization possible here with a more complex data structure and with the removing of tiles
	// since the time taken by this function can only grow at the time

	// PSot should be equal to zero or >=14 or <= 2^32-1
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 96)) != TOPJ_UINT32(0) && *(*TOPJ_UINT32)(unsafe.Pointer(bp + 96)) < TOPJ_UINT32(14) {
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 96)) == TOPJ_UINT32(12) { // MSD: Special case for the PHR data which are read by kakadu
			Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+7290,
				libc.VaList(bp+32, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 96 /* l_tot_len */))))
		} else {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+7327, libc.VaList(bp+40, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 96 /* l_tot_len */))))
			return DOPJ_FALSE
		}
	}

	// Ref A.4.2: Psot could be equal zero if it is the last tile-part of the codestream.
	if !(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 96)) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_INFO,

			ts+7388, 0)
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_last_tile_part = 1
	}

	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts != TOPJ_UINT32(0) && *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100)) >= (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts {
		// Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=2851
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+7499, libc.VaList(bp+48, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100 /* l_current_part */)),
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts))
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_last_tile_part = 1
		return DOPJ_FALSE
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 104)) != TOPJ_UINT32(0) { // Number of tile-part header is provided by this tile-part header
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 104 /* l_num_parts */)) += TOPJ_UINT32(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72)) & 0x10 >> 4))
		// Useful to manage the case of textGBR.jp2 file because two values of TNSot are allowed: the correct numbers of
		// tile-parts for that tile and zero (A.4.2 of 15444-1 : 2002).
		if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts != 0 {
			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100)) >= (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,

					ts+7599, libc.VaList(bp+64, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100 /* l_current_part */)),
						(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts))
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_last_tile_part = 1
				return DOPJ_FALSE
			}
		}
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100)) >= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 104)) {
			// testcase 451.pdf.SIGSEGV.ce9.3723
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,

				ts+7698, libc.VaList(bp+80, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100 /* l_current_part */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 104 /* l_num_parts */))))
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_last_tile_part = 1
			return DOPJ_FALSE
		}
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 104 /* l_num_parts */))
	}

	// If know the number of tile part header we will check if we didn't read the last
	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts != 0 {
		if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_tile_parts == *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100))+TOPJ_UINT32(1) {
			libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(1), 0, 0x1) // Process the last tile-part header
		}
	}

	if !((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_last_tile_part != 0) {
		// Keep the size of data to skip after this marker
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_sot_length = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 96)) - TOPJ_UINT32(12) // SOT_marker_size = 12
	} else {
		// FIXME: need to be computed from the number of bytes remaining in the codestream
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_sot_length = TOPJ_UINT32(0)
	}

	(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_TPH

	// Check if the current tile is outside the area we want decode or not corresponding to the tile index
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_tile_ind_to_dec == -1 {
		libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(libc.Bool32(l_tile_x < (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_start_tile_x ||
			l_tile_x >= (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_end_tile_x ||
			l_tile_y < (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_start_tile_y ||
			l_tile_y >= (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_end_tile_y)), 2, 0x4)
	} else {
		if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_tile_ind_to_dec >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+7806, ts+3645, uint32(4578), uintptr(unsafe.Pointer(&__func__108)))
		}
		libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(libc.Bool32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number != TOPJ_UINT32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_tile_ind_to_dec))), 2, 0x4)
	}

	// Index
	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index != 0 {
		if (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index != uintptr(00) {
		} else {
			libc.X__assert_fail(tls, ts+7863, ts+3645, uint32(4586), uintptr(unsafe.Pointer(&__func__108)))
		}
		(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftileno = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number
		(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_tpsno = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100 /* l_current_part */))

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 104)) != TOPJ_UINT32(0) {
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fnb_tps = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 104 /* l_num_parts */))
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_nb_tps = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 104 /* l_num_parts */))

			if !(int32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index) != 0) {
				(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index = Xopj_calloc(tls, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 104 /* l_num_parts */))), uint32(unsafe.Sizeof(Topj_tp_index_t{})))
				if !(int32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index) != 0) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+7899, 0)
					return DOPJ_FALSE
				}
			} else {
				var new_tp_index uintptr = Xopj_realloc(tls,
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index,
					uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 104)))*uint32(unsafe.Sizeof(Topj_tp_index_t{})))
				if !(new_tp_index != 0) {
					Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index)
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index = uintptr(0)
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+7899, 0)
					return DOPJ_FALSE
				}
				(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index = new_tp_index
			}
		} else {
			/*if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index)*/ {

				if !(int32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index) != 0) {
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_nb_tps = TOPJ_UINT32(10)
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index = Xopj_calloc(tls,
						uint32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_nb_tps),
						uint32(unsafe.Sizeof(Topj_tp_index_t{})))
					if !(int32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index) != 0) {
						(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_nb_tps = TOPJ_UINT32(0)
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+7899, 0)
						return DOPJ_FALSE
					}
				}

				if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100)) >= (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_nb_tps {
					var new_tp_index uintptr
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_nb_tps = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 100)) + TOPJ_UINT32(1)
					new_tp_index = Xopj_realloc(tls,
						(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index,
						uint32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_nb_tps)*uint32(unsafe.Sizeof(Topj_tp_index_t{})))
					if !(new_tp_index != 0) {
						Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index)
						(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index = uintptr(0)
						(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_nb_tps = TOPJ_UINT32(0)
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+7899, 0)
						return DOPJ_FALSE
					}
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index = new_tp_index
				}

			}

		}

	}

	// FIXME move this onto a separate method to call before reading any SOT, remove part about main_end header, use a index struct inside p_j2k
	// if (p_j2k->cstr_info) {
	//        if (l_tcp->first) {
	//        if (tileno == 0) {
	//        p_j2k->cstr_info->main_head_end = p_stream_tell(p_stream) - 13;
	//        }
	//
	//        p_j2k->cstr_info->tile[tileno].tileno = tileno;
	//        p_j2k->cstr_info->tile[tileno].start_pos = p_stream_tell(p_stream) - 12;
	//        p_j2k->cstr_info->tile[tileno].end_pos = p_j2k->cstr_info->tile[tileno].start_pos + totlen - 1;
	//        p_j2k->cstr_info->tile[tileno].num_tps = numparts;
	//
	//        if (numparts) {
	//        p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));
	//        }
	//        else {
	//        p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)
	//        }
	//        }
	//        else {
	//        p_j2k->cstr_info->tile[tileno].end_pos += totlen;
	//        }
	//
	//        p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = p_stream_tell(p_stream) - 12;
	//        p_j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos =
	//        p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;
	//        }
	return DOPJ_TRUE
}

var __func__108 = *(*[17]int8)(unsafe.Pointer(ts + 7967)) /* j2k.c:4378:1 */

// *
// Write one or more PLT markers in the provided buffer
func opj_j2k_write_plt_in_memory(tls *libc.TLS, p_j2k uintptr, marker_info uintptr, p_data uintptr, p_data_written uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4696:17: */
	bp := tls.Alloc(5)
	defer tls.Free(5)

	var Zplt TOPJ_BYTE = TOPJ_BYTE(0)
	var Lplt TOPJ_UINT16
	var p_data_start uintptr = p_data
	var p_data_Lplt uintptr = p_data + uintptr(2)
	var i TOPJ_UINT32

	_ = p_j2k

	Xopj_write_bytes_LE(tls, p_data, uint32(DJ2K_MS_PLT), uint32(2))
	p_data += uintptr(2)

	// Reserve space for Lplt
	p_data += uintptr(2)

	Xopj_write_bytes_LE(tls, p_data, uint32(Zplt), uint32(1))
	p_data += uintptr(1)

	Lplt = TOPJ_UINT16(3)

	for i = TOPJ_UINT32(0); i < (*Topj_tcd_marker_info_t)(unsafe.Pointer(marker_info)).Fpacket_count; i++ {
		// var var_bytes [5]TOPJ_BYTE at bp, 5

		var var_bytes_size TOPJ_UINT8 = TOPJ_UINT8(0)
		var packet_size TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer((*Topj_tcd_marker_info_t)(unsafe.Pointer(marker_info)).Fp_packet_size + uintptr(i)*4))

		// Packet size written in variable-length way, starting with LSB
		*(*TOPJ_BYTE)(unsafe.Pointer(bp + uintptr(var_bytes_size))) = TOPJ_BYTE(packet_size & TOPJ_UINT32(0x7f))
		var_bytes_size++
		packet_size >>= 7
		for packet_size > TOPJ_UINT32(0) {
			*(*TOPJ_BYTE)(unsafe.Pointer(bp + uintptr(var_bytes_size))) = TOPJ_BYTE(packet_size&TOPJ_UINT32(0x7f) | TOPJ_UINT32(0x80))
			var_bytes_size++
			packet_size >>= 7
		}

		// Check if that can fit in the current PLT marker. If not, finish
		// current one, and start a new one
		if int32(Lplt)+int32(var_bytes_size) > 65535 {
			if int32(Zplt) == 255 {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+7984, 0)
				return DOPJ_FALSE
			}

			// Patch Lplt
			Xopj_write_bytes_LE(tls, p_data_Lplt, uint32(Lplt), uint32(2))

			// Start new segment
			Xopj_write_bytes_LE(tls, p_data, uint32(DJ2K_MS_PLT), uint32(2))
			p_data += uintptr(2)

			// Reserve space for Lplt
			p_data_Lplt = p_data
			p_data += uintptr(2)

			Zplt++
			Xopj_write_bytes_LE(tls, p_data, uint32(Zplt), uint32(1))
			p_data += uintptr(1)

			Lplt = TOPJ_UINT16(3)
		}

		Lplt = TOPJ_UINT16(int32(Lplt) + int32(var_bytes_size))

		// Serialize variable-length packet size, starting with MSB
		for ; int32(var_bytes_size) > 0; var_bytes_size-- {
			Xopj_write_bytes_LE(tls, p_data, uint32(*(*TOPJ_BYTE)(unsafe.Pointer(bp + uintptr(int32(var_bytes_size)-1)))), uint32(1))
			p_data += uintptr(1)
		}
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = TOPJ_UINT32((int32(p_data) - int32(p_data_start)) / 1)

	// Patch Lplt
	Xopj_write_bytes_LE(tls, p_data_Lplt, uint32(Lplt), uint32(2))

	return DOPJ_TRUE
}

func opj_j2k_write_sod(tls *libc.TLS, p_j2k uintptr, p_tile_coder uintptr, p_data uintptr, p_data_written uintptr, total_data_size TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4780:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_cstr_info uintptr = uintptr(00)
	var l_remaining_data TOPJ_UINT32
	var marker_info uintptr = uintptr(0)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(4794), uintptr(unsafe.Pointer(&__func__109)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(4795), uintptr(unsafe.Pointer(&__func__109)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(4796), uintptr(unsafe.Pointer(&__func__109)))
	}

	_ = p_stream

	if total_data_size < TOPJ_UINT32(4) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+8051, 0)
		return DOPJ_FALSE
	}

	Xopj_write_bytes_LE(tls, p_data, uint32(DJ2K_MS_SOD),
		uint32(2)) // SOD

	// make room for the EOF marker
	l_remaining_data = total_data_size - TOPJ_UINT32(4)

	// update tile coder
	(*Topj_tcd_t)(unsafe.Pointer(p_tile_coder)).Ftp_num = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_current_poc_tile_part_number
	(*Topj_tcd_t)(unsafe.Pointer(p_tile_coder)).Fcur_tp_num = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_current_tile_part_number

	// INDEX >>
	// TODO mergeV2: check this part which use cstr_info
	//l_cstr_info = p_j2k->cstr_info;
	//     if (l_cstr_info) {
	//             if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {
	//                     //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;
	//                     l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;
	//             }
	//             else {
	//
	//     TODO
	//     if
	//             (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))
	//     {
	//             cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);
	//     }
	//}
	// UniPG>>
	// <<UniPG
	//}
	// << INDEX

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_current_tile_part_number == TOPJ_UINT32(0) {
		(*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tile_coder)).Ftcd_image)).Ftiles)).Fpackno = TOPJ_UINT32(0)
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = TOPJ_UINT32(0)

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_PLT != 0 {
		marker_info = Xopj_tcd_marker_info_create(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_PLT)
		if marker_info == uintptr(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+8106, 0)
			return DOPJ_FALSE
		}
	}

	if l_remaining_data < (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_reserved_bytes_for_PLT {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+8051, 0)
		Xopj_tcd_marker_info_destroy(tls, marker_info)
		return DOPJ_FALSE
	}
	l_remaining_data = l_remaining_data - (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_reserved_bytes_for_PLT

	if !(Xopj_tcd_encode_tile(tls, p_tile_coder, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		p_data+uintptr(2),
		p_data_written, l_remaining_data, l_cstr_info,
		marker_info,
		p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+8163, 0)
		Xopj_tcd_marker_info_destroy(tls, marker_info)
		return DOPJ_FALSE
	}

	// For SOD
	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) += TOPJ_UINT32(2)

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_PLT != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_data_written_PLT */)) = TOPJ_UINT32(0)
		var p_PLT_buffer uintptr = Xopj_malloc(tls,
			uint32((*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_reserved_bytes_for_PLT))
		if !(p_PLT_buffer != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+8183, 0)
			Xopj_tcd_marker_info_destroy(tls, marker_info)
			return DOPJ_FALSE
		}
		if !(opj_j2k_write_plt_in_memory(tls, p_j2k,
			marker_info,
			p_PLT_buffer,
			bp,
			p_manager) != 0) {
			Xopj_tcd_marker_info_destroy(tls, marker_info)
			Xopj_free(tls, p_PLT_buffer)
			return DOPJ_FALSE
		}

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) <= (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_reserved_bytes_for_PLT {
		} else {
			libc.X__assert_fail(tls, ts+8207, ts+3645, uint32(4908), uintptr(unsafe.Pointer(&__func__109)))
		}

		// Move PLT marker(s) before SOD
		libc.Xmemmove(tls, p_data+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp))), p_data, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written))))
		libc.Xmemcpy(tls, p_data, p_PLT_buffer, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_data_written_PLT */))))
		Xopj_free(tls, p_PLT_buffer)
		*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) += *(*TOPJ_UINT32)(unsafe.Pointer(bp))
	}

	Xopj_tcd_marker_info_destroy(tls, marker_info)

	return DOPJ_TRUE
}

var __func__109 = *(*[18]int8)(unsafe.Pointer(ts + 8288)) /* j2k.c:4788:1 */

func opj_j2k_read_sod(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:4923:17: */
	var l_current_read_size TOPJ_SIZE_T
	var l_cstr_index uintptr = uintptr(00)
	var l_current_data uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tile_len uintptr = uintptr(00)
	var l_sot_length_pb_detected TOPJ_BOOL = DOPJ_FALSE

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(4936), uintptr(unsafe.Pointer(&__func__110)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(4937), uintptr(unsafe.Pointer(&__func__110)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(4938), uintptr(unsafe.Pointer(&__func__110)))
	}

	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696

	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_last_tile_part != 0 {
		// opj_stream_get_number_byte_left returns OPJ_OFF_T
		//         // but we are in the last tile part,
		//         // so its result will fit on OPJ_UINT32 unless we find
		//         // a file with a single tile part of more than 4 GB...
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_sot_length = TOPJ_UINT32(Xopj_stream_get_number_byte_left(tls, p_stream) - 2)
	} else {
		// Check to avoid pass the limit of OPJ_UINT32
		if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length >= TOPJ_UINT32(2) {
			*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8 + 28)) -= TOPJ_UINT32(2)
		} else {
			// MSD: case commented to support empty SOT marker (PHR data)
		}
	}

	l_current_data = l_tcp + 5616
	l_tile_len = l_tcp + 5624

	// Patch to support new PHR data
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length != 0 {
		// If we are here, we'll try to read the data after allocation
		// Check enough bytes left in stream before allocation
		if TOPJ_OFF_T((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length) > Xopj_stream_get_number_byte_left(tls, p_stream) {
			if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fstrict != 0 {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+8306, 0)
				return DOPJ_FALSE
			} else {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,
					ts+8306, 0)
			}
		}
		if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length > uint32(0x7fffffff)*2+1-uint32(DOPJ_COMMON_CBLK_DATA_EXTRA) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,

				ts+8361, 0)
			return DOPJ_FALSE
		}
		// Add a margin of OPJ_COMMON_CBLK_DATA_EXTRA to the allocation we
		// do so that opj_mqc_init_dec_common() can safely add a synthetic
		// 0xFFFF marker.
		if !(int32(*(*uintptr)(unsafe.Pointer(l_current_data))) != 0) {
			// LH: oddly enough, in this path, l_tile_len!=0.
			// TODO: If this was consistent, we could simplify the code to only use realloc(), as realloc(0,...) default to malloc(0,...).
			*(*uintptr)(unsafe.Pointer(l_current_data)) = Xopj_malloc(tls,
				uint32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length+TOPJ_UINT32(DOPJ_COMMON_CBLK_DATA_EXTRA)))
		} else {
			var l_new_current_data uintptr
			if *(*TOPJ_UINT32)(unsafe.Pointer(l_tile_len)) > uint32(0x7fffffff)*2+1-uint32(DOPJ_COMMON_CBLK_DATA_EXTRA)-(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,

					ts+8448, 0)
				return DOPJ_FALSE
			}

			l_new_current_data = Xopj_realloc(tls, *(*uintptr)(unsafe.Pointer(l_current_data)),
				uint32(*(*TOPJ_UINT32)(unsafe.Pointer(l_tile_len))+(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length+TOPJ_UINT32(DOPJ_COMMON_CBLK_DATA_EXTRA)))
			if !(l_new_current_data != 0) {
				Xopj_free(tls, *(*uintptr)(unsafe.Pointer(l_current_data)))
				//nothing more is done as l_current_data will be set to null, and just
				//                   afterward we enter in the error path
				//                   and the actual tile_len is updated (committed) at the end of the
				//                   function.
			}
			*(*uintptr)(unsafe.Pointer(l_current_data)) = l_new_current_data
		}

		if *(*uintptr)(unsafe.Pointer(l_current_data)) == uintptr(00) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+8549, 0)
			return DOPJ_FALSE
		}
	} else {
		l_sot_length_pb_detected = DOPJ_TRUE
	}

	// Index
	l_cstr_index = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index
	if l_cstr_index != 0 {
		var l_current_pos TOPJ_OFF_T = Xopj_stream_tell(tls, p_stream) - 2

		var l_current_tile_part TOPJ_UINT32 = (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Fcurrent_tpsno
		(*Topj_tp_index_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index + uintptr(l_current_tile_part)*12)).Fend_header = l_current_pos
		(*Topj_tp_index_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*56)).Ftp_index + uintptr(l_current_tile_part)*12)).Fend_pos = TOPJ_OFF_T(uint32(l_current_pos) + uint32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length) + uint32(2))

		if DOPJ_FALSE == opj_j2k_add_tlmarker(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
			l_cstr_index,
			uint32(DJ2K_MS_SOD),
			l_current_pos,
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length+TOPJ_UINT32(2)) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+8583, 0)
			return DOPJ_FALSE
		}

		//l_cstr_index->packno = 0;
	}

	// Patch to support new PHR data
	if !(l_sot_length_pb_detected != 0) {
		l_current_read_size = Xopj_stream_read_data(tls,
			p_stream,
			*(*uintptr)(unsafe.Pointer(l_current_data))+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(l_tile_len))),
			uint32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length),
			p_manager)
	} else {
		l_current_read_size = TOPJ_SIZE_T(0)
	}

	if l_current_read_size != TOPJ_SIZE_T((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length) {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_NEOC
	} else {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_TPHSOT
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(l_tile_len)) += TOPJ_UINT32(l_current_read_size)

	return DOPJ_TRUE
}

var __func__110 = *(*[17]int8)(unsafe.Pointer(ts + 8619)) /* j2k.c:4927:1 */

func opj_j2k_write_rgn(tls *libc.TLS, p_j2k uintptr, p_tile_no TOPJ_UINT32, p_comp_no TOPJ_UINT32, nb_comps TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5071:17: */
	var l_current_data uintptr = uintptr(00)
	var l_rgn_size TOPJ_UINT32
	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_comp_room TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5087), uintptr(unsafe.Pointer(&__func__111)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5088), uintptr(unsafe.Pointer(&__func__111)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5089), uintptr(unsafe.Pointer(&__func__111)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_comp_no)*1080

	if nb_comps <= TOPJ_UINT32(256) {
		l_comp_room = TOPJ_UINT32(1)
	} else {
		l_comp_room = TOPJ_UINT32(2)
	}

	l_rgn_size = TOPJ_UINT32(6) + l_comp_room

	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_RGN),
		uint32(2)) // RGN
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_rgn_size-TOPJ_UINT32(2),
		uint32(2)) // Lrgn
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, p_comp_no,
		l_comp_room) // Crgn
	l_current_data += uintptr(l_comp_room)

	Xopj_write_bytes_LE(tls, l_current_data, uint32(0),
		uint32(1)) // Srgn
	l_current_data++

	Xopj_write_bytes_LE(tls, l_current_data, TOPJ_UINT32((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Froishift),
		uint32(1)) // SPrgn
	l_current_data++

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_rgn_size),
		p_manager) != TOPJ_SIZE_T(l_rgn_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__111 = *(*[18]int8)(unsafe.Pointer(ts + 8636)) /* j2k.c:5078:1 */

func opj_j2k_write_eoc(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5134:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5140), uintptr(unsafe.Pointer(&__func__112)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5141), uintptr(unsafe.Pointer(&__func__112)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5142), uintptr(unsafe.Pointer(&__func__112)))
	}

	Xopj_write_bytes_LE(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data,
		uint32(DJ2K_MS_EOC), uint32(2)) // EOC

	// UniPG>>

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
		return DOPJ_FALSE
	}

	if !(Xopj_stream_flush(tls, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__112 = *(*[18]int8)(unsafe.Pointer(ts + 8654)) /* j2k.c:5138:1 */

// *
// Reads a RGN marker (Region Of Interest)
//
// @param       p_header_data   the data contained in the POC box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the POC marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_rgn(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5175:17: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var l_nb_comp TOPJ_UINT32
	var l_image uintptr = uintptr(00)

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_comp_room TOPJ_UINT32
	// var l_comp_no TOPJ_UINT32 at bp+16, 4

	// var l_roi_sty TOPJ_UINT32 at bp+20, 4

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(5189), uintptr(unsafe.Pointer(&__func__113)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5190), uintptr(unsafe.Pointer(&__func__113)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5191), uintptr(unsafe.Pointer(&__func__113)))
	}

	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	l_nb_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps

	if l_nb_comp <= TOPJ_UINT32(256) {
		l_comp_room = TOPJ_UINT32(1)
	} else {
		l_comp_room = TOPJ_UINT32(2)
	}

	if p_header_size != TOPJ_UINT32(2)+l_comp_room {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+8672, 0)
		return DOPJ_FALSE
	}

	l_cp = p_j2k + 112
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	Xopj_read_bytes_LE(tls, p_header_data, bp+16, l_comp_room) // Crgn
	p_header_data += uintptr(l_comp_room)
	Xopj_read_bytes_LE(tls, p_header_data, bp+20,
		uint32(1)) // Srgn
	p_header_data++

	// testcase 3635.pdf.asan.77.2930
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)) >= l_nb_comp {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+8698,
			libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_comp_no */)), l_nb_comp))
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data,
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)))*1080+808, uint32(1)) // SPrgn
	p_header_data++

	return DOPJ_TRUE

}

var __func__113 = *(*[17]int8)(unsafe.Pointer(ts + 8755)) /* j2k.c:5180:1 */

func opj_j2k_get_tp_stride(tls *libc.TLS, p_tcp uintptr) TOPJ_FLOAT32 { /* j2k.c:5249:20: */
	return TOPJ_FLOAT32(((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_tile_parts - TOPJ_UINT32(1)) * TOPJ_UINT32(14))
}

func opj_j2k_get_default_stride(tls *libc.TLS, p_tcp uintptr) TOPJ_FLOAT32 { /* j2k.c:5254:20: */
	_ = p_tcp
	return TOPJ_FLOAT32(0)
}

func opj_j2k_update_rates(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5260:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var l_cp uintptr = uintptr(00)
	var l_image uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var k TOPJ_UINT32
	var l_x0 TOPJ_INT32
	var l_y0 TOPJ_INT32
	var l_x1 TOPJ_INT32
	var l_y1 TOPJ_INT32
	var l_rates uintptr = uintptr(0)
	var l_sot_remove TOPJ_FLOAT32
	var l_bits_empty TOPJ_UINT32
	var l_size_pixel TOPJ_UINT32
	var l_tile_size TOPJ_UINT64 = TOPJ_UINT64(0)
	var l_last_res TOPJ_UINT32
	var l_tp_stride_func uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5279), uintptr(unsafe.Pointer(&__func__114)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5280), uintptr(unsafe.Pointer(&__func__114)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5281), uintptr(unsafe.Pointer(&__func__114)))
	}

	_ = p_manager

	l_cp = p_j2k + 112
	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps

	l_bits_empty = TOPJ_UINT32(8) * (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps)).Fdx * (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps)).Fdy
	l_size_pixel = (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps * (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps)).Fprec
	l_sot_remove = TOPJ_FLOAT32(Xopj_stream_tell(tls, p_stream)) / TOPJ_FLOAT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw)

	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(l_cp + 120 + 20))&0x8>>3)) != 0 {
		l_tp_stride_func = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) TOPJ_FLOAT32
		}{opj_j2k_get_tp_stride}))
	} else {
		l_tp_stride_func = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) TOPJ_FLOAT32
		}{opj_j2k_get_default_stride}))
	}

	for i = TOPJ_UINT32(0); i < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth; i++ {
		for j = TOPJ_UINT32(0); j < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw; j++ {
			var l_offset TOPJ_FLOAT32 = (*struct {
				f func(*libc.TLS, uintptr) TOPJ_FLOAT32
			})(unsafe.Pointer(&struct{ uintptr }{l_tp_stride_func})).f(tls, l_tcp) / TOPJ_FLOAT32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers)

			// 4 borders of the tile rescale on the image if necessary
			l_x0 = opj_int_max(tls, TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0+j*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx),
				TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fx0))
			l_y0 = opj_int_max(tls, TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0+i*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy),
				TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fy0))
			l_x1 = opj_int_min(tls, TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0+(j+TOPJ_UINT32(1))*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx),
				TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fx1))
			l_y1 = opj_int_min(tls, TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0+(i+TOPJ_UINT32(1))*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy),
				TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fy1))

			l_rates = l_tcp + 20 /* &.rates */

			// Modification of the RATE >>
			for k = TOPJ_UINT32(0); k < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers; k++ {
				if *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) > 0.0 {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) = TOPJ_FLOAT32(TOPJ_FLOAT64(l_size_pixel)*float64(TOPJ_UINT32(l_x1-l_x0))*float64(TOPJ_UINT32(l_y1-l_y0))/
						float64(*(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates))*TOPJ_FLOAT32(l_bits_empty))) -
						l_offset
				}

				l_rates += 4
			}

			l_tcp += 5696

		}
	}

	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps

	for i = TOPJ_UINT32(0); i < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth; i++ {
		for j = TOPJ_UINT32(0); j < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw; j++ {
			l_rates = l_tcp + 20 /* &.rates */

			if *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) > 0.0 {
				*(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) -= l_sot_remove

				if *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) < 30.0 {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) = 30.0
				}
			}

			l_rates += 4

			l_last_res = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers - TOPJ_UINT32(1)

			for k = TOPJ_UINT32(1); k < l_last_res; k++ {

				if *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) > 0.0 {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) -= l_sot_remove

					if *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) < *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates - uintptr(1)*4))+10.0 {
						*(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates - uintptr(1)*4)) + 20.0
					}
				}

				l_rates += 4
			}

			if *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) > 0.0 {
				*(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) -= l_sot_remove + 2.

				if *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) < *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates - uintptr(1)*4))+10.0 {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(l_rates - uintptr(1)*4)) + 20.0
				}
			}

			l_tcp += 5696
		}
	}

	l_img_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps
	l_tile_size = TOPJ_UINT64(0)

	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps; i++ {
		l_tile_size = l_tile_size + TOPJ_UINT64(opj_uint_ceildiv(tls, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx))*
			TOPJ_UINT64(opj_uint_ceildiv(tls, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy))*
			TOPJ_UINT64((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec)

		l_img_comp += 64
	}

	// TODO: where does this magic value come from ?
	// This used to be 1.3 / 8, but with random data and very small code
	// block sizes, this is not enough. For example with
	// bin/test_tile_encoder 1 256 256 32 32 8 0 reversible_with_precinct.j2k 4 4 3 0 0 1 16 16
	// TODO revise this to take into account the overhead linked to the
	// number of packets and number of code blocks in packets
	l_tile_size = libc.Uint32FromFloat64(float64(l_tile_size) * 1.4 / float64(8))

	// Arbitrary amount to make the following work:
	// bin/test_tile_encoder 1 256 256 17 16 8 0 reversible_no_precinct.j2k 4 4 3 0 0 1
	l_tile_size = l_tile_size + TOPJ_UINT64(500)

	l_tile_size = l_tile_size + TOPJ_UINT64(opj_j2k_get_specific_header_sizes(tls, p_j2k))

	if l_tile_size > uint32(0x7fffffff)*2+1 {
		l_tile_size = uint32(0x7fffffff)*2 + 1
	}

	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_encoded_tile_size = TOPJ_UINT32(l_tile_size)
	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_encoded_tile_data = Xopj_malloc(tls, uint32((*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_encoded_tile_size))
	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_encoded_tile_data == uintptr(00) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+8772,
			libc.VaList(bp, TOPJ_UINT32(l_tile_size/TOPJ_UINT64(1024)/TOPJ_UINT64(1024))))
		return DOPJ_FALSE
	}

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_TLM != 0 {
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_tlm_sot_offsets_buffer = Xopj_malloc(tls, uint32(TOPJ_UINT32(6)*(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_total_tile_parts))
		if !(int32((*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_buffer) != 0) {
			return DOPJ_FALSE
		}

		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_tlm_sot_offsets_current = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_tlm_sot_offsets_buffer
	}

	return DOPJ_TRUE
}

var __func__114 = *(*[21]int8)(unsafe.Pointer(ts + 8839)) /* j2k.c:5263:1 */

func opj_j2k_get_end_header(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5487:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5492), uintptr(unsafe.Pointer(&__func__115)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5493), uintptr(unsafe.Pointer(&__func__115)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5494), uintptr(unsafe.Pointer(&__func__115)))
	}

	_ = p_manager

	(*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmain_head_end = Xopj_stream_tell(tls, p_stream)

	return DOPJ_TRUE
}

var __func__115 = *(*[23]int8)(unsafe.Pointer(ts + 8860)) /* j2k.c:5490:1 */

func opj_j2k_write_mct_data_group(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5503:17: */
	var i TOPJ_UINT32
	var l_mcc_record uintptr
	var l_mct_record uintptr
	var l_tcp uintptr

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5513), uintptr(unsafe.Pointer(&__func__116)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5514), uintptr(unsafe.Pointer(&__func__116)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5515), uintptr(unsafe.Pointer(&__func__116)))
	}

	if !(opj_j2k_write_cbd(tls, p_j2k, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	l_mct_record = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records

	for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records; i++ {

		if !(opj_j2k_write_mct_record(tls, p_j2k, l_mct_record, p_stream, p_manager) != 0) {
			return DOPJ_FALSE
		}

		l_mct_record += 32
	}

	l_mcc_record = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records

	for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records; i++ {

		if !(opj_j2k_write_mcc_record(tls, p_j2k, l_mcc_record, p_stream, p_manager) != 0) {
			return DOPJ_FALSE
		}

		l_mcc_record += 32
	}

	if !(opj_j2k_write_mco(tls, p_j2k, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__116 = *(*[29]int8)(unsafe.Pointer(ts + 8883)) /* j2k.c:5506:1 */

func opj_j2k_write_all_coc(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5551:17: */
	var compno TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5559), uintptr(unsafe.Pointer(&__func__117)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5560), uintptr(unsafe.Pointer(&__func__117)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5561), uintptr(unsafe.Pointer(&__func__117)))
	}

	for compno = TOPJ_UINT32(1); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; compno++ {
		// cod is first component of first tile
		if !(opj_j2k_compare_coc(tls, p_j2k, uint32(0), compno) != 0) {
			if !(opj_j2k_write_coc(tls, p_j2k, compno, p_stream, p_manager) != 0) {
				return DOPJ_FALSE
			}
		}
	}

	return DOPJ_TRUE
}

var __func__117 = *(*[22]int8)(unsafe.Pointer(ts + 8912)) /* j2k.c:5555:1 */

func opj_j2k_write_all_qcc(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5575:17: */
	var compno TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5583), uintptr(unsafe.Pointer(&__func__118)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5584), uintptr(unsafe.Pointer(&__func__118)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5585), uintptr(unsafe.Pointer(&__func__118)))
	}

	for compno = TOPJ_UINT32(1); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; compno++ {
		// qcd is first component of first tile
		if !(opj_j2k_compare_qcc(tls, p_j2k, uint32(0), compno) != 0) {
			if !(opj_j2k_write_qcc(tls, p_j2k, compno, p_stream, p_manager) != 0) {
				return DOPJ_FALSE
			}
		}
	}
	return DOPJ_TRUE
}

var __func__118 = *(*[22]int8)(unsafe.Pointer(ts + 8934)) /* j2k.c:5579:1 */

func opj_j2k_write_regions(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5598:17: */
	var compno TOPJ_UINT32
	var l_tccp uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5606), uintptr(unsafe.Pointer(&__func__119)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5607), uintptr(unsafe.Pointer(&__func__119)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5608), uintptr(unsafe.Pointer(&__func__119)))
	}

	l_tccp = (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps)).Ftccps

	for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; compno++ {
		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Froishift != 0 {

			if !(opj_j2k_write_rgn(tls, p_j2k, uint32(0), compno, (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps,
				p_stream, p_manager) != 0) {
				return DOPJ_FALSE
			}
		}

		l_tccp += 1080
	}

	return DOPJ_TRUE
}

var __func__119 = *(*[22]int8)(unsafe.Pointer(ts + 8956)) /* j2k.c:5601:1 */

func opj_j2k_write_epc(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5627:17: */
	var l_cstr_index uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5634), uintptr(unsafe.Pointer(&__func__120)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5635), uintptr(unsafe.Pointer(&__func__120)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5636), uintptr(unsafe.Pointer(&__func__120)))
	}

	_ = p_manager

	l_cstr_index = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index
	if l_cstr_index != 0 {
		(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fcodestream_size = TOPJ_UINT64(Xopj_stream_tell(tls, p_stream))
		// UniPG>>
		// The following adjustment is done to adjust the codestream size
		// if SOD is not at 0 in the buffer. Useful in case of JP2, where
		// the first bunch of bytes is not in the codestream
		*(*TOPJ_UINT64)(unsafe.Pointer(l_cstr_index + 8)) -= TOPJ_UINT64((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmain_head_start)
		// <<UniPG
	}

	return DOPJ_TRUE
}

var __func__120 = *(*[18]int8)(unsafe.Pointer(ts + 8978)) /* j2k.c:5630:1 */

func opj_j2k_read_unk(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, output_marker uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5667:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var l_unknown_marker TOPJ_UINT32 at bp, 4

	var l_marker_handler uintptr
	var l_size_unk TOPJ_UINT32 = TOPJ_UINT32(2)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5678), uintptr(unsafe.Pointer(&__func__121)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5679), uintptr(unsafe.Pointer(&__func__121)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5680), uintptr(unsafe.Pointer(&__func__121)))
	}

	Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+8996, 0)

	for {
		// Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer
		if Xopj_stream_read_data(tls, p_stream,
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
			return DOPJ_FALSE
		}

		// read 2 bytes as the new marker ID
		Xopj_read_bytes_LE(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data,
			bp, uint32(2))

		if !(*(*TOPJ_UINT32)(unsafe.Pointer(bp)) < TOPJ_UINT32(0xff00)) {

			// Get the marker handler from the marker ID
			l_marker_handler = opj_j2k_get_marker_handler(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_unknown_marker */)))

			if !((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state&(*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fstates != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+9030, 0)
				return DOPJ_FALSE
			} else {
				if (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid != TOPJ_UINT32(DJ2K_MS_UNK) {
					// Add the marker to the codestream index
					if (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid != TOPJ_UINT32(DJ2K_MS_SOT) {
						var res TOPJ_BOOL = opj_j2k_add_mhmarker(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index, uint32(DJ2K_MS_UNK),
							int32(TOPJ_UINT32(Xopj_stream_tell(tls, p_stream))-l_size_unk),
							l_size_unk)
						if res == DOPJ_FALSE {
							Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+4067, 0)
							return DOPJ_FALSE
						}
					}
					break // next marker is known and well located
				} else {
					l_size_unk = l_size_unk + TOPJ_UINT32(2)
				}
			}
		}
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(output_marker)) = (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid

	return DOPJ_TRUE
}

var __func__121 = *(*[17]int8)(unsafe.Pointer(ts + 9073)) /* j2k.c:5672:1 */

func opj_j2k_write_mct_record(tls *libc.TLS, p_j2k uintptr, p_mct_record uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5730:17: */
	var l_mct_size TOPJ_UINT32
	var l_current_data uintptr = uintptr(00)
	var l_tmp TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5740), uintptr(unsafe.Pointer(&__func__122)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5741), uintptr(unsafe.Pointer(&__func__122)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5742), uintptr(unsafe.Pointer(&__func__122)))
	}

	l_mct_size = TOPJ_UINT32(10) + (*Topj_mct_data_t)(unsafe.Pointer(p_mct_record)).Fm_data_size

	if l_mct_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_mct_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9090, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_mct_size
	}

	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_MCT),
		uint32(2)) // MCT
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_mct_size-TOPJ_UINT32(2),
		uint32(2)) // Lmct
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, uint32(0),
		uint32(2)) // Zmct
	l_current_data += uintptr(2)

	// only one marker atm
	l_tmp = (*Topj_mct_data_t)(unsafe.Pointer(p_mct_record)).Fm_index&TOPJ_UINT32(0xff) | (*Topj_mct_data_t)(unsafe.Pointer(p_mct_record)).Fm_array_type<<8 | (*Topj_mct_data_t)(unsafe.Pointer(p_mct_record)).Fm_element_type<<10

	Xopj_write_bytes_LE(tls, l_current_data, l_tmp, uint32(2))
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, uint32(0),
		uint32(2)) // Ymct
	l_current_data += uintptr(2)

	libc.Xmemcpy(tls, l_current_data, (*Topj_mct_data_t)(unsafe.Pointer(p_mct_record)).Fm_data, uint32((*Topj_mct_data_t)(unsafe.Pointer(p_mct_record)).Fm_data_size))

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_mct_size),
		p_manager) != TOPJ_SIZE_T(l_mct_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__122 = *(*[25]int8)(unsafe.Pointer(ts + 9129)) /* j2k.c:5734:1 */

// *
// Reads a MCT marker (Multiple Component Transform)
//
// @param       p_header_data   the data contained in the MCT box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the MCT marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_mct(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5804:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i TOPJ_UINT32
	var l_tcp uintptr = uintptr(00)
	// var l_tmp TOPJ_UINT32 at bp, 4

	var l_indix TOPJ_UINT32
	var l_mct_data uintptr

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(5817), uintptr(unsafe.Pointer(&__func__123)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5818), uintptr(unsafe.Pointer(&__func__123)))
	}

	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	if p_header_size < TOPJ_UINT32(2) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9154, 0)
		return DOPJ_FALSE
	}

	// first marker
	Xopj_read_bytes_LE(tls, p_header_data, bp, uint32(2)) // Zmct
	p_header_data += uintptr(2)
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+9180, 0)
		return DOPJ_TRUE
	}

	if p_header_size <= TOPJ_UINT32(6) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9154, 0)
		return DOPJ_FALSE
	}

	// Imct -> no need for other values, take the first, type is double with decorrelation x0000 1101 0000 0000
	Xopj_read_bytes_LE(tls, p_header_data, bp, uint32(2)) // Imct
	p_header_data += uintptr(2)

	l_indix = *(*TOPJ_UINT32)(unsafe.Pointer(bp)) & TOPJ_UINT32(0xff)
	l_mct_data = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records

	for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records; i++ {
		if (*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_index == l_indix {
			break
		}
		l_mct_data += 32
	}

	// NOT FOUND
	if i == (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records {
		if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records == (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mct_records {
			var new_mct_records uintptr
			*(*TOPJ_UINT32)(unsafe.Pointer(l_tcp + 5668)) += TOPJ_UINT32(DOPJ_J2K_MCT_DEFAULT_NB_RECORDS)

			new_mct_records = Xopj_realloc(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records,
				uint32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mct_records)*uint32(unsafe.Sizeof(Topj_mct_data_t{})))
			if !(new_mct_records != 0) {
				Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records)
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records = uintptr(0)
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mct_records = TOPJ_UINT32(0)
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records = TOPJ_UINT32(0)
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9240, 0)
				return DOPJ_FALSE
			}

			// Update m_mcc_records[].m_offset_array and m_decorrelation_array
			// to point to the new addresses
			if new_mct_records != (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records {
				for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records; i++ {
					var l_mcc_record uintptr = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records + uintptr(i)*32
					if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_decorrelation_array != 0 {
						(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_decorrelation_array = new_mct_records + uintptr((int32((*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_decorrelation_array)-int32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records))/32)*32
					}
					if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_offset_array != 0 {
						(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_offset_array = new_mct_records + uintptr((int32((*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_offset_array)-int32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records))/32)*32
					}
				}
			}

			(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records = new_mct_records
			l_mct_data = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records)*32
			libc.Xmemset(tls, l_mct_data, 0, uint32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mct_records-(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records)*uint32(unsafe.Sizeof(Topj_mct_data_t{})))
		}

		l_mct_data = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records)*32
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records++
	}

	if (*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data != 0 {
		Xopj_free(tls, (*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data)
		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data = uintptr(00)
		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data_size = TOPJ_UINT32(0)
	}

	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_index = l_indix
	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_array_type = *(*TOPJ_UINT32)(unsafe.Pointer(bp)) >> 8 & TOPJ_UINT32(3)
	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_element_type = *(*TOPJ_UINT32)(unsafe.Pointer(bp)) >> 10 & TOPJ_UINT32(3)

	Xopj_read_bytes_LE(tls, p_header_data, bp, uint32(2)) // Ymct
	p_header_data += uintptr(2)
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+9278, 0)
		return DOPJ_TRUE
	}

	p_header_size = p_header_size - TOPJ_UINT32(6)

	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data = Xopj_malloc(tls, uint32(p_header_size))
	if !(int32((*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9154, 0)
		return DOPJ_FALSE
	}
	libc.Xmemcpy(tls, (*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data, p_header_data, uint32(p_header_size))

	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data_size = p_header_size

	return DOPJ_TRUE
}

var __func__123 = *(*[17]int8)(unsafe.Pointer(ts + 9322)) /* j2k.c:5809:1 */

func opj_j2k_write_mcc_record(tls *libc.TLS, p_j2k uintptr, p_mcc_record uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:5937:17: */
	var i TOPJ_UINT32
	var l_mcc_size TOPJ_UINT32
	var l_current_data uintptr = uintptr(00)
	var l_nb_bytes_for_comp TOPJ_UINT32
	var l_mask TOPJ_UINT32
	var l_tmcc TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(5950), uintptr(unsafe.Pointer(&__func__124)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(5951), uintptr(unsafe.Pointer(&__func__124)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(5952), uintptr(unsafe.Pointer(&__func__124)))
	}

	if (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_nb_comps > TOPJ_UINT32(255) {
		l_nb_bytes_for_comp = TOPJ_UINT32(2)
		l_mask = TOPJ_UINT32(0x8000)
	} else {
		l_nb_bytes_for_comp = TOPJ_UINT32(1)
		l_mask = TOPJ_UINT32(0)
	}

	l_mcc_size = (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_nb_comps*TOPJ_UINT32(2)*l_nb_bytes_for_comp + TOPJ_UINT32(19)
	if l_mcc_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_mcc_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9339, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_mcc_size
	}

	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_MCC),
		uint32(2)) // MCC
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_mcc_size-TOPJ_UINT32(2),
		uint32(2)) // Lmcc
	l_current_data += uintptr(2)

	// first marker
	Xopj_write_bytes_LE(tls, l_current_data, uint32(0),
		uint32(2)) // Zmcc
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_index,
		uint32(1)) // Imcc -> no need for other values, take the first
	l_current_data++

	// only one marker atm
	Xopj_write_bytes_LE(tls, l_current_data, uint32(0),
		uint32(2)) // Ymcc
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, uint32(1),
		uint32(2)) // Qmcc -> number of collections -> 1
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, uint32(0x1),
		uint32(1)) // Xmcci type of component transformation -> array based decorrelation
	l_current_data++

	Xopj_write_bytes_LE(tls, l_current_data, (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_nb_comps|l_mask,
		uint32(2)) // Nmcci number of input components involved and size for each component offset = 8 bits
	l_current_data += uintptr(2)

	for i = TOPJ_UINT32(0); i < (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_nb_comps; i++ {
		Xopj_write_bytes_LE(tls, l_current_data, i,
			l_nb_bytes_for_comp) // Cmccij Component offset
		l_current_data += uintptr(l_nb_bytes_for_comp)
	}

	Xopj_write_bytes_LE(tls, l_current_data, (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_nb_comps|l_mask,
		uint32(2)) // Mmcci number of output components involved and size for each component offset = 8 bits
	l_current_data += uintptr(2)

	for i = TOPJ_UINT32(0); i < (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_nb_comps; i++ {
		Xopj_write_bytes_LE(tls, l_current_data, i,
			l_nb_bytes_for_comp) // Wmccij Component offset
		l_current_data += uintptr(l_nb_bytes_for_comp)
	}

	l_tmcc = libc.BoolUint32(!(TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(p_mcc_record + 24))&0x1>>0)) != 0)) & 1 << 16

	if (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_decorrelation_array != 0 {
		l_tmcc = l_tmcc | (*Topj_mct_data_t)(unsafe.Pointer((*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_decorrelation_array)).Fm_index
	}

	if (*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_offset_array != 0 {
		l_tmcc = l_tmcc | (*Topj_mct_data_t)(unsafe.Pointer((*Sopj_simple_mcc_decorrelation_data)(unsafe.Pointer(p_mcc_record)).Fm_offset_array)).Fm_index<<8
	}

	Xopj_write_bytes_LE(tls, l_current_data, l_tmcc,
		uint32(3)) // Tmcci : use MCT defined as number 1 and irreversible array based.
	l_current_data += uintptr(3)

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_mcc_size),
		p_manager) != TOPJ_SIZE_T(l_mcc_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__124 = *(*[25]int8)(unsafe.Pointer(ts + 9378)) /* j2k.c:5941:1 */

func opj_j2k_read_mcc(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:6052:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i TOPJ_UINT32
	var j TOPJ_UINT32
	// var l_tmp TOPJ_UINT32 at bp, 4

	// var l_indix TOPJ_UINT32 at bp+4, 4

	var l_tcp uintptr
	var l_mcc_record uintptr
	var l_mct_data uintptr
	// var l_nb_collections TOPJ_UINT32 at bp+8, 4

	// var l_nb_comps TOPJ_UINT32 at bp+12, 4

	var l_nb_bytes_by_comp TOPJ_UINT32
	var l_new_mcc TOPJ_BOOL = DOPJ_FALSE

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(6069), uintptr(unsafe.Pointer(&__func__125)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(6070), uintptr(unsafe.Pointer(&__func__125)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(6071), uintptr(unsafe.Pointer(&__func__125)))
	}

	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	if p_header_size < TOPJ_UINT32(2) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9403, 0)
		return DOPJ_FALSE
	}

	// first marker
	Xopj_read_bytes_LE(tls, p_header_data, bp, uint32(2)) // Zmcc
	p_header_data += uintptr(2)
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+9429, 0)
		return DOPJ_TRUE
	}

	if p_header_size < TOPJ_UINT32(7) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9403, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, bp+4,
		uint32(1)) // Imcc -> no need for other values, take the first
	p_header_data++

	l_mcc_record = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records

	for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records; i++ {
		if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_index == *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) {
			break
		}
		l_mcc_record += 32
	}

	//* NOT FOUND
	if i == (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records {
		if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records == (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mcc_records {
			var new_mcc_records uintptr
			*(*TOPJ_UINT32)(unsafe.Pointer(l_tcp + 5684)) += TOPJ_UINT32(DOPJ_J2K_MCC_DEFAULT_NB_RECORDS)

			new_mcc_records = Xopj_realloc(tls,
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records, uint32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mcc_records)*uint32(unsafe.Sizeof(Topj_simple_mcc_decorrelation_data_t{})))
			if !(new_mcc_records != 0) {
				Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records)
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records = uintptr(0)
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mcc_records = TOPJ_UINT32(0)
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records = TOPJ_UINT32(0)
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9475, 0)
				return DOPJ_FALSE
			}
			(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records = new_mcc_records
			l_mcc_record = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records)*32
			libc.Xmemset(tls, l_mcc_record, 0, uint32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mcc_records-(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records)*
				uint32(unsafe.Sizeof(Topj_simple_mcc_decorrelation_data_t{})))
		}
		l_mcc_record = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records)*32
		l_new_mcc = DOPJ_TRUE
	}
	(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_index = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_indix */))

	// only one marker atm
	Xopj_read_bytes_LE(tls, p_header_data, bp, uint32(2)) // Ymcc
	p_header_data += uintptr(2)
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+9429, 0)
		return DOPJ_TRUE
	}

	Xopj_read_bytes_LE(tls, p_header_data, bp+8,
		uint32(2)) // Qmcc -> number of collections -> 1
	p_header_data += uintptr(2)

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) > TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+9513, 0)
		return DOPJ_TRUE
	}

	p_header_size = p_header_size - TOPJ_UINT32(7)

	for i = TOPJ_UINT32(0); i < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_nb_collections */)); i++ {
		if p_header_size < TOPJ_UINT32(3) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9403, 0)
			return DOPJ_FALSE
		}

		Xopj_read_bytes_LE(tls, p_header_data, bp,
			uint32(1)) // Xmcci type of component transformation -> array based decorrelation
		p_header_data++

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(1) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+9557, 0)
			return DOPJ_TRUE
		}

		Xopj_read_bytes_LE(tls, p_header_data, bp+12, uint32(2))

		p_header_data += uintptr(2)
		p_header_size = p_header_size - TOPJ_UINT32(3)

		l_nb_bytes_by_comp = TOPJ_UINT32(1) + *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))>>15
		(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) & TOPJ_UINT32(0x7fff)

		if p_header_size < l_nb_bytes_by_comp*(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps+TOPJ_UINT32(2) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9403, 0)
			return DOPJ_FALSE
		}

		p_header_size = p_header_size - (l_nb_bytes_by_comp*(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps + TOPJ_UINT32(2))

		for j = TOPJ_UINT32(0); j < (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps; j++ {
			Xopj_read_bytes_LE(tls, p_header_data, bp,
				l_nb_bytes_by_comp) // Cmccij Component offset
			p_header_data += uintptr(l_nb_bytes_by_comp)

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != j {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,
					ts+9623, 0)
				return DOPJ_TRUE
			}
		}

		Xopj_read_bytes_LE(tls, p_header_data, bp+12, uint32(2))
		p_header_data += uintptr(2)

		l_nb_bytes_by_comp = TOPJ_UINT32(1) + *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))>>15
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_nb_comps */)) &= TOPJ_UINT32(0x7fff)

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) != (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+9677, 0)
			return DOPJ_TRUE
		}

		if p_header_size < l_nb_bytes_by_comp*(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps+TOPJ_UINT32(3) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9403, 0)
			return DOPJ_FALSE
		}

		p_header_size = p_header_size - (l_nb_bytes_by_comp*(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps + TOPJ_UINT32(3))

		for j = TOPJ_UINT32(0); j < (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps; j++ {
			Xopj_read_bytes_LE(tls, p_header_data, bp,
				l_nb_bytes_by_comp) // Wmccij Component offset
			p_header_data += uintptr(l_nb_bytes_by_comp)

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != j {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,
					ts+9623, 0)
				return DOPJ_TRUE
			}
		}

		Xopj_read_bytes_LE(tls, p_header_data, bp, uint32(3)) // Wmccij Component offset
		p_header_data += uintptr(3)

		libc.SetBitFieldPtr8Uint32(l_mcc_record+24, func() uint32 {
			if *(*TOPJ_UINT32)(unsafe.Pointer(bp))>>16&TOPJ_UINT32(1) > TOPJ_UINT32(0) {
				return uint32(0)
			}
			return uint32(1)
		}(), 0, 0x1)
		(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_decorrelation_array = uintptr(00)
		(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_offset_array = uintptr(00)

		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_indix */)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp)) & TOPJ_UINT32(0xff)
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) != TOPJ_UINT32(0) {
			l_mct_data = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records
			for j = TOPJ_UINT32(0); j < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records; j++ {
				if (*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_index == *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) {
					(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_decorrelation_array = l_mct_data
					break
				}
				l_mct_data += 32
			}

			if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_decorrelation_array == uintptr(00) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9403, 0)
				return DOPJ_FALSE
			}
		}

		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_indix */)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp)) >> 8 & TOPJ_UINT32(0xff)
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) != TOPJ_UINT32(0) {
			l_mct_data = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records
			for j = TOPJ_UINT32(0); j < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mct_records; j++ {
				if (*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_index == *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) {
					(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_offset_array = l_mct_data
					break
				}
				l_mct_data += 32
			}

			if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_offset_array == uintptr(00) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9403, 0)
				return DOPJ_FALSE
			}
		}
	}

	if p_header_size != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9403, 0)
		return DOPJ_FALSE
	}

	if l_new_mcc != 0 {
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records++
	}

	return DOPJ_TRUE
}

var __func__125 = *(*[17]int8)(unsafe.Pointer(ts + 9743)) /* j2k.c:6056:1 */

func opj_j2k_write_mco(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:6285:17: */
	var l_current_data uintptr = uintptr(00)
	var l_mco_size TOPJ_UINT32
	var l_tcp uintptr = uintptr(00)
	var l_mcc_record uintptr
	var i TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(6297), uintptr(unsafe.Pointer(&__func__126)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(6298), uintptr(unsafe.Pointer(&__func__126)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(6299), uintptr(unsafe.Pointer(&__func__126)))
	}

	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696

	l_mco_size = TOPJ_UINT32(5) + (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records
	if l_mco_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {

		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_mco_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9760, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_mco_size
	}
	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_MCO), uint32(2)) // MCO
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_mco_size-TOPJ_UINT32(2), uint32(2)) // Lmco
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records,
		uint32(1)) // Nmco : only one transform stage
	l_current_data++

	l_mcc_record = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records
	for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_mcc_records; i++ {
		Xopj_write_bytes_LE(tls, l_current_data, (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_index,
			uint32(1)) // Imco -> use the mcc indicated by 1
		l_current_data++
		l_mcc_record += 32
	}

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_mco_size),
		p_manager) != TOPJ_SIZE_T(l_mco_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__126 = *(*[18]int8)(unsafe.Pointer(ts + 9799)) /* j2k.c:6289:1 */

// *
// Reads a MCO marker (Multiple Component Transform Ordering)
//
// @param       p_header_data   the data contained in the MCO box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the MCO marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_mco(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:6356:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var l_tmp TOPJ_UINT32 at bp+4, 4

	var i TOPJ_UINT32
	// var l_nb_stages TOPJ_UINT32 at bp, 4

	var l_tcp uintptr
	var l_tccp uintptr
	var l_image uintptr

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(6369), uintptr(unsafe.Pointer(&__func__127)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(6370), uintptr(unsafe.Pointer(&__func__127)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(6371), uintptr(unsafe.Pointer(&__func__127)))
	}

	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	if p_header_size < TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9817, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, bp,
		uint32(1)) // Nmco : only one transform stage
	p_header_data++

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) > TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+9843, 0)
		return DOPJ_TRUE
	}

	if p_header_size != *(*TOPJ_UINT32)(unsafe.Pointer(bp))+TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+9817, 0)
		return DOPJ_FALSE
	}

	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps

	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps; i++ {
		(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fm_dc_level_shift = 0
		l_tccp += 1080
	}

	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix != 0 {
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix)
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix = uintptr(00)
	}

	for i = TOPJ_UINT32(0); i < *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_stages */)); i++ {
		Xopj_read_bytes_LE(tls, p_header_data, bp+4, uint32(1))
		p_header_data++

		if !(opj_j2k_add_mct(tls, l_tcp, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))) != 0) {
			return DOPJ_FALSE
		}
	}

	return DOPJ_TRUE
}

var __func__127 = *(*[17]int8)(unsafe.Pointer(ts + 9898)) /* j2k.c:6361:1 */

func opj_j2k_add_mct(tls *libc.TLS, p_tcp uintptr, p_image uintptr, p_index TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:6422:17: */
	var i TOPJ_UINT32
	var l_mcc_record uintptr
	var l_deco_array uintptr
	var l_offset_array uintptr
	var l_data_size TOPJ_UINT32
	var l_mct_size TOPJ_UINT32
	var l_offset_size TOPJ_UINT32
	var l_nb_elem TOPJ_UINT32
	var l_offset_data uintptr
	var l_current_offset_data uintptr
	var l_tccp uintptr

	// preconditions
	if p_tcp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6868, ts+3645, uint32(6434), uintptr(unsafe.Pointer(&__func__128)))
	}

	l_mcc_record = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records

	for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records; i++ {
		if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_index == p_index {
			break
		}
	}

	if i == (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records {
		//* element discarded *
		return DOPJ_TRUE
	}

	if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_nb_comps != (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps {
		//* do not support number of comps != image
		return DOPJ_TRUE
	}

	l_deco_array = (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_decorrelation_array

	if l_deco_array != 0 {
		l_data_size = sMCT_ELEMENT_SIZE[(*Topj_mct_data_t)(unsafe.Pointer(l_deco_array)).Fm_element_type] * (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps *
			(*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps
		if (*Topj_mct_data_t)(unsafe.Pointer(l_deco_array)).Fm_data_size != l_data_size {
			return DOPJ_FALSE
		}

		l_nb_elem = (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps * (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps
		l_mct_size = l_nb_elem * TOPJ_UINT32(unsafe.Sizeof(TOPJ_FLOAT32(0)))
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_decoding_matrix = Xopj_malloc(tls, uint32(l_mct_size))

		if !(int32((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_decoding_matrix) != 0) {
			return DOPJ_FALSE
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32)
		})(unsafe.Pointer(&struct{ uintptr }{j2k_mct_read_functions_to_float[(*Topj_mct_data_t)(unsafe.Pointer(l_deco_array)).Fm_element_type]})).f(tls,
			(*Topj_mct_data_t)(unsafe.Pointer(l_deco_array)).Fm_data, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_decoding_matrix, l_nb_elem)
	}

	l_offset_array = (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_record)).Fm_offset_array

	if l_offset_array != 0 {
		l_data_size = sMCT_ELEMENT_SIZE[(*Topj_mct_data_t)(unsafe.Pointer(l_offset_array)).Fm_element_type] * (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps
		if (*Topj_mct_data_t)(unsafe.Pointer(l_offset_array)).Fm_data_size != l_data_size {
			return DOPJ_FALSE
		}

		l_nb_elem = (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps
		l_offset_size = l_nb_elem * TOPJ_UINT32(unsafe.Sizeof(TOPJ_UINT32(0)))
		l_offset_data = Xopj_malloc(tls, uint32(l_offset_size))

		if !(l_offset_data != 0) {
			return DOPJ_FALSE
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32)
		})(unsafe.Pointer(&struct{ uintptr }{j2k_mct_read_functions_to_int32[(*Topj_mct_data_t)(unsafe.Pointer(l_offset_array)).Fm_element_type]})).f(tls,
			(*Topj_mct_data_t)(unsafe.Pointer(l_offset_array)).Fm_data, l_offset_data, l_nb_elem)

		l_tccp = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps
		l_current_offset_data = l_offset_data

		for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; i++ {
			(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fm_dc_level_shift = TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_current_offset_data, 4))))
			l_tccp += 1080
		}

		Xopj_free(tls, l_offset_data)
	}

	return DOPJ_TRUE
}

var __func__128 = *(*[16]int8)(unsafe.Pointer(ts + 9915)) /* j2k.c:6424:1 */

func opj_j2k_write_cbd(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:6509:17: */
	var i TOPJ_UINT32
	var l_cbd_size TOPJ_UINT32
	var l_current_data uintptr = uintptr(00)
	var l_image uintptr = uintptr(00)
	var l_comp uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(6520), uintptr(unsafe.Pointer(&__func__129)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(6521), uintptr(unsafe.Pointer(&__func__129)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(6522), uintptr(unsafe.Pointer(&__func__129)))
	}

	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	l_cbd_size = TOPJ_UINT32(6) + (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps

	if l_cbd_size > (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data_size {
		var new_header_tile_data uintptr = Xopj_realloc(tls,
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_cbd_size))
		if !(new_header_tile_data != 0) {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9931, 0)
			return DOPJ_FALSE
		}
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = new_header_tile_data
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = l_cbd_size
	}

	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data

	Xopj_write_bytes_LE(tls, l_current_data, uint32(DJ2K_MS_CBD), uint32(2)) // CBD
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, l_cbd_size-TOPJ_UINT32(2), uint32(2)) // L_CBD
	l_current_data += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_data, (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps, uint32(2)) // Ncbd
	l_current_data += uintptr(2)

	l_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps

	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps; i++ {
		Xopj_write_bytes_LE(tls, l_current_data, (*Topj_image_comp_t)(unsafe.Pointer(l_comp)).Fsgnd<<7|((*Topj_image_comp_t)(unsafe.Pointer(l_comp)).Fprec-TOPJ_UINT32(1)),
			uint32(1)) // Component bit depth
		l_current_data++

		l_comp += 64
	}

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data, uint32(l_cbd_size),
		p_manager) != TOPJ_SIZE_T(l_cbd_size) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__129 = *(*[18]int8)(unsafe.Pointer(ts + 9970)) /* j2k.c:6512:1 */

// *
// Reads a CBD marker (Component bit depth definition)
// @param       p_header_data   the data contained in the CBD box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the CBD marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_cbd(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:6578:17: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var l_nb_comp TOPJ_UINT32 at bp+16, 4

	var l_num_comp TOPJ_UINT32
	// var l_comp_def TOPJ_UINT32 at bp+20, 4

	var i TOPJ_UINT32
	var l_comp uintptr = uintptr(00)

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(6590), uintptr(unsafe.Pointer(&__func__130)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(6591), uintptr(unsafe.Pointer(&__func__130)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(6592), uintptr(unsafe.Pointer(&__func__130)))
	}

	l_num_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps

	if p_header_size != (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps+TOPJ_UINT32(2) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9988, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, bp+16,
		uint32(2)) // Ncbd
	p_header_data += uintptr(2)

	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)) != l_num_comp {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9988, 0)
		return DOPJ_FALSE
	}

	l_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fcomps
	for i = TOPJ_UINT32(0); i < l_num_comp; i++ {
		Xopj_read_bytes_LE(tls, p_header_data, bp+20,
			uint32(1)) // Component bit depth
		p_header_data++
		(*Topj_image_comp_t)(unsafe.Pointer(l_comp)).Fsgnd = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20)) >> 7 & TOPJ_UINT32(1)
		(*Topj_image_comp_t)(unsafe.Pointer(l_comp)).Fprec = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20))&TOPJ_UINT32(0x7f) + TOPJ_UINT32(1)

		if (*Topj_image_comp_t)(unsafe.Pointer(l_comp)).Fprec > TOPJ_UINT32(31) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+4927,
				libc.VaList(bp, i, (*Topj_image_comp_t)(unsafe.Pointer(l_comp)).Fprec))
			return DOPJ_FALSE
		}
		l_comp += 64
	}

	return DOPJ_TRUE
}

var __func__130 = *(*[17]int8)(unsafe.Pointer(ts + 10014)) /* j2k.c:6583:1 */

// *
// Reads a CAP marker (extended capabilities definition). Empty implementation.
// Found in HTJ2K files.
//
// @param       p_header_data   the data contained in the CAP box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the CAP marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_cap(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:6639:17: */
	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(6646), uintptr(unsafe.Pointer(&__func__131)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(6647), uintptr(unsafe.Pointer(&__func__131)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(6648), uintptr(unsafe.Pointer(&__func__131)))
	}

	_ = p_j2k
	_ = p_header_data
	_ = p_header_size
	_ = p_manager

	return DOPJ_TRUE
}

var __func__131 = *(*[17]int8)(unsafe.Pointer(ts + 10031)) /* j2k.c:6644:1 */

// *
// Reads a CPF marker (corresponding profile). Empty implementation. Found in HTJ2K files
// @param       p_header_data   the data contained in the CPF box.
// @param       p_j2k                   the jpeg2000 codec.
// @param       p_header_size   the size of the data contained in the CPF marker.
// @param       p_manager               the user event manager.
func opj_j2k_read_cpf(tls *libc.TLS, p_j2k uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:6665:17: */
	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(6672), uintptr(unsafe.Pointer(&__func__132)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(6673), uintptr(unsafe.Pointer(&__func__132)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(6674), uintptr(unsafe.Pointer(&__func__132)))
	}

	_ = p_j2k
	_ = p_header_data
	_ = p_header_size
	_ = p_manager

	return DOPJ_TRUE
}

var __func__132 = *(*[17]int8)(unsafe.Pointer(ts + 10048)) /* j2k.c:6670:1 */

// -----------------------------------------------------------------------
// J2K / JPT decoder interface
// -----------------------------------------------------------------------

func Xopj_j2k_setup_decoder(tls *libc.TLS, j2k uintptr, parameters uintptr) { /* j2k.c:6688:6: */
	if j2k != 0 && parameters != 0 {
		(*Topj_decoding_param_t)(unsafe.Pointer(j2k + 112 + 120)).Fm_layer = (*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fcp_layer
		(*Topj_decoding_param_t)(unsafe.Pointer(j2k + 112 + 120)).Fm_reduce = (*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fcp_reduce

		(*Topj_j2k_t)(unsafe.Pointer(j2k)).Fdump_state = (*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fflags & uint32(DOPJ_DPARAMETERS_DUMP_FLAG)
	}
}

func Xopj_j2k_decoder_set_strict_mode(tls *libc.TLS, j2k uintptr, strict TOPJ_BOOL) { /* j2k.c:6703:6: */
	if j2k != 0 {
		(*Topj_j2k_t)(unsafe.Pointer(j2k)).Fm_cp.Fstrict = strict
	}
}

func Xopj_j2k_set_threads(tls *libc.TLS, j2k uintptr, num_threads TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:6710:10: */
	// Currently we pass the thread-pool to the tcd, so we cannot re-set it
	// afterwards
	if Xopj_has_thread_support(tls) != 0 && (*Topj_j2k_t)(unsafe.Pointer(j2k)).Fm_tcd == uintptr(0) {
		Xopj_thread_pool_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(j2k)).Fm_tp)
		(*Topj_j2k_t)(unsafe.Pointer(j2k)).Fm_tp = uintptr(0)
		if num_threads <= TOPJ_UINT32(0x7fffffff) {
			(*Topj_j2k_t)(unsafe.Pointer(j2k)).Fm_tp = Xopj_thread_pool_create(tls, int32(num_threads))
		}
		if (*Topj_j2k_t)(unsafe.Pointer(j2k)).Fm_tp == uintptr(0) {
			(*Topj_j2k_t)(unsafe.Pointer(j2k)).Fm_tp = Xopj_thread_pool_create(tls, 0)
			return DOPJ_FALSE
		}
		return DOPJ_TRUE
	}
	return DOPJ_FALSE
}

func opj_j2k_get_default_thread_count(tls *libc.TLS) int32 { /* j2k.c:6729:12: */
	var num_threads_str uintptr = libc.Xgetenv(tls, ts+10065)
	var num_cpus int32
	var num_threads int32

	if num_threads_str == uintptr(0) || !(Xopj_has_thread_support(tls) != 0) {
		return 0
	}
	num_cpus = Xopj_get_num_cpus(tls)
	if libc.Xstrcmp(tls, num_threads_str, ts+10081) == 0 {
		return num_cpus
	}
	if num_cpus == 0 {
		num_cpus = 32
	}
	num_threads = libc.Xatoi(tls, num_threads_str)
	if num_threads < 0 {
		num_threads = 0
	} else if num_threads > 2*num_cpus {
		num_threads = 2 * num_cpus
	}
	return num_threads
}

// -----------------------------------------------------------------------
// J2K encoder interface
// -----------------------------------------------------------------------

func Xopj_j2k_create_compress(tls *libc.TLS) uintptr { /* j2k.c:6758:10: */
	var l_j2k uintptr = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_j2k_t{})))
	if !(l_j2k != 0) {
		return uintptr(0)
	}

	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_is_decoder = 0
	libc.SetBitFieldPtr8Uint32(l_j2k+112+148, TOPJ_BITFIELD(0), 1, 0x2)

	(*Topj_j2k_enc_t)(unsafe.Pointer(l_j2k + 8)).Fm_header_tile_data = Xopj_malloc(tls,
		uint32(DOPJ_J2K_DEFAULT_HEADER_SIZE))
	if !(int32((*Topj_j2k_enc_t)(unsafe.Pointer(l_j2k+8)).Fm_header_tile_data) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(0)
	}

	(*Topj_j2k_enc_t)(unsafe.Pointer(l_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(DOPJ_J2K_DEFAULT_HEADER_SIZE)

	// validation list creation
	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_validation_list = Xopj_procedure_list_create(tls)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_validation_list) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(0)
	}

	// execution list creation
	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_procedure_list = Xopj_procedure_list_create(tls)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_procedure_list) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(0)
	}

	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_tp = Xopj_thread_pool_create(tls, opj_j2k_get_default_thread_count(tls))
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_tp) != 0) {
		(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_tp = Xopj_thread_pool_create(tls, 0)
	}
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_tp) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(0)
	}

	return l_j2k
}

func opj_j2k_initialise_4K_poc(tls *libc.TLS, POC uintptr, numres int32) int32 { /* j2k.c:6805:12: */
	(*Topj_poc_t)(unsafe.Pointer(POC)).Ftile = TOPJ_UINT32(1)
	(*Topj_poc_t)(unsafe.Pointer(POC)).Fresno0 = TOPJ_UINT32(0)
	(*Topj_poc_t)(unsafe.Pointer(POC)).Fcompno0 = TOPJ_UINT32(0)
	(*Topj_poc_t)(unsafe.Pointer(POC)).Flayno1 = TOPJ_UINT32(1)
	(*Topj_poc_t)(unsafe.Pointer(POC)).Fresno1 = TOPJ_UINT32(numres - 1)
	(*Topj_poc_t)(unsafe.Pointer(POC)).Fcompno1 = TOPJ_UINT32(3)
	(*Topj_poc_t)(unsafe.Pointer(POC)).Fprg1 = OPJ_CPRL
	(*Topj_poc_t)(unsafe.Pointer(POC + 1*148)).Ftile = TOPJ_UINT32(1)
	(*Topj_poc_t)(unsafe.Pointer(POC + 1*148)).Fresno0 = TOPJ_UINT32(numres - 1)
	(*Topj_poc_t)(unsafe.Pointer(POC + 1*148)).Fcompno0 = TOPJ_UINT32(0)
	(*Topj_poc_t)(unsafe.Pointer(POC + 1*148)).Flayno1 = TOPJ_UINT32(1)
	(*Topj_poc_t)(unsafe.Pointer(POC + 1*148)).Fresno1 = TOPJ_UINT32(numres)
	(*Topj_poc_t)(unsafe.Pointer(POC + 1*148)).Fcompno1 = TOPJ_UINT32(3)
	(*Topj_poc_t)(unsafe.Pointer(POC + 1*148)).Fprg1 = OPJ_CPRL
	return 2
}

func opj_j2k_set_cinema_parameters(tls *libc.TLS, parameters uintptr, image uintptr, p_manager uintptr) { /* j2k.c:6824:13: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// Configure cinema parameters
	var i int32

	// No tiling
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftile_size_on = DOPJ_FALSE
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx = 1
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy = 1

	// One tile part for each component
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftp_flag = int8('C')
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftp_on = int8(1)

	// Tile and Image shall be at (0,0)
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tx0 = 0
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_ty0 = 0
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fimage_offset_x0 = 0
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fimage_offset_y0 = 0

	// Codeblock size= 32*32
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init = 32
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init = 32

	// Codeblock style: no mode switch enabled
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmode = 0

	// No ROI
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Froi_compno = -1

	// No subsampling
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fsubsampling_dx = 1
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fsubsampling_dy = 1

	// 9-7 transform
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Firreversible = 1

	// Number of layers
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers > 1 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+10090,
			libc.VaList(bp, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers,
				float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers-1)*4)))))
		*(*float32)(unsafe.Pointer(parameters + 4800)) = *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers-1)*4))
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers = 1
	}

	// Resolution levels
	switch int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) {
	case DOPJ_PROFILE_CINEMA_2K:
		if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution > 6 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+10263,
				libc.VaList(bp+16, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution+1))
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution = 6
		}
		break
	case DOPJ_PROFILE_CINEMA_4K:
		if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution < 2 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+10409,
				libc.VaList(bp+24, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution+1))
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution = 1
		} else if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution > 7 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+10563,
				libc.VaList(bp+32, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution+1))
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution = 7
		}
		break
	default:
		break
	}

	// Precincts
	*(*int32)(unsafe.Pointer(parameters + 48)) |= DJ2K_CP_CSTY_PRT
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution == 1 {
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec = 1
		*(*int32)(unsafe.Pointer(parameters + 5632)) = 128
		*(*int32)(unsafe.Pointer(parameters + 5764)) = 128
	} else {
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution - 1
		for i = 0; i < (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec; i++ {
			*(*int32)(unsafe.Pointer(parameters + 5632 + uintptr(i)*4)) = 256
			*(*int32)(unsafe.Pointer(parameters + 5764 + uintptr(i)*4)) = 256
		}
	}

	// The progression order shall be CPRL
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fprog_order = OPJ_CPRL

	// Progression order changes for 4K, disallowed for 2K
	if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) == DOPJ_PROFILE_CINEMA_4K {
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumpocs = TOPJ_UINT32(opj_j2k_initialise_4K_poc(tls, parameters+56,
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution))
	} else {
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumpocs = TOPJ_UINT32(0)
	}

	// Limited bit-rate
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_disto_alloc = 1
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size <= 0 {
		// No rate has been introduced, 24 fps is assumed
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size = DOPJ_CINEMA_24_CS
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+10717, 0)
	} else if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size > DOPJ_CINEMA_24_CS {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+10866, 0)
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size = DOPJ_CINEMA_24_CS
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size <= 0 {
		// No rate has been introduced, 24 fps is assumed
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size = DOPJ_CINEMA_24_COMP
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+11039, 0)
	} else if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size > DOPJ_CINEMA_24_COMP {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+11188, 0)
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size = DOPJ_CINEMA_24_COMP
	}

	*(*float32)(unsafe.Pointer(parameters + 4800)) = TOPJ_FLOAT32((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec) / TOPJ_FLOAT32(TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size)*TOPJ_UINT32(8)*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy)

}

func opj_j2k_is_cinema_compliant(tls *libc.TLS, image uintptr, rsiz TOPJ_UINT16, p_manager uintptr) TOPJ_BOOL { /* j2k.c:6972:17: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var i TOPJ_UINT32

	// Number of components
	if (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps != TOPJ_UINT32(3) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+11361,
			libc.VaList(bp, (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps))
		return DOPJ_FALSE
	}

	// Bitdepth
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
		if TOPJ_UINT32(libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fprec != TOPJ_UINT32(12)))|(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fsgnd != 0 {
			*(*[7]int8)(unsafe.Pointer(bp + 64 /* signed_str */)) = *(*[7]int8)(unsafe.Pointer(ts + 11527))
			*(*[9]int8)(unsafe.Pointer(bp + 71 /* unsigned_str */)) = *(*[9]int8)(unsafe.Pointer(ts + 11534))
			var tmp_str uintptr
			if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fsgnd != 0 {
				tmp_str = bp + 64 /* signed_str */
			} else {
				tmp_str = bp + 71 /* unsigned_str */
			}
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+11543,
				libc.VaList(bp+8, i, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fprec, tmp_str))
			return DOPJ_FALSE
		}
	}

	// Image size
	switch int32(rsiz) {
	case DOPJ_PROFILE_CINEMA_2K:
		if libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw > TOPJ_UINT32(2048))|libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh > TOPJ_UINT32(1080)) != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+11760,
				libc.VaList(bp+32, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh))
			return DOPJ_FALSE
		}
		break
	case DOPJ_PROFILE_CINEMA_4K:
		if libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw > TOPJ_UINT32(4096))|libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh > TOPJ_UINT32(2160)) != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+11931,
				libc.VaList(bp+48, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh))
			return DOPJ_FALSE
		}
		break
	default:
		break
	}

	return DOPJ_TRUE
}

func opj_j2k_get_imf_max_NL(tls *libc.TLS, parameters uintptr, image uintptr) int32 { /* j2k.c:7035:12: */
	// Decomposition levels
	var rsiz TOPJ_UINT16 = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz
	var profile TOPJ_UINT16 = TOPJ_UINT16(int32(rsiz) & 0xff00)
	var XTsiz TOPJ_UINT32
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftile_size_on != 0 {
		XTsiz = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx)
	} else {
		XTsiz = (*Topj_image_t)(unsafe.Pointer(image)).Fx1
	}
	switch int32(profile) {
	case DOPJ_PROFILE_IMF_2K:
		return 5
	case DOPJ_PROFILE_IMF_4K:
		return 6
	case DOPJ_PROFILE_IMF_8K:
		return 7
	case DOPJ_PROFILE_IMF_2K_R:
		{
			if XTsiz >= TOPJ_UINT32(2048) {
				return 5
			} else if XTsiz >= TOPJ_UINT32(1024) {
				return 4
			}
			break

		}
	case DOPJ_PROFILE_IMF_4K_R:
		{
			if XTsiz >= TOPJ_UINT32(4096) {
				return 6
			} else if XTsiz >= TOPJ_UINT32(2048) {
				return 5
			} else if XTsiz >= TOPJ_UINT32(1024) {
				return 4
			}
			break

		}
	case DOPJ_PROFILE_IMF_8K_R:
		{
			if XTsiz >= TOPJ_UINT32(8192) {
				return 7
			} else if XTsiz >= TOPJ_UINT32(4096) {
				return 6
			} else if XTsiz >= TOPJ_UINT32(2048) {
				return 5
			} else if XTsiz >= TOPJ_UINT32(1024) {
				return 4
			}
			break

		}
	default:
		break
	}
	return -1
}

func opj_j2k_set_imf_parameters(tls *libc.TLS, parameters uintptr, image uintptr, p_manager uintptr) { /* j2k.c:7086:13: */
	var rsiz TOPJ_UINT16 = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz
	var profile TOPJ_UINT16 = TOPJ_UINT16(int32(rsiz) & 0xff00)

	_ = p_manager

	// Override defaults set by opj_set_default_encoder_parameters
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init == DOPJ_COMP_PARAM_DEFAULT_CBLOCKW && (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init == DOPJ_COMP_PARAM_DEFAULT_CBLOCKH {
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init = 32
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init = 32
	}

	// One tile part for each component
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftp_flag = int8('C')
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftp_on = int8(1)

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fprog_order == OPJ_LRCP {
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fprog_order = OPJ_CPRL
	}

	if int32(profile) == DOPJ_PROFILE_IMF_2K || int32(profile) == DOPJ_PROFILE_IMF_4K || int32(profile) == DOPJ_PROFILE_IMF_8K {
		// 9-7 transform
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Firreversible = 1
	}

	// Adjust the number of resolutions if set to its defaults
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution == DOPJ_COMP_PARAM_DEFAULT_NUMRESOLUTION && (*Topj_image_t)(unsafe.Pointer(image)).Fx0 == TOPJ_UINT32(0) && (*Topj_image_t)(unsafe.Pointer(image)).Fy0 == TOPJ_UINT32(0) {
		var max_NL int32 = opj_j2k_get_imf_max_NL(tls, parameters, image)
		if max_NL >= 0 && (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution > max_NL {
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution = max_NL + 1
		}

		// Note: below is generic logic
		if !((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftile_size_on != 0) {
			for (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution > 0 {
				if (*Topj_image_t)(unsafe.Pointer(image)).Fx1 < uint32(1)<<(TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution)-1) {
					(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution--
					continue
				}
				if (*Topj_image_t)(unsafe.Pointer(image)).Fy1 < uint32(1)<<(TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution)-1) {
					(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution--
					continue
				}
				break
			}
		}
	}

	// Set defaults precincts
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcsty == 0 {
		*(*int32)(unsafe.Pointer(parameters + 48)) |= DJ2K_CP_CSTY_PRT
		if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution == 1 {
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec = 1
			*(*int32)(unsafe.Pointer(parameters + 5632)) = 128
			*(*int32)(unsafe.Pointer(parameters + 5764)) = 128
		} else {
			var i int32
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution - 1
			for i = 0; i < (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec; i++ {
				*(*int32)(unsafe.Pointer(parameters + 5632 + uintptr(i)*4)) = 256
				*(*int32)(unsafe.Pointer(parameters + 5764 + uintptr(i)*4)) = 256
			}
		}
	}
}

// Table A.53 from JPEG2000 standard
var tabMaxSubLevelFromMainLevel = [12]TOPJ_UINT16{
	TOPJ_UINT16(15), // unspecified
	TOPJ_UINT16(1),
	TOPJ_UINT16(1),
	TOPJ_UINT16(1),
	TOPJ_UINT16(2),
	TOPJ_UINT16(3),
	TOPJ_UINT16(4),
	TOPJ_UINT16(5),
	TOPJ_UINT16(6),
	TOPJ_UINT16(7),
	TOPJ_UINT16(8),
	TOPJ_UINT16(9),
} /* j2k.c:7160:25 */

func opj_j2k_is_imf_compliant(tls *libc.TLS, parameters uintptr, image uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:7175:17: */
	bp := tls.Alloc(408)
	defer tls.Free(408)

	var i TOPJ_UINT32
	var rsiz TOPJ_UINT16 = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz
	var profile TOPJ_UINT16 = TOPJ_UINT16(int32(rsiz) & 0xff00)
	var mainlevel TOPJ_UINT16 = TOPJ_UINT16(int32(rsiz) & 0xf)
	var sublevel TOPJ_UINT16 = TOPJ_UINT16(int32(rsiz) >> 4 & 0xf)
	var NL int32 = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution - 1
	var XTsiz TOPJ_UINT32
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftile_size_on != 0 {
		XTsiz = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx)
	} else {
		XTsiz = (*Topj_image_t)(unsafe.Pointer(image)).Fx1
	}
	var ret TOPJ_BOOL = DOPJ_TRUE

	// Validate mainlevel
	if int32(mainlevel) > DOPJ_IMF_MAINLEVEL_MAX {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+12096,
			libc.VaList(bp, int32(mainlevel)))
		ret = DOPJ_FALSE
	} else {
		// Validate sublevel
		if uint32(unsafe.Sizeof(tabMaxSubLevelFromMainLevel)) == uint32(DOPJ_IMF_MAINLEVEL_MAX+1)*uint32(unsafe.Sizeof(TOPJ_UINT16(0))) {
		} else {
			libc.X__assert_fail(tls, ts+12202, ts+3645, uint32(7199), uintptr(unsafe.Pointer(&__func__133)))
		}
		if int32(sublevel) > int32(tabMaxSubLevelFromMainLevel[mainlevel]) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+12310,
				libc.VaList(bp+8, int32(tabMaxSubLevelFromMainLevel[mainlevel]),
					int32(mainlevel),
					int32(sublevel)))
			ret = DOPJ_FALSE
		}
	}

	// Number of components
	if (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps > TOPJ_UINT32(3) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+12434,
			libc.VaList(bp+32, (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps))
		ret = DOPJ_FALSE
	}

	if (*Topj_image_t)(unsafe.Pointer(image)).Fx0 != TOPJ_UINT32(0) || (*Topj_image_t)(unsafe.Pointer(image)).Fy0 != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+12579,
			libc.VaList(bp+40, (*Topj_image_t)(unsafe.Pointer(image)).Fx0, libc.Bool32((*Topj_image_t)(unsafe.Pointer(image)).Fy0 != TOPJ_UINT32(0))))
		ret = DOPJ_FALSE
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tx0 != 0 || (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_ty0 != 0 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+12694,
			libc.VaList(bp+56, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tx0, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_ty0))
		ret = DOPJ_FALSE
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftile_size_on != 0 {
		if int32(profile) == DOPJ_PROFILE_IMF_2K || int32(profile) == DOPJ_PROFILE_IMF_4K || int32(profile) == DOPJ_PROFILE_IMF_8K {
			if TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx) < (*Topj_image_t)(unsafe.Pointer(image)).Fx1 || TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy) < (*Topj_image_t)(unsafe.Pointer(image)).Fy1 {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,

					ts+12808,
					libc.VaList(bp+72, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx,
						(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy,
						(*Topj_image_t)(unsafe.Pointer(image)).Fx1,
						(*Topj_image_t)(unsafe.Pointer(image)).Fy1))
				ret = DOPJ_FALSE
			}
		} else {
			if TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx) >= (*Topj_image_t)(unsafe.Pointer(image)).Fx1 && TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy) >= (*Topj_image_t)(unsafe.Pointer(image)).Fy1 {
				// ok
			} else if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx == 1024 && (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy == 1024 {
				// ok
			} else if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx == 2048 && (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy == 2048 && (int32(profile) == DOPJ_PROFILE_IMF_4K || int32(profile) == DOPJ_PROFILE_IMF_8K) {
				// ok
			} else if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx == 4096 && (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy == 4096 && int32(profile) == DOPJ_PROFILE_IMF_8K {
				// ok
			} else {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,

					ts+12964,
					libc.VaList(bp+104, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx,
						(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy))
				ret = DOPJ_FALSE
			}
		}
	}

	// Bitdepth
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
		if !((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fprec >= TOPJ_UINT32(8) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fprec <= TOPJ_UINT32(16)) || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fsgnd != 0 {
			*(*[7]int8)(unsafe.Pointer(bp + 392 /* signed_str */)) = *(*[7]int8)(unsafe.Pointer(ts + 11527))
			*(*[9]int8)(unsafe.Pointer(bp + 399 /* unsigned_str */)) = *(*[9]int8)(unsafe.Pointer(ts + 11534))
			var tmp_str uintptr
			if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fsgnd != 0 {
				tmp_str = bp + 392 /* signed_str */
			} else {
				tmp_str = bp + 399 /* unsigned_str */
			}
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+13208,
				libc.VaList(bp+120, i, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fprec, tmp_str))
			ret = DOPJ_FALSE
		}
	}

	// Sub-sampling
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
		if i == TOPJ_UINT32(0) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdx != TOPJ_UINT32(1) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+13397,
				libc.VaList(bp+144, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdx))
			ret = DOPJ_FALSE
		}
		if i == TOPJ_UINT32(1) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdx != TOPJ_UINT32(1) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdx != TOPJ_UINT32(2) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+13494,
				libc.VaList(bp+152, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdx))
			ret = DOPJ_FALSE
		}
		if i > TOPJ_UINT32(1) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdx != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i-TOPJ_UINT32(1))*64)).Fdx {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+13596,
				libc.VaList(bp+160, i+TOPJ_UINT32(1), (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdx, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i-TOPJ_UINT32(1))*64)).Fdx))
			ret = DOPJ_FALSE
		}
		if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdy != TOPJ_UINT32(1) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+13728,
				libc.VaList(bp+184, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fdy, i))
			ret = DOPJ_FALSE
		}
	}

	// Image size
	switch int32(profile) {
	case DOPJ_PROFILE_IMF_2K:
		fallthrough
	case DOPJ_PROFILE_IMF_2K_R:
		if libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw > TOPJ_UINT32(2048))|libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh > TOPJ_UINT32(1556)) != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+13841,
				libc.VaList(bp+200, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh))
			ret = DOPJ_FALSE
		}
		break
	case DOPJ_PROFILE_IMF_4K:
		fallthrough
	case DOPJ_PROFILE_IMF_4K_R:
		if libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw > TOPJ_UINT32(4096))|libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh > TOPJ_UINT32(3112)) != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+13989,
				libc.VaList(bp+216, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh))
			ret = DOPJ_FALSE
		}
		break
	case DOPJ_PROFILE_IMF_8K:
		fallthrough
	case DOPJ_PROFILE_IMF_8K_R:
		if libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw > TOPJ_UINT32(8192))|libc.Bool32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh > TOPJ_UINT32(6224)) != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+14137,
				libc.VaList(bp+232, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh))
			ret = DOPJ_FALSE
		}
		break
	default:
		if 0 != 0 {
		} else {
			libc.X__assert_fail(tls, ts+14285, ts+3645, uint32(7377), uintptr(unsafe.Pointer(&__func__133)))
		}
		return DOPJ_FALSE
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Froi_compno != -1 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+14287, 0)
		ret = DOPJ_FALSE
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init != 32 || (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init != 32 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+14420,
			libc.VaList(bp+248, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init,
				(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init))
		ret = DOPJ_FALSE
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fprog_order != OPJ_CPRL {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+14553,
			libc.VaList(bp+264, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fprog_order))
		ret = DOPJ_FALSE
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumpocs != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+14684,
			libc.VaList(bp+272, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumpocs))
		ret = DOPJ_FALSE
	}

	// Codeblock style: no mode switch enabled
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmode != 0 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+14795,
			libc.VaList(bp+280, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmode))
		ret = DOPJ_FALSE
	}

	if int32(profile) == DOPJ_PROFILE_IMF_2K || int32(profile) == DOPJ_PROFILE_IMF_4K || int32(profile) == DOPJ_PROFILE_IMF_8K {
		// Expect 9-7 transform
		if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Firreversible != 1 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+14942, 0)
			ret = DOPJ_FALSE
		}
	} else {
		// Expect 5-3 transform
		if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Firreversible != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+15089, 0)
			ret = DOPJ_FALSE
		}
	}

	// Number of layers
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers != 1 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,

			ts+15236,
			libc.VaList(bp+288, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers))
		ret = DOPJ_FALSE
	}

	// Decomposition levels
	switch int32(profile) {
	case DOPJ_PROFILE_IMF_2K:
		if !(NL >= 1 && NL <= 5) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+15358,
				libc.VaList(bp+296, NL))
			ret = DOPJ_FALSE
		}
		break
	case DOPJ_PROFILE_IMF_4K:
		if !(NL >= 1 && NL <= 6) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+15478,
				libc.VaList(bp+304, NL))
			ret = DOPJ_FALSE
		}
		break
	case DOPJ_PROFILE_IMF_8K:
		if !(NL >= 1 && NL <= 7) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+15598,
				libc.VaList(bp+312, NL))
			ret = DOPJ_FALSE
		}
		break
	case DOPJ_PROFILE_IMF_2K_R:
		{
			if XTsiz >= TOPJ_UINT32(2048) {
				if !(NL >= 1 && NL <= 5) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+15718,
						libc.VaList(bp+320, NL))
					ret = DOPJ_FALSE
				}
			} else if XTsiz >= TOPJ_UINT32(1024) {
				if !(NL >= 1 && NL <= 4) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+15858,
						libc.VaList(bp+328, NL))
					ret = DOPJ_FALSE
				}
			}
			break

		}
	case DOPJ_PROFILE_IMF_4K_R:
		{
			if XTsiz >= TOPJ_UINT32(4096) {
				if !(NL >= 1 && NL <= 6) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+16005,
						libc.VaList(bp+336, NL))
					ret = DOPJ_FALSE
				}
			} else if XTsiz >= TOPJ_UINT32(2048) {
				if !(NL >= 1 && NL <= 5) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+16145,
						libc.VaList(bp+344, NL))
					ret = DOPJ_FALSE
				}
			} else if XTsiz >= TOPJ_UINT32(1024) {
				if !(NL >= 1 && NL <= 4) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+16292,
						libc.VaList(bp+352, NL))
					ret = DOPJ_FALSE
				}
			}
			break

		}
	case DOPJ_PROFILE_IMF_8K_R:
		{
			if XTsiz >= TOPJ_UINT32(8192) {
				if !(NL >= 1 && NL <= 7) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+16439,
						libc.VaList(bp+360, NL))
					ret = DOPJ_FALSE
				}
			} else if XTsiz >= TOPJ_UINT32(4096) {
				if !(NL >= 1 && NL <= 6) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+16579,
						libc.VaList(bp+368, NL))
					ret = DOPJ_FALSE
				}
			} else if XTsiz >= TOPJ_UINT32(2048) {
				if !(NL >= 1 && NL <= 5) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+16145,
						libc.VaList(bp+376, NL))
					ret = DOPJ_FALSE
				}
			} else if XTsiz >= TOPJ_UINT32(1024) {
				if !(NL >= 1 && NL <= 4) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+16292,
						libc.VaList(bp+384, NL))
					ret = DOPJ_FALSE
				}
			}
			break

		}
	default:
		break
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution == 1 {
		if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec != 1 || *(*int32)(unsafe.Pointer(parameters + 5632)) != 128 || *(*int32)(unsafe.Pointer(parameters + 5764)) != 128 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+16726, 0)
			ret = DOPJ_FALSE
		}
	} else {
		var i int32
		for i = 0; i < (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec; i++ {
			if *(*int32)(unsafe.Pointer(parameters + 5632 + uintptr(i)*4)) != 256 || *(*int32)(unsafe.Pointer(parameters + 5764 + uintptr(i)*4)) != 256 {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,

					ts+16726, 0)
				ret = DOPJ_FALSE
			}
		}
	}

	return ret
}

var __func__133 = *(*[25]int8)(unsafe.Pointer(ts + 16869)) /* j2k.c:7178:1 */

func Xopj_j2k_setup_encoder(tls *libc.TLS, p_j2k uintptr, parameters uintptr, image uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:7616:10: */
	bp := tls.Alloc(309)
	defer tls.Free(309)

	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var tileno TOPJ_UINT32
	var numpocs_tile TOPJ_UINT32
	var cp uintptr = uintptr(00)
	var cblkw TOPJ_UINT32
	var cblkh TOPJ_UINT32

	if !(p_j2k != 0) || !(parameters != 0) || !(image != 0) {
		return DOPJ_FALSE
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution <= 0 || (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution > DOPJ_J2K_MAXRLVLS {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+16894,
			libc.VaList(bp, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution, DOPJ_J2K_MAXRLVLS))
		return DOPJ_FALSE
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init < 4 || (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init > 1024 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+16950,
			libc.VaList(bp+16, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init))
		return DOPJ_FALSE
	}
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init < 4 || (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init > 1024 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+17021,
			libc.VaList(bp+24, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init))
		return DOPJ_FALSE
	}
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init*(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init > 4096 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+17096, 0)
		return DOPJ_FALSE
	}
	cblkw = TOPJ_UINT32(opj_int_floorlog2(tls, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init))
	cblkh = TOPJ_UINT32(opj_int_floorlog2(tls, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init))
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init != int32(1)<<cblkw {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+16950,
			libc.VaList(bp+32, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init))
		return DOPJ_FALSE
	}
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init != int32(1)<<cblkh {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+16950,
			libc.VaList(bp+40, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init))
		return DOPJ_FALSE
	}

	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_nb_comps = (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps

	// keep a link to cp so that we can destroy it later in j2k_destroy_compress
	cp = p_j2k + 112

	// set default values for cp
	(*Topj_cp_t)(unsafe.Pointer(cp)).Ftw = TOPJ_UINT32(1)
	(*Topj_cp_t)(unsafe.Pointer(cp)).Fth = TOPJ_UINT32(1)

	// FIXME ADE: to be removed once deprecated cp_cinema and cp_rsiz have been removed
	if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) == DOPJ_PROFILE_NONE { // consider deprecated fields only if RSIZ has not been set
		var deprecated_used TOPJ_BOOL = DOPJ_FALSE
		switch (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_cinema {
		case OPJ_CINEMA2K_24:
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_CINEMA_2K)
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size = DOPJ_CINEMA_24_CS
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size = DOPJ_CINEMA_24_COMP
			deprecated_used = DOPJ_TRUE
			break
			fallthrough
		case OPJ_CINEMA2K_48:
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_CINEMA_2K)
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size = DOPJ_CINEMA_48_CS
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size = DOPJ_CINEMA_48_COMP
			deprecated_used = DOPJ_TRUE
			break
			fallthrough
		case OPJ_CINEMA4K_24:
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_CINEMA_4K)
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size = DOPJ_CINEMA_24_CS
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size = DOPJ_CINEMA_24_COMP
			deprecated_used = DOPJ_TRUE
			break
			fallthrough
		case OPJ_OFF:
			fallthrough
		default:
			break
		}
		switch (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_rsiz {
		case OPJ_CINEMA2K:
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_CINEMA_2K)
			deprecated_used = DOPJ_TRUE
			break
			fallthrough
		case OPJ_CINEMA4K:
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_CINEMA_4K)
			deprecated_used = DOPJ_TRUE
			break
			fallthrough
		case OPJ_MCT:
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_PART2 | DOPJ_EXTENSION_MCT)
			deprecated_used = DOPJ_TRUE
			fallthrough
		case OPJ_STD_RSIZ:
			fallthrough
		default:
			break
		}
		if deprecated_used != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+17162, 0)
		}
	}

	// If no explicit layers are provided, use lossless settings
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers == 0 {
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers = 1
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_disto_alloc = 1
		*(*float32)(unsafe.Pointer(parameters + 4800)) = float32(0)
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_disto_alloc != 0 {
		// Emit warnings if tcp_rates are not decreasing
		for i = TOPJ_UINT32(1); i < TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers); i++ {
			var rate_i_corr TOPJ_FLOAT32 = *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4))
			var rate_i_m_1_corr TOPJ_FLOAT32 = *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i-TOPJ_UINT32(1))*4))
			if float64(rate_i_corr) <= 1.0 {
				rate_i_corr = 1.0
			}
			if float64(rate_i_m_1_corr) <= 1.0 {
				rate_i_m_1_corr = 1.0
			}
			if rate_i_corr >= rate_i_m_1_corr {
				if rate_i_corr != *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4)) && rate_i_m_1_corr != *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i-TOPJ_UINT32(1))*4)) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+17299,
						libc.VaList(bp+48, i, float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4))), float64(rate_i_corr),
							i-TOPJ_UINT32(1), float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i-TOPJ_UINT32(1))*4))), float64(rate_i_m_1_corr)))
				} else if rate_i_corr != *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4)) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+17401,
						libc.VaList(bp+96, i, float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4))), float64(rate_i_corr),
							i-TOPJ_UINT32(1), float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i-TOPJ_UINT32(1))*4)))))
				} else if rate_i_m_1_corr != *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i-TOPJ_UINT32(1))*4)) {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+17485,
						libc.VaList(bp+136, i, float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4))),
							i-TOPJ_UINT32(1), float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i-TOPJ_UINT32(1))*4))), float64(rate_i_m_1_corr)))
				} else {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,

						ts+17569,
						libc.VaList(bp+176, i, float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4))),
							i-TOPJ_UINT32(1), float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i-TOPJ_UINT32(1))*4)))))
				}
			}
		}
	} else if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_fixed_quality != 0 {
		// Emit warnings if tcp_distoratio are not increasing
		for i = TOPJ_UINT32(1); i < TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers); i++ {
			if *(*float32)(unsafe.Pointer(parameters + 5200 + uintptr(i)*4)) < *(*float32)(unsafe.Pointer(parameters + 5200 + uintptr(i-TOPJ_UINT32(1))*4)) && !(i == TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers)-TOPJ_UINT32(1) && *(*float32)(unsafe.Pointer(parameters + 5200 + uintptr(i)*4)) == float32(0)) {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,

					ts+17635,
					libc.VaList(bp+208, i, float64(*(*float32)(unsafe.Pointer(parameters + 5200 + uintptr(i)*4))), i-TOPJ_UINT32(1),
						float64(*(*float32)(unsafe.Pointer(parameters + 5200 + uintptr(i-TOPJ_UINT32(1))*4)))))
			}
		}
	}

	// see if max_codestream_size does limit input rate
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size <= 0 {
		if *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers-1)*4)) > float32(0) {
			var temp_size TOPJ_FLOAT32
			temp_size = TOPJ_FLOAT32(float64((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec) / (float64(*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers-1)*4))) * float64(8) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy)))
			if temp_size > float32(0x7fffffff) {
				(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size = 0x7fffffff
			} else {
				(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size = libc.Int32FromFloat64(libc.Xfloor(tls, float64(temp_size)))
			}
		} else {
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size = 0
		}
	} else {
		var temp_rate TOPJ_FLOAT32
		var cap TOPJ_BOOL = DOPJ_FALSE

		if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) >= DOPJ_PROFILE_IMF_2K && int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) <= DOPJ_PROFILE_IMF_8K_R|0x009b && (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size > 0 && (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers == 1 && *(*float32)(unsafe.Pointer(parameters + 4800)) == float32(0) {
			*(*float32)(unsafe.Pointer(parameters + 4800)) = TOPJ_FLOAT32((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec) / TOPJ_FLOAT32(TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size)*TOPJ_UINT32(8)*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx*(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy)
		}

		temp_rate = TOPJ_FLOAT32(float64((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fw) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fh) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec) / (float64((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_cs_size) * float64(8) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx) * float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy)))
		for i = TOPJ_UINT32(0); i < TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers); i++ {
			if *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4)) < temp_rate {
				*(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(i)*4)) = temp_rate
				cap = DOPJ_TRUE
			}
		}
		if cap != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+17712, 0)
		}
	}

	if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) <= DOPJ_PROFILE_CINEMA_S4K || int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) >= DOPJ_PROFILE_IMF_2K && int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) <= DOPJ_PROFILE_IMF_8K_R|0x009b {
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_TLM = DOPJ_TRUE
	}

	// Manage profiles and applications and set RSIZ
	// set cinema parameters if required
	if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) <= DOPJ_PROFILE_CINEMA_S4K {
		if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) == DOPJ_PROFILE_CINEMA_S2K ||
			int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) == DOPJ_PROFILE_CINEMA_S4K {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+17804, 0)
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_NONE)
		} else {
			opj_j2k_set_cinema_parameters(tls, parameters, image, p_manager)
			if !(opj_j2k_is_cinema_compliant(tls, image, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz, p_manager) != 0) {
				(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_NONE)
			}
		}
	} else if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) == DOPJ_PROFILE_CINEMA_LTS {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+17866, 0)
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_NONE)
	} else if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) >= DOPJ_PROFILE_BC_SINGLE && int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) <= DOPJ_PROFILE_BC_MULTI_R|0x000b {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+17921, 0)
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_NONE)
	} else if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) >= DOPJ_PROFILE_IMF_2K && int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) <= DOPJ_PROFILE_IMF_8K_R|0x009b {
		opj_j2k_set_imf_parameters(tls, parameters, image, p_manager)
		if !(opj_j2k_is_imf_compliant(tls, parameters, image, p_manager) != 0) {
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_NONE)
		}
	} else if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz)&DOPJ_PROFILE_PART2 != 0 {
		if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) == DOPJ_PROFILE_PART2|DOPJ_EXTENSION_NONE {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+17969, 0)
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_NONE)
		} else if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz) != DOPJ_PROFILE_PART2|DOPJ_EXTENSION_MCT {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+18057, 0)
			(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_NONE)
		}
	}

	//
	//     copy user encoding parameters
	//
	(*Topj_encoding_param_t)(unsafe.Pointer(cp + 120)).Fm_max_comp_size = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size)
	(*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz
	libc.SetBitFieldPtr8Uint32(cp+120+20, TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_disto_alloc)&1, 0, 0x1)
	libc.SetBitFieldPtr8Uint32(cp+120+20, TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_fixed_alloc)&1, 1, 0x2)
	libc.SetBitFieldPtr8Uint32(cp+120+20, TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_fixed_quality)&1, 2, 0x4)

	// mod fixed_quality
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_fixed_alloc != 0 && (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_matrice != 0 {
		var array_size Tsize_t = Tsize_t((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers) * Tsize_t((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution) * Tsize_t(3) * Tsize_t(unsafe.Sizeof(TOPJ_INT32(0)))
		(*Topj_encoding_param_t)(unsafe.Pointer(cp + 120)).Fm_matrice = Xopj_malloc(tls, array_size)
		if !(int32((*Topj_encoding_param_t)(unsafe.Pointer(cp+120)).Fm_matrice) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+18116, 0)
			return DOPJ_FALSE
		}
		libc.Xmemcpy(tls, (*Topj_encoding_param_t)(unsafe.Pointer(cp+120)).Fm_matrice, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_matrice,
			array_size)
	}

	// tiles
	(*Topj_cp_t)(unsafe.Pointer(cp)).Ftdx = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdx)
	(*Topj_cp_t)(unsafe.Pointer(cp)).Ftdy = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tdy)

	// tile offset
	(*Topj_cp_t)(unsafe.Pointer(cp)).Ftx0 = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_tx0)
	(*Topj_cp_t)(unsafe.Pointer(cp)).Fty0 = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_ty0)

	// comment string
	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_comment != 0 {
		(*Topj_cp_t)(unsafe.Pointer(cp)).Fcomment = Xopj_malloc(tls, libc.Xstrlen(tls, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_comment)+1)
		if !(int32((*Topj_cp_t)(unsafe.Pointer(cp)).Fcomment) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+18188, 0)
			return DOPJ_FALSE
		}
		libc.Xstrcpy(tls, (*Topj_cp_t)(unsafe.Pointer(cp)).Fcomment, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_comment)
	} else {
		// Create default comment for codestream
		*(*[29]int8)(unsafe.Pointer(bp + 280 /* comment */)) = *(*[29]int8)(unsafe.Pointer(ts + 18242))
		var clen Tsize_t = libc.Xstrlen(tls, bp+280)
		var version uintptr = Xopj_version(tls)

		// UniPG>>
		(*Topj_cp_t)(unsafe.Pointer(cp)).Fcomment = Xopj_malloc(tls, clen+libc.Xstrlen(tls, version)+Tsize_t(1))
		if !(int32((*Topj_cp_t)(unsafe.Pointer(cp)).Fcomment) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+18271, 0)
			return DOPJ_FALSE
		}
		libc.Xsprintf(tls, (*Topj_cp_t)(unsafe.Pointer(cp)).Fcomment, ts+18317, libc.VaList(bp+240, bp+280, version))
		// <<UniPG
	}

	//
	//     calculate other encoding parameters
	//

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftile_size_on != 0 {
		if (*Topj_cp_t)(unsafe.Pointer(cp)).Ftdx == TOPJ_UINT32(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+18322, 0)
			return DOPJ_FALSE
		}
		if (*Topj_cp_t)(unsafe.Pointer(cp)).Ftdy == TOPJ_UINT32(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+18342, 0)
			return DOPJ_FALSE
		}
		(*Topj_cp_t)(unsafe.Pointer(cp)).Ftw = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(image)).Fx1-(*Topj_cp_t)(unsafe.Pointer(cp)).Ftx0),
			TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(cp)).Ftdx)))
		(*Topj_cp_t)(unsafe.Pointer(cp)).Fth = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(image)).Fy1-(*Topj_cp_t)(unsafe.Pointer(cp)).Fty0),
			TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(cp)).Ftdy)))
		// Check that the number of tiles is valid
		if (*Topj_cp_t)(unsafe.Pointer(cp)).Ftw > TOPJ_UINT32(65535)/(*Topj_cp_t)(unsafe.Pointer(cp)).Fth {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+5060,
				libc.VaList(bp+256, (*Topj_cp_t)(unsafe.Pointer(cp)).Ftw, (*Topj_cp_t)(unsafe.Pointer(cp)).Fth))
			return DOPJ_FALSE
		}
	} else {
		(*Topj_cp_t)(unsafe.Pointer(cp)).Ftdx = (*Topj_image_t)(unsafe.Pointer(image)).Fx1 - (*Topj_cp_t)(unsafe.Pointer(cp)).Ftx0
		(*Topj_cp_t)(unsafe.Pointer(cp)).Ftdy = (*Topj_image_t)(unsafe.Pointer(image)).Fy1 - (*Topj_cp_t)(unsafe.Pointer(cp)).Fty0
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftp_on != 0 {
		(*Topj_encoding_param_t)(unsafe.Pointer(cp + 120)).Fm_tp_flag = TOPJ_BYTE((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftp_flag)
		libc.SetBitFieldPtr8Uint32(cp+120+20, TOPJ_BITFIELD(1), 3, 0x8)
	}

	// initialize the multiple tiles
	// ----------------------------
	(*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps = Xopj_calloc(tls, uint32((*Topj_cp_t)(unsafe.Pointer(cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(cp)).Fth), uint32(unsafe.Sizeof(Topj_tcp_t{})))
	if !(int32((*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+18363, 0)
		return DOPJ_FALSE
	}

	for tileno = TOPJ_UINT32(0); tileno < (*Topj_cp_t)(unsafe.Pointer(cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(cp)).Fth; tileno++ {
		var tcp uintptr = (*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps + uintptr(tileno)*5696
		(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fnumlayers = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers)

		for j = TOPJ_UINT32(0); j < (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fnumlayers; j++ {
			if int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) <= DOPJ_PROFILE_CINEMA_S4K || int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) >= DOPJ_PROFILE_IMF_2K && int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) <= DOPJ_PROFILE_IMF_8K_R|0x009b {
				if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(cp + 120 + 20))&0x4>>2)) != 0 {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(tcp + 5200 + uintptr(j)*4)) = *(*float32)(unsafe.Pointer(parameters + 5200 + uintptr(j)*4))
				}
				*(*TOPJ_FLOAT32)(unsafe.Pointer(tcp + 20 + uintptr(j)*4)) = *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(j)*4))
			} else {
				if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(cp + 120 + 20))&0x4>>2)) != 0 { // add fixed_quality
					*(*TOPJ_FLOAT32)(unsafe.Pointer(tcp + 5200 + uintptr(j)*4)) = *(*float32)(unsafe.Pointer(parameters + 5200 + uintptr(j)*4))
				} else {
					*(*TOPJ_FLOAT32)(unsafe.Pointer(tcp + 20 + uintptr(j)*4)) = *(*float32)(unsafe.Pointer(parameters + 4800 + uintptr(j)*4))
				}
			}
			if !(int32(*(*uint8)(unsafe.Pointer(cp + 120 + 20))&0x4>>2) != 0) && float64(*(*TOPJ_FLOAT32)(unsafe.Pointer(tcp + 20 + uintptr(j)*4))) <= 1.0 {
				*(*TOPJ_FLOAT32)(unsafe.Pointer(tcp + 20 + uintptr(j)*4)) = 0.0 // force lossless
			}
		}

		(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fcsty = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcsty)
		(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fprg = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fprog_order
		(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fmct = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_mct)

		numpocs_tile = TOPJ_UINT32(0)
		libc.SetBitFieldPtr8Uint32(tcp+5688, TOPJ_BITFIELD(0), 2, 0x4)

		if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumpocs != 0 {
			// initialisation of POC
			for i = TOPJ_UINT32(0); i < (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumpocs; i++ {
				if tileno+TOPJ_UINT32(1) == (*Topj_poc_t)(unsafe.Pointer(parameters+56+uintptr(i)*148)).Ftile {
					var tcp_poc uintptr = tcp + 424 + uintptr(numpocs_tile)*148

					if (*Topj_poc_t)(unsafe.Pointer(parameters+56+uintptr(numpocs_tile)*148)).Fcompno0 >= (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps {
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+18417, libc.VaList(bp+272, i))
						return DOPJ_FALSE
					}

					(*Topj_poc_t)(unsafe.Pointer(tcp_poc)).Fresno0 = (*Topj_poc_t)(unsafe.Pointer(parameters + 56 + uintptr(numpocs_tile)*148)).Fresno0
					(*Topj_poc_t)(unsafe.Pointer(tcp_poc)).Fcompno0 = (*Topj_poc_t)(unsafe.Pointer(parameters + 56 + uintptr(numpocs_tile)*148)).Fcompno0
					(*Topj_poc_t)(unsafe.Pointer(tcp_poc)).Flayno1 = (*Topj_poc_t)(unsafe.Pointer(parameters + 56 + uintptr(numpocs_tile)*148)).Flayno1
					(*Topj_poc_t)(unsafe.Pointer(tcp_poc)).Fresno1 = (*Topj_poc_t)(unsafe.Pointer(parameters + 56 + uintptr(numpocs_tile)*148)).Fresno1
					(*Topj_poc_t)(unsafe.Pointer(tcp_poc)).Fcompno1 = opj_uint_min(tls, (*Topj_poc_t)(unsafe.Pointer(parameters+56+uintptr(numpocs_tile)*148)).Fcompno1,
						(*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps)
					(*Topj_poc_t)(unsafe.Pointer(tcp_poc)).Fprg1 = (*Topj_poc_t)(unsafe.Pointer(parameters + 56 + uintptr(numpocs_tile)*148)).Fprg1
					(*Topj_poc_t)(unsafe.Pointer(tcp_poc)).Ftile = (*Topj_poc_t)(unsafe.Pointer(parameters + 56 + uintptr(numpocs_tile)*148)).Ftile

					numpocs_tile++
				}
			}

			if numpocs_tile != 0 {

				// TODO MSD use the return value
				opj_j2k_check_poc_val(tls, parameters+56, tileno, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumpocs,
					TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution), (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps,
					TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers), p_manager)

				libc.SetBitFieldPtr8Uint32(tcp+5688, TOPJ_BITFIELD(1), 2, 0x4)
				(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fnumpocs = numpocs_tile - TOPJ_UINT32(1)
			}
		} else {
			(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fnumpocs = TOPJ_UINT32(0)
		}

		(*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps = Xopj_calloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps), uint32(unsafe.Sizeof(Topj_tccp_t{})))
		if !(int32((*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+18445, 0)
			return DOPJ_FALSE
		}
		if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data != 0 {

			var lMctSize TOPJ_UINT32 = (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps * (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps * TOPJ_UINT32(unsafe.Sizeof(TOPJ_FLOAT32(0)))
			var lTmpBuf uintptr = Xopj_malloc(tls, uint32(lMctSize))
			var l_dc_shift uintptr = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data + uintptr(lMctSize)

			if !(lTmpBuf != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+18509, 0)
				return DOPJ_FALSE
			}

			(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fmct = TOPJ_UINT32(2)
			(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fm_mct_coding_matrix = Xopj_malloc(tls, uint32(lMctSize))
			if !(int32((*Topj_tcp_t)(unsafe.Pointer(tcp)).Fm_mct_coding_matrix) != 0) {
				Xopj_free(tls, lTmpBuf)
				lTmpBuf = uintptr(0)
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+18552, 0)
				return DOPJ_FALSE
			}
			libc.Xmemcpy(tls, (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fm_mct_coding_matrix, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data, uint32(lMctSize))
			libc.Xmemcpy(tls, lTmpBuf, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data, uint32(lMctSize))

			(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fm_mct_decoding_matrix = Xopj_malloc(tls, uint32(lMctSize))
			if !(int32((*Topj_tcp_t)(unsafe.Pointer(tcp)).Fm_mct_decoding_matrix) != 0) {
				Xopj_free(tls, lTmpBuf)
				lTmpBuf = uintptr(0)
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+18610, 0)
				return DOPJ_FALSE
			}
			if Xopj_matrix_inversion_f(tls, lTmpBuf, (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fm_mct_decoding_matrix,
				(*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps) == DOPJ_FALSE {
				Xopj_free(tls, lTmpBuf)
				lTmpBuf = uintptr(0)
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+18670, 0)
				return DOPJ_FALSE
			}

			(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fmct_norms = Xopj_malloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps)*uint32(unsafe.Sizeof(TOPJ_FLOAT64(0))))
			if !(int32((*Topj_tcp_t)(unsafe.Pointer(tcp)).Fmct_norms) != 0) {
				Xopj_free(tls, lTmpBuf)
				lTmpBuf = uintptr(0)
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+18718, 0)
				return DOPJ_FALSE
			}
			Xopj_calculate_norms(tls, (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fmct_norms, (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps,
				(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fm_mct_decoding_matrix)
			Xopj_free(tls, lTmpBuf)

			for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
				var tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps + uintptr(i)*1080
				(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fm_dc_level_shift = *(*TOPJ_INT32)(unsafe.Pointer(l_dc_shift + uintptr(i)*4))
			}

			if Xopj_j2k_setup_mct_encoding(tls, tcp, image) == DOPJ_FALSE {
				// free will be handled by opj_j2k_destroy
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+18768, 0)
				return DOPJ_FALSE
			}
		} else {
			if (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fmct == TOPJ_UINT32(1) && (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps >= TOPJ_UINT32(3) { // RGB->YCC MCT is enabled
				if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdx || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdx != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdx || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+1*64)).Fdy || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fdy != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+2*64)).Fdy {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,
						ts+18802, 0)
					(*Topj_tcp_t)(unsafe.Pointer(tcp)).Fmct = TOPJ_UINT32(0)
				}
			}
			for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
				var tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps + uintptr(i)*1080
				var l_comp uintptr = (*Topj_image_t)(unsafe.Pointer(image)).Fcomps + uintptr(i)*64

				if !(int32((*Topj_image_comp_t)(unsafe.Pointer(l_comp)).Fsgnd) != 0) {
					(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fm_dc_level_shift = int32(1) << ((*Topj_image_comp_t)(unsafe.Pointer(l_comp)).Fprec - TOPJ_UINT32(1))
				}
			}
		}

		for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
			var tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps + uintptr(i)*1080

			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fcsty = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcsty & 0x01) // 0 => one precinct || 1 => custom precinct
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumresolutions = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution)
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fcblkw = TOPJ_UINT32(opj_int_floorlog2(tls, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init))
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fcblkh = TOPJ_UINT32(opj_int_floorlog2(tls, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init))
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fcblksty = TOPJ_UINT32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmode)
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fqmfbid = func() uint32 {
				if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Firreversible != 0 {
					return uint32(0)
				}
				return uint32(1)
			}()
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fqntsty = func() uint32 {
				if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Firreversible != 0 {
					return uint32(DJ2K_CCP_QNTSTY_SEQNT)
				}
				return uint32(DJ2K_CCP_QNTSTY_NOQNT)
			}()
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumgbits = TOPJ_UINT32(2)

			if TOPJ_INT32(i) == (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Froi_compno {
				(*Topj_tccp_t)(unsafe.Pointer(tccp)).Froishift = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Froi_shift
			} else {
				(*Topj_tccp_t)(unsafe.Pointer(tccp)).Froishift = 0
			}

			if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcsty&DJ2K_CCP_CSTY_PRT != 0 {
				var p TOPJ_INT32 = 0
				var it_res TOPJ_INT32
				if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumresolutions > TOPJ_UINT32(0) {
				} else {
					libc.X__assert_fail(tls, ts+18873, ts+3645, uint32(8236), uintptr(unsafe.Pointer(&__func__134)))
				}
				for it_res = TOPJ_INT32((*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumresolutions) - 1; it_res >= 0; it_res-- {
					if p < (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec {

						if *(*int32)(unsafe.Pointer(parameters + 5632 + uintptr(p)*4)) < 1 {
							*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 812 + uintptr(it_res)*4)) = TOPJ_UINT32(1)
						} else {
							*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 812 + uintptr(it_res)*4)) = TOPJ_UINT32(opj_int_floorlog2(tls, *(*int32)(unsafe.Pointer(parameters + 5632 + uintptr(p)*4))))
						}

						if *(*int32)(unsafe.Pointer(parameters + 5764 + uintptr(p)*4)) < 1 {
							*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 944 + uintptr(it_res)*4)) = TOPJ_UINT32(1)
						} else {
							*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 944 + uintptr(it_res)*4)) = TOPJ_UINT32(opj_int_floorlog2(tls, *(*int32)(unsafe.Pointer(parameters + 5764 + uintptr(p)*4))))
						}

					} else {
						var res_spec TOPJ_INT32 = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fres_spec
						var size_prcw TOPJ_INT32 = 0
						var size_prch TOPJ_INT32 = 0

						if res_spec > 0 {
						} else {
							libc.X__assert_fail(tls, ts+18898, ts+3645, uint32(8257), uintptr(unsafe.Pointer(&__func__134)))
						} // issue 189
						size_prcw = *(*int32)(unsafe.Pointer(parameters + 5632 + uintptr(res_spec-1)*4)) >> (p - (res_spec - 1))
						size_prch = *(*int32)(unsafe.Pointer(parameters + 5764 + uintptr(res_spec-1)*4)) >> (p - (res_spec - 1))

						if size_prcw < 1 {
							*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 812 + uintptr(it_res)*4)) = TOPJ_UINT32(1)
						} else {
							*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 812 + uintptr(it_res)*4)) = TOPJ_UINT32(opj_int_floorlog2(tls, size_prcw))
						}

						if size_prch < 1 {
							*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 944 + uintptr(it_res)*4)) = TOPJ_UINT32(1)
						} else {
							*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 944 + uintptr(it_res)*4)) = TOPJ_UINT32(opj_int_floorlog2(tls, size_prch))
						}
					}
					p++
					//printf("\nsize precinct for level %d : %d,%d\n", it_res,tccp->prcw[it_res], tccp->prch[it_res]);
				} //end for
			} else {
				for j = TOPJ_UINT32(0); j < (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumresolutions; j++ {
					*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 812 + uintptr(j)*4)) = TOPJ_UINT32(15)
					*(*TOPJ_UINT32)(unsafe.Pointer(tccp + 944 + uintptr(j)*4)) = TOPJ_UINT32(15)
				}
			}

			Xopj_dwt_calc_explicit_stepsizes(tls, tccp, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fprec)
		}
	}

	if (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data != 0 {
		Xopj_free(tls, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data)
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data = uintptr(00)
	}
	return DOPJ_TRUE
}

var __func__134 = *(*[22]int8)(unsafe.Pointer(ts + 18911)) /* j2k.c:7620:1 */

func opj_j2k_add_mhmarker(tls *libc.TLS, cstr_index uintptr, type1 TOPJ_UINT32, pos TOPJ_OFF_T, len TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:8295:17: */
	if cstr_index != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+18933, ts+3645, uint32(8298), uintptr(unsafe.Pointer(&__func__135)))
	}

	// expand the list?
	if (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarknum+TOPJ_UINT32(1) > (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmaxmarknum {
		var new_marker uintptr
		(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmaxmarknum = libc.Uint32FromFloat32(float32(100) + TOPJ_FLOAT32((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmaxmarknum))
		new_marker = Xopj_realloc(tls, (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker,
			uint32((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmaxmarknum)*uint32(unsafe.Sizeof(Topj_marker_info_t{})))
		if !(new_marker != 0) {
			Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker)
			(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker = uintptr(0)
			(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmaxmarknum = TOPJ_UINT32(0)
			(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarknum = TOPJ_UINT32(0)
			// opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add mh marker\n");
			return DOPJ_FALSE
		}
		(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker = new_marker
	}

	// add the marker
	(*Topj_marker_info_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker + uintptr((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarknum)*12)).Ftype = TOPJ_UINT16(type1)
	(*Topj_marker_info_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker + uintptr((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarknum)*12)).Fpos = TOPJ_OFF_T(TOPJ_INT32(pos))
	(*Topj_marker_info_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker + uintptr((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarknum)*12)).Flen = TOPJ_INT32(len)
	(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarknum++
	return DOPJ_TRUE
}

var __func__135 = *(*[21]int8)(unsafe.Pointer(ts + 18950)) /* j2k.c:8297:1 */

func opj_j2k_add_tlmarker(tls *libc.TLS, tileno TOPJ_UINT32, cstr_index uintptr, type1 TOPJ_UINT32, pos TOPJ_OFF_T, len TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:8326:17: */
	if cstr_index != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+18933, ts+3645, uint32(8330), uintptr(unsafe.Pointer(&__func__136)))
	}
	if (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+18971, ts+3645, uint32(8331), uintptr(unsafe.Pointer(&__func__136)))
	}

	// expand the list?
	if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarknum+TOPJ_UINT32(1) > (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmaxmarknum {
		var new_marker uintptr
		(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index + uintptr(tileno)*56)).Fmaxmarknum = libc.Uint32FromFloat32(float32(100) + TOPJ_FLOAT32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmaxmarknum))
		new_marker = Xopj_realloc(tls,
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarker,
			uint32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmaxmarknum)*uint32(unsafe.Sizeof(Topj_marker_info_t{})))
		if !(new_marker != 0) {
			Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarker)
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index + uintptr(tileno)*56)).Fmarker = uintptr(0)
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index + uintptr(tileno)*56)).Fmaxmarknum = TOPJ_UINT32(0)
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index + uintptr(tileno)*56)).Fmarknum = TOPJ_UINT32(0)
			// opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add tl marker\n");
			return DOPJ_FALSE
		}
		(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index + uintptr(tileno)*56)).Fmarker = new_marker
	}

	// add the marker
	(*Topj_marker_info_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarker + uintptr((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarknum)*12)).Ftype = TOPJ_UINT16(type1)
	(*Topj_marker_info_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarker + uintptr((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarknum)*12)).Fpos = TOPJ_OFF_T(TOPJ_INT32(pos))
	(*Topj_marker_info_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarker + uintptr((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarknum)*12)).Flen = TOPJ_INT32(len)
	(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Fmarknum++

	if type1 == TOPJ_UINT32(DJ2K_MS_SOT) {
		var l_current_tile_part TOPJ_UINT32 = (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index + uintptr(tileno)*56)).Fcurrent_tpsno

		if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Ftp_index != 0 {
			(*Topj_tp_index_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(tileno)*56)).Ftp_index + uintptr(l_current_tile_part)*12)).Fstart_pos = pos
		}

	}
	return DOPJ_TRUE
}

var __func__136 = *(*[21]int8)(unsafe.Pointer(ts + 19000)) /* j2k.c:8329:1 */

// -----------------------------------------------------------------------
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------

func Xopj_j2k_end_decompress(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8379:10: */
	_ = p_j2k
	_ = p_stream
	_ = p_manager
	return DOPJ_TRUE
}

func Xopj_j2k_read_header(tls *libc.TLS, p_stream uintptr, p_j2k uintptr, p_image uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8390:10: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(8396), uintptr(unsafe.Pointer(&__func__137)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(8397), uintptr(unsafe.Pointer(&__func__137)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(8398), uintptr(unsafe.Pointer(&__func__137)))
	}

	// create an empty image header
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = Xopj_image_create0(tls)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image) != 0) {
		return DOPJ_FALSE
	}

	// customization of the validation
	if !(opj_j2k_setup_decoding_validation(tls, p_j2k, p_manager) != 0) {
		Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = uintptr(0)
		return DOPJ_FALSE
	}

	// validation of the parameters codec
	if !(opj_j2k_exec(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list, p_stream, p_manager) != 0) {
		Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = uintptr(0)
		return DOPJ_FALSE
	}

	// customization of the encoding
	if !(opj_j2k_setup_header_reading(tls, p_j2k, p_manager) != 0) {
		Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = uintptr(0)
		return DOPJ_FALSE
	}

	// read header
	if !(opj_j2k_exec(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list, p_stream, p_manager) != 0) {
		Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = uintptr(0)
		return DOPJ_FALSE
	}

	*(*uintptr)(unsafe.Pointer(p_image)) = Xopj_image_create0(tls)
	if !(int32(*(*uintptr)(unsafe.Pointer(p_image))) != 0) {
		return DOPJ_FALSE
	}

	// Copy codestream image information to the output image
	Xopj_copy_image_header(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image, *(*uintptr)(unsafe.Pointer(p_image)))

	//Allocate and initialize some elements of codestrem index
	if !(opj_j2k_allocate_tile_element_cstr_index(tls, p_j2k) != 0) {
		Xopj_image_destroy(tls, *(*uintptr)(unsafe.Pointer(p_image)))
		*(*uintptr)(unsafe.Pointer(p_image)) = uintptr(0)
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__137 = *(*[20]int8)(unsafe.Pointer(ts + 19021)) /* j2k.c:8394:1 */

func opj_j2k_setup_header_reading(tls *libc.TLS, p_j2k uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8452:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(8456), uintptr(unsafe.Pointer(&__func__138)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(8457), uintptr(unsafe.Pointer(&__func__138)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_read_header_procedure})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	// DEVELOPER CORNER, add your custom procedures
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_copy_default_tcp_and_create_tcd})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__138 = *(*[29]int8)(unsafe.Pointer(ts + 19041)) /* j2k.c:8454:1 */

func opj_j2k_setup_decoding_validation(tls *libc.TLS, p_j2k uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8473:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(8477), uintptr(unsafe.Pointer(&__func__139)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(8478), uintptr(unsafe.Pointer(&__func__139)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_build_decoder})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_decoding_validation})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	// DEVELOPER CORNER, add your custom validation procedure
	return DOPJ_TRUE
}

var __func__139 = *(*[34]int8)(unsafe.Pointer(ts + 19070)) /* j2k.c:8475:1 */

func opj_j2k_mct_validation(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8493:17: */
	var l_is_valid TOPJ_BOOL = DOPJ_TRUE
	var i TOPJ_UINT32
	var j TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(8501), uintptr(unsafe.Pointer(&__func__140)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(8502), uintptr(unsafe.Pointer(&__func__140)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(8503), uintptr(unsafe.Pointer(&__func__140)))
	}

	_ = p_stream
	_ = p_manager

	if int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Frsiz)&0x8200 == 0x8200 {
		var l_nb_tiles TOPJ_UINT32 = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw
		var l_tcp uintptr = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps

		for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
			if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fmct == TOPJ_UINT32(2) {
				var l_tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps
				l_is_valid = l_is_valid & libc.Bool32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_coding_matrix != uintptr(00))

				for j = TOPJ_UINT32(0); j < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; j++ {
					l_is_valid = l_is_valid & libc.BoolInt32(!((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid&TOPJ_UINT32(1) != 0))
					l_tccp += 1080
				}
			}
			l_tcp += 5696
		}
	}

	return l_is_valid
}

var __func__140 = *(*[23]int8)(unsafe.Pointer(ts + 19104)) /* j2k.c:8496:1 */

func Xopj_j2k_setup_mct_encoding(tls *libc.TLS, p_tcp uintptr, p_image uintptr) TOPJ_BOOL { /* j2k.c:8529:10: */
	var i TOPJ_UINT32
	var l_indix TOPJ_UINT32 = TOPJ_UINT32(1)
	var l_mct_deco_data uintptr = uintptr(00)
	var l_mct_offset_data uintptr = uintptr(00)
	var l_mcc_data uintptr
	var l_mct_size TOPJ_UINT32
	var l_nb_elem TOPJ_UINT32
	var l_data uintptr
	var l_current_data uintptr
	var l_tccp uintptr

	// preconditions
	if p_tcp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6868, ts+3645, uint32(8540), uintptr(unsafe.Pointer(&__func__141)))
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fmct != TOPJ_UINT32(2) {
		return DOPJ_TRUE
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_decoding_matrix != 0 {
		if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records == (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mct_records {
			var new_mct_records uintptr
			*(*TOPJ_UINT32)(unsafe.Pointer(p_tcp + 5668)) += TOPJ_UINT32(DOPJ_J2K_MCT_DEFAULT_NB_RECORDS)

			new_mct_records = Xopj_realloc(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records,
				uint32((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mct_records)*uint32(unsafe.Sizeof(Topj_mct_data_t{})))
			if !(new_mct_records != 0) {
				Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records)
				(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records = uintptr(0)
				(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mct_records = TOPJ_UINT32(0)
				(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records = TOPJ_UINT32(0)
				// opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to setup mct encoding\n");
				return DOPJ_FALSE
			}
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records = new_mct_records
			l_mct_deco_data = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records)*32

			libc.Xmemset(tls, l_mct_deco_data, 0,
				uint32((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mct_records-(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records)*uint32(unsafe.Sizeof(Topj_mct_data_t{})))
		}
		l_mct_deco_data = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records)*32

		if (*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_data != 0 {
			Xopj_free(tls, (*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_data)
			(*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_data = uintptr(00)
		}

		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_index = libc.PostIncUint32(&l_indix, 1)
		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_array_type = MCT_TYPE_DECORRELATION
		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_element_type = MCT_TYPE_FLOAT
		l_nb_elem = (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps * (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps
		l_mct_size = l_nb_elem * sMCT_ELEMENT_SIZE[(*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_element_type]
		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_data = Xopj_malloc(tls, uint32(l_mct_size))

		if !(int32((*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_data) != 0) {
			return DOPJ_FALSE
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32)
		})(unsafe.Pointer(&struct{ uintptr }{j2k_mct_write_functions_from_float[(*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_element_type]})).f(tls,
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_decoding_matrix, (*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_data, l_nb_elem)

		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_deco_data)).Fm_data_size = l_mct_size
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records++
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records == (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mct_records {
		var new_mct_records uintptr
		*(*TOPJ_UINT32)(unsafe.Pointer(p_tcp + 5668)) += TOPJ_UINT32(DOPJ_J2K_MCT_DEFAULT_NB_RECORDS)
		new_mct_records = Xopj_realloc(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records,
			uint32((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mct_records)*uint32(unsafe.Sizeof(Topj_mct_data_t{})))
		if !(new_mct_records != 0) {
			Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records)
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records = uintptr(0)
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mct_records = TOPJ_UINT32(0)
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records = TOPJ_UINT32(0)
			// opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to setup mct encoding\n");
			return DOPJ_FALSE
		}
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records = new_mct_records
		l_mct_offset_data = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records)*32

		libc.Xmemset(tls, l_mct_offset_data, 0,
			uint32((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mct_records-(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records)*uint32(unsafe.Sizeof(Topj_mct_data_t{})))

		if l_mct_deco_data != 0 {
			l_mct_deco_data = l_mct_offset_data - uintptr(1)*32
		}
	}

	l_mct_offset_data = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records)*32

	if (*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data != 0 {
		Xopj_free(tls, (*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data)
		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data = uintptr(00)
	}

	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_index = libc.PostIncUint32(&l_indix, 1)
	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_array_type = MCT_TYPE_OFFSET
	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_element_type = MCT_TYPE_FLOAT
	l_nb_elem = (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps
	l_mct_size = l_nb_elem * sMCT_ELEMENT_SIZE[(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_element_type]
	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data = Xopj_malloc(tls, uint32(l_mct_size))

	if !(int32((*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data) != 0) {
		return DOPJ_FALSE
	}

	l_data = Xopj_malloc(tls, uint32(l_nb_elem)*uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))))
	if !(l_data != 0) {
		Xopj_free(tls, (*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data)
		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data = uintptr(00)
		return DOPJ_FALSE
	}

	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps
	l_current_data = l_data

	for i = TOPJ_UINT32(0); i < l_nb_elem; i++ {
		*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&l_current_data, 4))) = TOPJ_FLOAT32((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fm_dc_level_shift)
		l_tccp += 1080
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32)
	})(unsafe.Pointer(&struct{ uintptr }{j2k_mct_write_functions_from_float[(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_element_type]})).f(tls, l_data,
		(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data, l_nb_elem)

	Xopj_free(tls, l_data)

	(*Topj_mct_data_t)(unsafe.Pointer(l_mct_offset_data)).Fm_data_size = l_mct_size

	(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records++

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records == (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mcc_records {
		var new_mcc_records uintptr
		*(*TOPJ_UINT32)(unsafe.Pointer(p_tcp + 5684)) += TOPJ_UINT32(DOPJ_J2K_MCT_DEFAULT_NB_RECORDS)
		new_mcc_records = Xopj_realloc(tls,
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records, uint32((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mcc_records)*uint32(unsafe.Sizeof(Topj_simple_mcc_decorrelation_data_t{})))
		if !(new_mcc_records != 0) {
			Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records)
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records = uintptr(0)
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mcc_records = TOPJ_UINT32(0)
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records = TOPJ_UINT32(0)
			// opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to setup mct encoding\n");
			return DOPJ_FALSE
		}
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records = new_mcc_records
		l_mcc_data = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records)*32
		libc.Xmemset(tls, l_mcc_data, 0, uint32((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mcc_records-(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records)*uint32(unsafe.Sizeof(Topj_simple_mcc_decorrelation_data_t{})))

	}

	l_mcc_data = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records + uintptr((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records)*32
	(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_data)).Fm_decorrelation_array = l_mct_deco_data
	libc.SetBitFieldPtr8Uint32(l_mcc_data+24, TOPJ_BITFIELD(1), 0, 0x1)
	(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_data)).Fm_nb_comps = (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps
	(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_data)).Fm_index = libc.PostIncUint32(&l_indix, 1)
	(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_mcc_data)).Fm_offset_array = l_mct_offset_data
	(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records++

	return DOPJ_TRUE
}

var __func__141 = *(*[27]int8)(unsafe.Pointer(ts + 19127)) /* j2k.c:8530:1 */

func opj_j2k_build_decoder(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8692:17: */
	// add here initialization of cp
	//        copy paste of setup_decoder
	_ = p_j2k
	_ = p_stream
	_ = p_manager
	return DOPJ_TRUE
}

func opj_j2k_build_encoder(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8704:17: */
	// add here initialization of cp
	//        copy paste of setup_encoder
	_ = p_j2k
	_ = p_stream
	_ = p_manager
	return DOPJ_TRUE
}

func opj_j2k_encoding_validation(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8716:17: */
	var l_is_valid TOPJ_BOOL = DOPJ_TRUE

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(8723), uintptr(unsafe.Pointer(&__func__142)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(8724), uintptr(unsafe.Pointer(&__func__142)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(8725), uintptr(unsafe.Pointer(&__func__142)))
	}

	_ = p_stream

	// STATE checking
	// make sure the state is at 0
	l_is_valid = l_is_valid & libc.Bool32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_NONE)

	// POINTER validation
	// make sure a p_j2k codec is present
	l_is_valid = l_is_valid & libc.Bool32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list != uintptr(00))
	// make sure a validation list is present
	l_is_valid = l_is_valid & libc.Bool32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list != uintptr(00))

	// ISO 15444-1:2004 states between 1 & 33 (0 -> 32)
	// 33 (32) would always fail the check below (if a cast to 64bits was done)
	// FIXME Shall we change OPJ_J2K_MAXRLVLS to 32 ?
	if (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps)).Ftccps)).Fnumresolutions <= TOPJ_UINT32(0) || (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps)).Ftccps)).Fnumresolutions > TOPJ_UINT32(32) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+19154, 0)
		return DOPJ_FALSE
	}

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdx < TOPJ_UINT32(int32(1)<<((*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps)).Ftccps)).Fnumresolutions-1)) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+19154, 0)
		return DOPJ_FALSE
	}

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdy < TOPJ_UINT32(int32(1)<<((*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps)).Ftccps)).Fnumresolutions-1)) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+19154, 0)
		return DOPJ_FALSE
	}

	// PARAMETER VALIDATION
	return l_is_valid
}

var __func__142 = *(*[28]int8)(unsafe.Pointer(ts + 19224)) /* j2k.c:8719:1 */

func opj_j2k_decoding_validation(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8767:17: */
	var l_is_valid TOPJ_BOOL = DOPJ_TRUE

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(8775), uintptr(unsafe.Pointer(&__func__143)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(8776), uintptr(unsafe.Pointer(&__func__143)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(8777), uintptr(unsafe.Pointer(&__func__143)))
	}

	_ = p_stream
	_ = p_manager

	// STATE checking
	// make sure the state is at 0
	l_is_valid = l_is_valid & libc.Bool32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == TOPJ_UINT32(0x0000))

	// POINTER validation
	// make sure a p_j2k codec is present
	// make sure a procedure list is present
	l_is_valid = l_is_valid & libc.Bool32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list != uintptr(00))
	// make sure a validation list is present
	l_is_valid = l_is_valid & libc.Bool32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list != uintptr(00))

	// PARAMETER VALIDATION
	return l_is_valid
}

var __func__143 = *(*[28]int8)(unsafe.Pointer(ts + 19252)) /* j2k.c:8771:1 */

func opj_j2k_read_header_procedure(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8800:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var l_current_marker TOPJ_UINT32 at bp+8, 4

	// var l_marker_size TOPJ_UINT32 at bp+12, 4

	var l_marker_handler uintptr = uintptr(00)
	var l_has_siz TOPJ_BOOL = 0
	var l_has_cod TOPJ_BOOL = 0
	var l_has_qcd TOPJ_BOOL = 0

	// preconditions
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(8812), uintptr(unsafe.Pointer(&__func__144)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(8813), uintptr(unsafe.Pointer(&__func__144)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(8814), uintptr(unsafe.Pointer(&__func__144)))
	}

	//  We enter in the main header
	(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_MHSOC

	// Try to read the SOC marker, the codestream must begin with SOC marker
	if !(opj_j2k_read_soc(tls, p_j2k, p_stream, p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19280, 0)
		return DOPJ_FALSE
	}

	// Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer
	if Xopj_stream_read_data(tls, p_stream,
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
		return DOPJ_FALSE
	}

	// Read 2 bytes as the new marker ID
	Xopj_read_bytes_LE(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data,
		bp+8, uint32(2))

	// Try to read until the SOT is detected
	for *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) != TOPJ_UINT32(DJ2K_MS_SOT) {

		// Check if the current marker ID is valid
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) < TOPJ_UINT32(0xff00) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+19304, libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_current_marker */))))
			return DOPJ_FALSE
		}

		// Get the marker handler from the marker ID
		l_marker_handler = opj_j2k_get_marker_handler(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_current_marker */)))

		// Manage case where marker is unknown
		if (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid == TOPJ_UINT32(DJ2K_MS_UNK) {
			if !(opj_j2k_read_unk(tls, p_j2k, p_stream, bp+8, p_manager) != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+19355, 0)
				return DOPJ_FALSE
			}

			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) == TOPJ_UINT32(DJ2K_MS_SOT) {
				break // SOT marker is detected main header is completely read
			} else { // Get the marker handler from the marker ID
				l_marker_handler = opj_j2k_get_marker_handler(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_current_marker */)))
			}
		}

		if (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid == TOPJ_UINT32(DJ2K_MS_SIZ) {
			// Mark required SIZ marker as found
			l_has_siz = 1
		}
		if (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid == TOPJ_UINT32(DJ2K_MS_COD) {
			// Mark required COD marker as found
			l_has_cod = 1
		}
		if (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid == TOPJ_UINT32(DJ2K_MS_QCD) {
			// Mark required QCD marker as found
			l_has_qcd = 1
		}

		// Check if the marker is known and if it is the right place to find it
		if !((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state&(*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fstates != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+9030, 0)
			return DOPJ_FALSE
		}

		// Try to read 2 bytes (the marker size) from stream and copy them into the buffer
		if Xopj_stream_read_data(tls, p_stream,
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
			return DOPJ_FALSE
		}

		// read 2 bytes as the marker size
		Xopj_read_bytes_LE(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, bp+12,
			uint32(2))
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) < TOPJ_UINT32(2) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19410, 0)
			return DOPJ_FALSE
		}
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_marker_size */)) -= TOPJ_UINT32(2) // Subtract the size of the marker ID already read

		// Check if the marker size is compatible with the header data size
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) > (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data_size {
			var new_header_data uintptr = Xopj_realloc(tls,
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_marker_size */))))
			if !(new_header_data != 0) {
				Xopj_free(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data)
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data = uintptr(0)
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data_size = TOPJ_UINT32(0)
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19431, 0)
				return DOPJ_FALSE
			}
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data = new_header_data
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data_size = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_marker_size */))
		}

		// Try to read the rest of the marker segment from stream and copy them into the buffer
		if Xopj_stream_read_data(tls, p_stream,
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))),
			p_manager) != TOPJ_SIZE_T(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
			return DOPJ_FALSE
		}

		// Read the marker segment with the correct marker handler
		if !((*struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fhandler})).f(tls, p_j2k,
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)), p_manager) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+19465, 0)
			return DOPJ_FALSE
		}

		// Add the marker to the codestream index
		if DOPJ_FALSE == opj_j2k_add_mhmarker(tls,
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index,
			(*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid,
			int32(TOPJ_UINT32(Xopj_stream_tell(tls, p_stream))-*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))-TOPJ_UINT32(4)),
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))+TOPJ_UINT32(4)) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+4067, 0)
			return DOPJ_FALSE
		}

		// Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer
		if Xopj_stream_read_data(tls, p_stream,
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
			return DOPJ_FALSE
		}

		// read 2 bytes as the new marker ID
		Xopj_read_bytes_LE(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data,
			bp+8, uint32(2))
	}

	if l_has_siz == 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+19524, 0)
		return DOPJ_FALSE
	}
	if l_has_cod == 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+19570, 0)
		return DOPJ_FALSE
	}
	if l_has_qcd == 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+19616, 0)
		return DOPJ_FALSE
	}

	if !(opj_j2k_merge_ppm(tls, p_j2k+112, p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19662, 0)
		return DOPJ_FALSE
	}

	Xopj_event_msg(tls, p_manager, DEVT_INFO, ts+19688, 0)

	// Position of the last element if the main header
	(*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmain_head_end = TOPJ_OFF_T(TOPJ_UINT32(Xopj_stream_tell(tls, p_stream)) - TOPJ_UINT32(2))

	// Next step: read a tile-part header
	(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_TPHSOT

	return DOPJ_TRUE
}

var __func__144 = *(*[30]int8)(unsafe.Pointer(ts + 19729)) /* j2k.c:8803:1 */

func opj_j2k_exec(tls *libc.TLS, p_j2k uintptr, p_procedure_list uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:8985:17: */
	var l_procedure uintptr = uintptr(00)
	var l_result TOPJ_BOOL = DOPJ_TRUE
	var l_nb_proc TOPJ_UINT32
	var i TOPJ_UINT32

	// preconditions
	if p_procedure_list != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+19759, ts+3645, uint32(8996), uintptr(unsafe.Pointer(&__func__145)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(8997), uintptr(unsafe.Pointer(&__func__145)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(8998), uintptr(unsafe.Pointer(&__func__145)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(8999), uintptr(unsafe.Pointer(&__func__145)))
	}

	l_nb_proc = Xopj_procedure_list_get_nb_procedures(tls, p_procedure_list)
	l_procedure = Xopj_procedure_list_get_first_procedure(tls, p_procedure_list)

	for i = TOPJ_UINT32(0); i < l_nb_proc; i++ {
		l_result = libc.Bool32(l_result != 0 && (*(**struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{l_procedure}))).f(tls, p_j2k, p_stream, p_manager) != 0)
		l_procedure += 8
	}

	// and clear the procedure list at the end.
	Xopj_procedure_list_clear(tls, p_procedure_list)
	return l_result
}

var __func__145 = *(*[13]int8)(unsafe.Pointer(ts + 19782)) /* j2k.c:8989:1 */

// FIXME DOC
func opj_j2k_copy_default_tcp_and_create_tcd(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:9016:17: */
	var l_tcp uintptr = uintptr(00)
	var l_default_tcp uintptr = uintptr(00)
	var l_nb_tiles TOPJ_UINT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var l_current_tccp uintptr = uintptr(00)
	var l_tccp_size TOPJ_UINT32
	var l_mct_size TOPJ_UINT32
	var l_image uintptr
	var l_mcc_records_size TOPJ_UINT32
	var l_mct_records_size TOPJ_UINT32
	var l_src_mct_rec uintptr
	var l_dest_mct_rec uintptr
	var l_src_mcc_rec uintptr
	var l_dest_mcc_rec uintptr
	var l_offset TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(9035), uintptr(unsafe.Pointer(&__func__146)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(9036), uintptr(unsafe.Pointer(&__func__146)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(9037), uintptr(unsafe.Pointer(&__func__146)))
	}

	_ = p_stream

	l_image = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	l_nb_tiles = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw
	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps
	l_tccp_size = (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps * TOPJ_UINT32(unsafe.Sizeof(Topj_tccp_t{}))
	l_default_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	l_mct_size = (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps * (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps * TOPJ_UINT32(unsafe.Sizeof(TOPJ_FLOAT32(0)))

	// For each tile
	for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
		// keep the tile-compo coding parameters pointer of the current tile coding parameters
		l_current_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps
		//Copy default coding parameters into the current tile coding parameters
		libc.Xmemcpy(tls, l_tcp, l_default_tcp, uint32(unsafe.Sizeof(Topj_tcp_t{})))
		// Initialize some values of the current tile coding parameters
		libc.SetBitFieldPtr8Uint32(l_tcp+5688, TOPJ_BITFIELD(0), 0, 0x1)
		libc.SetBitFieldPtr8Uint32(l_tcp+5688, TOPJ_BITFIELD(0), 1, 0x2)
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fppt_data = uintptr(00)
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_current_tile_part_number = -1
		// Remove memory not owned by this tile in case of early error return.
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix = uintptr(00)
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mct_records = TOPJ_UINT32(0)
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records = uintptr(00)
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mcc_records = TOPJ_UINT32(0)
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records = uintptr(00)
		// Reconnect the tile-compo coding parameters pointer to the current tile coding parameters
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps = l_current_tccp

		// Get the mct_decoding_matrix of the dflt_tile_cp and copy them into the current tile cp
		if (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_mct_decoding_matrix != 0 {
			(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix = Xopj_malloc(tls, uint32(l_mct_size))
			if !(int32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix) != 0) {
				return DOPJ_FALSE
			}
			libc.Xmemcpy(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix, (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_mct_decoding_matrix,
				uint32(l_mct_size))
		}

		// Get the mct_record of the dflt_tile_cp and copy them into the current tile cp
		l_mct_records_size = (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_nb_max_mct_records * TOPJ_UINT32(unsafe.Sizeof(Topj_mct_data_t{}))
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records = Xopj_malloc(tls, uint32(l_mct_records_size))
		if !(int32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records) != 0) {
			return DOPJ_FALSE
		}
		libc.Xmemcpy(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records, (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_mct_records, uint32(l_mct_records_size))

		// Copy the mct record data from dflt_tile_cp to the current tile
		l_src_mct_rec = (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_mct_records
		l_dest_mct_rec = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records

		for j = TOPJ_UINT32(0); j < (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_nb_mct_records; j++ {

			if (*Topj_mct_data_t)(unsafe.Pointer(l_src_mct_rec)).Fm_data != 0 {

				(*Topj_mct_data_t)(unsafe.Pointer(l_dest_mct_rec)).Fm_data = Xopj_malloc(tls, uint32((*Topj_mct_data_t)(unsafe.Pointer(l_src_mct_rec)).Fm_data_size))
				if !(int32((*Topj_mct_data_t)(unsafe.Pointer(l_dest_mct_rec)).Fm_data) != 0) {
					return DOPJ_FALSE
				}
				libc.Xmemcpy(tls, (*Topj_mct_data_t)(unsafe.Pointer(l_dest_mct_rec)).Fm_data, (*Topj_mct_data_t)(unsafe.Pointer(l_src_mct_rec)).Fm_data,
					uint32((*Topj_mct_data_t)(unsafe.Pointer(l_src_mct_rec)).Fm_data_size))
			}

			l_src_mct_rec += 32
			l_dest_mct_rec += 32
			// Update with each pass to free exactly what has been allocated on early return.
			*(*TOPJ_UINT32)(unsafe.Pointer(l_tcp + 5668)) += TOPJ_UINT32(1)
		}

		// Get the mcc_record of the dflt_tile_cp and copy them into the current tile cp
		l_mcc_records_size = (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_nb_max_mcc_records * TOPJ_UINT32(unsafe.Sizeof(Topj_simple_mcc_decorrelation_data_t{}))
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records = Xopj_malloc(tls,
			uint32(l_mcc_records_size))
		if !(int32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records) != 0) {
			return DOPJ_FALSE
		}
		libc.Xmemcpy(tls, (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records, (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_mcc_records, uint32(l_mcc_records_size))
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_nb_max_mcc_records = (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_nb_max_mcc_records

		// Copy the mcc record data from dflt_tile_cp to the current tile
		l_src_mcc_rec = (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_mcc_records
		l_dest_mcc_rec = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mcc_records

		for j = TOPJ_UINT32(0); j < (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_nb_max_mcc_records; j++ {

			if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_src_mcc_rec)).Fm_decorrelation_array != 0 {
				l_offset = TOPJ_UINT32((int32((*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_src_mcc_rec)).Fm_decorrelation_array) - int32((*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_mct_records)) / 32)
				(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_dest_mcc_rec)).Fm_decorrelation_array = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records + uintptr(l_offset)*32
			}

			if (*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_src_mcc_rec)).Fm_offset_array != 0 {
				l_offset = TOPJ_UINT32((int32((*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_src_mcc_rec)).Fm_offset_array) - int32((*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Fm_mct_records)) / 32)
				(*Topj_simple_mcc_decorrelation_data_t)(unsafe.Pointer(l_dest_mcc_rec)).Fm_offset_array = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_records + uintptr(l_offset)*32
			}

			l_src_mcc_rec += 32
			l_dest_mcc_rec += 32
		}

		// Copy all the dflt_tile_compo_cp to the current tile cp
		libc.Xmemcpy(tls, l_current_tccp, (*Topj_tcp_t)(unsafe.Pointer(l_default_tcp)).Ftccps, uint32(l_tccp_size))

		// Move to next tile cp
		l_tcp += 5696
	}

	// Create the current tile decoder
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd = Xopj_tcd_create(tls, DOPJ_TRUE)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd) != 0) {
		return DOPJ_FALSE
	}

	if !(Xopj_tcd_init(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, l_image, p_j2k+112, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tp) != 0) {
		Xopj_tcd_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd = uintptr(00)
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19795, 0)
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__146 = *(*[40]int8)(unsafe.Pointer(ts + 19829)) /* j2k.c:9020:1 */

func opj_j2k_get_marker_handler(tls *libc.TLS, p_id TOPJ_UINT32) uintptr { /* j2k.c:9166:46: */
	var e uintptr
	for e = uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)); (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(e)).Fid != TOPJ_UINT32(0); e += 16 {
		if (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(e)).Fid == p_id {
			break // we find a handler corresponding to the marker ID
		}
	}
	return e
}

func Xopj_j2k_destroy(tls *libc.TLS, p_j2k uintptr) { /* j2k.c:9178:6: */
	if p_j2k == uintptr(00) {
		return
	}

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_is_decoder != 0 {

		if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp != uintptr(00) {
			opj_j2k_tcp_destroy(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp)
			Xopj_free(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp)
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp = uintptr(00)
		}

		if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data != uintptr(00) {
			Xopj_free(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data)
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data = uintptr(00)
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data_size = TOPJ_UINT32(0)
		}

		Xopj_free(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_comps_indices_to_decode)
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_comps_indices_to_decode = uintptr(00)
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_numcomps_to_decode = TOPJ_UINT32(0)

	} else {

		if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_encoded_tile_data != 0 {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_encoded_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_encoded_tile_data = uintptr(00)
		}

		if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_buffer != 0 {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_buffer)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_tlm_sot_offsets_buffer = uintptr(00)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_tlm_sot_offsets_current = uintptr(00)
		}

		if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data != 0 {
			Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(00)
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)
		}
	}

	Xopj_tcd_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)

	opj_j2k_cp_destroy(tls, p_j2k+112)
	libc.Xmemset(tls, p_j2k+112, 0, uint32(unsafe.Sizeof(Topj_cp_t{})))

	Xopj_procedure_list_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list)
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list = uintptr(00)

	Xopj_procedure_list_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list)
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list = uintptr(00)

	Xj2k_destroy_cstr_index(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index = uintptr(0)

	Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = uintptr(0)

	Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image = uintptr(0)

	Xopj_thread_pool_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tp)
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tp = uintptr(0)

	Xopj_free(tls, p_j2k)
}

func Xj2k_destroy_cstr_index(tls *libc.TLS, p_cstr_ind uintptr) { /* j2k.c:9248:6: */
	if p_cstr_ind != 0 {

		if (*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Fmarker != 0 {
			Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Fmarker)
			(*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Fmarker = uintptr(0)
		}

		if (*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index != 0 {
			var it_tile TOPJ_UINT32 = TOPJ_UINT32(0)

			for it_tile = TOPJ_UINT32(0); it_tile < (*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Fnb_of_tiles; it_tile++ {

				if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index+uintptr(it_tile)*56)).Fpacket_index != 0 {
					Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index+uintptr(it_tile)*56)).Fpacket_index)
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index + uintptr(it_tile)*56)).Fpacket_index = uintptr(0)
				}

				if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index+uintptr(it_tile)*56)).Ftp_index != 0 {
					Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index+uintptr(it_tile)*56)).Ftp_index)
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index + uintptr(it_tile)*56)).Ftp_index = uintptr(0)
				}

				if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index+uintptr(it_tile)*56)).Fmarker != 0 {
					Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index+uintptr(it_tile)*56)).Fmarker)
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index + uintptr(it_tile)*56)).Fmarker = uintptr(0)

				}
			}

			Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index)
			(*Topj_codestream_index_t)(unsafe.Pointer(p_cstr_ind)).Ftile_index = uintptr(0)
		}

		Xopj_free(tls, p_cstr_ind)
	}
}

func opj_j2k_tcp_destroy(tls *libc.TLS, p_tcp uintptr) { /* j2k.c:9287:13: */
	if p_tcp == uintptr(00) {
		return
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers != uintptr(00) {
		var i TOPJ_UINT32
		for i = 0; i < (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers_count; i++ {
			if (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers+uintptr(i)*16)).Fm_data != uintptr(0) {
				Xopj_free(tls, (*Topj_ppx)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers+uintptr(i)*16)).Fm_data)
			}
		}
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers_count = 0
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_markers = uintptr(0)
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_buffer != uintptr(00) {
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_buffer)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fppt_buffer = uintptr(00)
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps != uintptr(00) {
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps = uintptr(00)
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_coding_matrix != uintptr(00) {
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_coding_matrix)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_coding_matrix = uintptr(00)
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_decoding_matrix != uintptr(00) {
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_decoding_matrix)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_decoding_matrix = uintptr(00)
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records != 0 {
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mcc_records = uintptr(00)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_max_mcc_records = TOPJ_UINT32(0)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mcc_records = TOPJ_UINT32(0)
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records != 0 {
		var l_mct_data uintptr = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records
		var i TOPJ_UINT32

		for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_nb_mct_records; i++ {
			if (*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data != 0 {
				Xopj_free(tls, (*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data)
				(*Topj_mct_data_t)(unsafe.Pointer(l_mct_data)).Fm_data = uintptr(00)
			}

			l_mct_data += 32
		}

		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_mct_records = uintptr(00)
	}

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fmct_norms != uintptr(00) {
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fmct_norms)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fmct_norms = uintptr(00)
	}

	opj_j2k_tcp_data_destroy(tls, p_tcp)

}

func opj_j2k_tcp_data_destroy(tls *libc.TLS, p_tcp uintptr) { /* j2k.c:9358:13: */
	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_data != 0 {
		Xopj_free(tls, (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_data)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_data = uintptr(0)
		(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fm_data_size = TOPJ_UINT32(0)
	}
}

func opj_j2k_cp_destroy(tls *libc.TLS, p_cp uintptr) { /* j2k.c:9367:13: */
	var l_nb_tiles TOPJ_UINT32
	var l_current_tile uintptr = uintptr(00)

	if p_cp == uintptr(00) {
		return
	}
	if (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps != uintptr(00) {
		var i TOPJ_UINT32
		l_current_tile = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps
		l_nb_tiles = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth * (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw

		for i = 0; i < l_nb_tiles; i++ {
			opj_j2k_tcp_destroy(tls, l_current_tile)
			l_current_tile += 5696
		}
		Xopj_free(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps)
		(*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps = uintptr(00)
	}
	if (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers != uintptr(00) {
		var i TOPJ_UINT32
		for i = 0; i < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers_count; i++ {
			if (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers+uintptr(i)*16)).Fm_data != uintptr(0) {
				Xopj_free(tls, (*Topj_ppx)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers+uintptr(i)*16)).Fm_data)
			}
		}
		(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers_count = 0
		Xopj_free(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers)
		(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_markers = uintptr(0)
	}
	Xopj_free(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer)
	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_buffer = uintptr(00)
	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fppm_data = uintptr(0) // ppm_data belongs to the allocated buffer pointed by ppm_buffer
	Xopj_free(tls, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fcomment)
	(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fcomment = uintptr(00)
	if !(int32(*(*uint8)(unsafe.Pointer(p_cp + 148))&0x2>>1) != 0) {
		Xopj_free(tls, (*Topj_encoding_param_t)(unsafe.Pointer(p_cp+120)).Fm_matrice)
		(*Topj_encoding_param_t)(unsafe.Pointer(p_cp + 120)).Fm_matrice = uintptr(00)
	}
}

func opj_j2k_need_nb_tile_parts_correction(tls *libc.TLS, p_stream uintptr, tile_no TOPJ_UINT32, p_correction_needed uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:9410:17: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var l_header_data [10]TOPJ_BYTE at bp, 10

	var l_stream_pos_backup TOPJ_OFF_T
	// var l_current_marker TOPJ_UINT32 at bp+12, 4

	// var l_marker_size TOPJ_UINT32 at bp+16, 4

	// var l_tile_no TOPJ_UINT32 at bp+20, 4

	// var l_tot_len TOPJ_UINT32 at bp+24, 4

	// var l_current_part TOPJ_UINT32 at bp+28, 4

	// var l_num_parts TOPJ_UINT32 at bp+32, 4

	// initialize to no correction needed
	*(*TOPJ_BOOL)(unsafe.Pointer(p_correction_needed)) = DOPJ_FALSE

	if !(Xopj_stream_has_seek(tls, p_stream) != 0) {
		// We can't do much in this case, seek is needed
		return DOPJ_TRUE
	}

	l_stream_pos_backup = Xopj_stream_tell(tls, p_stream)
	if l_stream_pos_backup == -1 {
		// let's do nothing
		return DOPJ_TRUE
	}

	for {
		// Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer
		if Xopj_stream_read_data(tls, p_stream, bp, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
			// assume all is OK
			if !(Xopj_stream_seek(tls, p_stream, l_stream_pos_backup, p_manager) != 0) {
				return DOPJ_FALSE
			}
			return DOPJ_TRUE
		}

		// Read 2 bytes from buffer as the new marker ID
		Xopj_read_bytes_LE(tls, bp, bp+12, uint32(2))

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12)) != TOPJ_UINT32(DJ2K_MS_SOT) {
			// assume all is OK
			if !(Xopj_stream_seek(tls, p_stream, l_stream_pos_backup, p_manager) != 0) {
				return DOPJ_FALSE
			}
			return DOPJ_TRUE
		}

		// Try to read 2 bytes (the marker size) from stream and copy them into the buffer
		if Xopj_stream_read_data(tls, p_stream, bp, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
			return DOPJ_FALSE
		}

		// Read 2 bytes from the buffer as the marker size
		Xopj_read_bytes_LE(tls, bp, bp+16, uint32(2))

		// Check marker size for SOT Marker
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)) != TOPJ_UINT32(10) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19869, 0)
			return DOPJ_FALSE
		}
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_marker_size */)) -= TOPJ_UINT32(2)

		if Xopj_stream_read_data(tls, p_stream, bp, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 16))),
			p_manager) != TOPJ_SIZE_T(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 16))) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
			return DOPJ_FALSE
		}

		if !(opj_j2k_get_sot_values(tls, bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16)), bp+20,
			bp+24, bp+28, bp+32, p_manager) != 0) {
			return DOPJ_FALSE
		}

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20)) == tile_no {
			// we found what we were looking for
			break
		}

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) < 14 {
			// last SOT until EOC or invalid Psot value
			// assume all is OK
			if !(Xopj_stream_seek(tls, p_stream, l_stream_pos_backup, p_manager) != 0) {
				return DOPJ_FALSE
			}
			return DOPJ_TRUE
		}
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* l_tot_len */)) -= 12
		// look for next SOT marker
		if Xopj_stream_skip(tls, p_stream, TOPJ_OFF_T(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24))),
			p_manager) != TOPJ_OFF_T(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24))) {
			// assume all is OK
			if !(Xopj_stream_seek(tls, p_stream, l_stream_pos_backup, p_manager) != 0) {
				return DOPJ_FALSE
			}
			return DOPJ_TRUE
		}
	}

	// check for correction
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28)) == *(*TOPJ_UINT32)(unsafe.Pointer(bp + 32)) {
		*(*TOPJ_BOOL)(unsafe.Pointer(p_correction_needed)) = DOPJ_TRUE
	}

	if !(Xopj_stream_seek(tls, p_stream, l_stream_pos_backup, p_manager) != 0) {
		return DOPJ_FALSE
	}
	return DOPJ_TRUE
}

func Xopj_j2k_read_tile_header(tls *libc.TLS, p_j2k uintptr, p_tile_index uintptr, p_data_size uintptr, p_tile_x0 uintptr, p_tile_y0 uintptr, p_tile_x1 uintptr, p_tile_y1 uintptr, p_nb_comps uintptr, p_go_on uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:9518:10: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 36 /* l_current_marker */)) = TOPJ_UINT32(DJ2K_MS_SOT)
	// var l_marker_size TOPJ_UINT32 at bp+32, 4

	var l_marker_handler uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(0)
	var l_nb_tiles TOPJ_UINT32 = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth

	// preconditions
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(9535), uintptr(unsafe.Pointer(&__func__147)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(9536), uintptr(unsafe.Pointer(&__func__147)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(9537), uintptr(unsafe.Pointer(&__func__147)))
	}

	// Reach the End Of Codestream ?
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_EOC {
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 36 /* l_current_marker */)) = TOPJ_UINT32(DJ2K_MS_EOC)
	} else if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state != J2K_STATE_TPHSOT {
		return DOPJ_FALSE
	}

	// Read into the codestream until reach the EOC or ! can_decode ??? FIXME
	for !(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72))&0x1>>0) != 0) && *(*TOPJ_UINT32)(unsafe.Pointer(bp + 36)) != TOPJ_UINT32(DJ2K_MS_EOC) {

		// Try to read until the Start Of Data is detected
		for *(*TOPJ_UINT32)(unsafe.Pointer(bp + 36)) != TOPJ_UINT32(DJ2K_MS_SOD) {

			if Xopj_stream_get_number_byte_left(tls, p_stream) == 0 {
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_NEOC
				break
			}

			// Try to read 2 bytes (the marker size) from stream and copy them into the buffer
			if Xopj_stream_read_data(tls, p_stream,
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
				return DOPJ_FALSE
			}

			// Read 2 bytes from the buffer as the marker size
			Xopj_read_bytes_LE(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, bp+32,
				uint32(2))

			// Check marker size (does not include marker ID but includes marker size)
			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 32)) < TOPJ_UINT32(2) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19869, 0)
				return DOPJ_FALSE
			}

			// cf. https://code.google.com/p/openjpeg/issues/detail?id=226
			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 36)) == TOPJ_UINT32(0x8080) && Xopj_stream_get_number_byte_left(tls, p_stream) == 0 {
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_NEOC
				break
			}

			// Why this condition? FIXME
			if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state&J2K_STATE_TPH != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8 + 28)) -= *(*TOPJ_UINT32)(unsafe.Pointer(bp + 32)) + TOPJ_UINT32(2)
			}
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 32 /* l_marker_size */)) -= TOPJ_UINT32(2) // Subtract the size of the marker ID already read

			// Get the marker handler from the marker ID
			l_marker_handler = opj_j2k_get_marker_handler(tls, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 36 /* l_current_marker */)))

			// Check if the marker is known and if it is the right place to find it
			if !((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state&(*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fstates != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+9030, 0)
				return DOPJ_FALSE
			}
			// FIXME manage case of unknown marker as in the main header ?

			// Check if the marker size is compatible with the header data size
			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 32)) > (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data_size {
				var new_header_data uintptr = uintptr(0)
				// If we are here, this means we consider this marker as known & we will read it
				// Check enough bytes left in stream before allocation
				if TOPJ_OFF_T(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 32))) > Xopj_stream_get_number_byte_left(tls, p_stream) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+19895, 0)
					return DOPJ_FALSE
				}
				new_header_data = Xopj_realloc(tls,
					(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 32 /* l_marker_size */))))
				if !(new_header_data != 0) {
					Xopj_free(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data)
					(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data = uintptr(0)
					(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data_size = TOPJ_UINT32(0)
					Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19431, 0)
					return DOPJ_FALSE
				}
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data = new_header_data
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_data_size = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 32 /* l_marker_size */))
			}

			// Try to read the rest of the marker segment from stream and copy them into the buffer
			if Xopj_stream_read_data(tls, p_stream,
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 32))),
				p_manager) != TOPJ_SIZE_T(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 32))) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
				return DOPJ_FALSE
			}

			if !(int32((*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fhandler) != 0) {
				// See issue #175
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19940, 0)
				return DOPJ_FALSE
			}
			// Read the marker segment with the correct marker handler
			if !((*struct {
				f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL
			})(unsafe.Pointer(&struct{ uintptr }{(*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fhandler})).f(tls, p_j2k,
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 32)), p_manager) != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+19969, libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 36 /* l_current_marker */))))
				return DOPJ_FALSE
			}

			// Add the marker to the codestream index
			if DOPJ_FALSE == opj_j2k_add_tlmarker(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
				(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index,
				(*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid,
				int32(TOPJ_UINT32(Xopj_stream_tell(tls, p_stream))-*(*TOPJ_UINT32)(unsafe.Pointer(bp + 32))-TOPJ_UINT32(4)),
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 32))+TOPJ_UINT32(4)) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+8583, 0)
				return DOPJ_FALSE
			}

			// Keep the position of the last SOT marker read
			if (*Topj_dec_memory_marker_handler_t)(unsafe.Pointer(l_marker_handler)).Fid == TOPJ_UINT32(DJ2K_MS_SOT) {
				var sot_pos TOPJ_UINT32 = TOPJ_UINT32(Xopj_stream_tell(tls, p_stream)) - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 32)) - TOPJ_UINT32(4)
				if uint32(sot_pos) > uint32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_last_sot_read_pos) {
					(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_last_sot_read_pos = TOPJ_OFF_T(sot_pos)
				}
			}

			if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72))&0x4>>2)) != 0 {
				// Skip the rest of the tile part header
				if uint32(Xopj_stream_skip(tls, p_stream, int32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length),
					p_manager)) != uint32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_sot_length) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
					return DOPJ_FALSE
				}
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 36 /* l_current_marker */)) = TOPJ_UINT32(DJ2K_MS_SOD) // Normally we reached a SOD
			} else {
				// Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer
				if Xopj_stream_read_data(tls, p_stream,
					(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
					return DOPJ_FALSE
				}
				// Read 2 bytes from the buffer as the new marker ID
				Xopj_read_bytes_LE(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data,
					bp+36, uint32(2))
			}
		}
		if Xopj_stream_get_number_byte_left(tls, p_stream) == 0 &&
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_NEOC {
			break
		}

		// If we didn't skip data before, we need to read the SOD marker
		if !(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72))&0x4>>2) != 0) {
			// Try to read the SOD marker and skip data ? FIXME
			if !(opj_j2k_read_sod(tls, p_j2k, p_stream, p_manager) != 0) {
				return DOPJ_FALSE
			}
			if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72))&0x1>>0)) != 0 && !(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72))&0x8>>3) != 0) {
				// Issue 254
				// var l_correction_needed TOPJ_BOOL at bp+40, 4

				libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(1), 3, 0x8)
				if !(opj_j2k_need_nb_tile_parts_correction(tls, p_stream,
					(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number, bp+40, p_manager) != 0) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+20016, 0)
					return DOPJ_FALSE
				}
				if *(*TOPJ_BOOL)(unsafe.Pointer(bp + 40)) != 0 {
					var l_tile_no TOPJ_UINT32

					libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(0), 0, 0x1)
					libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(1), 4, 0x10)
					// correct tiles
					for l_tile_no = 0; l_tile_no < l_nb_tiles; l_tile_no++ {
						if (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps+uintptr(l_tile_no)*5696)).Fm_nb_tile_parts != 0 {
							*(*TOPJ_UINT32)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr(l_tile_no)*5696 + 5612)) += TOPJ_UINT32(1)
						}
					}
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,
						ts+20062, 0)
				}
			}
		} else {
			// Indicate we will try to read a new tile-part header
			libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(0), 2, 0x4)
			libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(0), 0, 0x1)
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_TPHSOT
		}

		if !(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72))&0x1>>0) != 0) {
			// Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer
			if Xopj_stream_read_data(tls, p_stream,
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data, uint32(2), p_manager) != TOPJ_SIZE_T(2) {

				// Deal with likely non conformant SPOT6 files, where the last
				// row of tiles have TPsot == 0 and TNsot == 0, and missing EOC,
				// but no other tile-parts were found.
				if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number+TOPJ_UINT32(1) == l_nb_tiles {
					var l_tile_no TOPJ_UINT32
					for l_tile_no = 0; l_tile_no < l_nb_tiles; l_tile_no++ {
						if (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps+uintptr(l_tile_no)*5696)).Fm_current_tile_part_number == 0 && (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps+uintptr(l_tile_no)*5696)).Fm_nb_tile_parts == TOPJ_UINT32(0) {
							break
						}
					}
					if l_tile_no < l_nb_tiles {
						Xopj_event_msg(tls, p_manager, DEVT_INFO,

							ts+20103,
							libc.VaList(bp+8, l_tile_no))
						(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number = l_tile_no
						*(*TOPJ_UINT32)(unsafe.Pointer(bp + 36 /* l_current_marker */)) = TOPJ_UINT32(DJ2K_MS_EOC)
						(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_EOC
						break
					}
				}

				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+9012, 0)
				return DOPJ_FALSE
			}

			// Read 2 bytes from buffer as the new marker ID
			Xopj_read_bytes_LE(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_header_data,
				bp+36, uint32(2))
		}
	}

	// Current marker is the EOC marker ?
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 36)) == TOPJ_UINT32(DJ2K_MS_EOC) {
		if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state != J2K_STATE_EOC {
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number = TOPJ_UINT32(0)
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_EOC
		}
	}

	// Deal with tiles that have a single tile-part with TPsot == 0 and TNsot == 0
	if !(int32(*(*uint8)(unsafe.Pointer(p_j2k + 8 + 72))&0x1>>0) != 0) {
		l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696

		for (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number < l_nb_tiles && (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_data == uintptr(00) {
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number++
			l_tcp += 5696
		}

		if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number == l_nb_tiles {
			*(*TOPJ_BOOL)(unsafe.Pointer(p_go_on)) = DOPJ_FALSE
			return DOPJ_TRUE
		}
	}

	if !(opj_j2k_merge_ppt(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps+uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696,
		p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+20200, 0)
		return DOPJ_FALSE
	}
	//FIXME ???
	if !(Xopj_tcd_init_decode_tile(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+19795, 0)
		return DOPJ_FALSE
	}

	Xopj_event_msg(tls, p_manager, DEVT_INFO, ts+20226,
		libc.VaList(bp+16, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number+TOPJ_UINT32(1), (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw))

	*(*TOPJ_UINT32)(unsafe.Pointer(p_tile_index)) = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number
	*(*TOPJ_BOOL)(unsafe.Pointer(p_go_on)) = DOPJ_TRUE
	if p_data_size != 0 {
		// For internal use in j2k.c, we don't need this
		// This is just needed for folks using the opj_read_tile_header() / opj_decode_tile_data() combo
		*(*TOPJ_UINT32)(unsafe.Pointer(p_data_size)) = Xopj_tcd_get_decoded_tile_size(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, DOPJ_FALSE)
		if *(*TOPJ_UINT32)(unsafe.Pointer(p_data_size)) == uint32(0x7fffffff)*2+1 {
			return DOPJ_FALSE
		}
	}
	*(*TOPJ_INT32)(unsafe.Pointer(p_tile_x0)) = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Ftcd_image)).Ftiles)).Fx0
	*(*TOPJ_INT32)(unsafe.Pointer(p_tile_y0)) = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Ftcd_image)).Ftiles)).Fy0
	*(*TOPJ_INT32)(unsafe.Pointer(p_tile_x1)) = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Ftcd_image)).Ftiles)).Fx1
	*(*TOPJ_INT32)(unsafe.Pointer(p_tile_y1)) = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Ftcd_image)).Ftiles)).Fy1
	*(*TOPJ_UINT32)(unsafe.Pointer(p_nb_comps)) = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Ftcd_image)).Ftiles)).Fnumcomps

	*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8)) |= J2K_STATE_DATA

	return DOPJ_TRUE
}

var __func__147 = *(*[25]int8)(unsafe.Pointer(ts + 20265)) /* j2k.c:9527:1 */

func Xopj_j2k_decode_tile(tls *libc.TLS, p_j2k uintptr, p_tile_index TOPJ_UINT32, p_data uintptr, p_data_size TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:9827:10: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var l_current_marker TOPJ_UINT32 at bp+4, 4

	// var l_data [2]TOPJ_BYTE at bp, 2

	var l_tcp uintptr
	var l_image_for_bounds uintptr

	// preconditions
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(9840), uintptr(unsafe.Pointer(&__func__148)))
	}
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(9841), uintptr(unsafe.Pointer(&__func__148)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(9842), uintptr(unsafe.Pointer(&__func__148)))
	}

	if !((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state&J2K_STATE_DATA != 0) ||
		p_tile_index != (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number {
		return DOPJ_FALSE
	}

	l_tcp = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr(p_tile_index)*5696
	if !(int32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_data) != 0) {
		opj_j2k_tcp_destroy(tls, l_tcp)
		return DOPJ_FALSE
	}

	// When using the opj_read_tile_header / opj_decode_tile_data API
	// such as in test_tile_decoder, m_output_image is NULL, so fall back
	// to the full image dimension. This is a bit surprising that
	// opj_set_decode_area() is only used to determine intersecting tiles,
	// but full tile decoding is done
	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image != 0 {
		l_image_for_bounds = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image
	} else {
		l_image_for_bounds = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	}
	if !(Xopj_tcd_decode_tile(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd,
		(*Topj_image_t)(unsafe.Pointer(l_image_for_bounds)).Fx0,
		(*Topj_image_t)(unsafe.Pointer(l_image_for_bounds)).Fy0,
		(*Topj_image_t)(unsafe.Pointer(l_image_for_bounds)).Fx1,
		(*Topj_image_t)(unsafe.Pointer(l_image_for_bounds)).Fy1,
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_numcomps_to_decode,
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_comps_indices_to_decode,
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_data,
		(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_data_size,
		p_tile_index,
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index, p_manager) != 0) {
		opj_j2k_tcp_destroy(tls, l_tcp)
		*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8)) |= J2K_STATE_ERR
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+20290, 0)
		return DOPJ_FALSE
	}

	// p_data can be set to NULL when the call will take care of using
	// itself the TCD data. This is typically the case for whole single
	// tile decoding optimization.
	if p_data != uintptr(0) {
		if !(Xopj_tcd_update_tile_data(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, p_data, p_data_size) != 0) {
			return DOPJ_FALSE
		}

		// To avoid to destroy the tcp which can be useful when we try to decode a tile decoded before (cf j2k_random_tile_access)
		// we destroy just the data which will be re-read in read_tile_header
		//opj_j2k_tcp_destroy(l_tcp);
		//         p_j2k->m_tcd->tcp = 0;
		opj_j2k_tcp_data_destroy(tls, l_tcp)
	}

	libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(0), 0, 0x1)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8)) &= libc.CplUint32(J2K_STATE_DATA)

	if Xopj_stream_get_number_byte_left(tls, p_stream) == 0 &&
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_NEOC {
		return DOPJ_TRUE
	}

	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state != J2K_STATE_EOC {
		if Xopj_stream_read_data(tls, p_stream, bp, uint32(2), p_manager) != TOPJ_SIZE_T(2) {
			Xopj_event_msg(tls, p_manager, func() int32 {
				if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fstrict != 0 {
					return DEVT_ERROR
				}
				return DEVT_WARNING
			}(),
				ts+9012, 0)
			if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fstrict != 0 {
				return DOPJ_FALSE
			}
			return DOPJ_TRUE
		}
		Xopj_read_bytes_LE(tls, bp, bp+4, uint32(2))

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) == TOPJ_UINT32(DJ2K_MS_EOC) {
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number = TOPJ_UINT32(0)
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_EOC
		} else if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) != TOPJ_UINT32(DJ2K_MS_SOT) {
			if Xopj_stream_get_number_byte_left(tls, p_stream) == 0 {
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_NEOC
				Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+20309, 0)
				return DOPJ_TRUE
			}
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+20339, 0)
			return DOPJ_FALSE
		}
	}

	return DOPJ_TRUE
}

var __func__148 = *(*[20]int8)(unsafe.Pointer(ts + 20371)) /* j2k.c:9833:1 */

func opj_j2k_update_image_data(tls *libc.TLS, p_tcd uintptr, p_output_image uintptr) TOPJ_BOOL { /* j2k.c:9927:17: */
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var l_width_src TOPJ_UINT32
	var l_height_src TOPJ_UINT32
	var l_width_dest TOPJ_UINT32
	var l_height_dest TOPJ_UINT32
	var l_offset_x0_src TOPJ_INT32
	var l_offset_y0_src TOPJ_INT32
	var l_offset_x1_src TOPJ_INT32
	var l_offset_y1_src TOPJ_INT32
	var l_start_offset_src TOPJ_SIZE_T
	var l_start_x_dest TOPJ_UINT32
	var l_start_y_dest TOPJ_UINT32
	var l_x0_dest TOPJ_UINT32
	var l_y0_dest TOPJ_UINT32
	var l_x1_dest TOPJ_UINT32
	var l_y1_dest TOPJ_UINT32
	var l_start_offset_dest TOPJ_SIZE_T

	var l_img_comp_src uintptr = uintptr(00)
	var l_img_comp_dest uintptr = uintptr(00)

	var l_tilec uintptr = uintptr(00)
	var l_image_src uintptr = uintptr(00)
	var l_dest_ptr uintptr

	l_tilec = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps
	l_image_src = (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage
	l_img_comp_src = (*Topj_image_t)(unsafe.Pointer(l_image_src)).Fcomps

	l_img_comp_dest = (*Topj_image_t)(unsafe.Pointer(p_output_image)).Fcomps

	i = TOPJ_UINT32(0)
__1:
	if !(i < (*Topj_image_t)(unsafe.Pointer(l_image_src)).Fnumcomps) {
		goto __3
	}
	{
		var res_x0 TOPJ_INT32
		var res_x1 TOPJ_INT32
		var res_y0 TOPJ_INT32
		var res_y1 TOPJ_INT32
		var src_data_stride TOPJ_UINT32
		var p_src_data uintptr

		// Copy info from decoded comp image to output image
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fresno_decoded = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_src)).Fresno_decoded

		if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
			var l_res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions + uintptr((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_src)).Fresno_decoded)*192
			res_x0 = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx0
			res_y0 = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy0
			res_x1 = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx1
			res_y1 = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy1
			src_data_stride = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx0)
			p_src_data = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata
		} else {
			var l_res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions + uintptr((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_src)).Fresno_decoded)*192
			res_x0 = TOPJ_INT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x0)
			res_y0 = TOPJ_INT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_y0)
			res_x1 = TOPJ_INT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x1)
			res_y1 = TOPJ_INT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_y1)
			src_data_stride = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x0
			p_src_data = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_win
		}

		if p_src_data == uintptr(0) {
			// Happens for partial component decoding
			goto __2
		}

		l_width_src = TOPJ_UINT32(res_x1 - res_x0)
		l_height_src = TOPJ_UINT32(res_y1 - res_y0)

		// Current tile component size
		//if (i == 0) {
		//         fprintf(stdout, "SRC: l_res_x0=%d, l_res_x1=%d, l_res_y0=%d, l_res_y1=%d\n",
		//                         res_x0, res_x1, res_y0, res_y1);
		//         }

		// Border of the current output component
		l_x0_dest = opj_uint_ceildivpow2(tls, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fx0, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Ffactor)
		l_y0_dest = opj_uint_ceildivpow2(tls, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fy0, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Ffactor)
		l_x1_dest = l_x0_dest + (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw // can't overflow given that image->x1 is uint32
		l_y1_dest = l_y0_dest + (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fh

		//if (i == 0) {
		//         fprintf(stdout, "DEST: l_x0_dest=%d, l_x1_dest=%d, l_y0_dest=%d, l_y1_dest=%d (%d)\n",
		//                         l_x0_dest, l_x1_dest, l_y0_dest, l_y1_dest, l_img_comp_dest->factor );
		//         }

		//-----
		// Compute the area (l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src)
		// of the input buffer (decoded tile component) which will be move
		// in the output buffer. Compute the area of the output buffer (l_start_x_dest,
		// l_start_y_dest, l_width_dest, l_height_dest)  which will be modified
		// by this input area.
		//
		if res_x0 >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+20391, ts+3645, uint32(10018), uintptr(unsafe.Pointer(&__func__149)))
		}
		if res_x1 >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+20403, ts+3645, uint32(10019), uintptr(unsafe.Pointer(&__func__149)))
		}
		if l_x0_dest < TOPJ_UINT32(res_x0) {
			l_start_x_dest = TOPJ_UINT32(res_x0) - l_x0_dest
			l_offset_x0_src = 0

			if l_x1_dest >= TOPJ_UINT32(res_x1) {
				l_width_dest = l_width_src
				l_offset_x1_src = 0
			} else {
				l_width_dest = l_x1_dest - TOPJ_UINT32(res_x0)
				l_offset_x1_src = TOPJ_INT32(l_width_src - l_width_dest)
			}
		} else {
			l_start_x_dest = 0
			l_offset_x0_src = TOPJ_INT32(l_x0_dest) - res_x0

			if l_x1_dest >= TOPJ_UINT32(res_x1) {
				l_width_dest = l_width_src - TOPJ_UINT32(l_offset_x0_src)
				l_offset_x1_src = 0
			} else {
				l_width_dest = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw
				l_offset_x1_src = res_x1 - TOPJ_INT32(l_x1_dest)
			}
		}

		if l_y0_dest < TOPJ_UINT32(res_y0) {
			l_start_y_dest = TOPJ_UINT32(res_y0) - l_y0_dest
			l_offset_y0_src = 0

			if l_y1_dest >= TOPJ_UINT32(res_y1) {
				l_height_dest = l_height_src
				l_offset_y1_src = 0
			} else {
				l_height_dest = l_y1_dest - TOPJ_UINT32(res_y0)
				l_offset_y1_src = TOPJ_INT32(l_height_src - l_height_dest)
			}
		} else {
			l_start_y_dest = 0
			l_offset_y0_src = TOPJ_INT32(l_y0_dest) - res_y0

			if l_y1_dest >= TOPJ_UINT32(res_y1) {
				l_height_dest = l_height_src - TOPJ_UINT32(l_offset_y0_src)
				l_offset_y1_src = 0
			} else {
				l_height_dest = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fh
				l_offset_y1_src = res_y1 - TOPJ_INT32(l_y1_dest)
			}
		}

		if l_offset_x0_src < 0 || l_offset_y0_src < 0 || l_offset_x1_src < 0 || l_offset_y1_src < 0 {
			return DOPJ_FALSE
		}
		// testcase 2977.pdf.asan.67.2198
		if TOPJ_INT32(l_width_dest) < 0 || TOPJ_INT32(l_height_dest) < 0 {
			return DOPJ_FALSE
		}
		//-----

		// Compute the input buffer offset
		l_start_offset_src = TOPJ_SIZE_T(l_offset_x0_src) + TOPJ_SIZE_T(l_offset_y0_src)*
			TOPJ_SIZE_T(src_data_stride)

		// Compute the output buffer offset
		l_start_offset_dest = TOPJ_SIZE_T(l_start_x_dest) + TOPJ_SIZE_T(l_start_y_dest)*
			TOPJ_SIZE_T((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw)

		// Allocate output component buffer if necessary
		if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fdata == uintptr(0) && l_start_offset_src == TOPJ_SIZE_T(0) && l_start_offset_dest == TOPJ_SIZE_T(0) && src_data_stride == (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw && l_width_dest == (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw && l_height_dest == (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fh {
			// If the final image matches the tile buffer, then borrow it
			// directly to save a copy
			if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
				(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fdata = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata
				(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata = uintptr(0)
			} else {
				(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fdata = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_win
				(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_win = uintptr(0)
			}
			goto __2
		} else if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fdata == uintptr(0) {
			var l_width TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw)
			var l_height TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fh)

			if l_height == 0 || uint64(l_width) > libc.Uint64(18446744073709551615)/uint64(l_height) || uint64(l_width*l_height) > libc.Uint64(18446744073709551615)/uint64(unsafe.Sizeof(TOPJ_INT32(0))) {
				// would overflow
				return DOPJ_FALSE
			}
			(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fdata = Xopj_image_data_alloc(tls, l_width*l_height*TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_INT32(0))))
			if !(int32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fdata) != 0) {
				return DOPJ_FALSE
			}

			if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw != l_width_dest || (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fh != l_height_dest {
				libc.Xmemset(tls, (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fdata, 0,
					TOPJ_SIZE_T((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw)*TOPJ_SIZE_T((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fh)*TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_INT32(0))))
			}
		}

		// Move the output buffer to the first place where we will write
		l_dest_ptr = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fdata + uintptr(l_start_offset_dest)*4

		{
			var l_src_ptr uintptr = p_src_data
			l_src_ptr += 4 * uintptr(l_start_offset_src)

			for j = TOPJ_UINT32(0); j < l_height_dest; j++ {
				libc.Xmemcpy(tls, l_dest_ptr, l_src_ptr, uint32(l_width_dest)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
				l_dest_ptr += 4 * uintptr((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp_dest)).Fw)
				l_src_ptr += 4 * uintptr(src_data_stride)
			}

		}

	}
	goto __2
__2:
	i++
	l_img_comp_dest += 64
	l_img_comp_src += 64
	l_tilec += 104
	goto __1
	goto __3
__3:
	;

	return DOPJ_TRUE
}

var __func__149 = *(*[26]int8)(unsafe.Pointer(ts + 20415)) /* j2k.c:9929:1 */

func opj_j2k_update_image_dimensions(tls *libc.TLS, p_image uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:10144:17: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var it_comp TOPJ_UINT32
	var l_comp_x1 TOPJ_INT32
	var l_comp_y1 TOPJ_INT32
	var l_img_comp uintptr = uintptr(0)

	l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps
	for it_comp = TOPJ_UINT32(0); it_comp < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; it_comp++ {
		var l_h TOPJ_INT32
		var l_w TOPJ_INT32
		if (*Topj_image_t)(unsafe.Pointer(p_image)).Fx0 > TOPJ_UINT32(0x7fffffff) || (*Topj_image_t)(unsafe.Pointer(p_image)).Fy0 > TOPJ_UINT32(0x7fffffff) || (*Topj_image_t)(unsafe.Pointer(p_image)).Fx1 > TOPJ_UINT32(0x7fffffff) || (*Topj_image_t)(unsafe.Pointer(p_image)).Fy1 > TOPJ_UINT32(0x7fffffff) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+20441, 0)
			return DOPJ_FALSE
		}

		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fx0 = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(p_image)).Fx0),
			TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)))
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fy0 = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(p_image)).Fy0),
			TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)))
		l_comp_x1 = opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(p_image)).Fx1), TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx))
		l_comp_y1 = opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(p_image)).Fy1), TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy))

		l_w = opj_int_ceildivpow2(tls, l_comp_x1, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor)) -
			opj_int_ceildivpow2(tls, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fx0), TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor))
		if l_w < 0 {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+20492,
				libc.VaList(bp, it_comp, l_w))
			return DOPJ_FALSE
		}
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fw = TOPJ_UINT32(l_w)

		l_h = opj_int_ceildivpow2(tls, l_comp_y1, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor)) -
			opj_int_ceildivpow2(tls, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fy0), TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor))
		if l_h < 0 {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+20561,
				libc.VaList(bp+16, it_comp, l_h))
			return DOPJ_FALSE
		}
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fh = TOPJ_UINT32(l_h)

		l_img_comp += 64
	}

	return DOPJ_TRUE
}

func Xopj_j2k_set_decoded_components(tls *libc.TLS, p_j2k uintptr, numcomps TOPJ_UINT32, comps_indices uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:10196:10: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i TOPJ_UINT32
	var already_mapped uintptr

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image == uintptr(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+20630, 0)
		return DOPJ_FALSE
	}

	already_mapped = Xopj_calloc(tls, uint32(unsafe.Sizeof(TOPJ_BOOL(0))),
		uint32((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps))
	if already_mapped == uintptr(0) {
		return DOPJ_FALSE
	}

	for i = TOPJ_UINT32(0); i < numcomps; i++ {
		if *(*TOPJ_UINT32)(unsafe.Pointer(comps_indices + uintptr(i)*4)) >= (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+20703,
				libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(comps_indices + uintptr(i)*4))))
			Xopj_free(tls, already_mapped)
			return DOPJ_FALSE
		}
		if *(*TOPJ_BOOL)(unsafe.Pointer(already_mapped + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(comps_indices + uintptr(i)*4)))*4)) != 0 {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+20732,
				libc.VaList(bp+8, *(*TOPJ_UINT32)(unsafe.Pointer(comps_indices + uintptr(i)*4))))
			Xopj_free(tls, already_mapped)
			return DOPJ_FALSE
		}
		*(*TOPJ_BOOL)(unsafe.Pointer(already_mapped + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(comps_indices + uintptr(i)*4)))*4)) = DOPJ_TRUE
	}
	Xopj_free(tls, already_mapped)

	Xopj_free(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_comps_indices_to_decode)
	if numcomps != 0 {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_comps_indices_to_decode = Xopj_malloc(tls, uint32(numcomps)*uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
		if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_comps_indices_to_decode == uintptr(0) {
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_numcomps_to_decode = TOPJ_UINT32(0)
			return DOPJ_FALSE
		}
		libc.Xmemcpy(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_comps_indices_to_decode,
			comps_indices,
			uint32(numcomps)*uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
	} else {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_comps_indices_to_decode = uintptr(0)
	}
	(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_numcomps_to_decode = numcomps

	return DOPJ_TRUE
}

func Xopj_j2k_set_decode_area(tls *libc.TLS, p_j2k uintptr, p_image uintptr, p_start_x TOPJ_INT32, p_start_y TOPJ_INT32, p_end_x TOPJ_INT32, p_end_y TOPJ_INT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:10256:10: */
	bp := tls.Alloc(192)
	defer tls.Free(192)

	var l_cp uintptr = p_j2k + 112
	var l_image uintptr = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image
	var ret TOPJ_BOOL
	var it_comp TOPJ_UINT32

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw == TOPJ_UINT32(1) && (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth == TOPJ_UINT32(1) && (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps)).Fm_data != uintptr(0) {
		// In the case of a single-tiled image whose codestream we have already
		// ingested, go on
	} else if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state != J2K_STATE_TPHSOT {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+20771, 0)
		return DOPJ_FALSE
	}

	// Update the comps[].factor member of the output image with the one
	// of m_reduce
	for it_comp = TOPJ_UINT32(0); it_comp < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; it_comp++ {
		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps + uintptr(it_comp)*64)).Ffactor = (*Topj_decoding_param_t)(unsafe.Pointer(p_j2k + 112 + 120)).Fm_reduce
	}

	if !(p_start_x != 0) && !(p_start_y != 0) && !(p_end_x != 0) && !(p_end_y != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_INFO,
			ts+20852, 0)

		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_x = TOPJ_UINT32(0)
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_y = TOPJ_UINT32(0)
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_x = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_y = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth

		(*Topj_image_t)(unsafe.Pointer(p_image)).Fx0 = (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fy0 = (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fx1 = (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fy1 = (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1

		return opj_j2k_update_image_dimensions(tls, p_image, p_manager)
	}

	// -----
	// Check if the positions provided by the user are correct

	// Left
	if p_start_x < 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+20921,
			libc.VaList(bp, p_start_x))
		return DOPJ_FALSE
	} else if TOPJ_UINT32(p_start_x) > (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+20987,
			libc.VaList(bp+8, p_start_x, (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1))
		return DOPJ_FALSE
	} else if TOPJ_UINT32(p_start_x) < (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+21074,
			libc.VaList(bp+24, p_start_x, (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0))
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_x = TOPJ_UINT32(0)
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fx0 = (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0
	} else {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_x = (TOPJ_UINT32(p_start_x) - (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0) / (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fx0 = TOPJ_UINT32(p_start_x)
	}

	// Up
	if p_start_y < 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+21162,
			libc.VaList(bp+40, p_start_y))
		return DOPJ_FALSE
	} else if TOPJ_UINT32(p_start_y) > (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+21226,
			libc.VaList(bp+48, p_start_y, (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1))
		return DOPJ_FALSE
	} else if TOPJ_UINT32(p_start_y) < (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+21311,
			libc.VaList(bp+64, p_start_y, (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0))
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_y = TOPJ_UINT32(0)
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fy0 = (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0
	} else {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_start_tile_y = (TOPJ_UINT32(p_start_y) - (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0) / (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fy0 = TOPJ_UINT32(p_start_y)
	}

	// Right
	if p_end_x <= 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+21397,
			libc.VaList(bp+80, p_end_x))
		return DOPJ_FALSE
	} else if TOPJ_UINT32(p_end_x) < (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+21463,
			libc.VaList(bp+88, p_end_x, (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0))
		return DOPJ_FALSE
	} else if TOPJ_UINT32(p_end_x) > (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+21552,
			libc.VaList(bp+104, p_end_x, (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1))
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_x = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fx1 = (*Topj_image_t)(unsafe.Pointer(l_image)).Fx1
	} else {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_x = TOPJ_UINT32(opj_int_ceildiv(tls,
			p_end_x-TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0), TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx)))
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fx1 = TOPJ_UINT32(p_end_x)
	}

	// Bottom
	if p_end_y <= 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+21640,
			libc.VaList(bp+120, p_end_y))
		return DOPJ_FALSE
	} else if TOPJ_UINT32(p_end_y) < (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+21707,
			libc.VaList(bp+128, p_end_y, (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0))
		return DOPJ_FALSE
	}
	if TOPJ_UINT32(p_end_y) > (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1 {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+21797,
			libc.VaList(bp+144, p_end_y, (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1))
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_y = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fy1 = (*Topj_image_t)(unsafe.Pointer(l_image)).Fy1
	} else {
		(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_end_tile_y = TOPJ_UINT32(opj_int_ceildiv(tls,
			p_end_y-TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0), TOPJ_INT32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy)))
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fy1 = TOPJ_UINT32(p_end_y)
	}
	// -----

	libc.SetBitFieldPtr8Uint32(p_j2k+8+72, TOPJ_BITFIELD(1), 1, 0x2)

	ret = opj_j2k_update_image_dimensions(tls, p_image, p_manager)

	if ret != 0 {
		Xopj_event_msg(tls, p_manager, DEVT_INFO, ts+21886,
			libc.VaList(bp+160, (*Topj_image_t)(unsafe.Pointer(p_image)).Fx0, (*Topj_image_t)(unsafe.Pointer(p_image)).Fy0, (*Topj_image_t)(unsafe.Pointer(p_image)).Fx1, (*Topj_image_t)(unsafe.Pointer(p_image)).Fy1))
	}

	return ret
}

func Xopj_j2k_create_decompress(tls *libc.TLS) uintptr { /* j2k.c:10411:10: */
	var l_j2k uintptr = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_j2k_t{})))
	if !(l_j2k != 0) {
		return uintptr(00)
	}

	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_is_decoder = 1
	libc.SetBitFieldPtr8Uint32(l_j2k+112+148, TOPJ_BITFIELD(1), 1, 0x2)
	// in the absence of JP2 boxes, consider different bit depth / sign
	// per component is allowed
	libc.SetBitFieldPtr8Uint32(l_j2k+112+148, TOPJ_BITFIELD(1), 2, 0x4)

	// Default to using strict mode.
	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_cp.Fstrict = DOPJ_TRUE

	(*Topj_j2k_dec_t)(unsafe.Pointer(l_j2k + 8)).Fm_default_tcp = Xopj_calloc(tls, uint32(1),
		uint32(unsafe.Sizeof(Topj_tcp_t{})))
	if !(int32((*Topj_j2k_dec_t)(unsafe.Pointer(l_j2k+8)).Fm_default_tcp) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(00)
	}

	(*Topj_j2k_dec_t)(unsafe.Pointer(l_j2k + 8)).Fm_header_data = Xopj_calloc(tls, uint32(1),
		uint32(DOPJ_J2K_DEFAULT_HEADER_SIZE))
	if !(int32((*Topj_j2k_dec_t)(unsafe.Pointer(l_j2k+8)).Fm_header_data) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(00)
	}

	(*Topj_j2k_dec_t)(unsafe.Pointer(l_j2k + 8)).Fm_header_data_size = TOPJ_UINT32(DOPJ_J2K_DEFAULT_HEADER_SIZE)

	(*Topj_j2k_dec_t)(unsafe.Pointer(l_j2k + 8)).Fm_tile_ind_to_dec = -1

	(*Topj_j2k_dec_t)(unsafe.Pointer(l_j2k + 8)).Fm_last_sot_read_pos = 0

	// codestream index creation
	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fcstr_index = opj_j2k_create_cstr_index(tls)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fcstr_index) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(00)
	}

	// validation list creation
	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_validation_list = Xopj_procedure_list_create(tls)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_validation_list) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(00)
	}

	// execution list creation
	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_procedure_list = Xopj_procedure_list_create(tls)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_procedure_list) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(00)
	}

	(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_tp = Xopj_thread_pool_create(tls, opj_j2k_get_default_thread_count(tls))
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_tp) != 0) {
		(*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_tp = Xopj_thread_pool_create(tls, 0)
	}
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(l_j2k)).Fm_tp) != 0) {
		Xopj_j2k_destroy(tls, l_j2k)
		return uintptr(0)
	}

	return l_j2k
}

func opj_j2k_create_cstr_index(tls *libc.TLS) uintptr { /* j2k.c:10485:30: */
	var cstr_index uintptr = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_codestream_index_t{})))
	if !(cstr_index != 0) {
		return uintptr(0)
	}

	(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmaxmarknum = TOPJ_UINT32(100)
	(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarknum = TOPJ_UINT32(0)
	(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker = Xopj_calloc(tls, uint32((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmaxmarknum), uint32(unsafe.Sizeof(Topj_marker_info_t{})))
	if !(int32((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker) != 0) {
		Xopj_free(tls, cstr_index)
		return uintptr(0)
	}

	(*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index = uintptr(0)

	return cstr_index
}

func opj_j2k_get_SPCod_SPCoc_size(tls *libc.TLS, p_j2k uintptr, p_tile_no TOPJ_UINT32, p_comp_no TOPJ_UINT32) TOPJ_UINT32 { /* j2k.c:10507:19: */
	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(10516), uintptr(unsafe.Pointer(&__func__150)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_comp_no)*1080

	// preconditions again
	if p_tile_no < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+21924, ts+3645, uint32(10523), uintptr(unsafe.Pointer(&__func__150)))
	}
	if p_comp_no < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
	} else {
		libc.X__assert_fail(tls, ts+21958, ts+3645, uint32(10524), uintptr(unsafe.Pointer(&__func__150)))
	}

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcsty&TOPJ_UINT32(DJ2K_CCP_CSTY_PRT) != 0 {
		return TOPJ_UINT32(5) + (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions
	} else {
		return TOPJ_UINT32(5)
	}
	return TOPJ_UINT32(0)
}

var __func__150 = *(*[29]int8)(unsafe.Pointer(ts + 22003)) /* j2k.c:10510:1 */

func opj_j2k_compare_SPCod_SPCoc(tls *libc.TLS, p_j2k uintptr, p_tile_no TOPJ_UINT32, p_first_comp_no TOPJ_UINT32, p_second_comp_no TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:10533:17: */
	var i TOPJ_UINT32
	var l_cp uintptr = uintptr(0)
	var l_tcp uintptr = uintptr(0)
	var l_tccp0 uintptr = uintptr(0)
	var l_tccp1 uintptr = uintptr(0)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(10543), uintptr(unsafe.Pointer(&__func__151)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_tccp0 = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_first_comp_no)*1080
	l_tccp1 = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_second_comp_no)*1080

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fnumresolutions != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fnumresolutions {
		return DOPJ_FALSE
	}
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fcblkw != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fcblkw {
		return DOPJ_FALSE
	}
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fcblkh != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fcblkh {
		return DOPJ_FALSE
	}
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fcblksty != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fcblksty {
		return DOPJ_FALSE
	}
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fqmfbid != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fqmfbid {
		return DOPJ_FALSE
	}
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fcsty&TOPJ_UINT32(DJ2K_CCP_CSTY_PRT) != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fcsty&TOPJ_UINT32(DJ2K_CCP_CSTY_PRT) {
		return DOPJ_FALSE
	}

	for i = 0; i < (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fnumresolutions; i++ {
		if *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp0 + 812 + uintptr(i)*4)) != *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp1 + 812 + uintptr(i)*4)) {
			return DOPJ_FALSE
		}
		if *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp0 + 944 + uintptr(i)*4)) != *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp1 + 944 + uintptr(i)*4)) {
			return DOPJ_FALSE
		}
	}
	return DOPJ_TRUE
}

var __func__151 = *(*[28]int8)(unsafe.Pointer(ts + 22032)) /* j2k.c:10535:1 */

func opj_j2k_write_SPCod_SPCoc(tls *libc.TLS, p_j2k uintptr, p_tile_no TOPJ_UINT32, p_comp_no TOPJ_UINT32, p_data uintptr, p_header_size uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:10580:17: */
	var i TOPJ_UINT32
	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(10593), uintptr(unsafe.Pointer(&__func__152)))
	}
	if p_header_size != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+22060, ts+3645, uint32(10594), uintptr(unsafe.Pointer(&__func__152)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(10595), uintptr(unsafe.Pointer(&__func__152)))
	}
	if p_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+22080, ts+3645, uint32(10596), uintptr(unsafe.Pointer(&__func__152)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_comp_no)*1080

	// preconditions again
	if p_tile_no < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+21924, ts+3645, uint32(10603), uintptr(unsafe.Pointer(&__func__152)))
	}
	if p_comp_no < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
	} else {
		libc.X__assert_fail(tls, ts+22093, ts+3645, uint32(10604), uintptr(unsafe.Pointer(&__func__152)))
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) < TOPJ_UINT32(5) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+22140, 0)
		return DOPJ_FALSE
	}

	Xopj_write_bytes_LE(tls, p_data, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions-TOPJ_UINT32(1), uint32(1)) // SPcoc (D)
	p_data++

	Xopj_write_bytes_LE(tls, p_data, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkw-TOPJ_UINT32(2), uint32(1)) // SPcoc (E)
	p_data++

	Xopj_write_bytes_LE(tls, p_data, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkh-TOPJ_UINT32(2), uint32(1)) // SPcoc (F)
	p_data++

	Xopj_write_bytes_LE(tls, p_data, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblksty,
		uint32(1)) // SPcoc (G)
	p_data++

	Xopj_write_bytes_LE(tls, p_data, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid,
		uint32(1)) // SPcoc (H)
	p_data++

	*(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) - TOPJ_UINT32(5)

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcsty&TOPJ_UINT32(DJ2K_CCP_CSTY_PRT) != 0 {

		if *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) < (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+22140, 0)
			return DOPJ_FALSE
		}

		for i = TOPJ_UINT32(0); i < (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions; i++ {
			Xopj_write_bytes_LE(tls, p_data, *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 812 + uintptr(i)*4))+*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 944 + uintptr(i)*4))<<4,
				uint32(1)) // SPcoc (I_i)
			p_data++
		}

		*(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) - (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions
	}

	return DOPJ_TRUE
}

var __func__152 = *(*[26]int8)(unsafe.Pointer(ts + 22175)) /* j2k.c:10586:1 */

func opj_j2k_read_SPCod_SPCoc(tls *libc.TLS, p_j2k uintptr, compno TOPJ_UINT32, p_header_data uintptr, p_header_size uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:10649:17: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var i TOPJ_UINT32
	// var l_tmp TOPJ_UINT32 at bp+40, 4

	var l_cp uintptr = uintptr(0)
	var l_tcp uintptr = uintptr(0)
	var l_tccp uintptr = uintptr(0)
	var l_current_ptr uintptr = uintptr(0)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(10662), uintptr(unsafe.Pointer(&__func__153)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(10663), uintptr(unsafe.Pointer(&__func__153)))
	}
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(10664), uintptr(unsafe.Pointer(&__func__153)))
	}

	l_cp = p_j2k + 112
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	// precondition again
	if compno < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
	} else {
		libc.X__assert_fail(tls, ts+22201, ts+3645, uint32(10672), uintptr(unsafe.Pointer(&__func__153)))
	}

	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(compno)*1080
	l_current_ptr = p_header_data

	// make sure room is sufficient
	if *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) < TOPJ_UINT32(5) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+22243, 0)
		return DOPJ_FALSE
	}

	// SPcod (D) / SPcoc (A)
	Xopj_read_bytes_LE(tls, l_current_ptr, l_tccp+4, uint32(1))
	(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions++ // tccp->numresolutions = read() + 1
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions > TOPJ_UINT32(DOPJ_J2K_MAXRLVLS) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+22278,
			libc.VaList(bp, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions, DOPJ_J2K_MAXRLVLS))
		return DOPJ_FALSE
	}
	l_current_ptr++

	// If user wants to remove more resolutions than the codestream contains, return error
	if (*Topj_decoding_param_t)(unsafe.Pointer(l_cp+120)).Fm_reduce >= (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,

			ts+22355,
			libc.VaList(bp+16, compno, (*Topj_decoding_param_t)(unsafe.Pointer(l_cp+120)).Fm_reduce, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions))
		*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8)) |= TOPJ_UINT32(0x8000) // FIXME J2K_DEC_STATE_ERR;
		return DOPJ_FALSE
	}

	// SPcod (E) / SPcoc (B)
	Xopj_read_bytes_LE(tls, l_current_ptr, l_tccp+8, uint32(1))
	l_current_ptr++
	*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 8)) += TOPJ_UINT32(2)

	// SPcod (F) / SPcoc (C)
	Xopj_read_bytes_LE(tls, l_current_ptr, l_tccp+12, uint32(1))
	l_current_ptr++
	*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 12)) += TOPJ_UINT32(2)

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkw > TOPJ_UINT32(10) || (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkh > TOPJ_UINT32(10) || (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkw+(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkh > TOPJ_UINT32(12) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+22533, 0)
		return DOPJ_FALSE
	}

	// SPcod (G) / SPcoc (D)
	Xopj_read_bytes_LE(tls, l_current_ptr, l_tccp+16, uint32(1))
	l_current_ptr++
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_HTMIXED) != TOPJ_UINT32(0) {
		// We do not support HT mixed mode yet.  For conformance, it should be supported.
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+22601, 0)
		return DOPJ_FALSE
	}

	// SPcod (H) / SPcoc (E)
	Xopj_read_bytes_LE(tls, l_current_ptr, l_tccp+20, uint32(1))
	l_current_ptr++

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid > TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+22681, 0)
		return DOPJ_FALSE
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) - TOPJ_UINT32(5)

	// use custom precinct size ?
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcsty&TOPJ_UINT32(DJ2K_CCP_CSTY_PRT) != 0 {
		if *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) < (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+22243, 0)
			return DOPJ_FALSE
		}

		// SPcod (I_i) / SPcoc (F_i)
		for i = TOPJ_UINT32(0); i < (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions; i++ {
			Xopj_read_bytes_LE(tls, l_current_ptr, bp+40, uint32(1))
			l_current_ptr++
			// Precinct exponent 0 is only allowed for lowest resolution level (Table A.21)
			if i != TOPJ_UINT32(0) && (*(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))&TOPJ_UINT32(0xf) == TOPJ_UINT32(0) || *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))>>4 == TOPJ_UINT32(0)) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+22746, 0)
				return DOPJ_FALSE
			}
			*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 812 + uintptr(i)*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40)) & TOPJ_UINT32(0xf)
			*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 944 + uintptr(i)*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40)) >> 4
		}

		*(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) - (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions
	} else {
		// set default size for the precinct width and height
		for i = TOPJ_UINT32(0); i < (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions; i++ {
			*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 812 + uintptr(i)*4)) = TOPJ_UINT32(15)
			*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 944 + uintptr(i)*4)) = TOPJ_UINT32(15)
		}
	}

	return DOPJ_TRUE
}

var __func__153 = *(*[25]int8)(unsafe.Pointer(ts + 22769)) /* j2k.c:10654:1 */

func opj_j2k_copy_tile_component_parameters(tls *libc.TLS, p_j2k uintptr) { /* j2k.c:10801:13: */
	// loop
	var i TOPJ_UINT32
	var l_cp uintptr = uintptr(0)
	var l_tcp uintptr = uintptr(0)
	var l_ref_tccp uintptr = uintptr(0)
	var l_copied_tccp uintptr = uintptr(0)
	var l_prc_size TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(10811), uintptr(unsafe.Pointer(&__func__154)))
	}

	l_cp = p_j2k + 112
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	l_ref_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps
	l_copied_tccp = l_ref_tccp + uintptr(1)*1080
	l_prc_size = (*Topj_tccp_t)(unsafe.Pointer(l_ref_tccp)).Fnumresolutions * TOPJ_UINT32(unsafe.Sizeof(TOPJ_UINT32(0)))

	for i = TOPJ_UINT32(1); i < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; i++ {
		(*Topj_tccp_t)(unsafe.Pointer(l_copied_tccp)).Fnumresolutions = (*Topj_tccp_t)(unsafe.Pointer(l_ref_tccp)).Fnumresolutions
		(*Topj_tccp_t)(unsafe.Pointer(l_copied_tccp)).Fcblkw = (*Topj_tccp_t)(unsafe.Pointer(l_ref_tccp)).Fcblkw
		(*Topj_tccp_t)(unsafe.Pointer(l_copied_tccp)).Fcblkh = (*Topj_tccp_t)(unsafe.Pointer(l_ref_tccp)).Fcblkh
		(*Topj_tccp_t)(unsafe.Pointer(l_copied_tccp)).Fcblksty = (*Topj_tccp_t)(unsafe.Pointer(l_ref_tccp)).Fcblksty
		(*Topj_tccp_t)(unsafe.Pointer(l_copied_tccp)).Fqmfbid = (*Topj_tccp_t)(unsafe.Pointer(l_ref_tccp)).Fqmfbid
		libc.Xmemcpy(tls, l_copied_tccp+812, l_ref_tccp+812, uint32(l_prc_size))
		libc.Xmemcpy(tls, l_copied_tccp+944, l_ref_tccp+944, uint32(l_prc_size))
		l_copied_tccp += 1080
	}
}

var __func__154 = *(*[39]int8)(unsafe.Pointer(ts + 22794)) /* j2k.c:10802:1 */

func opj_j2k_get_SQcd_SQcc_size(tls *libc.TLS, p_j2k uintptr, p_tile_no TOPJ_UINT32, p_comp_no TOPJ_UINT32) TOPJ_UINT32 { /* j2k.c:10835:19: */
	var l_num_bands TOPJ_UINT32

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(10846), uintptr(unsafe.Pointer(&__func__155)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_comp_no)*1080

	// preconditions again
	if p_tile_no < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+22833, ts+3645, uint32(10853), uintptr(unsafe.Pointer(&__func__155)))
	}
	if p_comp_no < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
	} else {
		libc.X__assert_fail(tls, ts+21958, ts+3645, uint32(10854), uintptr(unsafe.Pointer(&__func__155)))
	}

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_SIQNT) {
		l_num_bands = uint32(1)
	} else {
		l_num_bands = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions*TOPJ_UINT32(3) - TOPJ_UINT32(2)
	}

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_NOQNT) {
		return TOPJ_UINT32(1) + l_num_bands
	} else {
		return TOPJ_UINT32(1) + TOPJ_UINT32(2)*l_num_bands
	}
	return TOPJ_UINT32(0)
}

var __func__155 = *(*[27]int8)(unsafe.Pointer(ts + 22865)) /* j2k.c:10838:1 */

func opj_j2k_compare_SQcd_SQcc(tls *libc.TLS, p_j2k uintptr, p_tile_no TOPJ_UINT32, p_first_comp_no TOPJ_UINT32, p_second_comp_no TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:10866:17: */
	var l_cp uintptr = uintptr(0)
	var l_tcp uintptr = uintptr(0)
	var l_tccp0 uintptr = uintptr(0)
	var l_tccp1 uintptr = uintptr(0)
	var l_band_no TOPJ_UINT32
	var l_num_bands TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(10876), uintptr(unsafe.Pointer(&__func__156)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_tccp0 = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_first_comp_no)*1080
	l_tccp1 = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_second_comp_no)*1080

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fqntsty != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fqntsty {
		return DOPJ_FALSE
	}
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fnumgbits != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fnumgbits {
		return DOPJ_FALSE
	}
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_SIQNT) {
		l_num_bands = 1
	} else {
		l_num_bands = (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fnumresolutions*3 - 2
		if l_num_bands != (*Topj_tccp_t)(unsafe.Pointer(l_tccp1)).Fnumresolutions*3-2 {
			return DOPJ_FALSE
		}
	}

	for l_band_no = TOPJ_UINT32(0); l_band_no < l_num_bands; l_band_no++ {
		if (*Topj_stepsize_t)(unsafe.Pointer(l_tccp0+28+uintptr(l_band_no)*8)).Fexpn != (*Topj_stepsize_t)(unsafe.Pointer(l_tccp1+28+uintptr(l_band_no)*8)).Fexpn {
			return DOPJ_FALSE
		}
	}
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp0)).Fqntsty != TOPJ_UINT32(DJ2K_CCP_QNTSTY_NOQNT) {
		for l_band_no = TOPJ_UINT32(0); l_band_no < l_num_bands; l_band_no++ {
			if (*Topj_stepsize_t)(unsafe.Pointer(l_tccp0+28+uintptr(l_band_no)*8)).Fmant != (*Topj_stepsize_t)(unsafe.Pointer(l_tccp1+28+uintptr(l_band_no)*8)).Fmant {
				return DOPJ_FALSE
			}
		}
	}
	return DOPJ_TRUE
}

var __func__156 = *(*[26]int8)(unsafe.Pointer(ts + 22892)) /* j2k.c:10868:1 */

func opj_j2k_write_SQcd_SQcc(tls *libc.TLS, p_j2k uintptr, p_tile_no TOPJ_UINT32, p_comp_no TOPJ_UINT32, p_data uintptr, p_header_size uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:10914:17: */
	var l_header_size TOPJ_UINT32
	var l_band_no TOPJ_UINT32
	var l_num_bands TOPJ_UINT32
	var l_expn TOPJ_UINT32
	var l_mant TOPJ_UINT32

	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(10930), uintptr(unsafe.Pointer(&__func__157)))
	}
	if p_header_size != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+22060, ts+3645, uint32(10931), uintptr(unsafe.Pointer(&__func__157)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(10932), uintptr(unsafe.Pointer(&__func__157)))
	}
	if p_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+22080, ts+3645, uint32(10933), uintptr(unsafe.Pointer(&__func__157)))
	}

	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_comp_no)*1080

	// preconditions again
	if p_tile_no < (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+22833, ts+3645, uint32(10940), uintptr(unsafe.Pointer(&__func__157)))
	}
	if p_comp_no < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
	} else {
		libc.X__assert_fail(tls, ts+21958, ts+3645, uint32(10941), uintptr(unsafe.Pointer(&__func__157)))
	}

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_SIQNT) {
		l_num_bands = uint32(1)
	} else {
		l_num_bands = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions*TOPJ_UINT32(3) - TOPJ_UINT32(2)
	}

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_NOQNT) {
		l_header_size = TOPJ_UINT32(1) + l_num_bands

		if *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) < l_header_size {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+22918, 0)
			return DOPJ_FALSE
		}

		Xopj_write_bytes_LE(tls, p_data, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty+(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumgbits<<5,
			uint32(1)) // Sqcx
		p_data++

		for l_band_no = TOPJ_UINT32(0); l_band_no < l_num_bands; l_band_no++ {
			l_expn = TOPJ_UINT32((*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fexpn)
			Xopj_write_bytes_LE(tls, p_data, l_expn<<3, uint32(1)) // SPqcx_i
			p_data++
		}
	} else {
		l_header_size = TOPJ_UINT32(1) + TOPJ_UINT32(2)*l_num_bands

		if *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) < l_header_size {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+22918, 0)
			return DOPJ_FALSE
		}

		Xopj_write_bytes_LE(tls, p_data, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty+(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumgbits<<5,
			uint32(1)) // Sqcx
		p_data++

		for l_band_no = TOPJ_UINT32(0); l_band_no < l_num_bands; l_band_no++ {
			l_expn = TOPJ_UINT32((*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fexpn)
			l_mant = TOPJ_UINT32((*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fmant)

			Xopj_write_bytes_LE(tls, p_data, l_expn<<11+l_mant, uint32(2)) // SPqcx_i
			p_data += uintptr(2)
		}
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) - l_header_size

	return DOPJ_TRUE
}

var __func__157 = *(*[24]int8)(unsafe.Pointer(ts + 22951)) /* j2k.c:10920:1 */

func opj_j2k_read_SQcd_SQcc(tls *libc.TLS, p_j2k uintptr, p_comp_no TOPJ_UINT32, p_header_data uintptr, p_header_size uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:10989:17: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// loop
	var l_band_no TOPJ_UINT32
	var l_cp uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_current_ptr uintptr = uintptr(00)
	// var l_tmp TOPJ_UINT32 at bp+24, 4

	var l_num_band TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(11005), uintptr(unsafe.Pointer(&__func__158)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(11006), uintptr(unsafe.Pointer(&__func__158)))
	}
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+3645, uint32(11007), uintptr(unsafe.Pointer(&__func__158)))
	}

	l_cp = p_j2k + 112
	// come from tile part header or main header ?
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	// precondition again
	if p_comp_no < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
	} else {
		libc.X__assert_fail(tls, ts+21958, ts+3645, uint32(11017), uintptr(unsafe.Pointer(&__func__158)))
	}

	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps + uintptr(p_comp_no)*1080
	l_current_ptr = p_header_data

	if *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) < TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+22975, 0)
		return DOPJ_FALSE
	}
	*(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) -= TOPJ_UINT32(1)

	Xopj_read_bytes_LE(tls, l_current_ptr, bp+24, uint32(1)) // Sqcx
	l_current_ptr++

	(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) & TOPJ_UINT32(0x1f)
	(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumgbits = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) >> 5
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_SIQNT) {
		l_num_band = TOPJ_UINT32(1)
	} else {
		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_NOQNT) {
			l_num_band = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size))
		} else {
			l_num_band = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) / TOPJ_UINT32(2)
		}

		if l_num_band > TOPJ_UINT32(3*DOPJ_J2K_MAXRLVLS-2) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,

				ts+23011, libc.VaList(bp, l_num_band, 3*DOPJ_J2K_MAXRLVLS-2,
					3*DOPJ_J2K_MAXRLVLS-2))
			//return OPJ_FALSE;
		}
	}

	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_NOQNT) {
		for l_band_no = TOPJ_UINT32(0); l_band_no < l_num_band; l_band_no++ {
			Xopj_read_bytes_LE(tls, l_current_ptr, bp+24, uint32(1)) // SPqcx_i
			l_current_ptr++
			if l_band_no < TOPJ_UINT32(3*DOPJ_J2K_MAXRLVLS-2) {
				(*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fexpn = TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) >> 3)
				(*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fmant = 0
			}
		}
		*(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) - l_num_band
	} else {
		for l_band_no = TOPJ_UINT32(0); l_band_no < l_num_band; l_band_no++ {
			Xopj_read_bytes_LE(tls, l_current_ptr, bp+24, uint32(2)) // SPqcx_i
			l_current_ptr += uintptr(2)
			if l_band_no < TOPJ_UINT32(3*DOPJ_J2K_MAXRLVLS-2) {
				(*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fexpn = TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) >> 11)
				(*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fmant = TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) & TOPJ_UINT32(0x7ff))
			}
		}
		*(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) = *(*TOPJ_UINT32)(unsafe.Pointer(p_header_size)) - TOPJ_UINT32(2)*l_num_band
	}

	// Add Antonin : if scalar_derived -> compute other stepsizes
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_SIQNT) {
		for l_band_no = TOPJ_UINT32(1); l_band_no < TOPJ_UINT32(3*DOPJ_J2K_MAXRLVLS-2); l_band_no++ {
			(*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fexpn = func() int32 {
				if (*Topj_stepsize_t)(unsafe.Pointer(l_tccp+28)).Fexpn-TOPJ_INT32((l_band_no-TOPJ_UINT32(1))/TOPJ_UINT32(3)) > 0 {
					return (*Topj_stepsize_t)(unsafe.Pointer(l_tccp+28)).Fexpn - TOPJ_INT32((l_band_no-TOPJ_UINT32(1))/TOPJ_UINT32(3))
				}
				return 0
			}()
			(*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(l_band_no)*8)).Fmant = (*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28)).Fmant
		}
	}

	return DOPJ_TRUE
}

var __func__158 = *(*[23]int8)(unsafe.Pointer(ts + 23227)) /* j2k.c:10995:1 */

func opj_j2k_copy_tile_quantization_parameters(tls *libc.TLS, p_j2k uintptr) { /* j2k.c:11108:13: */
	var i TOPJ_UINT32
	var l_cp uintptr = uintptr(0)
	var l_tcp uintptr = uintptr(0)
	var l_ref_tccp uintptr = uintptr(0)
	var l_copied_tccp uintptr = uintptr(0)
	var l_size TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(11118), uintptr(unsafe.Pointer(&__func__159)))
	}

	l_cp = p_j2k + 112
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_TPH {
		l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696
	} else {
		l_tcp = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp
	}

	l_ref_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps
	l_copied_tccp = l_ref_tccp + uintptr(1)*1080
	l_size = uint32(3*DOPJ_J2K_MAXRLVLS-2) * uint32(unsafe.Sizeof(Topj_stepsize_t{}))

	for i = TOPJ_UINT32(1); i < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; i++ {
		(*Topj_tccp_t)(unsafe.Pointer(l_copied_tccp)).Fqntsty = (*Topj_tccp_t)(unsafe.Pointer(l_ref_tccp)).Fqntsty
		(*Topj_tccp_t)(unsafe.Pointer(l_copied_tccp)).Fnumgbits = (*Topj_tccp_t)(unsafe.Pointer(l_ref_tccp)).Fnumgbits
		libc.Xmemcpy(tls, l_copied_tccp+28, l_ref_tccp+28, uint32(l_size))
		l_copied_tccp += 1080
	}
}

var __func__159 = *(*[42]int8)(unsafe.Pointer(ts + 23250)) /* j2k.c:11109:1 */

func opj_j2k_dump_tile_info(tls *libc.TLS, l_default_tile uintptr, numcomps TOPJ_INT32, out_stream uintptr) { /* j2k.c:11137:13: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	if l_default_tile != 0 {
		var compno TOPJ_INT32

		libc.Xfprintf(tls, out_stream, ts+23292, 0)
		libc.Xfprintf(tls, out_stream, ts+23310, libc.VaList(bp, (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Fcsty))
		libc.Xfprintf(tls, out_stream, ts+23323, libc.VaList(bp+8, (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Fprg))
		libc.Xfprintf(tls, out_stream, ts+23335, libc.VaList(bp+16, (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Fnumlayers))
		libc.Xfprintf(tls, out_stream, ts+23352, libc.VaList(bp+24, (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Fmct))

		for compno = 0; compno < numcomps; compno++ {
			var l_tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Ftccps + uintptr(compno)*1080
			var resno TOPJ_UINT32
			var bandno TOPJ_INT32
			var numbands TOPJ_INT32

			// coding style
			libc.Xfprintf(tls, out_stream, ts+23363, libc.VaList(bp+32, compno))
			libc.Xfprintf(tls, out_stream, ts+23377, libc.VaList(bp+40, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcsty))
			libc.Xfprintf(tls, out_stream, ts+23391, libc.VaList(bp+48, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions))
			libc.Xfprintf(tls, out_stream, ts+23414, libc.VaList(bp+56, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkw))
			libc.Xfprintf(tls, out_stream, ts+23430, libc.VaList(bp+64, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkh))
			libc.Xfprintf(tls, out_stream, ts+23446, libc.VaList(bp+72, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblksty))
			libc.Xfprintf(tls, out_stream, ts+23463, libc.VaList(bp+80, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid))

			libc.Xfprintf(tls, out_stream, ts+23478, 0)
			for resno = TOPJ_UINT32(0); resno < (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions; resno++ {
				libc.Xfprintf(tls, out_stream, ts+23502, libc.VaList(bp+88, *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 812 + uintptr(resno)*4)), *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 944 + uintptr(resno)*4))))
			}
			libc.Xfprintf(tls, out_stream, ts+23511, 0)

			// quantization style
			libc.Xfprintf(tls, out_stream, ts+23513, libc.VaList(bp+104, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty))
			libc.Xfprintf(tls, out_stream, ts+23528, libc.VaList(bp+112, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumgbits))
			libc.Xfprintf(tls, out_stream, ts+23545, 0)
			if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_SIQNT) {
				numbands = 1
			} else {
				numbands = TOPJ_INT32((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions)*3 - 2
			}
			for bandno = 0; bandno < numbands; bandno++ {
				libc.Xfprintf(tls, out_stream, ts+23502, libc.VaList(bp+120, (*Topj_stepsize_t)(unsafe.Pointer(l_tccp+28+uintptr(bandno)*8)).Fmant,
					(*Topj_stepsize_t)(unsafe.Pointer(l_tccp+28+uintptr(bandno)*8)).Fexpn))
			}
			libc.Xfprintf(tls, out_stream, ts+23511, 0)

			// RGN value
			libc.Xfprintf(tls, out_stream, ts+23566, libc.VaList(bp+136, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Froishift))

			libc.Xfprintf(tls, out_stream, ts+23583, 0)
		} //end of component of default tile
		libc.Xfprintf(tls, out_stream, ts+23589, 0) //end of default tile
	}
}

func Xj2k_dump(tls *libc.TLS, p_j2k uintptr, flag TOPJ_INT32, out_stream uintptr) { /* j2k.c:11190:6: */
	// Check if the flag is compatible with j2k file
	if flag&DOPJ_JP2_INFO != 0 || flag&DOPJ_JP2_IND != 0 {
		libc.Xfprintf(tls, out_stream, ts+23594, 0)
		return
	}

	// Dump the image_header
	if flag&DOPJ_IMG_INFO != 0 {
		if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image != 0 {
			Xj2k_dump_image_header(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image, 0, out_stream)
		}
	}

	// Dump the codestream info from main header
	if flag&DOPJ_J2K_MH_INFO != 0 {
		if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image != 0 {
			opj_j2k_dump_MH_info(tls, p_j2k, out_stream)
		}
	}
	// Dump all tile/codestream info
	if flag&DOPJ_J2K_TCH_INFO != 0 {
		var l_nb_tiles TOPJ_UINT32 = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw
		var i TOPJ_UINT32
		var l_tcp uintptr = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps
		if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image != 0 {
			for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
				opj_j2k_dump_tile_info(tls, l_tcp, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps),
					out_stream)
				l_tcp += 5696
			}
		}
	}

	// Dump the codestream info of the current tile
	if flag&DOPJ_J2K_TH_INFO != 0 {

	}

	// Dump the codestream index from main header
	if flag&DOPJ_J2K_MH_IND != 0 {
		opj_j2k_dump_MH_index(tls, p_j2k, out_stream)
	}

	// Dump the codestream index of the current tile
	if flag&DOPJ_J2K_TH_IND != 0 {

	}

}

func opj_j2k_dump_MH_index(tls *libc.TLS, p_j2k uintptr, out_stream uintptr) { /* j2k.c:11242:13: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var cstr_index uintptr = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index
	var it_marker TOPJ_UINT32
	var it_tile TOPJ_UINT32
	var it_tile_part TOPJ_UINT32

	libc.Xfprintf(tls, out_stream, ts+23606, 0)

	libc.Xfprintf(tls, out_stream,
		ts+23644,
		libc.VaList(bp, (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmain_head_start, (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmain_head_end))

	libc.Xfprintf(tls, out_stream, ts+23709, 0)

	if (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker != 0 {
		for it_marker = TOPJ_UINT32(0); it_marker < (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarknum; it_marker++ {
			libc.Xfprintf(tls, out_stream, ts+23727,
				libc.VaList(bp+16, int32((*Topj_marker_info_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker+uintptr(it_marker)*12)).Ftype),
					(*Topj_marker_info_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker+uintptr(it_marker)*12)).Fpos,
					(*Topj_marker_info_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fmarker+uintptr(it_marker)*12)).Flen))
		}
	}

	libc.Xfprintf(tls, out_stream, ts+23589, 0)

	if (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index != 0 {

		// Simple test to avoid to write empty information
		var l_acc_nb_of_tile_part TOPJ_UINT32 = TOPJ_UINT32(0)
		for it_tile = TOPJ_UINT32(0); it_tile < (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fnb_of_tiles; it_tile++ {
			l_acc_nb_of_tile_part = l_acc_nb_of_tile_part + (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fnb_tps
		}

		if l_acc_nb_of_tile_part != 0 {
			libc.Xfprintf(tls, out_stream, ts+23757, 0)

			for it_tile = TOPJ_UINT32(0); it_tile < (*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Fnb_of_tiles; it_tile++ {
				var nb_of_tile_part TOPJ_UINT32 = (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index + uintptr(it_tile)*56)).Fnb_tps

				libc.Xfprintf(tls, out_stream, ts+23774, libc.VaList(bp+40, it_tile,
					nb_of_tile_part))

				if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index != 0 {
					for it_tile_part = TOPJ_UINT32(0); it_tile_part < nb_of_tile_part; it_tile_part++ {
						libc.Xfprintf(tls, out_stream,
							ts+23810,
							libc.VaList(bp+56, it_tile_part,
								(*Topj_tp_index_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index+uintptr(it_tile_part)*12)).Fstart_pos,
								(*Topj_tp_index_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index+uintptr(it_tile_part)*12)).Fend_header,
								(*Topj_tp_index_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index+uintptr(it_tile_part)*12)).Fend_pos))
					}
				}

				if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker != 0 {
					for it_marker = TOPJ_UINT32(0); it_marker < (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarknum; it_marker++ {
						libc.Xfprintf(tls, out_stream, ts+23727,
							libc.VaList(bp+88, int32((*Topj_marker_info_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker+uintptr(it_marker)*12)).Ftype),
								(*Topj_marker_info_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker+uintptr(it_marker)*12)).Fpos,
								(*Topj_marker_info_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker+uintptr(it_marker)*12)).Flen))
					}
				}
			}
			libc.Xfprintf(tls, out_stream, ts+23589, 0)
		}
	}

	libc.Xfprintf(tls, out_stream, ts+23873, 0)

}

func opj_j2k_dump_MH_info(tls *libc.TLS, p_j2k uintptr, out_stream uintptr) { /* j2k.c:11313:13: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	libc.Xfprintf(tls, out_stream, ts+23876, 0)

	libc.Xfprintf(tls, out_stream, ts+23913, libc.VaList(bp, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftx0, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fty0))
	libc.Xfprintf(tls, out_stream, ts+23931, libc.VaList(bp+16, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdx, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdy))
	libc.Xfprintf(tls, out_stream, ts+23949, libc.VaList(bp+32, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth))
	opj_j2k_dump_tile_info(tls, (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp,
		TOPJ_INT32((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps), out_stream)
	libc.Xfprintf(tls, out_stream, ts+23873, 0)
}

func Xj2k_dump_image_header(tls *libc.TLS, img_header uintptr, dev_dump_flag TOPJ_BOOL, out_stream uintptr) { /* j2k.c:11326:6: */
	bp := tls.Alloc(90)
	defer tls.Free(90)

	// var tab [2]int8 at bp+88, 2

	if dev_dump_flag != 0 {
		libc.Xfprintf(tls, libc.Xstdout, ts+23965, 0)
		*(*int8)(unsafe.Pointer(bp + 88)) = int8(0)
	} else {
		libc.Xfprintf(tls, out_stream, ts+24002, 0)
		*(*int8)(unsafe.Pointer(bp + 88)) = int8('\t')
		*(*int8)(unsafe.Pointer(bp + 88 + 1)) = int8(0)
	}

	libc.Xfprintf(tls, out_stream, ts+24016, libc.VaList(bp, bp+88, (*Topj_image_t)(unsafe.Pointer(img_header)).Fx0, (*Topj_image_t)(unsafe.Pointer(img_header)).Fy0))
	libc.Xfprintf(tls, out_stream, ts+24033, libc.VaList(bp+24, bp+88, (*Topj_image_t)(unsafe.Pointer(img_header)).Fx1,
		(*Topj_image_t)(unsafe.Pointer(img_header)).Fy1))
	libc.Xfprintf(tls, out_stream, ts+24050, libc.VaList(bp+48, bp+88, (*Topj_image_t)(unsafe.Pointer(img_header)).Fnumcomps))

	if (*Topj_image_t)(unsafe.Pointer(img_header)).Fcomps != 0 {
		var compno TOPJ_UINT32
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(img_header)).Fnumcomps; compno++ {
			libc.Xfprintf(tls, out_stream, ts+24066, libc.VaList(bp+64, bp+88, compno))
			Xj2k_dump_image_comp_header(tls, (*Topj_image_t)(unsafe.Pointer(img_header)).Fcomps+uintptr(compno)*64, dev_dump_flag,
				out_stream)
			libc.Xfprintf(tls, out_stream, ts+24086, libc.VaList(bp+80, bp+88))
		}
	}

	libc.Xfprintf(tls, out_stream, ts+23873, 0)
}

func Xj2k_dump_image_comp_header(tls *libc.TLS, comp_header uintptr, dev_dump_flag TOPJ_BOOL, out_stream uintptr) { /* j2k.c:11358:6: */
	bp := tls.Alloc(59)
	defer tls.Free(59)

	// var tab [3]int8 at bp+56, 3

	if dev_dump_flag != 0 {
		libc.Xfprintf(tls, libc.Xstdout, ts+24091, 0)
		*(*int8)(unsafe.Pointer(bp + 56)) = int8(0)
	} else {
		*(*int8)(unsafe.Pointer(bp + 56)) = int8('\t')
		*(*int8)(unsafe.Pointer(bp + 56 + 1)) = int8('\t')
		*(*int8)(unsafe.Pointer(bp + 56 + 2)) = int8(0)
	}

	libc.Xfprintf(tls, out_stream, ts+24133, libc.VaList(bp, bp+56, (*Topj_image_comp_t)(unsafe.Pointer(comp_header)).Fdx, (*Topj_image_comp_t)(unsafe.Pointer(comp_header)).Fdy))
	libc.Xfprintf(tls, out_stream, ts+24150, libc.VaList(bp+24, bp+56, (*Topj_image_comp_t)(unsafe.Pointer(comp_header)).Fprec))
	libc.Xfprintf(tls, out_stream, ts+24162, libc.VaList(bp+40, bp+56, (*Topj_image_comp_t)(unsafe.Pointer(comp_header)).Fsgnd))

	if dev_dump_flag != 0 {
		libc.Xfprintf(tls, out_stream, ts+23873, 0)
	}
}

func Xj2k_get_cstr_info(tls *libc.TLS, p_j2k uintptr) uintptr { /* j2k.c:11381:25: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var compno TOPJ_UINT32
	var numcomps TOPJ_UINT32 = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps
	var l_default_tile uintptr
	*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)) = Xopj_calloc(tls, uint32(1),
		uint32(unsafe.Sizeof(Topj_codestream_info_v2_t{})))
	if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
		return uintptr(0)
	}

	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fnbcomps = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps

	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Ftx0 = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftx0
	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fty0 = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fty0
	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Ftdx = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdx
	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Ftdy = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdy
	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Ftw = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw
	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fth = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth

	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Ftile_info = uintptr(0) // Not fill from the main header

	l_default_tile = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_default_tcp

	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fm_default_tile_info.Fcsty = (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Fcsty
	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fm_default_tile_info.Fprg = (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Fprg
	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fm_default_tile_info.Fnumlayers = (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Fnumlayers
	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fm_default_tile_info.Fmct = (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Fmct

	(*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fm_default_tile_info.Ftccp_info = Xopj_calloc(tls,
		uint32((*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* cstr_info */)))).Fnbcomps), uint32(unsafe.Sizeof(Topj_tccp_info_t{})))
	if !(int32((*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fm_default_tile_info.Ftccp_info) != 0) {
		Xopj_destroy_cstr_info(tls, bp)
		return uintptr(0)
	}

	for compno = TOPJ_UINT32(0); compno < numcomps; compno++ {
		var l_tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer(l_default_tile)).Ftccps + uintptr(compno)*1080
		var l_tccp_info uintptr = (*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fm_default_tile_info.Ftccp_info + uintptr(compno)*1080
		var bandno TOPJ_INT32
		var numbands TOPJ_INT32

		// coding style
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Fcsty = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcsty
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Fnumresolutions = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Fcblkw = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkw
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Fcblkh = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkh
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Fcblksty = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblksty
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Fqmfbid = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid
		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions < TOPJ_UINT32(DOPJ_J2K_MAXRLVLS) {
			libc.Xmemcpy(tls, l_tccp_info+948, l_tccp+944, uint32((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions))
			libc.Xmemcpy(tls, l_tccp_info+816, l_tccp+812, uint32((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions))
		}

		// quantization style
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Fqntsty = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Fnumgbits = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumgbits

		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqntsty == TOPJ_UINT32(DJ2K_CCP_QNTSTY_SIQNT) {
			numbands = 1
		} else {
			numbands = TOPJ_INT32((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions)*3 - 2
		}
		if numbands < 3*DOPJ_J2K_MAXRLVLS-2 {
			for bandno = 0; bandno < numbands; bandno++ {
				*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp_info + 32 + uintptr(bandno)*4)) = TOPJ_UINT32((*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(bandno)*8)).Fmant)
				*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp_info + 420 + uintptr(bandno)*4)) = TOPJ_UINT32((*Topj_stepsize_t)(unsafe.Pointer(l_tccp + 28 + uintptr(bandno)*8)).Fexpn)
			}
		}

		// RGN value
		(*Topj_tccp_info_t)(unsafe.Pointer(l_tccp_info)).Froishift = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Froishift
	}

	return *(*uintptr)(unsafe.Pointer(bp /* cstr_info */))
}

func Xj2k_get_cstr_index(tls *libc.TLS, p_j2k uintptr) uintptr { /* j2k.c:11457:23: */
	var l_cstr_index uintptr = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_codestream_index_t{})))
	if !(l_cstr_index != 0) {
		return uintptr(0)
	}

	(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmain_head_start = (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmain_head_start
	(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmain_head_end = (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmain_head_end
	(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fcodestream_size = (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fcodestream_size

	(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarknum = (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmarknum
	(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarker = Xopj_malloc(tls, uint32((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarknum)*uint32(unsafe.Sizeof(Topj_marker_info_t{})))
	if !(int32((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarker) != 0) {
		Xopj_free(tls, l_cstr_index)
		return uintptr(0)
	}

	if (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmarker != 0 {
		libc.Xmemcpy(tls, (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarker, (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmarker,
			uint32((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarknum)*uint32(unsafe.Sizeof(Topj_marker_info_t{})))
	} else {
		Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarker)
		(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarker = uintptr(0)
	}

	(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fnb_of_tiles = (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fnb_of_tiles
	(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index = Xopj_calloc(tls,
		uint32((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fnb_of_tiles), uint32(unsafe.Sizeof(Topj_tile_index_t{})))
	if !(int32((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index) != 0) {
		Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarker)
		Xopj_free(tls, l_cstr_index)
		return uintptr(0)
	}

	if !(int32((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index) != 0) {
		Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index)
		(*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index = uintptr(0)
	} else {
		var it_tile TOPJ_UINT32 = TOPJ_UINT32(0)
		for it_tile = TOPJ_UINT32(0); it_tile < (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fnb_of_tiles; it_tile++ {

			// Tile Marker
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr(it_tile)*56)).Fmarknum = (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr(it_tile)*56)).Fmarknum

			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr(it_tile)*56)).Fmarker = Xopj_malloc(tls, uint32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarknum)*uint32(unsafe.Sizeof(Topj_marker_info_t{})))

			if !(int32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker) != 0) {
				var it_tile_free TOPJ_UINT32

				for it_tile_free = TOPJ_UINT32(0); it_tile_free < it_tile; it_tile_free++ {
					Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile_free)*56)).Fmarker)
				}

				Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index)
				Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarker)
				Xopj_free(tls, l_cstr_index)
				return uintptr(0)
			}

			if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker != 0 {
				libc.Xmemcpy(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker,
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker,
					uint32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarknum)*uint32(unsafe.Sizeof(Topj_marker_info_t{})))
			} else {
				Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker)
				(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr(it_tile)*56)).Fmarker = uintptr(0)
			}

			// Tile part index
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr(it_tile)*56)).Fnb_tps = (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr(it_tile)*56)).Fnb_tps

			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr(it_tile)*56)).Ftp_index = Xopj_malloc(tls, uint32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fnb_tps)*uint32(unsafe.Sizeof(Topj_tp_index_t{})))

			if !(int32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index) != 0) {
				var it_tile_free TOPJ_UINT32

				for it_tile_free = TOPJ_UINT32(0); it_tile_free < it_tile; it_tile_free++ {
					Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile_free)*56)).Fmarker)
					Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile_free)*56)).Ftp_index)
				}

				Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index)
				Xopj_free(tls, (*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Fmarker)
				Xopj_free(tls, l_cstr_index)
				return uintptr(0)
			}

			if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index != 0 {
				libc.Xmemcpy(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index,
					(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index,
					uint32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Fnb_tps)*uint32(unsafe.Sizeof(Topj_tp_index_t{})))
			} else {
				Xopj_free(tls, (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index+uintptr(it_tile)*56)).Ftp_index)
				(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr(it_tile)*56)).Ftp_index = uintptr(0)
			}

			// Packet index (NOT USED)
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr(it_tile)*56)).Fnb_packet = TOPJ_UINT32(0)
			(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer(l_cstr_index)).Ftile_index + uintptr(it_tile)*56)).Fpacket_index = uintptr(0)

		}
	}

	return l_cstr_index
}

func opj_j2k_allocate_tile_element_cstr_index(tls *libc.TLS, p_j2k uintptr) TOPJ_BOOL { /* j2k.c:11572:17: */
	var it_tile TOPJ_UINT32 = TOPJ_UINT32(0)

	(*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fnb_of_tiles = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth
	(*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index = Xopj_calloc(tls,
		uint32((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fnb_of_tiles), uint32(unsafe.Sizeof(Topj_tile_index_t{})))
	if !(int32((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index) != 0) {
		return DOPJ_FALSE
	}

	for it_tile = TOPJ_UINT32(0); it_tile < (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fnb_of_tiles; it_tile++ {
		(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr(it_tile)*56)).Fmaxmarknum = TOPJ_UINT32(100)
		(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr(it_tile)*56)).Fmarknum = TOPJ_UINT32(0)
		(*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index + uintptr(it_tile)*56)).Fmarker = Xopj_calloc(tls, uint32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmaxmarknum),
			uint32(unsafe.Sizeof(Topj_marker_info_t{})))
		if !(int32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr(it_tile)*56)).Fmarker) != 0) {
			return DOPJ_FALSE
		}
	}

	return DOPJ_TRUE
}

func opj_j2k_are_all_used_components_decoded(tls *libc.TLS, p_j2k uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:11597:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var compno TOPJ_UINT32
	var decoded_all_used_components TOPJ_BOOL = DOPJ_TRUE

	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_numcomps_to_decode != 0 {
		for compno = TOPJ_UINT32(0); compno < (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8 /* &.m_specific_param */)).Fm_numcomps_to_decode; compno++ {
			var dec_compno TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_comps_indices_to_decode + uintptr(compno)*4))
			if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps+uintptr(dec_compno)*64)).Fdata == uintptr(0) {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+24174,
					libc.VaList(bp, dec_compno))
				decoded_all_used_components = DOPJ_FALSE
			}
		}
	} else {
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fnumcomps; compno++ {
			if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps+uintptr(compno)*64)).Fdata == uintptr(0) {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+24174,
					libc.VaList(bp+8, compno))
				decoded_all_used_components = DOPJ_FALSE
			}
		}
	}

	if decoded_all_used_components == DOPJ_FALSE {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24205, 0)
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

func opj_j2k_decode_tiles(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:11633:17: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	*(*TOPJ_BOOL)(unsafe.Pointer(bp + 64 /* l_go_on */)) = DOPJ_TRUE
	// var l_current_tile_no TOPJ_UINT32 at bp+40, 4

	// var l_tile_x0 TOPJ_INT32 at bp+44, 4

	// var l_tile_y0 TOPJ_INT32 at bp+48, 4

	// var l_tile_x1 TOPJ_INT32 at bp+52, 4

	// var l_tile_y1 TOPJ_INT32 at bp+56, 4

	// var l_nb_comps TOPJ_UINT32 at bp+60, 4

	var nr_tiles TOPJ_UINT32 = TOPJ_UINT32(0)

	// Particular case for whole single tile decoding
	// We can avoid allocating intermediate tile buffers
	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw == TOPJ_UINT32(1) && (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth == TOPJ_UINT32(1) && (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftx0 == TOPJ_UINT32(0) && (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fty0 == TOPJ_UINT32(0) && (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fx0 == TOPJ_UINT32(0) && (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fy0 == TOPJ_UINT32(0) && (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fx1 == (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdx && (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fy1 == (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdy {
		var i TOPJ_UINT32
		if !(Xopj_j2k_read_tile_header(tls, p_j2k,
			bp+40,
			uintptr(0),
			bp+44, bp+48,
			bp+52, bp+56,
			bp+60,
			bp+64,
			p_stream,
			p_manager) != 0) {
			return DOPJ_FALSE
		}

		if !(Xopj_j2k_decode_tile(tls, p_j2k, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40)), uintptr(0), uint32(0),
			p_stream, p_manager) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24243, 0)
			return DOPJ_FALSE
		}

		// Transfer TCD data to output image data
		for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fnumcomps; i++ {
			Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps+uintptr(i)*64)).Fdata)
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(i)*64)).Fdata = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(i)*104)).Fdata
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(i)*64)).Fresno_decoded = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Fimage)).Fcomps + uintptr(i)*64)).Fresno_decoded
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(i)*104)).Fdata = uintptr(0)
		}

		return DOPJ_TRUE
	}

	for {
		if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw == TOPJ_UINT32(1) && (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth == TOPJ_UINT32(1) && (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps)).Fm_data != uintptr(0) {
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 40 /* l_current_tile_no */)) = TOPJ_UINT32(0)
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number = TOPJ_UINT32(0)
			*(*TOPJ_UINT32)(unsafe.Pointer(p_j2k + 8)) |= J2K_STATE_DATA
		} else {
			if !(Xopj_j2k_read_tile_header(tls, p_j2k,
				bp+40,
				uintptr(0),
				bp+44, bp+48,
				bp+52, bp+56,
				bp+60,
				bp+64,
				p_stream,
				p_manager) != 0) {
				return DOPJ_FALSE
			}

			if !(*(*TOPJ_BOOL)(unsafe.Pointer(bp + 64)) != 0) {
				break
			}
		}

		if !(Xopj_j2k_decode_tile(tls, p_j2k, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40)), uintptr(0), uint32(0),
			p_stream, p_manager) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24270,
				libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))+TOPJ_UINT32(1), (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw))
			return DOPJ_FALSE
		}

		Xopj_event_msg(tls, p_manager, DEVT_INFO, ts+24299,
			libc.VaList(bp+16, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))+TOPJ_UINT32(1), (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw))

		if !(opj_j2k_update_image_data(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd,
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image) != 0) {
			return DOPJ_FALSE
		}

		if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw == TOPJ_UINT32(1) && (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth == TOPJ_UINT32(1) && !((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fx0 == (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fx0 && (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fy0 == (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fy0 && (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fx1 == (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fx1 && (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fy1 == (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fy1) {
			// Keep current tcp data
		} else {
			opj_j2k_tcp_data_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 40)))*5696)
		}

		Xopj_event_msg(tls, p_manager, DEVT_INFO,
			ts+24329, libc.VaList(bp+32, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))+TOPJ_UINT32(1)))

		if Xopj_stream_get_number_byte_left(tls, p_stream) == 0 &&
			(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_NEOC {
			break
		}
		if libc.PreIncUint32(&nr_tiles, 1) == (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw {
			break
		}
	}

	if !(opj_j2k_are_all_used_components_decoded(tls, p_j2k, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

// *
// Sets up the procedures to do on decoding data. Developers wanting to extend the library can add their own reading procedures.
func opj_j2k_setup_decoding(tls *libc.TLS, p_j2k uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:11754:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(11758), uintptr(unsafe.Pointer(&__func__160)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(11759), uintptr(unsafe.Pointer(&__func__160)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_decode_tiles})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	// DEVELOPER CORNER, add your custom procedures

	return DOPJ_TRUE
}

var __func__160 = *(*[23]int8)(unsafe.Pointer(ts + 24373)) /* j2k.c:11756:1 */

// Read and decode one tile.
func opj_j2k_decode_one_tile(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:11773:17: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	*(*TOPJ_BOOL)(unsafe.Pointer(bp + 64 /* l_go_on */)) = DOPJ_TRUE
	// var l_current_tile_no TOPJ_UINT32 at bp+40, 4

	var l_tile_no_to_dec TOPJ_UINT32
	// var l_tile_x0 TOPJ_INT32 at bp+44, 4

	// var l_tile_y0 TOPJ_INT32 at bp+48, 4

	// var l_tile_x1 TOPJ_INT32 at bp+52, 4

	// var l_tile_y1 TOPJ_INT32 at bp+56, 4

	// var l_nb_comps TOPJ_UINT32 at bp+60, 4

	var l_nb_tiles TOPJ_UINT32
	var i TOPJ_UINT32

	//Allocate and initialize some elements of codestrem index if not already done
	if !(int32((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index) != 0) {
		if !(opj_j2k_allocate_tile_element_cstr_index(tls, p_j2k) != 0) {
			return DOPJ_FALSE
		}
	}
	// Move into the codestream to the first SOT used to decode the desired tile
	l_tile_no_to_dec = TOPJ_UINT32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_tile_ind_to_dec)
	if (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index != 0 {
		if (*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index)).Ftp_index != 0 {
			if !(int32((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr(l_tile_no_to_dec)*56)).Fnb_tps) != 0) {
				// the index for this tile has not been built,
				//  so move to the last SOT read
				if !(Xopj_stream_read_seek(tls, p_stream,
					(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_last_sot_read_pos+2, p_manager) != 0) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24396, 0)
					return DOPJ_FALSE
				}
			} else {
				if !(Xopj_stream_read_seek(tls, p_stream,
					(*Topj_tp_index_t)(unsafe.Pointer((*Topj_tile_index_t)(unsafe.Pointer((*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Ftile_index+uintptr(l_tile_no_to_dec)*56)).Ftp_index)).Fstart_pos+2,
					p_manager) != 0) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24396, 0)
					return DOPJ_FALSE
				}
			}
			// Special case if we have previously read the EOC marker (if the previous tile getted is the last )
			if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_state == J2K_STATE_EOC {
				(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_state = J2K_STATE_TPHSOT
			}
		}
	}

	// Reset current tile part number for all tiles, and not only the one
	// of interest.
	// Not completely sure this is always correct but required for
	// ./build/bin/j2k_random_tile_access ./build/tests/tte1.j2k
	l_nb_tiles = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth
	for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
		(*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr(i)*5696)).Fm_current_tile_part_number = -1
	}

	for {
		if !(Xopj_j2k_read_tile_header(tls, p_j2k,
			bp+40,
			uintptr(0),
			bp+44, bp+48,
			bp+52, bp+56,
			bp+60,
			bp+64,
			p_stream,
			p_manager) != 0) {
			return DOPJ_FALSE
		}

		if !(*(*TOPJ_BOOL)(unsafe.Pointer(bp + 64)) != 0) {
			break
		}

		if !(Xopj_j2k_decode_tile(tls, p_j2k, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40)), uintptr(0), uint32(0),
			p_stream, p_manager) != 0) {
			return DOPJ_FALSE
		}
		Xopj_event_msg(tls, p_manager, DEVT_INFO, ts+24299,
			libc.VaList(bp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))+TOPJ_UINT32(1), (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw))

		if !(opj_j2k_update_image_data(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd,
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image) != 0) {
			return DOPJ_FALSE
		}
		opj_j2k_tcp_data_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps+uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 40)))*5696)

		Xopj_event_msg(tls, p_manager, DEVT_INFO,
			ts+24329, libc.VaList(bp+16, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))+TOPJ_UINT32(1)))

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40)) == l_tile_no_to_dec {
			// move into the codestream to the first SOT (FIXME or not move?)
			if !(Xopj_stream_read_seek(tls, p_stream, (*Topj_codestream_index_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index)).Fmain_head_end+2,
				p_manager) != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24396, 0)
				return DOPJ_FALSE
			}
			break
		} else {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+24424,
				libc.VaList(bp+24, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))+TOPJ_UINT32(1), l_tile_no_to_dec+TOPJ_UINT32(1)))
		}

	}

	if !(opj_j2k_are_all_used_components_decoded(tls, p_j2k, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

// *
// Sets up the procedures to do on decoding one tile. Developers wanting to extend the library can add their own reading procedures.
func opj_j2k_setup_decoding_tile(tls *libc.TLS, p_j2k uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:11886:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(11890), uintptr(unsafe.Pointer(&__func__161)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(11891), uintptr(unsafe.Pointer(&__func__161)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_decode_one_tile})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	// DEVELOPER CORNER, add your custom procedures

	return DOPJ_TRUE
}

var __func__161 = *(*[28]int8)(unsafe.Pointer(ts + 24491)) /* j2k.c:11888:1 */

func opj_j2k_move_data_from_codec_to_output_image(tls *libc.TLS, p_j2k uintptr, p_image uintptr) TOPJ_BOOL { /* j2k.c:11902:17: */
	var compno TOPJ_UINT32

	// Move data and copy one information from codec to output image
	if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_numcomps_to_decode > TOPJ_UINT32(0) {
		var newcomps uintptr = Xopj_malloc(tls,
			uint32((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_numcomps_to_decode)*uint32(unsafe.Sizeof(Topj_image_comp_t{})))
		if newcomps == uintptr(0) {
			Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)
			(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = uintptr(0)
			return DOPJ_FALSE
		}
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; compno++ {
			Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps+uintptr(compno)*64)).Fdata)
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps + uintptr(compno)*64)).Fdata = uintptr(0)
		}
		for compno = TOPJ_UINT32(0); compno < (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8 /* &.m_specific_param */)).Fm_numcomps_to_decode; compno++ {
			var src_compno TOPJ_UINT32 = *(*TOPJ_UINT32)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_comps_indices_to_decode + uintptr(compno)*4))
			libc.Xmemcpy(tls, newcomps+uintptr(compno)*64,
				(*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps+uintptr(src_compno)*64,
				uint32(unsafe.Sizeof(Topj_image_comp_t{})))
			(*Topj_image_comp_t)(unsafe.Pointer(newcomps + uintptr(compno)*64)).Fresno_decoded = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(src_compno)*64)).Fresno_decoded
			(*Topj_image_comp_t)(unsafe.Pointer(newcomps + uintptr(compno)*64)).Fdata = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(src_compno)*64)).Fdata
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(src_compno)*64)).Fdata = uintptr(0)
		}
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; compno++ {
			if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps+uintptr(compno)*64)).Fdata == uintptr(0) {
			} else {
				libc.X__assert_fail(tls, ts+24519, ts+3645, uint32(11935), uintptr(unsafe.Pointer(&__func__162)))
			}
			Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps+uintptr(compno)*64)).Fdata)
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(compno)*64)).Fdata = uintptr(0)
		}
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps = (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_numcomps_to_decode
		Xopj_free(tls, (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps)
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps = newcomps
	} else {
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; compno++ {
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps + uintptr(compno)*64)).Fresno_decoded = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(compno)*64)).Fresno_decoded
			Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps+uintptr(compno)*64)).Fdata)
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps + uintptr(compno)*64)).Fdata = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(compno)*64)).Fdata
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)).Fcomps + uintptr(compno)*64)).Fdata = uintptr(0)
		}
	}
	return DOPJ_TRUE
}

var __func__162 = *(*[45]int8)(unsafe.Pointer(ts + 24569)) /* j2k.c:11904:1 */

func Xopj_j2k_decode(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_image uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:11962:10: */
	if !(p_image != 0) {
		return DOPJ_FALSE
	}

	// Heuristics to detect sequence opj_read_header(), opj_set_decoded_resolution_factor()
	// and finally opj_decode_image() without manual setting of comps[].factor
	// We could potentially always execute it, if we don't allow people to do
	// opj_read_header(), modify x0,y0,x1,y1 of returned image an call opj_decode_image()
	if (*Topj_decoding_param_t)(unsafe.Pointer(p_j2k+112+120)).Fm_reduce > TOPJ_UINT32(0) && (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image != uintptr(0) && (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps > TOPJ_UINT32(0) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fcomps)).Ffactor == (*Topj_decoding_param_t)(unsafe.Pointer(p_j2k+112+120)).Fm_reduce && (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps > TOPJ_UINT32(0) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps)).Ffactor == TOPJ_UINT32(0) && (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps)).Fdata == uintptr(0) {
		var it_comp TOPJ_UINT32

		// Update the comps[].factor member of the output image with the one
		// of m_reduce
		for it_comp = TOPJ_UINT32(0); it_comp < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; it_comp++ {
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps + uintptr(it_comp)*64)).Ffactor = (*Topj_decoding_param_t)(unsafe.Pointer(p_j2k + 112 + 120)).Fm_reduce
		}
		if !(opj_j2k_update_image_dimensions(tls, p_image, p_manager) != 0) {
			return DOPJ_FALSE
		}
	}

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image == uintptr(0) {
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image = Xopj_image_create0(tls)
		if !(int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image) != 0) {
			return DOPJ_FALSE
		}
	}
	Xopj_copy_image_header(tls, p_image, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)

	// customization of the decoding
	if !(opj_j2k_setup_decoding(tls, p_j2k, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// Decode the codestream
	if !(opj_j2k_exec(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list, p_stream, p_manager) != 0) {
		Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = uintptr(0)
		return DOPJ_FALSE
	}

	// Move data and copy one information from codec to output image
	return opj_j2k_move_data_from_codec_to_output_image(tls, p_j2k, p_image)
}

func Xopj_j2k_get_tile(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_image uintptr, p_manager uintptr, tile_index TOPJ_UINT32) TOPJ_BOOL { /* j2k.c:12020:10: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var compno TOPJ_UINT32
	var l_tile_x TOPJ_UINT32
	var l_tile_y TOPJ_UINT32
	var l_img_comp uintptr

	if !(p_image != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24614, 0)
		return DOPJ_FALSE
	}

	if (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+24652, 0)
		return DOPJ_FALSE
	}

	if tile_index >= (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+24696, libc.VaList(bp, tile_index,
				(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth-TOPJ_UINT32(1)))
		return DOPJ_FALSE
	}

	// Compute the dimension of the desired tile
	l_tile_x = tile_index % (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw
	l_tile_y = tile_index / (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw

	(*Topj_image_t)(unsafe.Pointer(p_image)).Fx0 = l_tile_x*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdx + (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftx0
	if (*Topj_image_t)(unsafe.Pointer(p_image)).Fx0 < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fx0 {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fx0 = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fx0
	}
	(*Topj_image_t)(unsafe.Pointer(p_image)).Fx1 = (l_tile_x+TOPJ_UINT32(1))*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdx + (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftx0
	if (*Topj_image_t)(unsafe.Pointer(p_image)).Fx1 > (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fx1 {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fx1 = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fx1
	}

	(*Topj_image_t)(unsafe.Pointer(p_image)).Fy0 = l_tile_y*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdy + (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fty0
	if (*Topj_image_t)(unsafe.Pointer(p_image)).Fy0 < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fy0 {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fy0 = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fy0
	}
	(*Topj_image_t)(unsafe.Pointer(p_image)).Fy1 = (l_tile_y+TOPJ_UINT32(1))*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftdy + (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fty0
	if (*Topj_image_t)(unsafe.Pointer(p_image)).Fy1 > (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fy1 {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fy1 = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fy1
	}

	l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps
	for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; compno++ {
		var l_comp_x1 TOPJ_INT32
		var l_comp_y1 TOPJ_INT32

		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fcomps + uintptr(compno)*64)).Ffactor

		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fx0 = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(p_image)).Fx0),
			TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)))
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fy0 = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(p_image)).Fy0),
			TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)))
		l_comp_x1 = opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(p_image)).Fx1), TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx))
		l_comp_y1 = opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(p_image)).Fy1), TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy))

		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fw = TOPJ_UINT32(opj_int_ceildivpow2(tls, l_comp_x1,
			TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor)) - opj_int_ceildivpow2(tls, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fx0),
			TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor)))
		(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fh = TOPJ_UINT32(opj_int_ceildivpow2(tls, l_comp_y1,
			TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor)) - opj_int_ceildivpow2(tls, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fy0),
			TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Ffactor)))

		l_img_comp += 64
	}

	if (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps > (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps {
		// Can happen when calling repeatdly opj_get_decoded_tile() on an
		// image with a color palette, where color palette expansion is done
		// later in jp2.c
		for compno = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; compno < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; compno++ {
			Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps+uintptr(compno)*64)).Fdata)
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps + uintptr(compno)*64)).Fdata = uintptr(0)
		}
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps = (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps
	}

	// Destroy the previous output image
	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image != 0 {
		Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)
	}

	// Create the output image from the information previously computed
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image = Xopj_image_create0(tls)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image) != 0) {
		return DOPJ_FALSE
	}
	Xopj_copy_image_header(tls, p_image, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_output_image)

	(*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k + 8)).Fm_tile_ind_to_dec = TOPJ_INT32(tile_index)

	// customization of the decoding
	if !(opj_j2k_setup_decoding_tile(tls, p_j2k, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// Decode the codestream
	if !(opj_j2k_exec(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list, p_stream, p_manager) != 0) {
		Xopj_image_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = uintptr(0)
		return DOPJ_FALSE
	}

	// Move data and copy one information from codec to output image
	return opj_j2k_move_data_from_codec_to_output_image(tls, p_j2k, p_image)
}

func Xopj_j2k_set_decoded_resolution_factor(tls *libc.TLS, p_j2k uintptr, res_factor TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12135:10: */
	var it_comp TOPJ_UINT32

	(*Topj_decoding_param_t)(unsafe.Pointer(p_j2k + 112 + 120)).Fm_reduce = res_factor

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image != 0 {
		if (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fcomps != 0 {
			if (*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp != 0 {
				if (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp)).Ftccps != 0 {
					for it_comp = TOPJ_UINT32(0); it_comp < (*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fnumcomps; it_comp++ {
						var max_res TOPJ_UINT32 = (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_dec_t)(unsafe.Pointer(p_j2k+8)).Fm_default_tcp)).Ftccps + uintptr(it_comp)*1080)).Fnumresolutions
						if res_factor >= max_res {
							Xopj_event_msg(tls, p_manager, DEVT_ERROR,
								ts+24757, 0)
							return DOPJ_FALSE
						}
						(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fcomps + uintptr(it_comp)*64)).Ffactor = res_factor
					}
					return DOPJ_TRUE
				}
			}
		}
	}

	return DOPJ_FALSE
}

// -----------------------------------------------------------------------

func Xopj_j2k_encoder_set_extra_options(tls *libc.TLS, p_j2k uintptr, p_options uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12168:10: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p_option_iter uintptr

	if p_options == uintptr(0) {
		return DOPJ_TRUE
	}

	for p_option_iter = p_options; *(*uintptr)(unsafe.Pointer(p_option_iter)) != uintptr(0); p_option_iter += 8 {
		if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(p_option_iter)), ts+24833, uint32(4)) == 0 {
			if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(p_option_iter)), ts+24838) == 0 {
				(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_PLT = DOPJ_TRUE
			} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(p_option_iter)), ts+24846) == 0 {
				(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_PLT = DOPJ_FALSE
			} else {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+24853, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(p_option_iter))))
				return DOPJ_FALSE
			}
		} else if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(p_option_iter)), ts+24884, uint32(4)) == 0 {
			if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(p_option_iter)), ts+24889) == 0 {
				(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_TLM = DOPJ_TRUE
			} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(p_option_iter)), ts+24897) == 0 {
				(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_TLM = DOPJ_FALSE
			} else {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+24853, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(p_option_iter))))
				return DOPJ_FALSE
			}
		} else if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(p_option_iter)), ts+24904, libc.Xstrlen(tls, ts+24904)) == 0 {
			var tileno TOPJ_UINT32
			var cp uintptr = p_j2k + 112

			var numgbits int32 = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(p_option_iter))+uintptr(libc.Xstrlen(tls, ts+24904)))
			if numgbits < 0 || numgbits > 7 {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+24916, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(p_option_iter))))
				return DOPJ_FALSE
			}

			for tileno = TOPJ_UINT32(0); tileno < (*Topj_cp_t)(unsafe.Pointer(cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(cp)).Fth; tileno++ {
				var i TOPJ_UINT32
				var tcp uintptr = (*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps + uintptr(tileno)*5696
				for i = TOPJ_UINT32(0); i < (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8 /* &.m_specific_param */)).Fm_nb_comps; i++ {
					var tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps + uintptr(i)*1080
					(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumgbits = TOPJ_UINT32(numgbits)
				}
			}
		} else {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+24966, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(p_option_iter))))
			return DOPJ_FALSE
		}
	}

	return DOPJ_TRUE
}

// -----------------------------------------------------------------------

func Xopj_j2k_encode(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12231:10: */
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var l_nb_tiles TOPJ_UINT32
	var l_max_tile_size TOPJ_SIZE_T = TOPJ_SIZE_T(0)
	var l_current_tile_size TOPJ_SIZE_T
	var l_current_data uintptr = uintptr(00)
	var l_reuse_data TOPJ_BOOL = DOPJ_FALSE
	var p_tcd uintptr = uintptr(00)

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(12243), uintptr(unsafe.Pointer(&__func__163)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(12244), uintptr(unsafe.Pointer(&__func__163)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(12245), uintptr(unsafe.Pointer(&__func__163)))
	}

	p_tcd = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd

	l_nb_tiles = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth * (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw
	if l_nb_tiles == TOPJ_UINT32(1) {
		l_reuse_data = DOPJ_TRUE
		for j = TOPJ_UINT32(0); j < (*Topj_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Fimage)).Fnumcomps; j++ {
			var l_img_comp uintptr = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps + uintptr(j)*64
			if Tsize_t((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdata)&0xF != 0 { // tile data shall be aligned on 16 bytes
				l_reuse_data = DOPJ_FALSE
			}
		}
	}
	for i = TOPJ_UINT32(0); i < l_nb_tiles; i++ {
		if !(opj_j2k_pre_write_tile(tls, p_j2k, i, p_stream, p_manager) != 0) {
			if l_current_data != 0 {
				Xopj_free(tls, l_current_data)
			}
			return DOPJ_FALSE
		}

		// if we only have one tile, then simply set tile component data equal to image component data
		// otherwise, allocate the data
		for j = TOPJ_UINT32(0); j < (*Topj_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Fimage)).Fnumcomps; j++ {
			var l_tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(j)*104
			if l_reuse_data != 0 {
				var l_img_comp uintptr = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps + uintptr(j)*64
				(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdata
				(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).FownsData = DOPJ_FALSE
			} else {
				if !(Xopj_alloc_tile_component_data(tls, l_tilec) != 0) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24987, 0)
					if l_current_data != 0 {
						Xopj_free(tls, l_current_data)
					}
					return DOPJ_FALSE
				}
			}
		}
		l_current_tile_size = Xopj_tcd_get_encoder_input_buffer_size(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)
		if !(l_reuse_data != 0) {
			if l_current_tile_size > l_max_tile_size {
				var l_new_current_data uintptr = Xopj_realloc(tls, l_current_data,
					l_current_tile_size)
				if !(l_new_current_data != 0) {
					if l_current_data != 0 {
						Xopj_free(tls, l_current_data)
					}
					Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+25025, 0)
					return DOPJ_FALSE
				}
				l_current_data = l_new_current_data
				l_max_tile_size = l_current_tile_size
			}
			if l_current_data == uintptr(0) {
				// Should not happen in practice, but will avoid Coverity to
				// complain about a null pointer dereference
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts+14285, ts+3645, uint32(12306), uintptr(unsafe.Pointer(&__func__163)))
				}
				return DOPJ_FALSE
			}

			// copy image data (32 bit) to l_current_data as contiguous, all-component, zero offset buffer
			// 32 bit components @ 8 bit precision get converted to 8 bit
			// 32 bit components @ 16 bit precision get converted to 16 bit
			opj_j2k_get_tile_data(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, l_current_data)

			// now copy this data into the tile component
			if !(Xopj_tcd_copy_tile_data(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, l_current_data,
				l_current_tile_size) != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+25064, 0)
				Xopj_free(tls, l_current_data)
				return DOPJ_FALSE
			}
		}

		if !(opj_j2k_post_write_tile(tls, p_j2k, p_stream, p_manager) != 0) {
			if l_current_data != 0 {
				Xopj_free(tls, l_current_data)
			}
			return DOPJ_FALSE
		}
	}

	if l_current_data != 0 {
		Xopj_free(tls, l_current_data)
	}
	return DOPJ_TRUE
}

var __func__163 = *(*[15]int8)(unsafe.Pointer(ts + 25111)) /* j2k.c:12234:1 */

func Xopj_j2k_end_compress(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12339:10: */
	// customization of the encoding
	if !(opj_j2k_setup_end_compress(tls, p_j2k, p_manager) != 0) {
		return DOPJ_FALSE
	}

	if !(opj_j2k_exec(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

func Xopj_j2k_start_compress(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_image uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12355:10: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(12361), uintptr(unsafe.Pointer(&__func__164)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(12362), uintptr(unsafe.Pointer(&__func__164)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(12363), uintptr(unsafe.Pointer(&__func__164)))
	}

	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image = Xopj_image_create0(tls)
	if !(int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+25126, 0)
		return DOPJ_FALSE
	}
	Xopj_copy_image_header(tls, p_image, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)

	// TODO_MSD: Find a better way
	if (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps != 0 {
		var it_comp TOPJ_UINT32
		for it_comp = TOPJ_UINT32(0); it_comp < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; it_comp++ {
			if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps+uintptr(it_comp)*64)).Fdata != 0 {
				(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image)).Fcomps + uintptr(it_comp)*64)).Fdata = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps + uintptr(it_comp)*64)).Fdata
				(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps + uintptr(it_comp)*64)).Fdata = uintptr(0)

			}
		}
	}

	// customization of the validation
	if !(opj_j2k_setup_encoding_validation(tls, p_j2k, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// validation of the parameters codec
	if !(opj_j2k_exec(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// customization of the encoding
	if !(opj_j2k_setup_header_writing(tls, p_j2k, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// write header
	if !(opj_j2k_exec(tls, p_j2k, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__164 = *(*[23]int8)(unsafe.Pointer(ts + 25159)) /* j2k.c:12359:1 */

func opj_j2k_pre_write_tile(tls *libc.TLS, p_j2k uintptr, p_tile_index TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12407:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	_ = p_stream
	if p_tile_index != (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+25182, 0)
		return DOPJ_FALSE
	}

	Xopj_event_msg(tls, p_manager, DEVT_INFO, ts+25219,
		libc.VaList(bp, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number+TOPJ_UINT32(1), (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftw*(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fth))

	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_current_tile_part_number = TOPJ_UINT32(0)
	(*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Fcur_totnum_tp = (*Topj_tcp_t)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Ftcps + uintptr(p_tile_index)*5696)).Fm_nb_tile_parts
	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_current_poc_tile_part_number = TOPJ_UINT32(0)

	// initialisation before tile encoding
	if !(Xopj_tcd_init_encode_tile(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number,
		p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

func opj_get_tile_dimensions(tls *libc.TLS, l_image uintptr, l_tilec uintptr, l_img_comp uintptr, l_size_comp uintptr, l_width uintptr, l_height uintptr, l_offset_x uintptr, l_offset_y uintptr, l_image_width uintptr, l_stride uintptr, l_tile_offset uintptr) { /* j2k.c:12434:13: */
	var l_remaining TOPJ_UINT32
	*(*TOPJ_UINT32)(unsafe.Pointer(l_size_comp)) = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec >> 3 // (/8)
	l_remaining = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec & TOPJ_UINT32(7)                      // (%8)
	if l_remaining != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(l_size_comp)) += TOPJ_UINT32(1)
	}

	if *(*TOPJ_UINT32)(unsafe.Pointer(l_size_comp)) == TOPJ_UINT32(3) {
		*(*TOPJ_UINT32)(unsafe.Pointer(l_size_comp)) = TOPJ_UINT32(4)
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(l_width)) = TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx1 - (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0)
	*(*TOPJ_UINT32)(unsafe.Pointer(l_height)) = TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy1 - (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0)
	*(*TOPJ_UINT32)(unsafe.Pointer(l_offset_x)) = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fx0),
		TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)))
	*(*TOPJ_UINT32)(unsafe.Pointer(l_offset_y)) = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fy0),
		TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)))
	*(*TOPJ_UINT32)(unsafe.Pointer(l_image_width)) = TOPJ_UINT32(opj_int_ceildiv(tls, TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fx1)-TOPJ_INT32((*Topj_image_t)(unsafe.Pointer(l_image)).Fx0), TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)))
	*(*TOPJ_UINT32)(unsafe.Pointer(l_stride)) = *(*TOPJ_UINT32)(unsafe.Pointer(l_image_width)) - *(*TOPJ_UINT32)(unsafe.Pointer(l_width))
	*(*TOPJ_UINT32)(unsafe.Pointer(l_tile_offset)) = TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0) - *(*TOPJ_UINT32)(unsafe.Pointer(l_offset_x)) + (TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0)-*(*TOPJ_UINT32)(unsafe.Pointer(l_offset_y)))**(*TOPJ_UINT32)(unsafe.Pointer(l_image_width))
}

func opj_j2k_get_tile_data(tls *libc.TLS, p_tcd uintptr, p_data uintptr) { /* j2k.c:12470:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var k TOPJ_UINT32 = TOPJ_UINT32(0)

	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; i++ {
		var l_image uintptr = (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage
		var l_src_ptr uintptr
		var l_tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(i)*104
		var l_img_comp uintptr = (*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps + uintptr(i)*64
		// var l_size_comp TOPJ_UINT32 at bp, 4

		// var l_width TOPJ_UINT32 at bp+4, 4

		// var l_height TOPJ_UINT32 at bp+8, 4

		// var l_offset_x TOPJ_UINT32 at bp+12, 4

		// var l_offset_y TOPJ_UINT32 at bp+16, 4

		// var l_image_width TOPJ_UINT32 at bp+20, 4

		// var l_stride TOPJ_UINT32 at bp+24, 4

		// var l_tile_offset TOPJ_UINT32 at bp+28, 4

		opj_get_tile_dimensions(tls, l_image,
			l_tilec,
			l_img_comp,
			bp,
			bp+4,
			bp+8,
			bp+12,
			bp+16,
			bp+20,
			bp+24,
			bp+28)

		l_src_ptr = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdata + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 28)))*4

		switch *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_size_comp */)) {
		case TOPJ_UINT32(1):
			{
				var l_dest_ptr uintptr = p_data
				if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd != 0 {
					for j = TOPJ_UINT32(0); j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_height */)); j++ {
						for k = TOPJ_UINT32(0); k < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_width */)); k++ {
							*(*TOPJ_CHAR)(unsafe.Pointer(l_dest_ptr)) = TOPJ_CHAR(*(*TOPJ_INT32)(unsafe.Pointer(l_src_ptr)))
							l_dest_ptr++
							l_src_ptr += 4
						}
						l_src_ptr += 4 * uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)))
					}
				} else {
					for j = TOPJ_UINT32(0); j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_height */)); j++ {
						for k = TOPJ_UINT32(0); k < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_width */)); k++ {
							*(*TOPJ_CHAR)(unsafe.Pointer(l_dest_ptr)) = TOPJ_CHAR(*(*TOPJ_INT32)(unsafe.Pointer(l_src_ptr)) & 0xff)
							l_dest_ptr++
							l_src_ptr += 4
						}
						l_src_ptr += 4 * uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)))
					}
				}

				p_data = l_dest_ptr

			}
			break
		case TOPJ_UINT32(2):
			{
				var l_dest_ptr uintptr = p_data
				if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd != 0 {
					for j = TOPJ_UINT32(0); j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_height */)); j++ {
						for k = TOPJ_UINT32(0); k < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_width */)); k++ {
							*(*TOPJ_INT16)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 2))) = TOPJ_INT16(*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 4))))
						}
						l_src_ptr += 4 * uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)))
					}
				} else {
					for j = TOPJ_UINT32(0); j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_height */)); j++ {
						for k = TOPJ_UINT32(0); k < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_width */)); k++ {
							*(*TOPJ_INT16)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 2))) = TOPJ_INT16(*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 4))) & 0xffff)
						}
						l_src_ptr += 4 * uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)))
					}
				}

				p_data = l_dest_ptr

			}
			break
		case TOPJ_UINT32(4):
			{
				var l_dest_ptr uintptr = p_data
				for j = TOPJ_UINT32(0); j < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_height */)); j++ {
					for k = TOPJ_UINT32(0); k < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_width */)); k++ {
						*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 4))) = *(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 4)))
					}
					l_src_ptr += 4 * uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)))
				}

				p_data = l_dest_ptr

			}
			break
		}
	}
}

func opj_j2k_post_write_tile(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12559:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var l_nb_bytes_written TOPJ_UINT32 at bp, 4

	var l_current_data uintptr = uintptr(00)
	var l_tile_size TOPJ_UINT32 = TOPJ_UINT32(0)
	var l_available_data TOPJ_UINT32

	// preconditions
	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_encoded_tile_data != 0 {
	} else {
		libc.X__assert_fail(tls, ts+25240, ts+3645, uint32(12569), uintptr(unsafe.Pointer(&__func__165)))
	}

	l_tile_size = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_encoded_tile_size
	l_available_data = l_tile_size
	l_current_data = (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_encoded_tile_data

	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes_written */)) = TOPJ_UINT32(0)
	if !(opj_j2k_write_first_tile_part(tls, p_j2k, l_current_data, bp,
		l_available_data, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}
	l_current_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes_written */)))
	l_available_data = l_available_data - *(*TOPJ_UINT32)(unsafe.Pointer(bp))

	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes_written */)) = TOPJ_UINT32(0)
	if !(opj_j2k_write_all_tile_parts(tls, p_j2k, l_current_data, bp,
		l_available_data, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	l_available_data = l_available_data - *(*TOPJ_UINT32)(unsafe.Pointer(bp))
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes_written */)) = l_tile_size - l_available_data

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_encoded_tile_data,
		uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp))), p_manager) != TOPJ_SIZE_T(*(*TOPJ_UINT32)(unsafe.Pointer(bp))) {
		return DOPJ_FALSE
	}

	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number++

	return DOPJ_TRUE
}

var __func__165 = *(*[24]int8)(unsafe.Pointer(ts + 25294)) /* j2k.c:12562:1 */

func opj_j2k_setup_end_compress(tls *libc.TLS, p_j2k uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12603:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(12607), uintptr(unsafe.Pointer(&__func__166)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(12608), uintptr(unsafe.Pointer(&__func__166)))
	}

	// DEVELOPER CORNER, insert your custom procedures
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_eoc})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_TLM != 0 {
		if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			}{opj_j2k_write_updated_tlm})), p_manager) != 0) {
			return DOPJ_FALSE
		}
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_epc})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_end_encoding})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_destroy_header_memory})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	return DOPJ_TRUE
}

var __func__166 = *(*[27]int8)(unsafe.Pointer(ts + 25318)) /* j2k.c:12605:1 */

func opj_j2k_setup_encoding_validation(tls *libc.TLS, p_j2k uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12638:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(12642), uintptr(unsafe.Pointer(&__func__167)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(12643), uintptr(unsafe.Pointer(&__func__167)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_build_encoder})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_encoding_validation})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	// DEVELOPER CORNER, add your custom validation procedure
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_validation_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_mct_validation})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__167 = *(*[34]int8)(unsafe.Pointer(ts + 25345)) /* j2k.c:12640:1 */

func opj_j2k_setup_header_writing(tls *libc.TLS, p_j2k uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12663:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(12667), uintptr(unsafe.Pointer(&__func__168)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(12668), uintptr(unsafe.Pointer(&__func__168)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_init_info})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_soc})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_siz})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_cod})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_qcd})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_all_coc})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_all_qcc})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_TLM != 0 {
		if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			}{opj_j2k_write_tlm})), p_manager) != 0) {
			return DOPJ_FALSE
		}

		if int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Frsiz) == DOPJ_PROFILE_CINEMA_4K {
			if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
				}{opj_j2k_write_poc})), p_manager) != 0) {
				return DOPJ_FALSE
			}
		}
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_write_regions})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Fcomment != uintptr(00) {
		if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			}{opj_j2k_write_com})), p_manager) != 0) {
			return DOPJ_FALSE
		}
	}

	// DEVELOPER CORNER, insert your custom procedures
	if int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_cp.Frsiz)&(DOPJ_PROFILE_PART2|DOPJ_EXTENSION_MCT) == DOPJ_PROFILE_PART2|DOPJ_EXTENSION_MCT {
		if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			}{opj_j2k_write_mct_data_group})), p_manager) != 0) {
			return DOPJ_FALSE
		}
	}
	// End of Developer Corner

	if (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fcstr_index != 0 {
		if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			}{opj_j2k_get_end_header})), p_manager) != 0) {
			return DOPJ_FALSE
		}
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_create_tcd})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_j2k_update_rates})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__168 = *(*[29]int8)(unsafe.Pointer(ts + 25379)) /* j2k.c:12665:1 */

func opj_j2k_write_first_tile_part(tls *libc.TLS, p_j2k uintptr, p_data uintptr, p_data_written uintptr, total_data_size TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12754:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_nb_bytes_written TOPJ_UINT32 = TOPJ_UINT32(0)
	// var l_current_nb_bytes_written TOPJ_UINT32 at bp, 4

	var l_begin_data uintptr = uintptr(00)

	var l_tcd uintptr = uintptr(00)
	var l_cp uintptr = uintptr(00)

	l_tcd = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd
	l_cp = p_j2k + 112

	(*Topj_tcd_t)(unsafe.Pointer(l_tcd)).Fcur_pino = TOPJ_UINT32(0)

	//Get number of tile parts
	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_current_poc_tile_part_number = TOPJ_UINT32(0)

	// INDEX >>
	// << INDEX

	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)) = TOPJ_UINT32(0)
	l_begin_data = p_data
	if !(opj_j2k_write_sot(tls, p_j2k, p_data, total_data_size,
		bp, p_stream,
		p_manager) != 0) {
		return DOPJ_FALSE
	}

	l_nb_bytes_written = l_nb_bytes_written + *(*TOPJ_UINT32)(unsafe.Pointer(bp))
	p_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)))
	total_data_size = total_data_size - *(*TOPJ_UINT32)(unsafe.Pointer(bp))

	if !(int32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Frsiz) <= DOPJ_PROFILE_CINEMA_S4K) {
		if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696 + 5688))&0x4>>2)) != 0 {
			*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)) = TOPJ_UINT32(0)
			opj_j2k_write_poc_in_memory(tls, p_j2k, p_data, bp,
				p_manager)
			l_nb_bytes_written = l_nb_bytes_written + *(*TOPJ_UINT32)(unsafe.Pointer(bp))
			p_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)))
			total_data_size = total_data_size - *(*TOPJ_UINT32)(unsafe.Pointer(bp))
		}
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)) = TOPJ_UINT32(0)
	if !(opj_j2k_write_sod(tls, p_j2k, l_tcd, p_data, bp,
		total_data_size, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	l_nb_bytes_written = l_nb_bytes_written + *(*TOPJ_UINT32)(unsafe.Pointer(bp))
	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = l_nb_bytes_written

	// Writing Psot in SOT marker
	Xopj_write_bytes_LE(tls, l_begin_data+uintptr(6), l_nb_bytes_written,
		uint32(4)) // PSOT

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_TLM != 0 {
		opj_j2k_update_tlm(tls, p_j2k, l_nb_bytes_written)
	}

	return DOPJ_TRUE
}

func opj_j2k_write_all_tile_parts(tls *libc.TLS, p_j2k uintptr, p_data uintptr, p_data_written uintptr, total_data_size TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12839:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var tilepartno TOPJ_UINT32 = TOPJ_UINT32(0)
	var l_nb_bytes_written TOPJ_UINT32 = TOPJ_UINT32(0)
	// var l_current_nb_bytes_written TOPJ_UINT32 at bp, 4

	var l_part_tile_size TOPJ_UINT32
	var tot_num_tp TOPJ_UINT32
	var pino TOPJ_UINT32
	var l_begin_data uintptr
	var l_tcp uintptr = uintptr(00)
	var l_tcd uintptr = uintptr(00)
	var l_cp uintptr = uintptr(00)

	l_tcd = (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd
	l_cp = p_j2k + 112
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)*5696

	//Get number of tile parts
	tot_num_tp = opj_j2k_get_num_tp(tls, l_cp, uint32(0), (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)

	// start writing remaining tile parts
	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_current_tile_part_number++
	for tilepartno = TOPJ_UINT32(1); tilepartno < tot_num_tp; tilepartno++ {
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_current_poc_tile_part_number = tilepartno
		*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)) = TOPJ_UINT32(0)
		l_part_tile_size = TOPJ_UINT32(0)
		l_begin_data = p_data

		if !(opj_j2k_write_sot(tls, p_j2k, p_data,
			total_data_size,
			bp,
			p_stream,
			p_manager) != 0) {
			return DOPJ_FALSE
		}

		l_nb_bytes_written = l_nb_bytes_written + *(*TOPJ_UINT32)(unsafe.Pointer(bp))
		p_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)))
		total_data_size = total_data_size - *(*TOPJ_UINT32)(unsafe.Pointer(bp))
		l_part_tile_size = l_part_tile_size + *(*TOPJ_UINT32)(unsafe.Pointer(bp))

		*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)) = TOPJ_UINT32(0)
		if !(opj_j2k_write_sod(tls, p_j2k, l_tcd, p_data, bp,
			total_data_size, p_stream, p_manager) != 0) {
			return DOPJ_FALSE
		}

		p_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)))
		l_nb_bytes_written = l_nb_bytes_written + *(*TOPJ_UINT32)(unsafe.Pointer(bp))
		total_data_size = total_data_size - *(*TOPJ_UINT32)(unsafe.Pointer(bp))
		l_part_tile_size = l_part_tile_size + *(*TOPJ_UINT32)(unsafe.Pointer(bp))

		// Writing Psot in SOT marker
		Xopj_write_bytes_LE(tls, l_begin_data+uintptr(6), l_part_tile_size,
			uint32(4)) // PSOT

		if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_TLM != 0 {
			opj_j2k_update_tlm(tls, p_j2k, l_part_tile_size)
		}

		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_current_tile_part_number++
	}

	for pino = TOPJ_UINT32(1); pino <= (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs; pino++ {
		(*Topj_tcd_t)(unsafe.Pointer(l_tcd)).Fcur_pino = pino

		//Get number of tile parts
		tot_num_tp = opj_j2k_get_num_tp(tls, l_cp, pino, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_current_tile_number)
		for tilepartno = TOPJ_UINT32(0); tilepartno < tot_num_tp; tilepartno++ {
			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_current_poc_tile_part_number = tilepartno
			*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)) = TOPJ_UINT32(0)
			l_part_tile_size = TOPJ_UINT32(0)
			l_begin_data = p_data

			if !(opj_j2k_write_sot(tls, p_j2k, p_data,
				total_data_size,
				bp, p_stream,
				p_manager) != 0) {
				return DOPJ_FALSE
			}

			l_nb_bytes_written = l_nb_bytes_written + *(*TOPJ_UINT32)(unsafe.Pointer(bp))
			p_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)))
			total_data_size = total_data_size - *(*TOPJ_UINT32)(unsafe.Pointer(bp))
			l_part_tile_size = l_part_tile_size + *(*TOPJ_UINT32)(unsafe.Pointer(bp))

			*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)) = TOPJ_UINT32(0)

			if !(opj_j2k_write_sod(tls, p_j2k, l_tcd, p_data, bp,
				total_data_size, p_stream, p_manager) != 0) {
				return DOPJ_FALSE
			}

			l_nb_bytes_written = l_nb_bytes_written + *(*TOPJ_UINT32)(unsafe.Pointer(bp))
			p_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_current_nb_bytes_written */)))
			total_data_size = total_data_size - *(*TOPJ_UINT32)(unsafe.Pointer(bp))
			l_part_tile_size = l_part_tile_size + *(*TOPJ_UINT32)(unsafe.Pointer(bp))

			// Writing Psot in SOT marker
			Xopj_write_bytes_LE(tls, l_begin_data+uintptr(6), l_part_tile_size,
				uint32(4)) // PSOT

			if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_TLM != 0 {
				opj_j2k_update_tlm(tls, p_j2k, l_part_tile_size)
			}

			(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_current_tile_part_number++
		}
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = l_nb_bytes_written

	return DOPJ_TRUE
}

func opj_j2k_write_updated_tlm(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12961:17: */
	var l_tlm_size TOPJ_UINT32
	var l_tlm_position TOPJ_OFF_T
	var l_current_position TOPJ_OFF_T
	var size_per_tile_part TOPJ_UINT32

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(12970), uintptr(unsafe.Pointer(&__func__169)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(12971), uintptr(unsafe.Pointer(&__func__169)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(12972), uintptr(unsafe.Pointer(&__func__169)))
	}

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_Ttlmi_is_byte != 0 {
		size_per_tile_part = uint32(5)
	} else {
		size_per_tile_part = uint32(6)
	}
	l_tlm_size = size_per_tile_part * (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_total_tile_parts
	l_tlm_position = 6 + (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_start
	l_current_position = Xopj_stream_tell(tls, p_stream)

	if !(Xopj_stream_seek(tls, p_stream, l_tlm_position, p_manager) != 0) {
		return DOPJ_FALSE
	}

	if Xopj_stream_write_data(tls, p_stream,
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_buffer, uint32(l_tlm_size),
		p_manager) != TOPJ_SIZE_T(l_tlm_size) {
		return DOPJ_FALSE
	}

	if !(Xopj_stream_seek(tls, p_stream, l_current_position, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__169 = *(*[26]int8)(unsafe.Pointer(ts + 25408)) /* j2k.c:12964:1 */

func opj_j2k_end_encoding(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:12997:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(13002), uintptr(unsafe.Pointer(&__func__170)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(13003), uintptr(unsafe.Pointer(&__func__170)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(13004), uintptr(unsafe.Pointer(&__func__170)))
	}

	_ = p_stream
	_ = p_manager

	Xopj_tcd_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)
	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd = uintptr(00)

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_buffer != 0 {
		Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_tlm_sot_offsets_buffer)
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_tlm_sot_offsets_buffer = uintptr(0)
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_tlm_sot_offsets_current = uintptr(0)
	}

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_encoded_tile_data != 0 {
		Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_encoded_tile_data)
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_encoded_tile_data = uintptr(0)
	}

	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_encoded_tile_size = TOPJ_UINT32(0)

	return DOPJ_TRUE
}

var __func__170 = *(*[21]int8)(unsafe.Pointer(ts + 25434)) /* j2k.c:13000:1 */

// *
// Destroys the memory associated with the decoding of headers.
func opj_j2k_destroy_header_memory(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:13031:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(13037), uintptr(unsafe.Pointer(&__func__171)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(13038), uintptr(unsafe.Pointer(&__func__171)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(13039), uintptr(unsafe.Pointer(&__func__171)))
	}

	_ = p_stream
	_ = p_manager

	if (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data != 0 {
		Xopj_free(tls, (*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k+8)).Fm_header_tile_data)
		(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data = uintptr(0)
	}

	(*Topj_j2k_enc_t)(unsafe.Pointer(p_j2k + 8)).Fm_header_tile_data_size = TOPJ_UINT32(0)

	return DOPJ_TRUE
}

var __func__171 = *(*[30]int8)(unsafe.Pointer(ts + 25455)) /* j2k.c:13035:1 */

func opj_j2k_init_info(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:13054:17: */
	var l_cstr_info uintptr = uintptr(00)
	_ = l_cstr_info

	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(13061), uintptr(unsafe.Pointer(&__func__172)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(13062), uintptr(unsafe.Pointer(&__func__172)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(13063), uintptr(unsafe.Pointer(&__func__172)))
	}
	_ = l_cstr_info

	_ = p_stream

	// TODO mergeV2: check this part which use cstr_info
	/*l_cstr_info = p_j2k->cstr_info;

	  if (l_cstr_info)  {
	          OPJ_UINT32 compno;
	          l_cstr_info->tile = (opj_tile_info_t *) opj_malloc(p_j2k->m_cp.tw * p_j2k->m_cp.th * sizeof(opj_tile_info_t));

	          l_cstr_info->image_w = p_j2k->m_image->x1 - p_j2k->m_image->x0;
	          l_cstr_info->image_h = p_j2k->m_image->y1 - p_j2k->m_image->y0;

	          l_cstr_info->prog = (&p_j2k->m_cp.tcps[0])->prg;

	          l_cstr_info->tw = p_j2k->m_cp.tw;
	          l_cstr_info->th = p_j2k->m_cp.th;

	          l_cstr_info->tile_x = p_j2k->m_cp.tdx;*/ // new version parser
	/*l_cstr_info->tile_y = p_j2k->m_cp.tdy;*/ // new version parser
	/*l_cstr_info->tile_Ox = p_j2k->m_cp.tx0;*/ // new version parser
	/*l_cstr_info->tile_Oy = p_j2k->m_cp.ty0;*/ // new version parser

	/*l_cstr_info->numcomps = p_j2k->m_image->numcomps;

	  l_cstr_info->numlayers = (&p_j2k->m_cp.tcps[0])->numlayers;

	  l_cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(p_j2k->m_image->numcomps * sizeof(OPJ_INT32));

	  for (compno=0; compno < p_j2k->m_image->numcomps; compno++) {
	          l_cstr_info->numdecompos[compno] = (&p_j2k->m_cp.tcps[0])->tccps->numresolutions - 1;
	  }

	  l_cstr_info->D_max = 0.0;       */ // ADD Marcela

	/*l_cstr_info->main_head_start = opj_stream_tell(p_stream);*/ // position of SOC

	//l_cstr_info->maxmarknum = 100;
	//     l_cstr_info->marker = (opj_marker_info_t *) opj_malloc(l_cstr_info->maxmarknum * sizeof(opj_marker_info_t));
	//     l_cstr_info->marknum = 0;
	//     }

	return opj_j2k_calculate_tp(tls, p_j2k, p_j2k+112,
		p_j2k+8+40, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image,
		p_manager)
}

var __func__172 = *(*[18]int8)(unsafe.Pointer(ts + 25485)) /* j2k.c:13057:1 */

// *
// Creates a tile-coder encoder.
//
// @param       p_stream                the stream to write data to.
// @param       p_j2k                   J2K codec.
// @param       p_manager               the user event manager.
func opj_j2k_create_tcd(tls *libc.TLS, p_j2k uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:13119:17: */
	// preconditions
	if p_j2k != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3947, ts+3645, uint32(13125), uintptr(unsafe.Pointer(&__func__173)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+3645, uint32(13126), uintptr(unsafe.Pointer(&__func__173)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+3645, uint32(13127), uintptr(unsafe.Pointer(&__func__173)))
	}

	_ = p_stream

	(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd = Xopj_tcd_create(tls, DOPJ_FALSE)

	if !(int32((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+25503, 0)
		return DOPJ_FALSE
	}

	if !(Xopj_tcd_init(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_private_image, p_j2k+112,
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tp) != 0) {
		Xopj_tcd_destroy(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)
		(*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd = uintptr(00)
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__173 = *(*[19]int8)(unsafe.Pointer(ts + 25543)) /* j2k.c:13123:1 */

func Xopj_j2k_write_tile(tls *libc.TLS, p_j2k uintptr, p_tile_index TOPJ_UINT32, p_data uintptr, p_data_size TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* j2k.c:13148:10: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if !(opj_j2k_pre_write_tile(tls, p_j2k, p_tile_index, p_stream, p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+25562, libc.VaList(bp, p_tile_index))
		return DOPJ_FALSE
	} else {
		var j TOPJ_UINT32
		// Allocate data
		for j = TOPJ_UINT32(0); j < (*Topj_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Fimage)).Fnumcomps; j++ {
			var l_tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Sopj_tcd)(unsafe.Pointer((*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(j)*104

			if !(Xopj_alloc_tile_component_data(tls, l_tilec) != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+24987, 0)
				return DOPJ_FALSE
			}
		}

		// now copy data into the tile component
		if !(Xopj_tcd_copy_tile_data(tls, (*Topj_j2k_t)(unsafe.Pointer(p_j2k)).Fm_tcd, p_data, uint32(p_data_size)) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+25064, 0)
			return DOPJ_FALSE
		}
		if !(opj_j2k_post_write_tile(tls, p_j2k, p_stream, p_manager) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+25619, libc.VaList(bp+8, p_tile_index))
			return DOPJ_FALSE
		}
	}

	return DOPJ_TRUE
}

var jp2_header = [3]Topj_jp2_header_handler_t{
	{Fid: TOPJ_UINT32(DJP2_JP), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJP2_FTYP), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJP2_JP2H), Fhandler: 0},
} /* jp2.c:425:39 */

var jp2_img_header = [6]Topj_jp2_header_handler_t{
	{Fid: TOPJ_UINT32(DJP2_IHDR), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJP2_COLR), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJP2_BPCC), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJP2_PCLR), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJP2_CMAP), Fhandler: 0},
	{Fid: TOPJ_UINT32(DJP2_CDEF), Fhandler: 0},
} /* jp2.c:431:39 */

// -----------------------------------------------------------------------
func opj_jp2_read_boxhdr(tls *libc.TLS, box uintptr, p_number_bytes_read uintptr, cio uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:473:17: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// read header from file
	// var l_data_header [8]TOPJ_BYTE at bp, 8

	// preconditions
	if cio != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25677, ts+25687, uint32(482), uintptr(unsafe.Pointer(&__func__178)))
	}
	if box != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25712, ts+25687, uint32(483), uintptr(unsafe.Pointer(&__func__178)))
	}
	if p_number_bytes_read != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25722, ts+25687, uint32(484), uintptr(unsafe.Pointer(&__func__178)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(485), uintptr(unsafe.Pointer(&__func__178)))
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_number_bytes_read)) = TOPJ_UINT32(Xopj_stream_read_data(tls, cio, bp, uint32(8),
		p_manager))
	if *(*TOPJ_UINT32)(unsafe.Pointer(p_number_bytes_read)) != TOPJ_UINT32(8) {
		return DOPJ_FALSE
	}

	// process read data
	Xopj_read_bytes_LE(tls, bp, box, uint32(4))
	Xopj_read_bytes_LE(tls, bp+uintptr(4), box+4, uint32(4))

	if (*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength == TOPJ_UINT32(0) { // last box
		var bleft TOPJ_OFF_T = Xopj_stream_get_number_byte_left(tls, cio)
		if bleft > libc.Int32FromUint32(0xFFFFFFFF-8) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+25748, 0)
			return DOPJ_FALSE
		}
		(*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength = TOPJ_UINT32(bleft) + 8
		if TOPJ_OFF_T((*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength) == bleft+8 {
		} else {
			libc.X__assert_fail(tls, ts+25790, ts+25687, uint32(505), uintptr(unsafe.Pointer(&__func__178)))
		}
		return DOPJ_TRUE
	}

	// do we have a "special very large box ?"
	// read then the XLBox
	if (*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength == TOPJ_UINT32(1) {
		// var l_xl_part_size TOPJ_UINT32 at bp+8, 4

		var l_nb_bytes_read TOPJ_UINT32 = TOPJ_UINT32(Xopj_stream_read_data(tls, cio,
			bp, uint32(8), p_manager))
		if l_nb_bytes_read != TOPJ_UINT32(8) {
			if l_nb_bytes_read > TOPJ_UINT32(0) {
				*(*TOPJ_UINT32)(unsafe.Pointer(p_number_bytes_read)) += l_nb_bytes_read
			}

			return DOPJ_FALSE
		}

		*(*TOPJ_UINT32)(unsafe.Pointer(p_number_bytes_read)) = TOPJ_UINT32(16)
		Xopj_read_bytes_LE(tls, bp, bp+8, uint32(4))
		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8)) != TOPJ_UINT32(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+25748, 0)
			return DOPJ_FALSE
		}
		Xopj_read_bytes_LE(tls, bp+uintptr(4), box, uint32(4))
	}
	return DOPJ_TRUE
}

var __func__178 = *(*[20]int8)(unsafe.Pointer(ts + 25826)) /* jp2.c:477:1 */

func opj_jp2_read_ihdr(tls *libc.TLS, jp2 uintptr, p_image_header_data uintptr, p_image_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:561:17: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// preconditions
	if p_image_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25846, ts+25687, uint32(567), uintptr(unsafe.Pointer(&__func__179)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(568), uintptr(unsafe.Pointer(&__func__179)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(569), uintptr(unsafe.Pointer(&__func__179)))
	}

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps != uintptr(0) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+25882, 0)
		return DOPJ_TRUE
	}

	if p_image_header_size != TOPJ_UINT32(14) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+25930, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_image_header_data, jp2+28, uint32(4)) // HEIGHT
	p_image_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_image_header_data, jp2+24, uint32(4)) // WIDTH
	p_image_header_data += uintptr(4)
	Xopj_read_bytes_LE(tls, p_image_header_data, jp2+32, uint32(2)) // NC
	p_image_header_data += uintptr(2)

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fh < TOPJ_UINT32(1) || (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fw < TOPJ_UINT32(1) || (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps < TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+25963,
			libc.VaList(bp, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fw, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fh, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps))
		return DOPJ_FALSE
	}
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps-1 >= 16384 { // unsigned underflow is well defined: 1U <= jp2->numcomps <= 16384U
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26014, 0)
		return DOPJ_FALSE
	}

	// allocate memory for components
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps = Xopj_calloc(tls, uint32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps),
		uint32(unsafe.Sizeof(Topj_jp2_comps_t{})))
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps == uintptr(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+26051, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_image_header_data, jp2+36, uint32(1)) // BPC
	p_image_header_data++

	Xopj_read_bytes_LE(tls, p_image_header_data, jp2+40, uint32(1)) // C
	p_image_header_data++

	// Should be equal to 7 cf. chapter about image header box of the norm
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).FC != TOPJ_UINT32(7) {
		Xopj_event_msg(tls, p_manager, DEVT_INFO,
			ts+26100,
			libc.VaList(bp+24, (*Topj_jp2_t)(unsafe.Pointer(jp2)).FC))
	}

	Xopj_read_bytes_LE(tls, p_image_header_data, jp2+44, uint32(1)) // UnkC
	p_image_header_data++
	Xopj_read_bytes_LE(tls, p_image_header_data, jp2+48, uint32(1)) // IPR
	p_image_header_data++

	libc.SetBitFieldPtr8Uint32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k+112+148, TOPJ_BITFIELD(libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbpc == TOPJ_UINT32(255))), 2, 0x4)
	(*Topj_j2k_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k)).Fihdr_w = (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fw
	(*Topj_j2k_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k)).Fihdr_h = (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fh
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fhas_ihdr = TOPJ_BYTE(1)

	return DOPJ_TRUE
}

var __func__179 = *(*[18]int8)(unsafe.Pointer(ts + 26190)) /* jp2.c:565:1 */

func opj_jp2_write_ihdr(tls *libc.TLS, jp2 uintptr, p_nb_bytes_written uintptr) uintptr { /* jp2.c:636:17: */
	var l_ihdr_data uintptr
	var l_current_ihdr_ptr uintptr

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(643), uintptr(unsafe.Pointer(&__func__180)))
	}
	if p_nb_bytes_written != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+26208, ts+25687, uint32(644), uintptr(unsafe.Pointer(&__func__180)))
	}

	// default image header is 22 bytes wide
	l_ihdr_data = Xopj_calloc(tls, uint32(1), uint32(22))
	if l_ihdr_data == uintptr(00) {
		return uintptr(00)
	}

	l_current_ihdr_ptr = l_ihdr_data

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, uint32(22), uint32(4)) // write box size
	l_current_ihdr_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, uint32(DJP2_IHDR), uint32(4)) // IHDR
	l_current_ihdr_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fh, uint32(4)) // HEIGHT
	l_current_ihdr_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fw, uint32(4)) // WIDTH
	l_current_ihdr_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps, uint32(2)) // NC
	l_current_ihdr_ptr += uintptr(2)

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbpc, uint32(1)) // BPC
	l_current_ihdr_ptr++

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).FC, uint32(1)) // C : Always 7
	l_current_ihdr_ptr++

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).FUnkC,
		uint32(1)) // UnkC, colorspace unknown
	l_current_ihdr_ptr++

	Xopj_write_bytes_LE(tls, l_current_ihdr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).FIPR,
		uint32(1)) // IPR, no intellectual property
	l_current_ihdr_ptr++

	*(*TOPJ_UINT32)(unsafe.Pointer(p_nb_bytes_written)) = TOPJ_UINT32(22)

	return l_ihdr_data
}

var __func__180 = *(*[19]int8)(unsafe.Pointer(ts + 26233)) /* jp2.c:639:1 */

func opj_jp2_write_bpcc(tls *libc.TLS, jp2 uintptr, p_nb_bytes_written uintptr) uintptr { /* jp2.c:688:17: */
	var i TOPJ_UINT32
	// room for 8 bytes for box and 1 byte for each component
	var l_bpcc_size TOPJ_UINT32
	var l_bpcc_data uintptr
	var l_current_bpcc_ptr uintptr

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(698), uintptr(unsafe.Pointer(&__func__181)))
	}
	if p_nb_bytes_written != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+26208, ts+25687, uint32(699), uintptr(unsafe.Pointer(&__func__181)))
	}
	l_bpcc_size = TOPJ_UINT32(8) + (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps

	l_bpcc_data = Xopj_calloc(tls, uint32(1), uint32(l_bpcc_size))
	if l_bpcc_data == uintptr(00) {
		return uintptr(00)
	}

	l_current_bpcc_ptr = l_bpcc_data

	Xopj_write_bytes_LE(tls, l_current_bpcc_ptr, l_bpcc_size,
		uint32(4)) // write box size
	l_current_bpcc_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_bpcc_ptr, uint32(DJP2_BPCC), uint32(4)) // BPCC
	l_current_bpcc_ptr += uintptr(4)

	for i = TOPJ_UINT32(0); i < (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps; i++ {
		Xopj_write_bytes_LE(tls, l_current_bpcc_ptr, (*Topj_jp2_comps_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps+uintptr(i)*12)).Fbpcc,
			uint32(1)) // write each component information
		l_current_bpcc_ptr++
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_nb_bytes_written)) = l_bpcc_size

	return l_bpcc_data
}

var __func__181 = *(*[19]int8)(unsafe.Pointer(ts + 26252)) /* jp2.c:691:1 */

func opj_jp2_read_bpcc(tls *libc.TLS, jp2 uintptr, p_bpc_header_data uintptr, p_bpc_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:727:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i TOPJ_UINT32

	// preconditions
	if p_bpc_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+26271, ts+25687, uint32(736), uintptr(unsafe.Pointer(&__func__182)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(737), uintptr(unsafe.Pointer(&__func__182)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(738), uintptr(unsafe.Pointer(&__func__182)))
	}

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbpc != TOPJ_UINT32(255) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+26295,
			libc.VaList(bp, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbpc))
	}

	// and length is relevant
	if p_bpc_header_size != (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26409, 0)
		return DOPJ_FALSE
	}

	// read info for each component
	for i = TOPJ_UINT32(0); i < (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps; i++ {
		Xopj_read_bytes_LE(tls, p_bpc_header_data, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps+uintptr(i)*12+8,
			uint32(1)) // read each BPCC component
		p_bpc_header_data++
	}

	return DOPJ_TRUE
}

var __func__182 = *(*[18]int8)(unsafe.Pointer(ts + 26441)) /* jp2.c:732:1 */

func opj_jp2_write_cdef(tls *libc.TLS, jp2 uintptr, p_nb_bytes_written uintptr) uintptr { /* jp2.c:762:17: */
	// room for 8 bytes for box, 2 for n
	var l_cdef_size TOPJ_UINT32 = TOPJ_UINT32(10)
	var l_cdef_data uintptr
	var l_current_cdef_ptr uintptr
	var l_value TOPJ_UINT32
	var i TOPJ_UINT16

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(772), uintptr(unsafe.Pointer(&__func__183)))
	}
	if p_nb_bytes_written != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+26208, ts+25687, uint32(773), uintptr(unsafe.Pointer(&__func__183)))
	}
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+26459, ts+25687, uint32(774), uintptr(unsafe.Pointer(&__func__183)))
	}
	if (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+26485, ts+25687, uint32(775), uintptr(unsafe.Pointer(&__func__183)))
	}
	if uint32((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Fn) > 0 {
	} else {
		libc.X__assert_fail(tls, ts+26517, ts+25687, uint32(776), uintptr(unsafe.Pointer(&__func__183)))
	}

	l_cdef_size = l_cdef_size + 6*uint32((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Fn)

	l_cdef_data = Xopj_malloc(tls, uint32(l_cdef_size))
	if l_cdef_data == uintptr(00) {
		return uintptr(00)
	}

	l_current_cdef_ptr = l_cdef_data

	Xopj_write_bytes_LE(tls, l_current_cdef_ptr, l_cdef_size, uint32(4)) // write box size
	l_current_cdef_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_cdef_ptr, uint32(DJP2_CDEF), uint32(4)) // BPCC
	l_current_cdef_ptr += uintptr(4)

	l_value = TOPJ_UINT32((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Fn)
	Xopj_write_bytes_LE(tls, l_current_cdef_ptr, l_value, uint32(2)) // N
	l_current_cdef_ptr += uintptr(2)

	for i = uint16(0); int32(i) < int32((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Fn); i++ {
		l_value = TOPJ_UINT32((*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Fcn)
		Xopj_write_bytes_LE(tls, l_current_cdef_ptr, l_value, uint32(2)) // Cni
		l_current_cdef_ptr += uintptr(2)
		l_value = TOPJ_UINT32((*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Ftyp)
		Xopj_write_bytes_LE(tls, l_current_cdef_ptr, l_value, uint32(2)) // Typi
		l_current_cdef_ptr += uintptr(2)
		l_value = TOPJ_UINT32((*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Fasoc)
		Xopj_write_bytes_LE(tls, l_current_cdef_ptr, l_value, uint32(2)) // Asoci
		l_current_cdef_ptr += uintptr(2)
	}
	*(*TOPJ_UINT32)(unsafe.Pointer(p_nb_bytes_written)) = l_cdef_size

	return l_cdef_data
}

var __func__183 = *(*[19]int8)(unsafe.Pointer(ts + 26545)) /* jp2.c:764:1 */

func opj_jp2_write_colr(tls *libc.TLS, jp2 uintptr, p_nb_bytes_written uintptr) uintptr { /* jp2.c:813:17: */
	// room for 8 bytes for box 3 for common data and variable upon profile
	var l_colr_size TOPJ_UINT32 = TOPJ_UINT32(11)
	var l_colr_data uintptr
	var l_current_colr_ptr uintptr

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(822), uintptr(unsafe.Pointer(&__func__184)))
	}
	if p_nb_bytes_written != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+26208, ts+25687, uint32(823), uintptr(unsafe.Pointer(&__func__184)))
	}
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth == TOPJ_UINT32(1) || (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth == TOPJ_UINT32(2) {
	} else {
		libc.X__assert_fail(tls, ts+26564, ts+25687, uint32(824), uintptr(unsafe.Pointer(&__func__184)))
	}

	switch (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth {
	case TOPJ_UINT32(1):
		l_colr_size = l_colr_size + TOPJ_UINT32(4) // EnumCS
		break
	case TOPJ_UINT32(2):
		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_len != 0 {
		} else {
			libc.X__assert_fail(tls, ts+26597, ts+25687, uint32(831), uintptr(unsafe.Pointer(&__func__184)))
		} // ICC profile
		l_colr_size = l_colr_size + (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_len
		break
	default:
		return uintptr(00)
	}

	l_colr_data = Xopj_calloc(tls, uint32(1), uint32(l_colr_size))
	if l_colr_data == uintptr(00) {
		return uintptr(00)
	}

	l_current_colr_ptr = l_colr_data

	Xopj_write_bytes_LE(tls, l_current_colr_ptr, l_colr_size,
		uint32(4)) // write box size
	l_current_colr_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_colr_ptr, uint32(DJP2_COLR), uint32(4)) // BPCC
	l_current_colr_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_colr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth, uint32(1)) // METH
	l_current_colr_ptr++

	Xopj_write_bytes_LE(tls, l_current_colr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fprecedence, uint32(1)) // PRECEDENCE
	l_current_colr_ptr++

	Xopj_write_bytes_LE(tls, l_current_colr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fapprox, uint32(1)) // APPROX
	l_current_colr_ptr++

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth == TOPJ_UINT32(1) { // Meth value is restricted to 1 or 2 (Table I.9 of part 1)
		Xopj_write_bytes_LE(tls, l_current_colr_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs, uint32(4))
	} else {
		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth == TOPJ_UINT32(2) { // ICC profile
			var i TOPJ_UINT32
			for i = TOPJ_UINT32(0); i < (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_len; i++ {
				Xopj_write_bytes_LE(tls, l_current_colr_ptr, uint32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf + uintptr(i)))), uint32(1))
				l_current_colr_ptr++
			}
		}
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_nb_bytes_written)) = l_colr_size

	return l_colr_data
}

var __func__184 = *(*[19]int8)(unsafe.Pointer(ts + 26624)) /* jp2.c:816:1 */

func opj_jp2_free_pclr(tls *libc.TLS, color uintptr) { /* jp2.c:880:13: */
	Xopj_free(tls, (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fchannel_sign)
	Xopj_free(tls, (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fchannel_size)
	Xopj_free(tls, (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fentries)

	if (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fcmap != 0 {
		Xopj_free(tls, (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fcmap)
	}

	Xopj_free(tls, (*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)
	(*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr = uintptr(0)
}

func opj_jp2_check_color(tls *libc.TLS, image uintptr, color uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:894:17: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var i TOPJ_UINT16

	// testcase 4149.pdf.SIGSEGV.cf7.3501
	if (*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef != 0 {
		var info uintptr = (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef)).Finfo
		var n TOPJ_UINT16 = (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef)).Fn
		var nr_channels TOPJ_UINT32 = (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps // FIXME image->numcomps == jp2->numcomps before color is applied ???

		// cdef applies to cmap channels if any
		if (*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr != 0 && (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fcmap != 0 {
			nr_channels = TOPJ_UINT32((*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fnr_channels)
		}

		for i = TOPJ_UINT16(0); int32(i) < int32(n); i++ {
			if TOPJ_UINT32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(i)*6)).Fcn) >= nr_channels {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26643,
					libc.VaList(bp, int32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(i)*6)).Fcn), nr_channels))
				return DOPJ_FALSE
			}
			if uint32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(i)*6)).Fasoc) == 65535 {
				continue
			}

			if int32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(i)*6)).Fasoc) > 0 && TOPJ_UINT32(int32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(i)*6)).Fasoc)-1) >= nr_channels {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26643,
					libc.VaList(bp+16, int32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(i)*6)).Fasoc)-1, nr_channels))
				return DOPJ_FALSE
			}
		}

		// issue 397
		// ISO 15444-1 states that if cdef is present, it shall contain a complete list of channel definitions.
		for nr_channels > TOPJ_UINT32(0) {
			for i = TOPJ_UINT16(0); int32(i) < int32(n); i++ {
				if TOPJ_UINT32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(i)*6)).Fcn) == nr_channels-1 {
					break
				}
			}
			if int32(i) == int32(n) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26680, 0)
				return DOPJ_FALSE
			}
			nr_channels--
		}
	}

	// testcases 451.pdf.SIGSEGV.f4c.3723, 451.pdf.SIGSEGV.5b5.3723 and
	//        66ea31acbb0f23a2bbc91f64d69a03f5_signal_sigsegv_13937c0_7030_5725.pdf
	if (*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr != 0 && (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fcmap != 0 {
		var nr_channels TOPJ_UINT16 = TOPJ_UINT16((*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fnr_channels)
		var cmap uintptr = (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fcmap
		var pcol_usage uintptr
		var is_sane TOPJ_BOOL = DOPJ_TRUE

		// verify that all original components match an existing one
		for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
			if TOPJ_UINT32((*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap+uintptr(i)*4)).Fcmp) >= (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26643,
					libc.VaList(bp+32, int32((*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap+uintptr(i)*4)).Fcmp), (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps))
				is_sane = DOPJ_FALSE
			}
		}

		pcol_usage = Xopj_calloc(tls, uint32(nr_channels), uint32(unsafe.Sizeof(TOPJ_BOOL(0))))
		if !(pcol_usage != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26713, 0)
			return DOPJ_FALSE
		}
		// verify that no component is targeted more than once
		for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
			var mtyp TOPJ_BYTE = (*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fmtyp
			var pcol TOPJ_BYTE = (*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fpcol
			// See ISO 15444-1 Table I.14  MTYPi field values
			if int32(mtyp) != 0 && int32(mtyp) != 1 {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+26730, libc.VaList(bp+48, int32(i),
						int32(mtyp)))
				is_sane = DOPJ_FALSE
			} else if int32(pcol) >= int32(nr_channels) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+26769, libc.VaList(bp+64, int32(pcol)))
				is_sane = DOPJ_FALSE
			} else if *(*TOPJ_BOOL)(unsafe.Pointer(pcol_usage + uintptr(pcol)*4)) != 0 && int32(mtyp) == 1 {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26825, libc.VaList(bp+72, int32(pcol)))
				is_sane = DOPJ_FALSE
			} else if int32(mtyp) == 0 && int32(pcol) != 0 {
				// I.5.3.5 PCOL: If the value of the MTYP field for this channel is 0, then
				// the value of this field shall be 0.
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26856, libc.VaList(bp+80, int32(i),
					int32(pcol)))
				is_sane = DOPJ_FALSE
			} else if int32(mtyp) == 1 && int32(pcol) != int32(i) {
				// OpenJPEG implementation limitation. See assert(i == pcol);
				// in opj_jp2_apply_pclr()
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,

					ts+26892, libc.VaList(bp+96, int32(i), int32(i), int32(pcol)))
				is_sane = DOPJ_FALSE
			} else {
				*(*TOPJ_BOOL)(unsafe.Pointer(pcol_usage + uintptr(pcol)*4)) = DOPJ_TRUE
			}
		}
		// verify that all components are targeted at least once
		for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
			if !(*(*TOPJ_BOOL)(unsafe.Pointer(pcol_usage + uintptr(i)*4)) != 0) && int32((*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap+uintptr(i)*4)).Fmtyp) != 0 {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+26993,
					libc.VaList(bp+120, int32(i)))
				is_sane = DOPJ_FALSE
			}
		}
		// Issue 235/447 weird cmap
		if 1 != 0 && is_sane != 0 && (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps == 1 {
			for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
				if !(*(*TOPJ_BOOL)(unsafe.Pointer(pcol_usage + uintptr(i)*4)) != 0) {
					is_sane = int32(0)
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,
						ts+27031, 0)
					break
				}
			}
			if !(is_sane != 0) {
				is_sane = DOPJ_TRUE
				for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
					(*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fmtyp = uint8(1)
					(*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fpcol = TOPJ_BYTE(i)
				}
			}
		}
		Xopj_free(tls, pcol_usage)
		if !(is_sane != 0) {
			return DOPJ_FALSE
		}
	}

	return DOPJ_TRUE
}

// file9.jp2
func opj_jp2_apply_pclr(tls *libc.TLS, image uintptr, color uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1036:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var old_comps uintptr
	var new_comps uintptr
	var channel_size uintptr
	var channel_sign uintptr
	var entries uintptr
	var cmap uintptr
	var src uintptr
	var dst uintptr
	var j TOPJ_UINT32
	var max TOPJ_UINT32
	var i TOPJ_UINT16
	var nr_channels TOPJ_UINT16
	var cmp TOPJ_UINT16
	var pcol TOPJ_UINT16
	var k TOPJ_INT32
	var top_k TOPJ_INT32

	channel_size = (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fchannel_size
	channel_sign = (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fchannel_sign
	entries = (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fentries
	cmap = (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fcmap
	nr_channels = TOPJ_UINT16((*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fnr_channels)

	for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
		// Palette mapping:
		cmp = (*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fcmp
		if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(cmp)*64)).Fdata == uintptr(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+27082, libc.VaList(bp, int32(i)))
			return DOPJ_FALSE
		}
	}

	old_comps = (*Topj_image_t)(unsafe.Pointer(image)).Fcomps
	new_comps = Xopj_malloc(tls, uint32(nr_channels)*uint32(unsafe.Sizeof(Topj_image_comp_t{})))
	if !(new_comps != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+27138, 0)
		return DOPJ_FALSE
	}
	for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
		pcol = TOPJ_UINT16((*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fpcol)
		cmp = (*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fcmp

		// Direct use
		if int32((*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap+uintptr(i)*4)).Fmtyp) == 0 {
			if int32(pcol) == 0 {
			} else {
				libc.X__assert_fail(tls, ts+27190, ts+25687, uint32(1079), uintptr(unsafe.Pointer(&__func__185)))
			}
			*(*Topj_image_comp_t)(unsafe.Pointer(new_comps + uintptr(i)*64)) = *(*Topj_image_comp_t)(unsafe.Pointer(old_comps + uintptr(cmp)*64))
		} else {
			if int32(i) == int32(pcol) {
			} else {
				libc.X__assert_fail(tls, ts+27200, ts+25687, uint32(1082), uintptr(unsafe.Pointer(&__func__185)))
			}
			*(*Topj_image_comp_t)(unsafe.Pointer(new_comps + uintptr(pcol)*64)) = *(*Topj_image_comp_t)(unsafe.Pointer(old_comps + uintptr(cmp)*64))
		}

		// Palette mapping:
		(*Topj_image_comp_t)(unsafe.Pointer(new_comps + uintptr(i)*64)).Fdata = Xopj_image_data_alloc(tls, uint32(unsafe.Sizeof(TOPJ_INT32(0)))*uint32((*Topj_image_comp_t)(unsafe.Pointer(old_comps+uintptr(cmp)*64)).Fw)*uint32((*Topj_image_comp_t)(unsafe.Pointer(old_comps+uintptr(cmp)*64)).Fh))
		if !(int32((*Topj_image_comp_t)(unsafe.Pointer(new_comps+uintptr(i)*64)).Fdata) != 0) {
			for int32(i) > 0 {
				i--
				Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer(new_comps+uintptr(i)*64)).Fdata)
			}
			Xopj_free(tls, new_comps)
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+27138, 0)
			return DOPJ_FALSE
		}
		(*Topj_image_comp_t)(unsafe.Pointer(new_comps + uintptr(i)*64)).Fprec = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer(channel_size + uintptr(i))))
		(*Topj_image_comp_t)(unsafe.Pointer(new_comps + uintptr(i)*64)).Fsgnd = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer(channel_sign + uintptr(i))))
	}

	top_k = int32((*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_pclr)).Fnr_entries) - 1

	for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
		// Palette mapping:
		cmp = (*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fcmp
		pcol = TOPJ_UINT16((*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fpcol)
		src = (*Topj_image_comp_t)(unsafe.Pointer(old_comps + uintptr(cmp)*64)).Fdata
		if src != 0 {
		} else {
			libc.X__assert_fail(tls, ts+27210, ts+25687, uint32(1110), uintptr(unsafe.Pointer(&__func__185)))
		} // verified above
		max = (*Topj_image_comp_t)(unsafe.Pointer(new_comps+uintptr(pcol)*64)).Fw * (*Topj_image_comp_t)(unsafe.Pointer(new_comps+uintptr(pcol)*64)).Fh

		// Direct use:
		if int32((*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap+uintptr(i)*4)).Fmtyp) == 0 {
			dst = (*Topj_image_comp_t)(unsafe.Pointer(new_comps + uintptr(i)*64)).Fdata
			if dst != 0 {
			} else {
				libc.X__assert_fail(tls, ts+27214, ts+25687, uint32(1116), uintptr(unsafe.Pointer(&__func__185)))
			}
			for j = TOPJ_UINT32(0); j < max; j++ {
				*(*TOPJ_INT32)(unsafe.Pointer(dst + uintptr(j)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src + uintptr(j)*4))
			}
		} else {
			if int32(i) == int32(pcol) {
			} else {
				libc.X__assert_fail(tls, ts+27200, ts+25687, uint32(1121), uintptr(unsafe.Pointer(&__func__185)))
			}
			dst = (*Topj_image_comp_t)(unsafe.Pointer(new_comps + uintptr(pcol)*64)).Fdata
			if dst != 0 {
			} else {
				libc.X__assert_fail(tls, ts+27214, ts+25687, uint32(1123), uintptr(unsafe.Pointer(&__func__185)))
			}
			for j = TOPJ_UINT32(0); j < max; j++ {
				// The index
				if libc.AssignInt32(&k, *(*TOPJ_INT32)(unsafe.Pointer(src + uintptr(j)*4))) < 0 {
					k = 0
				} else if k > top_k {
					k = top_k
				}

				// The colour
				*(*TOPJ_INT32)(unsafe.Pointer(dst + uintptr(j)*4)) = TOPJ_INT32(*(*TOPJ_UINT32)(unsafe.Pointer(entries + uintptr(k*TOPJ_INT32(nr_channels)+TOPJ_INT32(pcol))*4)))
			}
		}
	}

	max = (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps
	for j = TOPJ_UINT32(0); j < max; j++ {
		if (*Topj_image_comp_t)(unsafe.Pointer(old_comps+uintptr(j)*64)).Fdata != 0 {
			Xopj_image_data_free(tls, (*Topj_image_comp_t)(unsafe.Pointer(old_comps+uintptr(j)*64)).Fdata)
		}
	}

	Xopj_free(tls, old_comps)
	(*Topj_image_t)(unsafe.Pointer(image)).Fcomps = new_comps
	(*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps = TOPJ_UINT32(nr_channels)

	return DOPJ_TRUE
}

var __func__185 = *(*[19]int8)(unsafe.Pointer(ts + 27218)) /* jp2.c:1039:1 */

// apply_pclr()

func opj_jp2_read_pclr(tls *libc.TLS, jp2 uintptr, p_pclr_header_data uintptr, p_pclr_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1152:17: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var jp2_pclr uintptr
	var channel_size uintptr
	var channel_sign uintptr
	var entries uintptr
	var nr_entries TOPJ_UINT16
	var nr_channels TOPJ_UINT16
	var i TOPJ_UINT16
	var j TOPJ_UINT16
	// var l_value TOPJ_UINT32 at bp+8, 4

	var orig_header_data uintptr = p_pclr_header_data

	// preconditions
	if p_pclr_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+27237, ts+25687, uint32(1167), uintptr(unsafe.Pointer(&__func__186)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(1168), uintptr(unsafe.Pointer(&__func__186)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(1169), uintptr(unsafe.Pointer(&__func__186)))
	}
	_ = p_pclr_header_size

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr != 0 {
		return DOPJ_FALSE
	}

	if p_pclr_header_size < TOPJ_UINT32(3) {
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_pclr_header_data, bp+8, uint32(2)) // NE
	p_pclr_header_data += uintptr(2)
	nr_entries = TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_value */)))
	if uint32(nr_entries) == 0 || uint32(nr_entries) > 1024 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+27262,
			libc.VaList(bp, int32(nr_entries)))
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_pclr_header_data, bp+8, uint32(1)) // NPC
	p_pclr_header_data++
	nr_channels = TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_value */)))
	if uint32(nr_channels) == 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+27300, 0)
		return DOPJ_FALSE
	}

	if p_pclr_header_size < TOPJ_UINT32(3)+TOPJ_UINT32(nr_channels) {
		return DOPJ_FALSE
	}

	entries = Xopj_malloc(tls, uint32(unsafe.Sizeof(TOPJ_UINT32(0)))*uint32(nr_channels)*uint32(nr_entries))
	if !(entries != 0) {
		return DOPJ_FALSE
	}
	channel_size = Xopj_malloc(tls, uint32(nr_channels))
	if !(channel_size != 0) {
		Xopj_free(tls, entries)
		return DOPJ_FALSE
	}
	channel_sign = Xopj_malloc(tls, uint32(nr_channels))
	if !(channel_sign != 0) {
		Xopj_free(tls, entries)
		Xopj_free(tls, channel_size)
		return DOPJ_FALSE
	}

	jp2_pclr = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_jp2_pclr_t{})))
	if !(jp2_pclr != 0) {
		Xopj_free(tls, entries)
		Xopj_free(tls, channel_size)
		Xopj_free(tls, channel_sign)
		return DOPJ_FALSE
	}

	(*Topj_jp2_pclr_t)(unsafe.Pointer(jp2_pclr)).Fchannel_sign = channel_sign
	(*Topj_jp2_pclr_t)(unsafe.Pointer(jp2_pclr)).Fchannel_size = channel_size
	(*Topj_jp2_pclr_t)(unsafe.Pointer(jp2_pclr)).Fentries = entries
	(*Topj_jp2_pclr_t)(unsafe.Pointer(jp2_pclr)).Fnr_entries = nr_entries
	(*Topj_jp2_pclr_t)(unsafe.Pointer(jp2_pclr)).Fnr_channels = TOPJ_BYTE(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_value */)))
	(*Topj_jp2_pclr_t)(unsafe.Pointer(jp2_pclr)).Fcmap = uintptr(0)

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr = jp2_pclr

	for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
		Xopj_read_bytes_LE(tls, p_pclr_header_data, bp+8, uint32(1)) // Bi
		p_pclr_header_data++

		*(*TOPJ_BYTE)(unsafe.Pointer(channel_size + uintptr(i))) = TOPJ_BYTE(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8))&TOPJ_UINT32(0x7f) + TOPJ_UINT32(1))
		*(*TOPJ_BYTE)(unsafe.Pointer(channel_sign + uintptr(i))) = func() uint8 {
			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8))&TOPJ_UINT32(0x80) != 0 {
				return uint8(1)
			}
			return uint8(0)
		}()
	}

	for j = TOPJ_UINT16(0); int32(j) < int32(nr_entries); j++ {
		for i = TOPJ_UINT16(0); int32(i) < int32(nr_channels); i++ {
			var bytes_to_read TOPJ_UINT32 = TOPJ_UINT32((int32(*(*TOPJ_BYTE)(unsafe.Pointer(channel_size + uintptr(i)))) + 7) >> 3)

			if uint32(bytes_to_read) > uint32(unsafe.Sizeof(TOPJ_UINT32(0))) {
				bytes_to_read = TOPJ_UINT32(unsafe.Sizeof(TOPJ_UINT32(0)))
			}
			if Tptrdiff_t(p_pclr_header_size) < (int32(p_pclr_header_data)-int32(orig_header_data))/1+Tptrdiff_t(bytes_to_read) {
				return DOPJ_FALSE
			}

			Xopj_read_bytes_LE(tls, p_pclr_header_data, bp+8, bytes_to_read) // Cji
			p_pclr_header_data += uintptr(bytes_to_read)
			*(*TOPJ_UINT32)(unsafe.Pointer(entries)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_value */))
			entries += 4
		}
	}

	return DOPJ_TRUE
}

var __func__186 = *(*[18]int8)(unsafe.Pointer(ts + 27345)) /* jp2.c:1157:1 */

func opj_jp2_read_cmap(tls *libc.TLS, jp2 uintptr, p_cmap_header_data uintptr, p_cmap_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1266:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var cmap uintptr
	var i TOPJ_BYTE
	var nr_channels TOPJ_BYTE
	// var l_value TOPJ_UINT32 at bp, 4

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(1277), uintptr(unsafe.Pointer(&__func__187)))
	}
	if p_cmap_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+27363, ts+25687, uint32(1278), uintptr(unsafe.Pointer(&__func__187)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(1279), uintptr(unsafe.Pointer(&__func__187)))
	}
	_ = p_cmap_header_size

	// Need nr_channels:
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr == uintptr(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+27388, 0)
		return DOPJ_FALSE
	}

	// Part 1, I.5.3.5: 'There shall be at most one Component Mapping box
	// inside a JP2 Header box' :
	if (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fcmap != 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+27434, 0)
		return DOPJ_FALSE
	}

	nr_channels = (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fnr_channels
	if p_cmap_header_size < TOPJ_UINT32(nr_channels)*TOPJ_UINT32(4) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+27465, 0)
		return DOPJ_FALSE
	}

	cmap = Xopj_malloc(tls, uint32(nr_channels)*uint32(unsafe.Sizeof(Topj_jp2_cmap_comp_t{})))
	if !(cmap != 0) {
		return DOPJ_FALSE
	}

	for i = TOPJ_BYTE(0); int32(i) < int32(nr_channels); i++ {
		Xopj_read_bytes_LE(tls, p_cmap_header_data, bp, uint32(2)) // CMP^i
		p_cmap_header_data += uintptr(2)
		(*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fcmp = TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_value */)))

		Xopj_read_bytes_LE(tls, p_cmap_header_data, bp, uint32(1)) // MTYP^i
		p_cmap_header_data++
		(*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fmtyp = TOPJ_BYTE(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_value */)))

		Xopj_read_bytes_LE(tls, p_cmap_header_data, bp, uint32(1)) // PCOL^i
		p_cmap_header_data++
		(*Topj_jp2_cmap_comp_t)(unsafe.Pointer(cmap + uintptr(i)*4)).Fpcol = TOPJ_BYTE(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_value */)))
	}

	(*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fcmap = cmap

	return DOPJ_TRUE
}

var __func__187 = *(*[18]int8)(unsafe.Pointer(ts + 27498)) /* jp2.c:1271:1 */

func opj_jp2_apply_cdef(tls *libc.TLS, image uintptr, color uintptr, manager uintptr) { /* jp2.c:1329:13: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var info uintptr
	var i TOPJ_UINT16
	var n TOPJ_UINT16
	var cn TOPJ_UINT16
	var asoc TOPJ_UINT16
	var acn TOPJ_UINT16

	info = (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef)).Finfo
	n = (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef)).Fn

	for i = TOPJ_UINT16(0); int32(i) < int32(n); i++ {
		// WATCH: acn = asoc - 1 !
		asoc = (*Topj_jp2_cdef_info_t)(unsafe.Pointer(info + uintptr(i)*6)).Fasoc
		cn = (*Topj_jp2_cdef_info_t)(unsafe.Pointer(info + uintptr(i)*6)).Fcn

		if TOPJ_UINT32(cn) >= (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps {
			Xopj_event_msg(tls, manager, DEVT_WARNING, ts+27516,
				libc.VaList(bp, int32(cn), (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps))
			continue
		}
		if int32(asoc) == 0 || int32(asoc) == 65535 {
			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps + uintptr(cn)*64)).Falpha = (*Topj_jp2_cdef_info_t)(unsafe.Pointer(info + uintptr(i)*6)).Ftyp
			continue
		}

		acn = TOPJ_UINT16(int32(asoc) - 1)
		if TOPJ_UINT32(acn) >= (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps {
			Xopj_event_msg(tls, manager, DEVT_WARNING, ts+27556,
				libc.VaList(bp+16, int32(acn), (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps))
			continue
		}

		// Swap only if color channel
		if int32(cn) != int32(acn) && int32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(i)*6)).Ftyp) == 0 {
			// var saved Topj_image_comp_t at bp+32, 64

			var j TOPJ_UINT16

			libc.Xmemcpy(tls, bp+32, (*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(cn)*64, uint32(unsafe.Sizeof(Topj_image_comp_t{})))
			libc.Xmemcpy(tls, (*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(cn)*64, (*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(acn)*64, uint32(unsafe.Sizeof(Topj_image_comp_t{})))
			libc.Xmemcpy(tls, (*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(acn)*64, bp+32, uint32(unsafe.Sizeof(Topj_image_comp_t{})))

			// Swap channels in following channel definitions, don't bother with j <= i that are already processed
			for j = TOPJ_UINT16(uint32(i) + 1); int32(j) < int32(n); j++ {
				if int32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(j)*6)).Fcn) == int32(cn) {
					(*Topj_jp2_cdef_info_t)(unsafe.Pointer(info + uintptr(j)*6)).Fcn = acn
				} else if int32((*Topj_jp2_cdef_info_t)(unsafe.Pointer(info+uintptr(j)*6)).Fcn) == int32(acn) {
					(*Topj_jp2_cdef_info_t)(unsafe.Pointer(info + uintptr(j)*6)).Fcn = cn
				}
				// asoc is related to color index. Do not update.
			}
		}

		(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps + uintptr(cn)*64)).Falpha = (*Topj_jp2_cdef_info_t)(unsafe.Pointer(info + uintptr(i)*6)).Ftyp
	}

	if (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef)).Finfo != 0 {
		Xopj_free(tls, (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef)).Finfo)
	}

	Xopj_free(tls, (*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef)
	(*Topj_jp2_color_t)(unsafe.Pointer(color)).Fjp2_cdef = uintptr(0)

}

// jp2_apply_cdef()

func opj_jp2_read_cdef(tls *libc.TLS, jp2 uintptr, p_cdef_header_data uintptr, p_cdef_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1392:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var cdef_info uintptr
	var i TOPJ_UINT16
	// var l_value TOPJ_UINT32 at bp, 4

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(1403), uintptr(unsafe.Pointer(&__func__188)))
	}
	if p_cdef_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+27597, ts+25687, uint32(1404), uintptr(unsafe.Pointer(&__func__188)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(1405), uintptr(unsafe.Pointer(&__func__188)))
	}
	_ = p_cdef_header_size

	// Part 1, I.5.3.6: 'The shall be at most one Channel Definition box
	// inside a JP2 Header box.'
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef != 0 {
		return DOPJ_FALSE
	}

	if p_cdef_header_size < TOPJ_UINT32(2) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+27622, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_cdef_header_data, bp, uint32(2)) // N
	p_cdef_header_data += uintptr(2)

	if int32(TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp)))) == 0 { // szukw000: FIXME
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+27655, 0)
		return DOPJ_FALSE
	}

	if p_cdef_header_size < TOPJ_UINT32(2)+TOPJ_UINT32(TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp))))*TOPJ_UINT32(6) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+27622, 0)
		return DOPJ_FALSE
	}

	cdef_info = Xopj_malloc(tls, uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp)))*uint32(unsafe.Sizeof(Topj_jp2_cdef_info_t{})))
	if !(cdef_info != 0) {
		return DOPJ_FALSE
	}

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_jp2_cdef_t{})))
	if !(int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef) != 0) {
		Xopj_free(tls, cdef_info)
		return DOPJ_FALSE
	}
	(*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo = cdef_info
	(*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Fn = TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_value */)))

	for i = TOPJ_UINT16(0); int32(i) < int32((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Fn); i++ {
		Xopj_read_bytes_LE(tls, p_cdef_header_data, bp, uint32(2)) // Cn^i
		p_cdef_header_data += uintptr(2)
		(*Topj_jp2_cdef_info_t)(unsafe.Pointer(cdef_info + uintptr(i)*6)).Fcn = TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_value */)))

		Xopj_read_bytes_LE(tls, p_cdef_header_data, bp, uint32(2)) // Typ^i
		p_cdef_header_data += uintptr(2)
		(*Topj_jp2_cdef_info_t)(unsafe.Pointer(cdef_info + uintptr(i)*6)).Ftyp = TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_value */)))

		Xopj_read_bytes_LE(tls, p_cdef_header_data, bp, uint32(2)) // Asoc^i
		p_cdef_header_data += uintptr(2)
		(*Topj_jp2_cdef_info_t)(unsafe.Pointer(cdef_info + uintptr(i)*6)).Fasoc = TOPJ_UINT16(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_value */)))
	}

	return DOPJ_TRUE
}

var __func__188 = *(*[18]int8)(unsafe.Pointer(ts + 27716)) /* jp2.c:1397:1 */

func opj_jp2_read_colr(tls *libc.TLS, jp2 uintptr, p_colr_header_data uintptr, p_colr_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1464:17: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var l_value TOPJ_UINT32 at bp+60, 4

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(1473), uintptr(unsafe.Pointer(&__func__189)))
	}
	if p_colr_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+27734, ts+25687, uint32(1474), uintptr(unsafe.Pointer(&__func__189)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(1475), uintptr(unsafe.Pointer(&__func__189)))
	}

	if p_colr_header_size < TOPJ_UINT32(3) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+27759, 0)
		return DOPJ_FALSE
	}

	// Part 1, I.5.3.3 : 'A conforming JP2 reader shall ignore all Colour
	// Specification boxes after the first.'
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_has_colr != 0 {
		Xopj_event_msg(tls, p_manager, DEVT_INFO,
			ts+27791, 0)
		p_colr_header_data += uintptr(p_colr_header_size)
		return DOPJ_TRUE
	}

	Xopj_read_bytes_LE(tls, p_colr_header_data, jp2+52, uint32(1)) // METH
	p_colr_header_data++

	Xopj_read_bytes_LE(tls, p_colr_header_data, jp2+64, uint32(1)) // PRECEDENCE
	p_colr_header_data++

	Xopj_read_bytes_LE(tls, p_colr_header_data, jp2+56, uint32(1)) // APPROX
	p_colr_header_data++

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth == TOPJ_UINT32(1) {
		if p_colr_header_size < TOPJ_UINT32(7) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+27900,
				libc.VaList(bp, p_colr_header_size))
			return DOPJ_FALSE
		}
		if p_colr_header_size > TOPJ_UINT32(7) && (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs != TOPJ_UINT32(14) { // handled below for CIELab)
			// testcase Altona_Technical_v20_x4.pdf
			Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+27900,
				libc.VaList(bp+8, p_colr_header_size))
		}

		Xopj_read_bytes_LE(tls, p_colr_header_data, jp2+60, uint32(4)) // EnumCS

		p_colr_header_data += uintptr(4)

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs == TOPJ_UINT32(14) { // CIELab
			var cielab uintptr
			// var rl TOPJ_UINT32 at bp+32, 4

			// var ol TOPJ_UINT32 at bp+36, 4

			// var ra TOPJ_UINT32 at bp+40, 4

			// var oa TOPJ_UINT32 at bp+44, 4

			// var rb TOPJ_UINT32 at bp+48, 4

			// var ob TOPJ_UINT32 at bp+52, 4

			// var il TOPJ_UINT32 at bp+56, 4

			cielab = Xopj_malloc(tls, uint32(9)*uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
			if cielab == uintptr(0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+27936, 0)
				return DOPJ_FALSE
			}
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab)) = TOPJ_UINT32(14) // enumcs

			// default values
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 32 /* rl */)) = libc.AssignPtrUint32(bp+40 /* ra */, libc.AssignPtrUint32(bp+48 /* rb */, libc.AssignPtrUint32(bp+36 /* ol */, libc.AssignPtrUint32(bp+44 /* oa */, libc.AssignPtrUint32(bp+52 /* ob */, TOPJ_UINT32(0))))))
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 56 /* il */)) = TOPJ_UINT32(0x00443530) // D50
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 1*4)) = TOPJ_UINT32(0x44454600)     // DEF

			if p_colr_header_size == TOPJ_UINT32(35) {
				Xopj_read_bytes_LE(tls, p_colr_header_data, bp+32, uint32(4))
				p_colr_header_data += uintptr(4)
				Xopj_read_bytes_LE(tls, p_colr_header_data, bp+36, uint32(4))
				p_colr_header_data += uintptr(4)
				Xopj_read_bytes_LE(tls, p_colr_header_data, bp+40, uint32(4))
				p_colr_header_data += uintptr(4)
				Xopj_read_bytes_LE(tls, p_colr_header_data, bp+44, uint32(4))
				p_colr_header_data += uintptr(4)
				Xopj_read_bytes_LE(tls, p_colr_header_data, bp+48, uint32(4))
				p_colr_header_data += uintptr(4)
				Xopj_read_bytes_LE(tls, p_colr_header_data, bp+52, uint32(4))
				p_colr_header_data += uintptr(4)
				Xopj_read_bytes_LE(tls, p_colr_header_data, bp+56, uint32(4))
				p_colr_header_data += uintptr(4)

				*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 1*4)) = TOPJ_UINT32(0)
			} else if p_colr_header_size != TOPJ_UINT32(7) {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,
					ts+27966, libc.VaList(bp+16, p_colr_header_size))
			}
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 2*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 32 /* rl */))
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 4*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40 /* ra */))
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 6*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 48 /* rb */))
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 3*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 36 /* ol */))
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 5*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 44 /* oa */))
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 7*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 52 /* ob */))
			*(*TOPJ_UINT32)(unsafe.Pointer(cielab + 8*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 56 /* il */))

			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf = cielab
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_len = TOPJ_UINT32(0)
		}
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_has_colr = TOPJ_BYTE(1)
	} else if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth == TOPJ_UINT32(2) {
		// ICC profile
		var it_icc_value TOPJ_INT32 = 0
		var icc_len TOPJ_INT32 = TOPJ_INT32(p_colr_header_size) - 3

		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_len = TOPJ_UINT32(icc_len)
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf = Xopj_calloc(tls, uint32(1), Tsize_t(icc_len))
		if !(int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf) != 0) {
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_len = TOPJ_UINT32(0)
			return DOPJ_FALSE
		}

		for it_icc_value = 0; it_icc_value < icc_len; it_icc_value++ {
			Xopj_read_bytes_LE(tls, p_colr_header_data, bp+60, uint32(1)) // icc values
			p_colr_header_data++
			*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf + uintptr(it_icc_value))) = TOPJ_BYTE(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 60 /* l_value */)))
		}

		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_has_colr = TOPJ_BYTE(1)
	} else if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth > TOPJ_UINT32(2) {
		//  ISO/IEC 15444-1:2004 (E), Table I.9 Legal METH values:
		//         conforming JP2 reader shall ignore the entire Colour Specification box.
		Xopj_event_msg(tls, p_manager, DEVT_INFO,

			ts+28010, libc.VaList(bp+24, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth))
	}

	return DOPJ_TRUE
}

var __func__189 = *(*[18]int8)(unsafe.Pointer(ts + 28116)) /* jp2.c:1469:1 */

func Xopj_jp2_decode(tls *libc.TLS, jp2 uintptr, p_stream uintptr, p_image uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1597:10: */
	if !(p_image != 0) {
		return DOPJ_FALSE
	}

	// J2K decoding
	if !(Xopj_j2k_decode(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, p_stream, p_image, p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+28134, 0)
		return DOPJ_FALSE
	}

	if (*Topj_j2k_dec_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k+8)).Fm_numcomps_to_decode != 0 {
		// Bypass all JP2 component transforms
		return DOPJ_TRUE
	}

	if !((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fignore_pclr_cmap_cdef != 0) {
		if !(opj_jp2_check_color(tls, p_image, jp2+120, p_manager) != 0) {
			return DOPJ_FALSE
		}

		// Set Image Color Space
		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs == TOPJ_UINT32(16) {
			(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_SRGB
		} else if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs == TOPJ_UINT32(17) {
			(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_GRAY
		} else if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs == TOPJ_UINT32(18) {
			(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_SYCC
		} else if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs == TOPJ_UINT32(24) {
			(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_EYCC
		} else if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs == TOPJ_UINT32(12) {
			(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_CMYK
		} else {
			(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_UNKNOWN
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr != 0 {
			// Part 1, I.5.3.4: Either both or none :
			if !(int32((*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fcmap) != 0) {
				opj_jp2_free_pclr(tls, jp2+120)
			} else {
				if !(opj_jp2_apply_pclr(tls, p_image, jp2+120, p_manager) != 0) {
					return DOPJ_FALSE
				}
			}
		}

		// Apply the color space if needed
		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef != 0 {
			opj_jp2_apply_cdef(tls, p_image, jp2+120, p_manager)
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf != 0 {
			(*Topj_image_t)(unsafe.Pointer(p_image)).Ficc_profile_buf = (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf
			(*Topj_image_t)(unsafe.Pointer(p_image)).Ficc_profile_len = (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_len
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf = uintptr(0)
		}
	}

	return DOPJ_TRUE
}

func opj_jp2_write_jp2h(tls *libc.TLS, jp2 uintptr, stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1664:17: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var l_writers [4]Topj_jp2_img_header_writer_handler_t at bp, 96

	var l_current_writer uintptr
	var i TOPJ_INT32
	var l_nb_pass TOPJ_INT32
	// size of data for super box
	var l_jp2h_size TOPJ_UINT32 = TOPJ_UINT32(8)
	var l_result TOPJ_BOOL = DOPJ_TRUE

	// to store the data of the super box
	// var l_jp2h_data [8]TOPJ_BYTE at bp+96, 8

	// preconditions
	if stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+28183, ts+25687, uint32(1681), uintptr(unsafe.Pointer(&__func__190)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(1682), uintptr(unsafe.Pointer(&__func__190)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(1683), uintptr(unsafe.Pointer(&__func__190)))
	}

	libc.Xmemset(tls, bp, 0, uint32(unsafe.Sizeof([4]Topj_jp2_img_header_writer_handler_t{})))

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbpc == TOPJ_UINT32(255) {
		l_nb_pass = 3
		(*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(bp)).Fhandler = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		}{opj_jp2_write_ihdr}))
		(*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(bp + 1*24)).Fhandler = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		}{opj_jp2_write_bpcc}))
		(*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(bp + 2*24)).Fhandler = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		}{opj_jp2_write_colr}))
	} else {
		l_nb_pass = 2
		(*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(bp)).Fhandler = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		}{opj_jp2_write_ihdr}))
		(*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(bp + 1*24)).Fhandler = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		}{opj_jp2_write_colr}))
	}

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef != uintptr(0) {
		(*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(bp + uintptr(l_nb_pass)*24)).Fhandler = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		}{opj_jp2_write_cdef}))
		l_nb_pass++
	}

	// write box header
	// write JP2H type
	Xopj_write_bytes_LE(tls, bp+96+uintptr(4), uint32(DJP2_JP2H), uint32(4))

	l_current_writer = bp /* &l_writers[0] */
	for i = 0; i < l_nb_pass; i++ {
		(*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_data = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fhandler})).f(tls, jp2,
			l_current_writer+16)
		if (*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_data == uintptr(00) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+28196, 0)
			l_result = DOPJ_FALSE
			break
		}

		l_jp2h_size = l_jp2h_size + (*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_size
		l_current_writer += 24
	}

	if !(l_result != 0) {
		l_current_writer = bp /* &l_writers[0] */
		for i = 0; i < l_nb_pass; i++ {
			if (*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_data != uintptr(00) {
				Xopj_free(tls, (*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_data)
			}
			l_current_writer += 24
		}

		return DOPJ_FALSE
	}

	// write super box size
	Xopj_write_bytes_LE(tls, bp+96, l_jp2h_size, uint32(4))

	// write super box data on stream
	if Xopj_stream_write_data(tls, stream, bp+96, uint32(8), p_manager) != TOPJ_SIZE_T(8) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+28239, 0)
		l_result = DOPJ_FALSE
	}

	if l_result != 0 {
		l_current_writer = bp /* &l_writers[0] */
		for i = 0; i < l_nb_pass; i++ {
			if Xopj_stream_write_data(tls, stream, (*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_data,
				uint32((*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_size), p_manager) != TOPJ_SIZE_T((*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_size) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+28239, 0)
				l_result = DOPJ_FALSE
				break
			}
			l_current_writer += 24
		}
	}

	l_current_writer = bp /* &l_writers[0] */

	// cleanup
	for i = 0; i < l_nb_pass; i++ {
		if (*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_data != uintptr(00) {
			Xopj_free(tls, (*Topj_jp2_img_header_writer_handler_t)(unsafe.Pointer(l_current_writer)).Fm_data)
		}
		l_current_writer += 24
	}

	return l_result
}

var __func__190 = *(*[19]int8)(unsafe.Pointer(ts + 28282)) /* jp2.c:1668:1 */

func opj_jp2_write_ftyp(tls *libc.TLS, jp2 uintptr, cio uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1771:17: */
	var i TOPJ_UINT32
	var l_ftyp_size TOPJ_UINT32
	var l_ftyp_data uintptr
	var l_current_data_ptr uintptr
	var l_result TOPJ_BOOL

	// preconditions
	if cio != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25677, ts+25687, uint32(1781), uintptr(unsafe.Pointer(&__func__191)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(1782), uintptr(unsafe.Pointer(&__func__191)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(1783), uintptr(unsafe.Pointer(&__func__191)))
	}
	l_ftyp_size = TOPJ_UINT32(16) + TOPJ_UINT32(4)*(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl

	l_ftyp_data = Xopj_calloc(tls, uint32(1), uint32(l_ftyp_size))

	if l_ftyp_data == uintptr(00) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+28301, 0)
		return DOPJ_FALSE
	}

	l_current_data_ptr = l_ftyp_data

	Xopj_write_bytes_LE(tls, l_current_data_ptr, l_ftyp_size, uint32(4)) // box size
	l_current_data_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_data_ptr, uint32(DJP2_FTYP), uint32(4)) // FTYP
	l_current_data_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_data_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbrand, uint32(4)) // BR
	l_current_data_ptr += uintptr(4)

	Xopj_write_bytes_LE(tls, l_current_data_ptr, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fminversion, uint32(4)) // MinV
	l_current_data_ptr += uintptr(4)

	for i = TOPJ_UINT32(0); i < (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl; i++ {
		Xopj_write_bytes_LE(tls, l_current_data_ptr, *(*TOPJ_UINT32)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl + uintptr(i)*4)), uint32(4)) // CL
	}

	l_result = libc.Bool32(Xopj_stream_write_data(tls, cio, l_ftyp_data, uint32(l_ftyp_size),
		p_manager) == TOPJ_SIZE_T(l_ftyp_size))
	if !(l_result != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+28340, 0)
	}

	Xopj_free(tls, l_ftyp_data)

	return l_result
}

var __func__191 = *(*[19]int8)(unsafe.Pointer(ts + 28381)) /* jp2.c:1774:1 */

func opj_jp2_write_jp2c(tls *libc.TLS, jp2 uintptr, cio uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1823:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var j2k_codestream_exit TOPJ_OFF_T
	// var l_data_header [8]TOPJ_BYTE at bp, 8

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(1831), uintptr(unsafe.Pointer(&__func__192)))
	}
	if cio != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25677, ts+25687, uint32(1832), uintptr(unsafe.Pointer(&__func__192)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(1833), uintptr(unsafe.Pointer(&__func__192)))
	}
	if Xopj_stream_has_seek(tls, cio) != 0 {
	} else {
		libc.X__assert_fail(tls, ts+28400, ts+25687, uint32(1834), uintptr(unsafe.Pointer(&__func__192)))
	}

	j2k_codestream_exit = Xopj_stream_tell(tls, cio)
	Xopj_write_bytes_LE(tls, bp,
		TOPJ_UINT32(j2k_codestream_exit-(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k_codestream_offset),
		uint32(4)) // size of codestream
	Xopj_write_bytes_LE(tls, bp+uintptr(4), uint32(DJP2_JP2C),
		uint32(4)) // JP2C

	if !(Xopj_stream_seek(tls, cio, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k_codestream_offset, p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+28425, 0)
		return DOPJ_FALSE
	}

	if Xopj_stream_write_data(tls, cio, bp, uint32(8), p_manager) != TOPJ_SIZE_T(8) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+28425, 0)
		return DOPJ_FALSE
	}

	if !(Xopj_stream_seek(tls, cio, j2k_codestream_exit, p_manager) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+28425, 0)
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__192 = *(*[19]int8)(unsafe.Pointer(ts + 28456)) /* jp2.c:1826:1 */

func opj_jp2_write_jp(tls *libc.TLS, jp2 uintptr, cio uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1861:17: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// 12 bytes will be read
	// var l_signature_data [12]TOPJ_BYTE at bp, 12

	// preconditions
	if cio != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25677, ts+25687, uint32(1869), uintptr(unsafe.Pointer(&__func__193)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(1870), uintptr(unsafe.Pointer(&__func__193)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(1871), uintptr(unsafe.Pointer(&__func__193)))
	}

	_ = jp2

	// write box length
	Xopj_write_bytes_LE(tls, bp, uint32(12), uint32(4))
	// writes box type
	Xopj_write_bytes_LE(tls, bp+uintptr(4), uint32(DJP2_JP), uint32(4))
	// writes magic number
	Xopj_write_bytes_LE(tls, bp+uintptr(8), uint32(0x0d0a870a), uint32(4))

	if Xopj_stream_write_data(tls, cio, bp, uint32(12), p_manager) != TOPJ_SIZE_T(12) {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__193 = *(*[17]int8)(unsafe.Pointer(ts + 28475)) /* jp2.c:1864:1 */

// -----------------------------------------------------------------------
// JP2 decoder interface
// -----------------------------------------------------------------------

func Xopj_jp2_setup_decoder(tls *libc.TLS, jp2 uintptr, parameters uintptr) { /* jp2.c:1893:6: */
	// setup the J2K codec
	Xopj_j2k_setup_decoder(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, parameters)

	// further JP2 initializations go here
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_has_colr = TOPJ_BYTE(0)
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fignore_pclr_cmap_cdef = TOPJ_BOOL((*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fflags & uint32(DOPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG))
}

func Xopj_jp2_decoder_set_strict_mode(tls *libc.TLS, jp2 uintptr, strict TOPJ_BOOL) { /* jp2.c:1904:6: */
	Xopj_j2k_decoder_set_strict_mode(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, strict)
}

func Xopj_jp2_set_threads(tls *libc.TLS, jp2 uintptr, num_threads TOPJ_UINT32) TOPJ_BOOL { /* jp2.c:1909:10: */
	return Xopj_j2k_set_threads(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, num_threads)
}

// -----------------------------------------------------------------------
// JP2 encoder interface
// -----------------------------------------------------------------------

func Xopj_jp2_setup_encoder(tls *libc.TLS, jp2 uintptr, parameters uintptr, image uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:1918:10: */
	var i TOPJ_UINT32
	var depth_0 TOPJ_UINT32
	var sign TOPJ_UINT32
	var alpha_count TOPJ_UINT32
	var color_channels TOPJ_UINT32 = 0
	var alpha_channel TOPJ_UINT32 = 0

	if !(jp2 != 0) || !(parameters != 0) || !(image != 0) {
		return DOPJ_FALSE
	}

	// setup the J2K codec
	// -------------------

	// Check if number of components respects standard
	if (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps < TOPJ_UINT32(1) || (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps > TOPJ_UINT32(16384) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+28492, 0)
		return DOPJ_FALSE
	}

	if Xopj_j2k_setup_encoder(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, parameters, image,
		p_manager) == DOPJ_FALSE {
		return DOPJ_FALSE
	}

	// setup the JP2 codec
	// -------------------

	// Profile box

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbrand = TOPJ_UINT32(DJP2_JP2) // BR
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fminversion = TOPJ_UINT32(0)   // MinV
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl = TOPJ_UINT32(1)
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl = Xopj_malloc(tls, uint32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl)*uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
	if !(int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+28561, 0)
		return DOPJ_FALSE
	}
	*(*TOPJ_UINT32)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl)) = TOPJ_UINT32(DJP2_JP2) // CL0 : JP2

	// Image Header box

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps = (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps // NC
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps = Xopj_malloc(tls, uint32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps)*uint32(unsafe.Sizeof(Topj_jp2_comps_t{})))
	if !(int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+28561, 0)
		// Memory of jp2->cl will be freed by opj_jp2_destroy
		return DOPJ_FALSE
	}

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fh = (*Topj_image_t)(unsafe.Pointer(image)).Fy1 - (*Topj_image_t)(unsafe.Pointer(image)).Fy0 // HEIGHT
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fw = (*Topj_image_t)(unsafe.Pointer(image)).Fx1 - (*Topj_image_t)(unsafe.Pointer(image)).Fx0 // WIDTH
	// BPC
	depth_0 = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fprec - TOPJ_UINT32(1)
	sign = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps)).Fsgnd
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbpc = depth_0 + sign<<7
	for i = TOPJ_UINT32(1); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
		var depth TOPJ_UINT32 = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fprec - TOPJ_UINT32(1)
		sign = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps + uintptr(i)*64)).Fsgnd
		if depth_0 != depth {
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fbpc = TOPJ_UINT32(255)
		}
	}
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).FC = TOPJ_UINT32(7)    // C : Always 7
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).FUnkC = TOPJ_UINT32(0) // UnkC, colorspace specified in colr box
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).FIPR = TOPJ_UINT32(0)  // IPR, no intellectual property

	// BitsPerComponent box
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
		(*Topj_jp2_comps_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps + uintptr(i)*12)).Fbpcc = (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fprec - TOPJ_UINT32(1) + (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Fsgnd<<7
	}

	// Colour Specification box
	if (*Topj_image_t)(unsafe.Pointer(image)).Ficc_profile_len != 0 {
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth = TOPJ_UINT32(2)
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs = TOPJ_UINT32(0)
	} else {
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth = TOPJ_UINT32(1)
		if (*Topj_image_t)(unsafe.Pointer(image)).Fcolor_space == 1 {
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs = TOPJ_UINT32(16) // sRGB as defined by IEC 61966-2-1
		} else if (*Topj_image_t)(unsafe.Pointer(image)).Fcolor_space == 2 {
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs = TOPJ_UINT32(17) // greyscale
		} else if (*Topj_image_t)(unsafe.Pointer(image)).Fcolor_space == 3 {
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs = TOPJ_UINT32(18) // YUV
		}
	}

	// Channel Definition box
	// FIXME not provided by parameters
	// We try to do what we can...
	alpha_count = 0
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
		if int32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Falpha) != 0 {
			alpha_count++
			alpha_channel = i
		}
	}
	if alpha_count == 1 { // no way to deal with more than 1 alpha channel
		switch (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fenumcs {
		case TOPJ_UINT32(16):
			fallthrough
		case TOPJ_UINT32(18):
			color_channels = TOPJ_UINT32(3)
			break
			fallthrough
		case TOPJ_UINT32(17):
			color_channels = TOPJ_UINT32(1)
			break
			fallthrough
		default:
			alpha_count = 0
			break
		}
		if alpha_count == 0 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+28607, 0)
		} else if (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps < color_channels+TOPJ_UINT32(1) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+28681, 0)
			alpha_count = 0
		} else if alpha_channel < color_channels {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+28774, 0)
			alpha_count = 0
		}
	} else if alpha_count > TOPJ_UINT32(1) {
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+28857, 0)
	}
	if alpha_count == 1 { // if here, we know what we can do
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_jp2_cdef_t{})))
		if !(int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+28922, 0)
			return DOPJ_FALSE
		}
		// no memset needed, all values will be overwritten except if jp2->color.jp2_cdef->info allocation fails,
		// in which case jp2->color.jp2_cdef->info will be NULL => valid for destruction
		(*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo = Xopj_malloc(tls,
			uint32((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps)*uint32(unsafe.Sizeof(Topj_jp2_cdef_info_t{})))
		if !(int32((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo) != 0) {
			// memory will be freed by opj_jp2_destroy
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+28922, 0)
			return DOPJ_FALSE
		}
		(*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Fn = TOPJ_UINT16((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps) // cast is valid : image->numcomps [1,16384]
		for i = 0; i < color_channels; i++ {
			(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Fcn = TOPJ_UINT16(i) // cast is valid : image->numcomps [1,16384]
			(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Ftyp = uint16(0)
			(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Fasoc = TOPJ_UINT16(i + 1) // No overflow + cast is valid : image->numcomps [1,16384]
		}
		for ; i < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; i++ {
			if int32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer(image)).Fcomps+uintptr(i)*64)).Falpha) != 0 { // we'll be here exactly once
				(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Fcn = TOPJ_UINT16(i) // cast is valid : image->numcomps [1,16384]
				(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Ftyp = uint16(1)     // Opacity channel
				(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Fasoc = uint16(0)    // Apply alpha channel to the whole image
			} else {
				// Unknown channel
				(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Fcn = TOPJ_UINT16(i) // cast is valid : image->numcomps [1,16384]
				(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Ftyp = uint16(65535)
				(*Topj_jp2_cdef_info_t)(unsafe.Pointer((*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo + uintptr(i)*6)).Fasoc = uint16(65535)
			}
		}
	}

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fprecedence = TOPJ_UINT32(0) // PRECEDENCE
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fapprox = TOPJ_UINT32(0)     // APPROX

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjpip_on = (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fjpip_on

	return DOPJ_TRUE
}

func Xopj_jp2_encode(tls *libc.TLS, jp2 uintptr, stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2105:10: */
	return Xopj_j2k_encode(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, stream, p_manager)
}

func Xopj_jp2_end_decompress(tls *libc.TLS, jp2 uintptr, cio uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2112:10: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2118), uintptr(unsafe.Pointer(&__func__194)))
	}
	if cio != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25677, ts+25687, uint32(2119), uintptr(unsafe.Pointer(&__func__194)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2120), uintptr(unsafe.Pointer(&__func__194)))
	}

	// customization of the end encoding
	if !(opj_jp2_setup_end_header_reading(tls, jp2, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// write header
	if !(opj_jp2_exec(tls, jp2, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list, cio, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return Xopj_j2k_end_decompress(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, cio, p_manager)
}

var __func__194 = *(*[23]int8)(unsafe.Pointer(ts + 28966)) /* jp2.c:2116:1 */

func Xopj_jp2_end_compress(tls *libc.TLS, jp2 uintptr, cio uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2135:10: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2141), uintptr(unsafe.Pointer(&__func__195)))
	}
	if cio != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25677, ts+25687, uint32(2142), uintptr(unsafe.Pointer(&__func__195)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2143), uintptr(unsafe.Pointer(&__func__195)))
	}

	// customization of the end encoding
	if !(opj_jp2_setup_end_header_writing(tls, jp2, p_manager) != 0) {
		return DOPJ_FALSE
	}

	if !(Xopj_j2k_end_compress(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, cio, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// write header
	return opj_jp2_exec(tls, jp2, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list, cio, p_manager)
}

var __func__195 = *(*[21]int8)(unsafe.Pointer(ts + 28989)) /* jp2.c:2139:1 */

func opj_jp2_setup_end_header_writing(tls *libc.TLS, jp2 uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2158:17: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2162), uintptr(unsafe.Pointer(&__func__196)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2163), uintptr(unsafe.Pointer(&__func__196)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_jp2_write_jp2c})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	// DEVELOPER CORNER, add your custom procedures
	return DOPJ_TRUE
}

var __func__196 = *(*[33]int8)(unsafe.Pointer(ts + 29010)) /* jp2.c:2160:1 */

func opj_jp2_setup_end_header_reading(tls *libc.TLS, jp2 uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2193:17: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2197), uintptr(unsafe.Pointer(&__func__197)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2198), uintptr(unsafe.Pointer(&__func__197)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_jp2_read_header_procedure})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	// DEVELOPER CORNER, add your custom procedures

	return DOPJ_TRUE
}

var __func__197 = *(*[33]int8)(unsafe.Pointer(ts + 29043)) /* jp2.c:2195:1 */

func opj_jp2_default_validation(tls *libc.TLS, jp2 uintptr, cio uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2209:17: */
	var l_is_valid TOPJ_BOOL = DOPJ_TRUE
	var i TOPJ_UINT32

	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2218), uintptr(unsafe.Pointer(&__func__198)))
	}
	if cio != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25677, ts+25687, uint32(2219), uintptr(unsafe.Pointer(&__func__198)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2220), uintptr(unsafe.Pointer(&__func__198)))
	}

	_ = p_manager

	// JPEG2000 codec validation

	// STATE checking
	// make sure the state is at 0
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state == JP2_STATE_NONE)

	// make sure not reading a jp2h ???? WEIRD
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_img_state == JP2_IMG_STATE_NONE)

	// POINTER validation
	// make sure a j2k codec is present
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k != uintptr(00))

	// make sure a procedure list is present
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list != uintptr(00))

	// make sure a validation list is present
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list != uintptr(00))

	// PARAMETER VALIDATION
	// number of components
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl > TOPJ_UINT32(0))
	// width
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fh > TOPJ_UINT32(0))
	// height
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fw > TOPJ_UINT32(0))
	// precision
	for i = TOPJ_UINT32(0); i < (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcomps; i++ {
		l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_comps_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps+uintptr(i)*12)).Fbpcc&0x7F < 38) // 0 is valid, ignore sign for check
	}

	// METH
	l_is_valid = l_is_valid & libc.Bool32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth > TOPJ_UINT32(0) && (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fmeth < TOPJ_UINT32(3))

	// stream validation
	// back and forth is needed
	l_is_valid = l_is_valid & Xopj_stream_has_seek(tls, cio)

	return l_is_valid
}

var __func__198 = *(*[27]int8)(unsafe.Pointer(ts + 29076)) /* jp2.c:2213:1 */

func opj_jp2_read_header_procedure(tls *libc.TLS, jp2 uintptr, stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2266:17: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	// var box Topj_jp2_box_t at bp+136, 12

	// var l_nb_bytes_read TOPJ_UINT32 at bp+148, 4

	var l_current_handler uintptr
	var l_current_handler_misplaced uintptr
	var l_last_data_size TOPJ_UINT32 = TOPJ_UINT32(DOPJ_BOX_SIZE)
	var l_current_data_size TOPJ_UINT32
	var l_current_data uintptr = uintptr(00)

	// preconditions
	if stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+28183, ts+25687, uint32(2280), uintptr(unsafe.Pointer(&__func__199)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2281), uintptr(unsafe.Pointer(&__func__199)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2282), uintptr(unsafe.Pointer(&__func__199)))
	}

	l_current_data = Xopj_calloc(tls, uint32(1), uint32(l_last_data_size))

	if l_current_data == uintptr(00) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+29103, 0)
		return DOPJ_FALSE
	}

	for opj_jp2_read_boxhdr(tls, bp+136, bp+148, stream, p_manager) != 0 {
		// is it the codestream box ?
		if (*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype == TOPJ_UINT32(DJP2_JP2C) {
			if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state&JP2_STATE_HEADER != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(jp2 + 108)) |= JP2_STATE_CODESTREAM
				Xopj_free(tls, l_current_data)
				return DOPJ_TRUE
			} else {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+29153, 0)
				Xopj_free(tls, l_current_data)
				return DOPJ_FALSE
			}
		} else if (*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Flength == TOPJ_UINT32(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+29181, 0)
			Xopj_free(tls, l_current_data)
			return DOPJ_FALSE
		} else if (*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Flength < *(*TOPJ_UINT32)(unsafe.Pointer(bp + 148)) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+29219, libc.VaList(bp, (*Topj_jp2_box_t)(unsafe.Pointer(bp+136 /* &box */)).Flength,
				(*Topj_jp2_box_t)(unsafe.Pointer(bp+136 /* &box */)).Ftype))
			Xopj_free(tls, l_current_data)
			return DOPJ_FALSE
		}

		l_current_handler = opj_jp2_find_handler(tls, (*Topj_jp2_box_t)(unsafe.Pointer(bp+136 /* &box */)).Ftype)
		l_current_handler_misplaced = opj_jp2_img_find_handler(tls, (*Topj_jp2_box_t)(unsafe.Pointer(bp+136 /* &box */)).Ftype)
		l_current_data_size = (*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Flength - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 148))

		if l_current_handler != uintptr(00) || l_current_handler_misplaced != uintptr(00) {
			if l_current_handler == uintptr(00) {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,
					ts+29245,
					libc.VaList(bp+16, int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>24)), int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>16)),
						int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>8)), int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>0))))
				if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state&JP2_STATE_HEADER != 0 {
					// read anyway, we already have jp2h
					l_current_handler = l_current_handler_misplaced
				} else {
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,
						ts+29296,
						libc.VaList(bp+48, int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>24)), int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>16)),
							int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>8)), int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>0))))
					*(*TOPJ_UINT32)(unsafe.Pointer(jp2 + 108)) |= JP2_STATE_UNKNOWN
					if uint32(Xopj_stream_skip(tls, stream, int32(l_current_data_size),
						p_manager)) != uint32(l_current_data_size) {
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+29362, 0)
						Xopj_free(tls, l_current_data)
						return DOPJ_FALSE
					}
					continue
				}
			}
			if TOPJ_OFF_T(l_current_data_size) > Xopj_stream_get_number_byte_left(tls, stream) {
				// do not even try to malloc if we can't read
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+29412,
					libc.VaList(bp+80, (*Topj_jp2_box_t)(unsafe.Pointer(bp+136 /* &box */)).Flength, int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>24)), int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>16)),
						int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>8)), int32(TOPJ_BYTE((*Topj_jp2_box_t)(unsafe.Pointer(bp+136)).Ftype>>0)), l_current_data_size,
						TOPJ_UINT32(Xopj_stream_get_number_byte_left(tls, stream))))
				Xopj_free(tls, l_current_data)
				return DOPJ_FALSE
			}
			if l_current_data_size > l_last_data_size {
				var new_current_data uintptr = Xopj_realloc(tls, l_current_data,
					uint32(l_current_data_size))
				if !(new_current_data != 0) {
					Xopj_free(tls, l_current_data)
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+29488, 0)
					return DOPJ_FALSE
				}
				l_current_data = new_current_data
				l_last_data_size = l_current_data_size
			}

			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 148 /* l_nb_bytes_read */)) = TOPJ_UINT32(Xopj_stream_read_data(tls, stream, l_current_data,
				uint32(l_current_data_size), p_manager))
			if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 148)) != l_current_data_size {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+29530, 0)
				Xopj_free(tls, l_current_data)
				return DOPJ_FALSE
			}

			if !((*struct {
				f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL
			})(unsafe.Pointer(&struct{ uintptr }{(*Topj_jp2_header_handler_t)(unsafe.Pointer(l_current_handler)).Fhandler})).f(tls, jp2, l_current_data, l_current_data_size,
				p_manager) != 0) {
				Xopj_free(tls, l_current_data)
				return DOPJ_FALSE
			}
		} else {
			if !((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state&JP2_STATE_SIGNATURE != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+29579, 0)
				Xopj_free(tls, l_current_data)
				return DOPJ_FALSE
			}
			if !((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state&JP2_STATE_FILE_TYPE != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+29649, 0)
				Xopj_free(tls, l_current_data)
				return DOPJ_FALSE
			}
			*(*TOPJ_UINT32)(unsafe.Pointer(jp2 + 108)) |= JP2_STATE_UNKNOWN
			if uint32(Xopj_stream_skip(tls, stream, int32(l_current_data_size),
				p_manager)) != uint32(l_current_data_size) {
				if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state&JP2_STATE_CODESTREAM != 0 {
					// If we already read the codestream, do not error out
					// Needed for data/input/nonregression/issue254.jp2
					Xopj_event_msg(tls, p_manager, DEVT_WARNING,
						ts+29362, 0)
					Xopj_free(tls, l_current_data)
					return DOPJ_TRUE
				} else {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+29362, 0)
					Xopj_free(tls, l_current_data)
					return DOPJ_FALSE
				}
			}
		}
	}

	Xopj_free(tls, l_current_data)

	return DOPJ_TRUE
}

var __func__199 = *(*[30]int8)(unsafe.Pointer(ts + 29710)) /* jp2.c:2270:1 */

// *
// Executes the given procedures on the given codec.
//
// @param   p_procedure_list    the list of procedures to execute
// @param   jp2                 the jpeg2000 file codec to execute the procedures on.
// @param   stream                  the stream to execute the procedures on.
// @param   p_manager           the user manager.
//
// @return  true                if all the procedures were successfully executed.
func opj_jp2_exec(tls *libc.TLS, jp2 uintptr, p_procedure_list uintptr, stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2431:17: */
	var l_procedure uintptr = uintptr(00)
	var l_result TOPJ_BOOL = DOPJ_TRUE
	var l_nb_proc TOPJ_UINT32
	var i TOPJ_UINT32

	// preconditions
	if p_procedure_list != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+19759, ts+25687, uint32(2444), uintptr(unsafe.Pointer(&__func__200)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2445), uintptr(unsafe.Pointer(&__func__200)))
	}
	if stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+28183, ts+25687, uint32(2446), uintptr(unsafe.Pointer(&__func__200)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2447), uintptr(unsafe.Pointer(&__func__200)))
	}

	l_nb_proc = Xopj_procedure_list_get_nb_procedures(tls, p_procedure_list)
	l_procedure = Xopj_procedure_list_get_first_procedure(tls, p_procedure_list)

	for i = TOPJ_UINT32(0); i < l_nb_proc; i++ {
		l_result = libc.Bool32(l_result != 0 && (*(**struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{l_procedure}))).f(tls, jp2, stream, p_manager) != 0)
		l_procedure += 8
	}

	// and clear the procedure list at the end.
	Xopj_procedure_list_clear(tls, p_procedure_list)
	return l_result
}

var __func__200 = *(*[13]int8)(unsafe.Pointer(ts + 29740)) /* jp2.c:2437:1 */

func Xopj_jp2_start_compress(tls *libc.TLS, jp2 uintptr, stream uintptr, p_image uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2463:10: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2470), uintptr(unsafe.Pointer(&__func__201)))
	}
	if stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+28183, ts+25687, uint32(2471), uintptr(unsafe.Pointer(&__func__201)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2472), uintptr(unsafe.Pointer(&__func__201)))
	}

	// customization of the validation
	if !(opj_jp2_setup_encoding_validation(tls, jp2, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// validation of the parameters codec
	if !(opj_jp2_exec(tls, jp2, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list, stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// customization of the encoding
	if !(opj_jp2_setup_header_writing(tls, jp2, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// write header
	if !(opj_jp2_exec(tls, jp2, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list, stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	return Xopj_j2k_start_compress(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k, stream, p_image, p_manager)
}

var __func__201 = *(*[23]int8)(unsafe.Pointer(ts + 29753)) /* jp2.c:2468:1 */

func opj_jp2_find_handler(tls *libc.TLS, p_id TOPJ_UINT32) uintptr { /* jp2.c:2497:39: */
	var i TOPJ_UINT32
	var l_handler_size TOPJ_UINT32 = uint32(unsafe.Sizeof(jp2_header)) / uint32(unsafe.Sizeof(Topj_jp2_header_handler_t{}))

	for i = TOPJ_UINT32(0); i < l_handler_size; i++ {
		if jp2_header[i].Fid == p_id {
			return uintptr(unsafe.Pointer(&jp2_header)) + uintptr(i)*16
		}
	}
	return uintptr(0)
}

// *
// Finds the image execution function related to the given box id.
//
// @param   p_id    the id of the handler to fetch.
//
// @return  the given handler or 00 if it could not be found.
func opj_jp2_img_find_handler(tls *libc.TLS, p_id TOPJ_UINT32) uintptr { /* jp2.c:2517:39: */
	var i TOPJ_UINT32
	var l_handler_size TOPJ_UINT32 = uint32(unsafe.Sizeof(jp2_img_header)) / uint32(unsafe.Sizeof(Topj_jp2_header_handler_t{}))
	for i = TOPJ_UINT32(0); i < l_handler_size; i++ {
		if jp2_img_header[i].Fid == p_id {
			return uintptr(unsafe.Pointer(&jp2_img_header)) + uintptr(i)*16
		}
	}

	return uintptr(0)
}

// *
// Reads a jpeg2000 file signature box.
//
// @param   p_header_data   the data contained in the signature box.
// @param   jp2             the jpeg2000 file codec.
// @param   p_header_size   the size of the data contained in the signature box.
// @param   p_manager       the user event manager.
//
// @return true if the file signature box is valid.
func opj_jp2_read_jp(tls *libc.TLS, jp2 uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2541:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var l_magic_number TOPJ_UINT32 at bp, 4

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+25687, uint32(2551), uintptr(unsafe.Pointer(&__func__202)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2552), uintptr(unsafe.Pointer(&__func__202)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2553), uintptr(unsafe.Pointer(&__func__202)))
	}

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state != JP2_STATE_NONE {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+29776, 0)
		return DOPJ_FALSE
	}

	// assure length of data is correct (4 -> magic number)
	if p_header_size != TOPJ_UINT32(4) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+29830, 0)
		return DOPJ_FALSE
	}

	// rearrange data
	Xopj_read_bytes_LE(tls, p_header_data, bp, uint32(4))
	if *(*TOPJ_UINT32)(unsafe.Pointer(bp)) != TOPJ_UINT32(0x0d0a870a) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+29864, 0)
		return DOPJ_FALSE
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(jp2 + 108)) |= JP2_STATE_SIGNATURE

	return DOPJ_TRUE
}

var __func__202 = *(*[16]int8)(unsafe.Pointer(ts + 29908)) /* jp2.c:2547:1 */

// *
// Reads a a FTYP box - File type box
//
// @param   p_header_data   the data contained in the FTYP box.
// @param   jp2             the jpeg2000 file codec.
// @param   p_header_size   the size of the data contained in the FTYP box.
// @param   p_manager       the user event manager.
//
// @return true if the FTYP box is valid.
func opj_jp2_read_ftyp(tls *libc.TLS, jp2 uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2590:17: */
	var i TOPJ_UINT32
	var l_remaining_bytes TOPJ_UINT32

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+25687, uint32(2599), uintptr(unsafe.Pointer(&__func__203)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2600), uintptr(unsafe.Pointer(&__func__203)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2601), uintptr(unsafe.Pointer(&__func__203)))
	}

	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state != JP2_STATE_SIGNATURE {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+29924, 0)
		return DOPJ_FALSE
	}

	// assure length of data is correct
	if p_header_size < TOPJ_UINT32(8) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+29974, 0)
		return DOPJ_FALSE
	}

	Xopj_read_bytes_LE(tls, p_header_data, jp2+68, uint32(4)) // BR
	p_header_data += uintptr(4)

	Xopj_read_bytes_LE(tls, p_header_data, jp2+72, uint32(4)) // MinV
	p_header_data += uintptr(4)

	l_remaining_bytes = p_header_size - TOPJ_UINT32(8)

	// the number of remaining bytes should be a multiple of 4
	if l_remaining_bytes&TOPJ_UINT32(0x3) != TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+29974, 0)
		return DOPJ_FALSE
	}

	// div by 4
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl = l_remaining_bytes >> 2
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl != 0 {
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl = Xopj_calloc(tls, uint32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl), uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl == uintptr(00) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+30010, 0)
			return DOPJ_FALSE
		}
	}

	for i = TOPJ_UINT32(0); i < (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fnumcl; i++ {
		Xopj_read_bytes_LE(tls, p_header_data, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl+uintptr(i)*4, uint32(4)) // CLi
		p_header_data += uintptr(4)
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(jp2 + 108)) |= JP2_STATE_FILE_TYPE

	return DOPJ_TRUE
}

var __func__203 = *(*[18]int8)(unsafe.Pointer(ts + 30043)) /* jp2.c:2595:1 */

func opj_jp2_skip_jp2c(tls *libc.TLS, jp2 uintptr, stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2649:17: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2654), uintptr(unsafe.Pointer(&__func__204)))
	}
	if stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+28183, ts+25687, uint32(2655), uintptr(unsafe.Pointer(&__func__204)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2656), uintptr(unsafe.Pointer(&__func__204)))
	}

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k_codestream_offset = Xopj_stream_tell(tls, stream)

	if Xopj_stream_skip(tls, stream, 8, p_manager) != 8 {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__204 = *(*[18]int8)(unsafe.Pointer(ts + 30061)) /* jp2.c:2652:1 */

func opj_jpip_skip_iptr(tls *libc.TLS, jp2 uintptr, stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2667:17: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2672), uintptr(unsafe.Pointer(&__func__205)))
	}
	if stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+28183, ts+25687, uint32(2673), uintptr(unsafe.Pointer(&__func__205)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2674), uintptr(unsafe.Pointer(&__func__205)))
	}

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjpip_iptr_offset = Xopj_stream_tell(tls, stream)

	if Xopj_stream_skip(tls, stream, 24, p_manager) != 24 {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

var __func__205 = *(*[19]int8)(unsafe.Pointer(ts + 30079)) /* jp2.c:2670:1 */

// *
// Reads the Jpeg2000 file Header box - JP2 Header box (warning, this is a super box).
//
// @param   p_header_data   the data contained in the file header box.
// @param   jp2             the jpeg2000 file codec.
// @param   p_header_size   the size of the data contained in the file header box.
// @param   p_manager       the user event manager.
//
// @return true if the JP2 Header box was successfully recognized.
func opj_jp2_read_jp2h(tls *libc.TLS, jp2 uintptr, p_header_data uintptr, p_header_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2695:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_box_size */)) = TOPJ_UINT32(0)
	var l_current_data_size TOPJ_UINT32 = TOPJ_UINT32(0)
	// var box Topj_jp2_box_t at bp, 12

	var l_current_handler uintptr
	var l_has_ihdr TOPJ_BOOL = 0

	// preconditions
	if p_header_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+4176, ts+25687, uint32(2707), uintptr(unsafe.Pointer(&__func__206)))
	}
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2708), uintptr(unsafe.Pointer(&__func__206)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2709), uintptr(unsafe.Pointer(&__func__206)))
	}

	// make sure the box is well placed
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_state&JP2_STATE_FILE_TYPE != JP2_STATE_FILE_TYPE {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+30098, 0)
		return DOPJ_FALSE
	}

	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjp2_img_state = JP2_IMG_STATE_NONE

	// iterate while remaining data
	for p_header_size > TOPJ_UINT32(0) {

		if !(opj_jp2_read_boxhdr_char(tls, bp, p_header_data, bp+12, p_header_size,
			p_manager) != 0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+30143, 0)
			return DOPJ_FALSE
		}

		if (*Topj_jp2_box_t)(unsafe.Pointer(bp)).Flength > p_header_size {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+30186, 0)
			return DOPJ_FALSE
		}

		l_current_handler = opj_jp2_img_find_handler(tls, (*Topj_jp2_box_t)(unsafe.Pointer(bp /* &box */)).Ftype)
		l_current_data_size = (*Topj_jp2_box_t)(unsafe.Pointer(bp)).Flength - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12))
		p_header_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_box_size */)))

		if l_current_handler != uintptr(00) {
			if !((*struct {
				f func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL
			})(unsafe.Pointer(&struct{ uintptr }{(*Topj_jp2_header_handler_t)(unsafe.Pointer(l_current_handler)).Fhandler})).f(tls, jp2, p_header_data, l_current_data_size,
				p_manager) != 0) {
				return DOPJ_FALSE
			}
		} else {
			*(*TOPJ_UINT32)(unsafe.Pointer(jp2 + 112)) |= JP2_IMG_STATE_UNKNOWN
		}

		if (*Topj_jp2_box_t)(unsafe.Pointer(bp)).Ftype == TOPJ_UINT32(DJP2_IHDR) {
			l_has_ihdr = 1
		}

		p_header_data += uintptr(l_current_data_size)
		p_header_size = p_header_size - (*Topj_jp2_box_t)(unsafe.Pointer(bp)).Flength
	}

	if l_has_ihdr == 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+30258, 0)
		return DOPJ_FALSE
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(jp2 + 108)) |= JP2_STATE_HEADER
	(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fhas_jp2h = TOPJ_BYTE(1)

	return DOPJ_TRUE
}

var __func__206 = *(*[18]int8)(unsafe.Pointer(ts + 30317)) /* jp2.c:2700:1 */

func opj_jp2_read_boxhdr_char(tls *libc.TLS, box uintptr, p_data uintptr, p_number_bytes_read uintptr, p_box_max_size TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2769:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var l_value TOPJ_UINT32 at bp, 4

	// preconditions
	if p_data != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+22080, ts+25687, uint32(2779), uintptr(unsafe.Pointer(&__func__207)))
	}
	if box != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25712, ts+25687, uint32(2780), uintptr(unsafe.Pointer(&__func__207)))
	}
	if p_number_bytes_read != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25722, ts+25687, uint32(2781), uintptr(unsafe.Pointer(&__func__207)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2782), uintptr(unsafe.Pointer(&__func__207)))
	}

	if p_box_max_size < TOPJ_UINT32(8) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+30335, 0)
		return DOPJ_FALSE
	}

	// process read data
	Xopj_read_bytes_LE(tls, p_data, bp, uint32(4))
	p_data += uintptr(4)
	(*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength = *(*TOPJ_UINT32)(unsafe.Pointer(bp))

	Xopj_read_bytes_LE(tls, p_data, bp, uint32(4))
	p_data += uintptr(4)
	(*Topj_jp2_box_t)(unsafe.Pointer(box)).Ftype = *(*TOPJ_UINT32)(unsafe.Pointer(bp))

	*(*TOPJ_UINT32)(unsafe.Pointer(p_number_bytes_read)) = TOPJ_UINT32(8)

	// do we have a "special very large box ?"
	// read then the XLBox
	if (*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength == TOPJ_UINT32(1) {
		// var l_xl_part_size TOPJ_UINT32 at bp+4, 4

		if p_box_max_size < TOPJ_UINT32(16) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+30375, 0)
			return DOPJ_FALSE
		}

		Xopj_read_bytes_LE(tls, p_data, bp+4, uint32(4))
		p_data += uintptr(4)
		*(*TOPJ_UINT32)(unsafe.Pointer(p_number_bytes_read)) += TOPJ_UINT32(4)

		if *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4)) != TOPJ_UINT32(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+25748, 0)
			return DOPJ_FALSE
		}

		Xopj_read_bytes_LE(tls, p_data, bp, uint32(4))
		*(*TOPJ_UINT32)(unsafe.Pointer(p_number_bytes_read)) += TOPJ_UINT32(4)
		(*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength = *(*TOPJ_UINT32)(unsafe.Pointer(bp))

		if (*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength == TOPJ_UINT32(0) {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+29181, 0)
			return DOPJ_FALSE
		}
	} else if (*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength == TOPJ_UINT32(0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+29181, 0)
		return DOPJ_FALSE
	}
	if (*Topj_jp2_box_t)(unsafe.Pointer(box)).Flength < *(*TOPJ_UINT32)(unsafe.Pointer(p_number_bytes_read)) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+30419, 0)
		return DOPJ_FALSE
	}
	return DOPJ_TRUE
}

var __func__207 = *(*[25]int8)(unsafe.Pointer(ts + 30448)) /* jp2.c:2775:1 */

func Xopj_jp2_read_header(tls *libc.TLS, p_stream uintptr, jp2 uintptr, p_image uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2840:10: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2847), uintptr(unsafe.Pointer(&__func__208)))
	}
	if p_stream != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3996, ts+25687, uint32(2848), uintptr(unsafe.Pointer(&__func__208)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2849), uintptr(unsafe.Pointer(&__func__208)))
	}

	// customization of the validation
	if !(opj_jp2_setup_decoding_validation(tls, jp2, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// customization of the encoding
	if !(opj_jp2_setup_header_reading(tls, jp2, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// validation of the parameters codec
	if !(opj_jp2_exec(tls, jp2, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// read header
	if !(opj_jp2_exec(tls, jp2, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list, p_stream, p_manager) != 0) {
		return DOPJ_FALSE
	}
	if int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fhas_jp2h) == 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+30473, 0)
		return DOPJ_FALSE
	}
	if int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fhas_ihdr) == 0 {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+30502, 0)
		return DOPJ_FALSE
	}

	return Xopj_j2k_read_header(tls, p_stream,
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k,
		p_image,
		p_manager)
}

var __func__208 = *(*[20]int8)(unsafe.Pointer(ts + 30531)) /* jp2.c:2845:1 */

func opj_jp2_setup_encoding_validation(tls *libc.TLS, jp2 uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2885:17: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2889), uintptr(unsafe.Pointer(&__func__209)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2890), uintptr(unsafe.Pointer(&__func__209)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_jp2_default_validation})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	// DEVELOPER CORNER, add your custom validation procedure

	return DOPJ_TRUE
}

var __func__209 = *(*[34]int8)(unsafe.Pointer(ts + 30551)) /* jp2.c:2887:1 */

func opj_jp2_setup_decoding_validation(tls *libc.TLS, jp2 uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2901:17: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2905), uintptr(unsafe.Pointer(&__func__210)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2906), uintptr(unsafe.Pointer(&__func__210)))
	}

	_ = jp2
	_ = p_manager

	// DEVELOPER CORNER, add your custom validation procedure

	return DOPJ_TRUE
}

var __func__210 = *(*[34]int8)(unsafe.Pointer(ts + 30585)) /* jp2.c:2903:1 */

func opj_jp2_setup_header_writing(tls *libc.TLS, jp2 uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2916:17: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2920), uintptr(unsafe.Pointer(&__func__211)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2921), uintptr(unsafe.Pointer(&__func__211)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_jp2_write_jp})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_jp2_write_ftyp})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_jp2_write_jp2h})), p_manager) != 0) {
		return DOPJ_FALSE
	}
	if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fjpip_on != 0 {
		if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			}{opj_jpip_skip_iptr})), p_manager) != 0) {
			return DOPJ_FALSE
		}
	}
	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_jp2_skip_jp2c})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	// DEVELOPER CORNER, insert your custom procedures

	return DOPJ_TRUE
}

var __func__211 = *(*[29]int8)(unsafe.Pointer(ts + 30619)) /* jp2.c:2918:1 */

func opj_jp2_setup_header_reading(tls *libc.TLS, jp2 uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2951:17: */
	// preconditions
	if jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+25872, ts+25687, uint32(2955), uintptr(unsafe.Pointer(&__func__212)))
	}
	if p_manager != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3959, ts+25687, uint32(2956), uintptr(unsafe.Pointer(&__func__212)))
	}

	if !(Xopj_procedure_list_add_procedure(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{opj_jp2_read_header_procedure})), p_manager) != 0) {
		return DOPJ_FALSE
	}

	// DEVELOPER CORNER, add your custom procedures

	return DOPJ_TRUE
}

var __func__212 = *(*[29]int8)(unsafe.Pointer(ts + 30648)) /* jp2.c:2953:1 */

func Xopj_jp2_read_tile_header(tls *libc.TLS, p_jp2 uintptr, p_tile_index uintptr, p_data_size uintptr, p_tile_x0 uintptr, p_tile_y0 uintptr, p_tile_x1 uintptr, p_tile_y1 uintptr, p_nb_comps uintptr, p_go_on uintptr, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2968:10: */
	return Xopj_j2k_read_tile_header(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k,
		p_tile_index,
		p_data_size,
		p_tile_x0, p_tile_y0,
		p_tile_x1, p_tile_y1,
		p_nb_comps,
		p_go_on,
		p_stream,
		p_manager)
}

func Xopj_jp2_write_tile(tls *libc.TLS, p_jp2 uintptr, p_tile_index TOPJ_UINT32, p_data uintptr, p_data_size TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:2992:10: */
	return Xopj_j2k_write_tile(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k, p_tile_index, p_data, p_data_size,
		p_stream, p_manager)
}

func Xopj_jp2_decode_tile(tls *libc.TLS, p_jp2 uintptr, p_tile_index TOPJ_UINT32, p_data uintptr, p_data_size TOPJ_UINT32, p_stream uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:3005:10: */
	return Xopj_j2k_decode_tile(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k, p_tile_index, p_data, p_data_size,
		p_stream, p_manager)
}

func Xopj_jp2_destroy(tls *libc.TLS, jp2 uintptr) { /* jp2.c:3017:6: */
	if jp2 != 0 {
		// destroy the J2K codec
		Xopj_j2k_destroy(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k)
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k = uintptr(00)

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps != 0 {
			Xopj_free(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps)
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcomps = uintptr(00)
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl != 0 {
			Xopj_free(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl)
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcl = uintptr(00)
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf != 0 {
			Xopj_free(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf)
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf = uintptr(00)
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef != 0 {
			if (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo != 0 {
				Xopj_free(tls, (*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo)
				(*Topj_jp2_cdef_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)).Finfo = uintptr(0)
			}

			Xopj_free(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef)
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef = uintptr(00)
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr != 0 {
			if (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fcmap != 0 {
				Xopj_free(tls, (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fcmap)
				(*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fcmap = uintptr(0)
			}
			if (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fchannel_sign != 0 {
				Xopj_free(tls, (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fchannel_sign)
				(*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fchannel_sign = uintptr(0)
			}
			if (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fchannel_size != 0 {
				Xopj_free(tls, (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fchannel_size)
				(*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fchannel_size = uintptr(0)
			}
			if (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fentries != 0 {
				Xopj_free(tls, (*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fentries)
				(*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)).Fentries = uintptr(0)
			}

			Xopj_free(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr)
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr = uintptr(00)
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list != 0 {
			Xopj_procedure_list_destroy(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list)
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list = uintptr(00)
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list != 0 {
			Xopj_procedure_list_destroy(tls, (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list)
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list = uintptr(00)
		}

		Xopj_free(tls, jp2)
	}
}

func Xopj_jp2_set_decoded_components(tls *libc.TLS, p_jp2 uintptr, numcomps TOPJ_UINT32, comps_indices uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:3085:10: */
	return Xopj_j2k_set_decoded_components(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k,
		numcomps, comps_indices,
		p_manager)
}

func Xopj_jp2_set_decode_area(tls *libc.TLS, p_jp2 uintptr, p_image uintptr, p_start_x TOPJ_INT32, p_start_y TOPJ_INT32, p_end_x TOPJ_INT32, p_end_y TOPJ_INT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:3095:10: */
	return Xopj_j2k_set_decode_area(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k, p_image, p_start_x, p_start_y,
		p_end_x, p_end_y, p_manager)
}

func Xopj_jp2_get_tile(tls *libc.TLS, p_jp2 uintptr, p_stream uintptr, p_image uintptr, p_manager uintptr, tile_index TOPJ_UINT32) TOPJ_BOOL { /* jp2.c:3106:10: */
	if !(p_image != 0) {
		return DOPJ_FALSE
	}

	Xopj_event_msg(tls, p_manager, DEVT_WARNING,
		ts+30677, 0)

	if !(Xopj_j2k_get_tile(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k, p_stream, p_image, p_manager, tile_index) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+28134, 0)
		return DOPJ_FALSE
	}

	if (*Topj_j2k_dec_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k+8)).Fm_numcomps_to_decode != 0 {
		// Bypass all JP2 component transforms
		return DOPJ_TRUE
	}

	if !(opj_jp2_check_color(tls, p_image, p_jp2+120, p_manager) != 0) {
		return DOPJ_FALSE
	}

	// Set Image Color Space
	if (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fenumcs == TOPJ_UINT32(16) {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_SRGB
	} else if (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fenumcs == TOPJ_UINT32(17) {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_GRAY
	} else if (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fenumcs == TOPJ_UINT32(18) {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_SYCC
	} else if (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fenumcs == TOPJ_UINT32(24) {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_EYCC
	} else if (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fenumcs == TOPJ_UINT32(12) {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_CMYK
	} else {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Fcolor_space = OPJ_CLRSPC_UNKNOWN
	}

	if (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fcolor.Fjp2_pclr != 0 {
		// Part 1, I.5.3.4: Either both or none :
		if !(int32((*Topj_jp2_pclr_t)(unsafe.Pointer((*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fcolor.Fjp2_pclr)).Fcmap) != 0) {
			opj_jp2_free_pclr(tls, p_jp2+120)
		} else {
			if !(opj_jp2_apply_pclr(tls, p_image, p_jp2+120, p_manager) != 0) {
				return DOPJ_FALSE
			}
		}
	}

	// Apply the color space if needed
	if (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fcolor.Fjp2_cdef != 0 {
		opj_jp2_apply_cdef(tls, p_image, p_jp2+120, p_manager)
	}

	if (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fcolor.Ficc_profile_buf != 0 {
		(*Topj_image_t)(unsafe.Pointer(p_image)).Ficc_profile_buf = (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fcolor.Ficc_profile_buf
		(*Topj_image_t)(unsafe.Pointer(p_image)).Ficc_profile_len = (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fcolor.Ficc_profile_len
		(*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fcolor.Ficc_profile_buf = uintptr(0)
	}

	return DOPJ_TRUE
}

// -----------------------------------------------------------------------
// JP2 encoder interface
// -----------------------------------------------------------------------

func Xopj_jp2_create(tls *libc.TLS, p_is_decoder TOPJ_BOOL) uintptr { /* jp2.c:3179:10: */
	var jp2 uintptr = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_jp2_t{})))
	if jp2 != 0 {

		// create the J2K codec
		if !(p_is_decoder != 0) {
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k = Xopj_j2k_create_compress(tls)
		} else {
			(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k = Xopj_j2k_create_decompress(tls)
		}

		if (*Topj_jp2_t)(unsafe.Pointer(jp2)).Fj2k == uintptr(00) {
			Xopj_jp2_destroy(tls, jp2)
			return uintptr(00)
		}

		// Color structure
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_buf = uintptr(0)
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Ficc_profile_len = TOPJ_UINT32(0)
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_cdef = uintptr(0)
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_pclr = uintptr(0)
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fcolor.Fjp2_has_colr = TOPJ_BYTE(0)

		// validation list creation
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list = Xopj_procedure_list_create(tls)
		if !(int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_validation_list) != 0) {
			Xopj_jp2_destroy(tls, jp2)
			return uintptr(00)
		}

		// execution list creation
		(*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list = Xopj_procedure_list_create(tls)
		if !(int32((*Topj_jp2_t)(unsafe.Pointer(jp2)).Fm_procedure_list) != 0) {
			Xopj_jp2_destroy(tls, jp2)
			return uintptr(00)
		}
	}

	return jp2
}

func Xjp2_dump(tls *libc.TLS, p_jp2 uintptr, flag TOPJ_INT32, out_stream uintptr) { /* jp2.c:3221:6: */
	// preconditions
	if p_jp2 != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+30752, ts+25687, uint32(3224), uintptr(unsafe.Pointer(&__func__213)))
	}

	Xj2k_dump(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k,
		flag,
		out_stream)
}

var __func__213 = *(*[9]int8)(unsafe.Pointer(ts + 30764)) /* jp2.c:3222:1 */

func Xjp2_get_cstr_index(tls *libc.TLS, p_jp2 uintptr) uintptr { /* jp2.c:3231:23: */
	return Xj2k_get_cstr_index(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k)
}

func Xjp2_get_cstr_info(tls *libc.TLS, p_jp2 uintptr) uintptr { /* jp2.c:3236:25: */
	return Xj2k_get_cstr_info(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k)
}

func Xopj_jp2_set_decoded_resolution_factor(tls *libc.TLS, p_jp2 uintptr, res_factor TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* jp2.c:3241:10: */
	return Xopj_j2k_set_decoded_resolution_factor(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k, res_factor, p_manager)
}

// -----------------------------------------------------------------------

func Xopj_jp2_encoder_set_extra_options(tls *libc.TLS, p_jp2 uintptr, p_options uintptr, p_manager uintptr) TOPJ_BOOL { /* jp2.c:3250:10: */
	return Xopj_j2k_encoder_set_extra_options(tls, (*Topj_jp2_t)(unsafe.Pointer(p_jp2)).Fj2k, p_options, p_manager)
}

// -----------------------------------------------------------------------

// JPIP specific

// <summary>
// This table contains the norms of the basis function of the reversible MCT.
// </summary>
var opj_mct_norms = [3]TOPJ_FLOAT64{1.732, .8292, .8292} /* mct.c:59:26 */

// <summary>
// This table contains the norms of the basis function of the irreversible MCT.
// </summary>
var opj_mct_norms_real = [3]TOPJ_FLOAT64{1.732, 1.805, 1.573} /* mct.c:64:26 */

func Xopj_mct_get_mct_norms(tls *libc.TLS) uintptr { /* mct.c:66:19: */
	return uintptr(unsafe.Pointer(&opj_mct_norms))
}

func Xopj_mct_get_mct_norms_real(tls *libc.TLS) uintptr { /* mct.c:71:19: */
	return uintptr(unsafe.Pointer(&opj_mct_norms_real))
}

// <summary>
// Forward reversible MCT.
// </summary>
func Xopj_mct_encode(tls *libc.TLS, c0 uintptr, c1 uintptr, c2 uintptr, n TOPJ_SIZE_T) { /* mct.c:122:6: */
	var i TOPJ_SIZE_T
	var len TOPJ_SIZE_T = n

	for i = TOPJ_SIZE_T(0); i < len; i++ {
		var r TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(c0 + uintptr(i)*4))
		var g TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(c1 + uintptr(i)*4))
		var b TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(c2 + uintptr(i)*4))
		var y TOPJ_INT32 = (r + g*2 + b) >> 2
		var u TOPJ_INT32 = b - g
		var v TOPJ_INT32 = r - g
		*(*TOPJ_INT32)(unsafe.Pointer(c0 + uintptr(i)*4)) = y
		*(*TOPJ_INT32)(unsafe.Pointer(c1 + uintptr(i)*4)) = u
		*(*TOPJ_INT32)(unsafe.Pointer(c2 + uintptr(i)*4)) = v
	}
}

// <summary>
// Inverse reversible MCT.
// </summary>
func Xopj_mct_decode(tls *libc.TLS, c0 uintptr, c1 uintptr, c2 uintptr, n TOPJ_SIZE_T) { /* mct.c:184:6: */
	var i TOPJ_SIZE_T
	for i = TOPJ_SIZE_T(0); i < n; i++ {
		var y TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(c0 + uintptr(i)*4))
		var u TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(c1 + uintptr(i)*4))
		var v TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(c2 + uintptr(i)*4))
		var g TOPJ_INT32 = y - (u+v)>>2
		var r TOPJ_INT32 = v + g
		var b TOPJ_INT32 = u + g
		*(*TOPJ_INT32)(unsafe.Pointer(c0 + uintptr(i)*4)) = r
		*(*TOPJ_INT32)(unsafe.Pointer(c1 + uintptr(i)*4)) = g
		*(*TOPJ_INT32)(unsafe.Pointer(c2 + uintptr(i)*4)) = b
	}
}

// <summary>
// Get norm of basis function of reversible MCT.
// </summary>
func Xopj_mct_getnorm(tls *libc.TLS, compno TOPJ_UINT32) TOPJ_FLOAT64 { /* mct.c:208:13: */
	return opj_mct_norms[compno]
}

// <summary>
// Forward irreversible MCT.
// </summary>
func Xopj_mct_encode_real(tls *libc.TLS, c0 uintptr, c1 uintptr, c2 uintptr, n TOPJ_SIZE_T) { /* mct.c:216:6: */
	var i TOPJ_SIZE_T
	for i = TOPJ_SIZE_T(0); i < n; i++ {
		var r TOPJ_FLOAT32 = *(*TOPJ_FLOAT32)(unsafe.Pointer(c0 + uintptr(i)*4))
		var g TOPJ_FLOAT32 = *(*TOPJ_FLOAT32)(unsafe.Pointer(c1 + uintptr(i)*4))
		var b TOPJ_FLOAT32 = *(*TOPJ_FLOAT32)(unsafe.Pointer(c2 + uintptr(i)*4))
		var y TOPJ_FLOAT32 = 0.299*r + 0.587*g + 0.114*b
		var u TOPJ_FLOAT32 = -0.16875*r - 0.331260*g + 0.5*b
		var v TOPJ_FLOAT32 = 0.5*r - 0.41869*g - 0.08131*b
		*(*TOPJ_FLOAT32)(unsafe.Pointer(c0 + uintptr(i)*4)) = y
		*(*TOPJ_FLOAT32)(unsafe.Pointer(c1 + uintptr(i)*4)) = u
		*(*TOPJ_FLOAT32)(unsafe.Pointer(c2 + uintptr(i)*4)) = v
	}
}

// <summary>
// Inverse irreversible MCT.
// </summary>
func Xopj_mct_decode_real(tls *libc.TLS, c0 uintptr, c1 uintptr, c2 uintptr, n TOPJ_SIZE_T) { /* mct.c:286:6: */
	var i TOPJ_SIZE_T
	for i = TOPJ_SIZE_T(0); i < n; i++ {
		var y TOPJ_FLOAT32 = *(*TOPJ_FLOAT32)(unsafe.Pointer(c0 + uintptr(i)*4))
		var u TOPJ_FLOAT32 = *(*TOPJ_FLOAT32)(unsafe.Pointer(c1 + uintptr(i)*4))
		var v TOPJ_FLOAT32 = *(*TOPJ_FLOAT32)(unsafe.Pointer(c2 + uintptr(i)*4))
		var r TOPJ_FLOAT32 = y + v*1.402
		var g TOPJ_FLOAT32 = y - u*0.34413 - v*0.71414
		var b TOPJ_FLOAT32 = y + u*1.772
		*(*TOPJ_FLOAT32)(unsafe.Pointer(c0 + uintptr(i)*4)) = r
		*(*TOPJ_FLOAT32)(unsafe.Pointer(c1 + uintptr(i)*4)) = g
		*(*TOPJ_FLOAT32)(unsafe.Pointer(c2 + uintptr(i)*4)) = b
	}
}

// <summary>
// Get norm of basis function of irreversible MCT.
// </summary>
func Xopj_mct_getnorm_real(tls *libc.TLS, compno TOPJ_UINT32) TOPJ_FLOAT64 { /* mct.c:347:13: */
	return opj_mct_norms_real[compno]
}

func Xopj_mct_encode_custom(tls *libc.TLS, pCodingdata uintptr, n TOPJ_SIZE_T, pData uintptr, pNbComp TOPJ_UINT32, isSigned TOPJ_UINT32) TOPJ_BOOL { /* mct.c:353:10: */
	var lMct uintptr = pCodingdata
	var i TOPJ_SIZE_T
	var j TOPJ_UINT32
	var k TOPJ_UINT32
	var lNbMatCoeff TOPJ_UINT32 = pNbComp * pNbComp
	var lCurrentData uintptr = uintptr(00)
	var lCurrentMatrix uintptr = uintptr(00)
	var lData uintptr = pData
	var lMultiplicator TOPJ_UINT32 = TOPJ_UINT32(int32(1) << 13)
	var lMctPtr uintptr

	_ = isSigned

	lCurrentData = Xopj_malloc(tls, uint32(pNbComp+lNbMatCoeff)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
	if !(lCurrentData != 0) {
		return DOPJ_FALSE
	}

	lCurrentMatrix = lCurrentData + uintptr(pNbComp)*4

	for i = TOPJ_SIZE_T(0); i < TOPJ_SIZE_T(lNbMatCoeff); i++ {
		*(*TOPJ_INT32)(unsafe.Pointer(lCurrentMatrix + uintptr(i)*4)) = libc.Int32FromFloat32(*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lMct, 4))) * TOPJ_FLOAT32(lMultiplicator))
	}

	for i = TOPJ_SIZE_T(0); i < n; i++ {
		lMctPtr = lCurrentMatrix
		for j = TOPJ_UINT32(0); j < pNbComp; j++ {
			*(*TOPJ_INT32)(unsafe.Pointer(lCurrentData + uintptr(j)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(lData + uintptr(j)*8))))
		}

		for j = TOPJ_UINT32(0); j < pNbComp; j++ {
			*(*TOPJ_INT32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(lData + uintptr(j)*8)))) = 0
			for k = TOPJ_UINT32(0); k < pNbComp; k++ {
				*(*TOPJ_INT32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(lData + uintptr(j)*8)))) += opj_int_fix_mul(tls, *(*TOPJ_INT32)(unsafe.Pointer(lMctPtr)), *(*TOPJ_INT32)(unsafe.Pointer(lCurrentData + uintptr(k)*4)))
				lMctPtr += 4
			}

			*(*uintptr)(unsafe.Pointer(lData + uintptr(j)*8)) += 4
		}
	}

	Xopj_free(tls, lCurrentData)

	return DOPJ_TRUE
}

func Xopj_mct_decode_custom(tls *libc.TLS, pDecodingData uintptr, n TOPJ_SIZE_T, pData uintptr, pNbComp TOPJ_UINT32, isSigned TOPJ_UINT32) TOPJ_BOOL { /* mct.c:407:10: */
	var lMct uintptr
	var i TOPJ_SIZE_T
	var j TOPJ_UINT32
	var k TOPJ_UINT32

	var lCurrentData uintptr = uintptr(00)
	var lCurrentResult uintptr = uintptr(00)
	var lData uintptr = pData

	_ = isSigned

	lCurrentData = Xopj_malloc(tls, uint32(TOPJ_UINT32(2)*pNbComp)*uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))))
	if !(lCurrentData != 0) {
		return DOPJ_FALSE
	}
	lCurrentResult = lCurrentData + uintptr(pNbComp)*4

	for i = TOPJ_SIZE_T(0); i < n; i++ {
		lMct = pDecodingData
		for j = TOPJ_UINT32(0); j < pNbComp; j++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(lCurrentData + uintptr(j)*4)) = *(*TOPJ_FLOAT32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(lData + uintptr(j)*8))))
		}
		for j = TOPJ_UINT32(0); j < pNbComp; j++ {
			*(*TOPJ_FLOAT32)(unsafe.Pointer(lCurrentResult + uintptr(j)*4)) = TOPJ_FLOAT32(0)
			for k = TOPJ_UINT32(0); k < pNbComp; k++ {
				*(*TOPJ_FLOAT32)(unsafe.Pointer(lCurrentResult + uintptr(j)*4)) += *(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&lMct, 4))) * *(*TOPJ_FLOAT32)(unsafe.Pointer(lCurrentData + uintptr(k)*4))
			}
			*(*TOPJ_FLOAT32)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(lData + uintptr(j)*8)), 4))) = *(*TOPJ_FLOAT32)(unsafe.Pointer(lCurrentResult + uintptr(j)*4))
		}
	}
	Xopj_free(tls, lCurrentData)
	return DOPJ_TRUE
}

func Xopj_calculate_norms(tls *libc.TLS, pNorms uintptr, pNbComps TOPJ_UINT32, pMatrix uintptr) { /* mct.c:448:6: */
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var lIndex TOPJ_UINT32
	var lCurrentValue TOPJ_FLOAT32
	var lNorms uintptr = pNorms
	var lMatrix uintptr = pMatrix

	for i = TOPJ_UINT32(0); i < pNbComps; i++ {
		*(*TOPJ_FLOAT64)(unsafe.Pointer(lNorms + uintptr(i)*8)) = TOPJ_FLOAT64(0)
		lIndex = i

		for j = TOPJ_UINT32(0); j < pNbComps; j++ {
			lCurrentValue = *(*TOPJ_FLOAT32)(unsafe.Pointer(lMatrix + uintptr(lIndex)*4))
			lIndex = lIndex + pNbComps
			*(*TOPJ_FLOAT64)(unsafe.Pointer(lNorms + uintptr(i)*8)) += TOPJ_FLOAT64(lCurrentValue) * float64(lCurrentValue)
		}
		*(*TOPJ_FLOAT64)(unsafe.Pointer(lNorms + uintptr(i)*8)) = libc.Xsqrt(tls, *(*TOPJ_FLOAT64)(unsafe.Pointer(lNorms + uintptr(i)*8)))
	}
}

//@}

//@}

// <summary>
// This array defines all the possible states for a context.
// </summary>
var mqc_states = [94]Topj_mqc_state_t{
	{Fqeval: TOPJ_UINT32(0x5601), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5601), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3401), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3401), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1801), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1801), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0ac1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0ac1), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0521), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0521), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0221), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0221), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5601), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5601), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5401), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5401), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x4801), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x4801), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3801), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3801), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3001), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3001), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x2401), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x2401), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1c01), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1c01), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1601), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1601), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5601), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5601), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5401), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5401), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5101), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5101), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x4801), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x4801), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3801), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3801), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3401), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3401), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3001), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x3001), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x2801), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x2801), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x2401), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x2401), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x2201), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x2201), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1c01), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1c01), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1801), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1801), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1601), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1601), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1401), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1401), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1201), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1201), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1101), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x1101), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0ac1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0ac1), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x09c1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x09c1), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x08a1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x08a1), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0521), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0521), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0441), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0441), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x02a1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x02a1), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0221), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0221), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0141), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0141), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0111), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0111), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0085), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0085), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0049), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0049), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0025), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0025), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0015), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0015), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0009), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0009), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0005), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0005), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0001), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x0001), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5601), Fnmps: 0, Fnlps: 0},
	{Fqeval: TOPJ_UINT32(0x5601), Fmps: TOPJ_UINT32(1), Fnmps: 0, Fnlps: 0},
} /* mqc.c:61:30 */

//
// ==========================================================
//    local functions
// ==========================================================

func opj_mqc_setbits(tls *libc.TLS, mqc uintptr) { /* mqc.c:164:13: */
	var tempc TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc + (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
	*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) |= TOPJ_UINT32(0xffff)
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc >= tempc {
		*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= TOPJ_UINT32(0x8000)
	}
}

//
// ==========================================================
//    MQ-Coder interface
// ==========================================================

func Xopj_mqc_numbytes(tls *libc.TLS, mqc uintptr) TOPJ_UINT32 { /* mqc.c:179:12: */
	var diff Tptrdiff_t = (int32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp) - int32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fstart)) / 1
	return TOPJ_UINT32(diff)
}

func Xopj_mqc_init_enc(tls *libc.TLS, mqc uintptr, bp uintptr) { /* mqc.c:188:6: */
	// To avoid the curctx pointer to be dangling, but not strictly
	// required as the current context is always set before encoding
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40

	// As specified in Figure C.10 - Initialization of the encoder
	// (C.2.8 Initialization of the encoder (INITENC))
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = TOPJ_UINT32(0x8000)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(0)
	// Yes, we point before the start of the buffer, but this is safe
	// given opj_tcd_code_block_enc_allocate_data()
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp = bp - uintptr(1)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(12)
	// At this point we should test *(mqc->bp) against 0xFF, but this is not
	// necessary, as this is only used at the beginning of the code block
	// and our initial fake byte is set at 0
	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) != 0xff {
	} else {
		libc.X__assert_fail(tls, ts+30773, ts+30792, uint32(205), uintptr(unsafe.Pointer(&__func__222)))
	}

	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fstart = bp
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter = TOPJ_UINT32(0)
}

var __func__222 = *(*[17]int8)(unsafe.Pointer(ts + 30817)) /* mqc.c:189:1 */

func Xopj_mqc_flush(tls *libc.TLS, mqc uintptr) { /* mqc.c:212:6: */
	// C.2.9 Termination of coding (FLUSH)
	// Figure C.11  FLUSH procedure
	opj_mqc_setbits(tls, mqc)
	libc.AssignShlPtrUint32(mqc, int((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct))
	Xopj_mqc_byteout(tls, mqc)
	libc.AssignShlPtrUint32(mqc, int((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct))
	Xopj_mqc_byteout(tls, mqc)

	// It is forbidden that a coding pass ends with 0xff
	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) != 0xff {
		// Advance pointer so that opj_mqc_numbytes() returns a valid value
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
	}
}

func Xopj_mqc_bypass_init_enc(tls *libc.TLS, mqc uintptr) { /* mqc.c:229:6: */
	// This function is normally called after at least one opj_mqc_flush()
	// which will have advance mqc->bp by at least 2 bytes beyond its
	// initial position
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp >= (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fstart {
	} else {
		libc.X__assert_fail(tls, ts+30834, ts+30792, uint32(234), uintptr(unsafe.Pointer(&__func__223)))
	}
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(0)
	// in theory we should initialize to 8, but use this special value
	// as a hint that opj_mqc_bypass_enc() has never been called, so
	// as to avoid the 0xff 0x7f elimination trick in opj_mqc_bypass_flush_enc()
	// to trigger when we don't have output any bit during this bypass sequence
	// Any value > 8 will do
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = DBYPASS_CT_INIT
	// Given that we are called after opj_mqc_flush(), the previous byte
	// cannot be 0xff.
	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + libc.UintptrFromInt32(-1)))) != 0xff {
	} else {
		libc.X__assert_fail(tls, ts+30856, ts+30792, uint32(244), uintptr(unsafe.Pointer(&__func__223)))
	}
}

var __func__223 = *(*[24]int8)(unsafe.Pointer(ts + 30876)) /* mqc.c:230:1 */

func Xopj_mqc_bypass_enc(tls *libc.TLS, mqc uintptr, d TOPJ_UINT32) { /* mqc.c:247:6: */
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == DBYPASS_CT_INIT {
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
	}
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc + d<<(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
		*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc)
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
		// If the previous byte was 0xff, make sure that the next msb is 0
		if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
		}
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(0)
	}
}

func Xopj_mqc_bypass_get_extra_bytes(tls *libc.TLS, mqc uintptr, erterm TOPJ_BOOL) TOPJ_UINT32 { /* mqc.c:266:12: */
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct < TOPJ_UINT32(7) || (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(7) && (erterm != 0 || int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + libc.UintptrFromInt32(-1)))) != 0xff) {
		return uint32(1)
	}
	return uint32(0)
}

func Xopj_mqc_bypass_flush_enc(tls *libc.TLS, mqc uintptr, erterm TOPJ_BOOL) { /* mqc.c:272:6: */
	// Is there any bit remaining to be flushed ?
	// If the last output byte is 0xff, we can discard it, unless
	// erterm is required (I'm not completely sure why in erterm
	// we must output 0xff 0x2a if the last byte was 0xff instead of
	// discarding it, but Kakadu requires it when decoding
	// in -fussy mode)
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct < TOPJ_UINT32(7) || (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(7) && (erterm != 0 || int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + libc.UintptrFromInt32(-1)))) != 0xff) {
		var bit_value TOPJ_BYTE = TOPJ_BYTE(0)
		// If so, fill the remaining lsbs with an alternating sequence of
		// 0,1,...
		// Note: it seems the standard only requires that for a ERTERM flush
		// and doesn't specify what to do for a regular BYPASS flush
		for (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct > TOPJ_UINT32(0) {
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) += TOPJ_UINT32(int32(bit_value) << (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct)
			bit_value = TOPJ_BYTE(1 - uint32(bit_value))
		}
		*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc)
		// Advance pointer so that opj_mqc_numbytes() returns a valid value
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
	} else if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(7) && int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + libc.UintptrFromInt32(-1)))) == 0xff {
		// Discard last 0xff
		if !(erterm != 0) {
		} else {
			libc.X__assert_fail(tls, ts+30900, ts+30792, uint32(296), uintptr(unsafe.Pointer(&__func__224)))
		}
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp--
	} else if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(8) && !(erterm != 0) && int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + libc.UintptrFromInt32(-1)))) == 0x7f && int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + libc.UintptrFromInt32(-2)))) == 0xff {
		// Tiny optimization: discard terminating 0xff 0x7f since it is
		// interpreted as 0xff 0x7f [0xff 0xff] by the decoder, and given
		// the bit stuffing, in fact as 0xff 0xff [0xff ..]
		// Happens once on opj_compress -i ../MAPA.tif -o MAPA.j2k  -M 1
		*(*uintptr)(unsafe.Pointer(mqc + 16)) -= uintptr(2)
	}

	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + libc.UintptrFromInt32(-1)))) != 0xff {
	} else {
		libc.X__assert_fail(tls, ts+30856, ts+30792, uint32(307), uintptr(unsafe.Pointer(&__func__224)))
	}
}

var __func__224 = *(*[25]int8)(unsafe.Pointer(ts + 30908)) /* mqc.c:273:1 */

func Xopj_mqc_reset_enc(tls *libc.TLS, mqc uintptr) { /* mqc.c:310:6: */
	Xopj_mqc_resetstates(tls, mqc)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC+DT1_NUMCTXS_ZC+DT1_NUMCTXS_SC+DT1_NUMCTXS_MAG+DT1_NUMCTXS_AGG), uint32(0), 46)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC+DT1_NUMCTXS_ZC+DT1_NUMCTXS_SC+DT1_NUMCTXS_MAG), uint32(0), 3)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC), uint32(0), 4)
}

func Xopj_mqc_restart_init_enc(tls *libc.TLS, mqc uintptr) { /* mqc.c:337:6: */
	// <Re-init part>

	// As specified in Figure C.10 - Initialization of the encoder
	// (C.2.8 Initialization of the encoder (INITENC))
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = TOPJ_UINT32(0x8000)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(0)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(12)
	// This function is normally called after at least one opj_mqc_flush()
	// which will have advance mqc->bp by at least 2 bytes beyond its
	// initial position
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp--
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp >= (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fstart-uintptr(1) {
	} else {
		libc.X__assert_fail(tls, ts+30933, ts+30792, uint32(350), uintptr(unsafe.Pointer(&__func__225)))
	}
	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) != 0xff {
	} else {
		libc.X__assert_fail(tls, ts+30959, ts+30792, uint32(351), uintptr(unsafe.Pointer(&__func__225)))
	}
	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(13)
	}
}

var __func__225 = *(*[25]int8)(unsafe.Pointer(ts + 30976)) /* mqc.c:338:1 */

func Xopj_mqc_erterm_enc(tls *libc.TLS, mqc uintptr) { /* mqc.c:357:6: */
	var k TOPJ_INT32 = TOPJ_INT32(TOPJ_UINT32(11) - (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct + TOPJ_UINT32(1))

	for k > 0 {
		libc.AssignShlPtrUint32(mqc, int((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct))
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(0)
		Xopj_mqc_byteout(tls, mqc)
		k = k - TOPJ_INT32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct)
	}

	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) != 0xff {
		Xopj_mqc_byteout(tls, mqc)
	}
}

//*
// Encode the most probable symbol
// @param mqc MQC handle
func opj_mqc_codemps(tls *libc.TLS, mqc uintptr) { /* mqc.c:382:20: */
	{
		*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
		if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
			if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
			} else {
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) += (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
			}
			*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
			{
				for __ccgo := true; __ccgo; __ccgo = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
					libc.AssignShlPtrUint32(mqc+4, int(1))
					libc.AssignShlPtrUint32(mqc, int(1))
					(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
					if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
						Xopj_mqc_byteout(tls, mqc)
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
					}
				}
			}
		} else {
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) += (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
		}
	}

}

//*
// Encode the most least symbol
// @param mqc MQC handle
func opj_mqc_codelps(tls *libc.TLS, mqc uintptr) { /* mqc.c:391:20: */
	{
		*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
		if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) += (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
		} else {
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
		}
		*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
		{
			for __ccgo := true; __ccgo; __ccgo = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
				libc.AssignShlPtrUint32(mqc+4, int(1))
				libc.AssignShlPtrUint32(mqc, int(1))
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
				if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
					(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
					Xopj_mqc_byteout(tls, mqc)
					(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
					(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
				}
			}
		}

	}

}

//*
// Encode a symbol using the MQ-coder
// @param mqc MQC handle
// @param d The symbol to be encoded (0 or 1)
func opj_mqc_encode(tls *libc.TLS, mqc uintptr, d TOPJ_UINT32) { /* mqc.c:401:20: */
	if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps == d {
		opj_mqc_codemps(tls, mqc)
	} else {
		opj_mqc_codelps(tls, mqc)
	}
}

func Xopj_mqc_segmark_enc(tls *libc.TLS, mqc uintptr) { /* mqc.c:410:6: */
	var i TOPJ_UINT32
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40 + 18*8

	for i = TOPJ_UINT32(1); i < TOPJ_UINT32(5); i++ {
		opj_mqc_encode(tls, mqc, i%TOPJ_UINT32(2))
	}
}

func opj_mqc_init_dec_common(tls *libc.TLS, mqc uintptr, bp uintptr, len TOPJ_UINT32, extra_writable_bytes TOPJ_UINT32) { /* mqc.c:420:13: */
	_ = extra_writable_bytes

	if extra_writable_bytes >= TOPJ_UINT32(DOPJ_COMMON_CBLK_DATA_EXTRA) {
	} else {
		libc.X__assert_fail(tls, ts+31001, ts+30792, uint32(427), uintptr(unsafe.Pointer(&__func__226)))
	}
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fstart = bp
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend = bp + uintptr(len)
	// Insert an artificial 0xFF 0xFF marker at end of the code block
	// data so that the bytein routines stop on it. This saves us comparing
	// the bp and end pointers
	// But before inserting it, backup th bytes we will overwrite
	libc.Xmemcpy(tls, mqc+208, (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend, uint32(DOPJ_COMMON_CBLK_DATA_EXTRA))
	*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend)) = TOPJ_BYTE(0xFF)
	*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend + 1)) = TOPJ_BYTE(0xFF)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp = bp
}

var __func__226 = *(*[24]int8)(unsafe.Pointer(ts + 31052)) /* mqc.c:424:1 */

func Xopj_mqc_init_dec(tls *libc.TLS, mqc uintptr, bp uintptr, len TOPJ_UINT32, extra_writable_bytes TOPJ_UINT32) { /* mqc.c:439:6: */
	// Implements ISO 15444-1 C.3.5 Initialization of the decoder (INITDEC)
	// Note: alternate "J.1 - Initialization of the software-conventions
	// decoder" has been tried, but does
	// not bring any improvement.
	// See https://github.com/uclouvain/openjpeg/issues/921
	opj_mqc_init_dec_common(tls, mqc, bp, len, extra_writable_bytes)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter = TOPJ_UINT32(0)
	if len == TOPJ_UINT32(0) {
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(int32(0xff) << 16)
	} else {
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) << 16)
	}

	opj_mqc_bytein(tls, mqc)
	libc.AssignShlPtrUint32(mqc, int(7))
	*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 8)) -= TOPJ_UINT32(7)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = TOPJ_UINT32(0x8000)
}

func Xopj_mqc_raw_init_dec(tls *libc.TLS, mqc uintptr, bp uintptr, len TOPJ_UINT32, extra_writable_bytes TOPJ_UINT32) { /* mqc.c:463:6: */
	opj_mqc_init_dec_common(tls, mqc, bp, len, extra_writable_bytes)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = TOPJ_UINT32(0)
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(0)
}

func Xopq_mqc_finish_dec(tls *libc.TLS, mqc uintptr) { /* mqc.c:472:6: */
	// Restore the bytes overwritten by opj_mqc_init_dec_common()
	libc.Xmemcpy(tls, (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend, mqc+208, uint32(DOPJ_COMMON_CBLK_DATA_EXTRA))
}

func Xopj_mqc_resetstates(tls *libc.TLS, mqc uintptr) { /* mqc.c:478:6: */
	var i TOPJ_UINT32
	for i = TOPJ_UINT32(0); i < TOPJ_UINT32(DMQC_NUMCTXS); i++ {
		*(*uintptr)(unsafe.Pointer(mqc + 40 + uintptr(i)*8)) = uintptr(unsafe.Pointer(&mqc_states))
	}
}

func Xopj_mqc_setstate(tls *libc.TLS, mqc uintptr, ctxno TOPJ_UINT32, msb TOPJ_UINT32, prob TOPJ_INT32) { /* mqc.c:486:6: */
	*(*uintptr)(unsafe.Pointer(mqc + 40 + uintptr(ctxno)*8)) = uintptr(unsafe.Pointer(&mqc_states)) + uintptr(msb+TOPJ_UINT32(prob<<1))*24
}

func Xopj_mqc_byteout(tls *libc.TLS, mqc uintptr) { /* mqc.c:492:6: */
	// bp is initialized to start - 1 in opj_mqc_init_enc()
	// but this is safe, see opj_tcd_code_block_enc_allocate_data()
	if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp >= (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fstart-uintptr(1) {
	} else {
		libc.X__assert_fail(tls, ts+30933, ts+30792, uint32(496), uintptr(unsafe.Pointer(&__func__227)))
	}
	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
		*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc >> 20)
		*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) &= TOPJ_UINT32(0xfffff)
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
	} else {
		if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc&TOPJ_UINT32(0x8000000) == TOPJ_UINT32(0) {
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
			*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc >> 19)
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) &= TOPJ_UINT32(0x7ffff)
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
		} else {
			*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))++
			if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) &= TOPJ_UINT32(0x7ffffff)
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
				*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc >> 20)
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) &= TOPJ_UINT32(0xfffff)
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
			} else {
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
				*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc >> 19)
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) &= TOPJ_UINT32(0x7ffff)
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
			}
		}
	}
}

var __func__227 = *(*[16]int8)(unsafe.Pointer(ts + 31076)) /* mqc.c:493:1 */

// ----------------------------------------------------------------------
// Functions to set the message handlers

func Xopj_set_info_handler(tls *libc.TLS, p_codec uintptr, p_callback Topj_msg_callback, p_user_data uintptr) TOPJ_BOOL { /* openjpeg.c:44:23: */
	var l_codec uintptr = p_codec
	if !(l_codec != 0) {
		return DOPJ_FALSE
	}

	(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_event_mgr.Finfo_handler = p_callback
	(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_event_mgr.Fm_info_data = p_user_data

	return DOPJ_TRUE
}

func Xopj_set_warning_handler(tls *libc.TLS, p_codec uintptr, p_callback Topj_msg_callback, p_user_data uintptr) TOPJ_BOOL { /* openjpeg.c:59:23: */
	var l_codec uintptr = p_codec
	if !(l_codec != 0) {
		return DOPJ_FALSE
	}

	(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_event_mgr.Fwarning_handler = p_callback
	(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_event_mgr.Fm_warning_data = p_user_data

	return DOPJ_TRUE
}

func Xopj_set_error_handler(tls *libc.TLS, p_codec uintptr, p_callback Topj_msg_callback, p_user_data uintptr) TOPJ_BOOL { /* openjpeg.c:74:23: */
	var l_codec uintptr = p_codec
	if !(l_codec != 0) {
		return DOPJ_FALSE
	}

	(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_event_mgr.Ferror_handler = p_callback
	(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_event_mgr.Fm_error_data = p_user_data

	return DOPJ_TRUE
}

// ----------------------------------------------------------------------

func opj_read_from_file(tls *libc.TLS, p_buffer uintptr, p_nb_bytes TOPJ_SIZE_T, p_user_data uintptr) TOPJ_SIZE_T { /* openjpeg.c:91:19: */
	var p_file uintptr = p_user_data
	var l_nb_read TOPJ_SIZE_T = libc.Xfread(tls, p_buffer, uint32(1), p_nb_bytes, p_file)
	if l_nb_read != 0 {
		return l_nb_read
	}
	return libc.Uint32(libc.Uint32FromInt32(-1))
}

func opj_get_data_length_from_file(tls *libc.TLS, p_user_data uintptr) TOPJ_UINT64 { /* openjpeg.c:99:19: */
	var p_file uintptr = p_user_data
	var file_length TOPJ_OFF_T = 0

	libc.Xfseek(tls, p_file, 0, DSEEK_END)
	file_length = libc.Xftell(tls, p_file)
	libc.Xfseek(tls, p_file, 0, DSEEK_SET)

	return TOPJ_UINT64(file_length)
}

func opj_write_from_file(tls *libc.TLS, p_buffer uintptr, p_nb_bytes TOPJ_SIZE_T, p_user_data uintptr) TOPJ_SIZE_T { /* openjpeg.c:111:19: */
	var p_file uintptr = p_user_data
	return libc.Xfwrite(tls, p_buffer, uint32(1), p_nb_bytes, p_file)
}

func opj_skip_from_file(tls *libc.TLS, p_nb_bytes TOPJ_OFF_T, p_user_data uintptr) TOPJ_OFF_T { /* openjpeg.c:118:18: */
	var p_file uintptr = p_user_data
	if libc.Xfseek(tls, p_file, p_nb_bytes, DSEEK_CUR) != 0 {
		return -1
	}

	return p_nb_bytes
}

func opj_seek_from_file(tls *libc.TLS, p_nb_bytes TOPJ_OFF_T, p_user_data uintptr) TOPJ_BOOL { /* openjpeg.c:128:17: */
	var p_file uintptr = p_user_data
	if libc.Xfseek(tls, p_file, p_nb_bytes, DSEEK_SET) != 0 {
		return DOPJ_FALSE
	}

	return DOPJ_TRUE
}

func opj_close_from_file(tls *libc.TLS, p_user_data uintptr) { /* openjpeg.c:138:13: */
	var p_file uintptr = p_user_data
	libc.Xfclose(tls, p_file)
}

// ----------------------------------------------------------------------

// ----------------------------------------------------------------------

func Xopj_version(tls *libc.TLS) uintptr { /* openjpeg.c:171:11: */
	return ts + 31092 /* "2.5.0" */
}

// ----------------------------------------------------------------------
// DECOMPRESSION FUNCTIONS

func Xopj_create_decompress(tls *libc.TLS, p_format TOPJ_CODEC_FORMAT) uintptr { /* openjpeg.c:179:12: */
	var l_codec uintptr = uintptr(00)

	l_codec = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_codec_private_t{})))
	if !(l_codec != 0) {
		return uintptr(00)
	}

	(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor = 1

	switch p_format {
	case OPJ_CODEC_J2K:
		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_dump_codec = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_INT32, uintptr)
		}{Xj2k_dump}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_get_codec_info = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) uintptr
		}{Xj2k_get_cstr_info}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_get_codec_index = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) uintptr
		}{Xj2k_get_cstr_index}))

		*(*uintptr)(unsafe.Pointer(l_codec + 8 /* &.opj_decode */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_decode}))

		*(*uintptr)(unsafe.Pointer(l_codec + 32 /* &.opj_end_decompress */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_end_decompress}))

		*(*uintptr)(unsafe.Pointer(l_codec)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_read_header}))

		*(*uintptr)(unsafe.Pointer(l_codec + 40 /* &.opj_destroy */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{Xopj_j2k_destroy}))

		*(*uintptr)(unsafe.Pointer(l_codec + 48 /* &.opj_setup_decoder */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{Xopj_j2k_setup_decoder}))

		*(*uintptr)(unsafe.Pointer(l_codec + 56 /* &.opj_decoder_set_strict_mode */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_BOOL)
		}{Xopj_j2k_decoder_set_strict_mode}))

		*(*uintptr)(unsafe.Pointer(l_codec + 16 /* &.opj_read_tile_header */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_read_tile_header}))

		*(*uintptr)(unsafe.Pointer(l_codec + 24 /* &.opj_decode_tile_data */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_decode_tile}))

		*(*uintptr)(unsafe.Pointer(l_codec + 64 /* &.opj_set_decode_area */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_INT32, TOPJ_INT32, TOPJ_INT32, TOPJ_INT32, uintptr) TOPJ_BOOL
		}{Xopj_j2k_set_decode_area}))

		*(*uintptr)(unsafe.Pointer(l_codec + 72 /* &.opj_get_decoded_tile */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, TOPJ_UINT32) TOPJ_BOOL
		}{Xopj_j2k_get_tile}))

		*(*uintptr)(unsafe.Pointer(l_codec + 80 /* &.opj_set_decoded_resolution_factor */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL
		}{Xopj_j2k_set_decoded_resolution_factor}))

		*(*uintptr)(unsafe.Pointer(l_codec + 88 /* &.opj_set_decoded_components */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_set_decoded_components}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_set_threads = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32) TOPJ_BOOL
		}{Xopj_j2k_set_threads}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec = Xopj_j2k_create_decompress(tls)

		if !(int32((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec) != 0) {
			Xopj_free(tls, l_codec)
			return uintptr(0)
		}

		break

	case OPJ_CODEC_JP2:
		// get a JP2 decoder handle
		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_dump_codec = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_INT32, uintptr)
		}{Xjp2_dump}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_get_codec_info = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) uintptr
		}{Xjp2_get_cstr_info}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_get_codec_index = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) uintptr
		}{Xjp2_get_cstr_index}))

		*(*uintptr)(unsafe.Pointer(l_codec + 8 /* &.opj_decode */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_decode}))

		*(*uintptr)(unsafe.Pointer(l_codec + 32 /* &.opj_end_decompress */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_end_decompress}))

		*(*uintptr)(unsafe.Pointer(l_codec)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_read_header}))

		*(*uintptr)(unsafe.Pointer(l_codec + 16 /* &.opj_read_tile_header */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_read_tile_header}))

		*(*uintptr)(unsafe.Pointer(l_codec + 24 /* &.opj_decode_tile_data */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_decode_tile}))

		*(*uintptr)(unsafe.Pointer(l_codec + 40 /* &.opj_destroy */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{Xopj_jp2_destroy}))

		*(*uintptr)(unsafe.Pointer(l_codec + 48 /* &.opj_setup_decoder */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{Xopj_jp2_setup_decoder}))

		*(*uintptr)(unsafe.Pointer(l_codec + 56 /* &.opj_decoder_set_strict_mode */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_BOOL)
		}{Xopj_jp2_decoder_set_strict_mode}))

		*(*uintptr)(unsafe.Pointer(l_codec + 64 /* &.opj_set_decode_area */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_INT32, TOPJ_INT32, TOPJ_INT32, TOPJ_INT32, uintptr) TOPJ_BOOL
		}{Xopj_jp2_set_decode_area}))

		*(*uintptr)(unsafe.Pointer(l_codec + 72 /* &.opj_get_decoded_tile */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, TOPJ_UINT32) TOPJ_BOOL
		}{Xopj_jp2_get_tile}))

		*(*uintptr)(unsafe.Pointer(l_codec + 80 /* &.opj_set_decoded_resolution_factor */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL
		}{Xopj_jp2_set_decoded_resolution_factor}))

		*(*uintptr)(unsafe.Pointer(l_codec + 88 /* &.opj_set_decoded_components */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_set_decoded_components}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_set_threads = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32) TOPJ_BOOL
		}{Xopj_jp2_set_threads}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec = Xopj_jp2_create(tls, DOPJ_TRUE)

		if !(int32((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec) != 0) {
			Xopj_free(tls, l_codec)
			return uintptr(00)
		}

		break
	case OPJ_CODEC_UNKNOWN:
		fallthrough
	case OPJ_CODEC_JPT:
		fallthrough
	default:
		Xopj_free(tls, l_codec)
		return uintptr(00)
	}

	Xopj_set_default_event_handler(tls, l_codec+104)
	return l_codec
}

func Xopj_set_default_decoder_parameters(tls *libc.TLS, parameters uintptr) { /* openjpeg.c:382:19: */
	if parameters != 0 {
		libc.Xmemset(tls, parameters, 0, uint32(unsafe.Sizeof(Topj_dparameters_t{})))
		// default decoding parameters
		(*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fcp_layer = TOPJ_UINT32(0)
		(*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fcp_reduce = TOPJ_UINT32(0)

		(*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fdecod_format = -1
		(*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fcod_format = -1
		(*Topj_dparameters_t)(unsafe.Pointer(parameters)).Fflags = uint32(0)
		// UniPG>>
		// <<UniPG
	}
}

func Xopj_codec_set_threads(tls *libc.TLS, p_codec uintptr, num_threads int32) TOPJ_BOOL { /* openjpeg.c:405:23: */
	if p_codec != 0 && num_threads >= 0 {
		var l_codec uintptr = p_codec

		return (*struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_set_threads})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec, TOPJ_UINT32(num_threads))
	}
	return DOPJ_FALSE
}

func Xopj_setup_decoder(tls *libc.TLS, p_codec uintptr, parameters uintptr) TOPJ_BOOL { /* openjpeg.c:416:23: */
	if p_codec != 0 && parameters != 0 {
		var l_codec uintptr = p_codec

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			Xopj_event_msg(tls, l_codec+104, DEVT_ERROR,
				ts+31098, 0)
			return DOPJ_FALSE
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 48 /* &.opj_setup_decoder */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			parameters)
		return DOPJ_TRUE
	}
	return DOPJ_FALSE
}

func Xopj_decoder_set_strict_mode(tls *libc.TLS, p_codec uintptr, strict TOPJ_BOOL) TOPJ_BOOL { /* openjpeg.c:436:31: */
	if p_codec != 0 {
		var l_codec uintptr = p_codec

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			Xopj_event_msg(tls, l_codec+104, DEVT_ERROR,
				ts+31179, 0)
			return DOPJ_FALSE
		}

		(*struct {
			f func(*libc.TLS, uintptr, TOPJ_BOOL)
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 56 /* &.opj_decoder_set_strict_mode */))})).f(tls,
			(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			strict)
		return DOPJ_TRUE
	}
	return DOPJ_FALSE
}

func Xopj_read_header(tls *libc.TLS, p_stream uintptr, p_codec uintptr, p_image uintptr) TOPJ_BOOL { /* openjpeg.c:456:23: */
	if p_codec != 0 && p_stream != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			Xopj_event_msg(tls, l_codec+104, DEVT_ERROR,
				ts+31270, 0)
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ /* &.opj_read_header */))})).f(tls, l_stream,
			(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			p_image,
			l_codec+104)
	}

	return DOPJ_FALSE
}

func Xopj_set_decoded_components(tls *libc.TLS, p_codec uintptr, numcomps TOPJ_UINT32, comps_indices uintptr, apply_color_transforms TOPJ_BOOL) TOPJ_BOOL { /* openjpeg.c:480:23: */
	if p_codec != 0 {
		var l_codec uintptr = p_codec

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			Xopj_event_msg(tls, l_codec+104, DEVT_ERROR,
				ts+31349, 0)
			return DOPJ_FALSE
		}

		if apply_color_transforms != 0 {
			Xopj_event_msg(tls, l_codec+104, DEVT_ERROR,
				ts+31439, 0)
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 88 /* &.opj_set_decoded_components */))})).f(tls,
			(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			numcomps,
			comps_indices,
			l_codec+104)
	}
	return DOPJ_FALSE
}

func Xopj_decode(tls *libc.TLS, p_codec uintptr, p_stream uintptr, p_image uintptr) TOPJ_BOOL { /* openjpeg.c:509:23: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if p_codec != 0 && p_stream != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			libc.Xfprintf(tls, libc.Xstdout, ts+31492, libc.VaList(bp, ts+31502))
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 8 /* &.opj_decode */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			l_stream,
			p_image,
			l_codec+104)
	}

	return DOPJ_FALSE
}

func Xopj_set_decode_area(tls *libc.TLS, p_codec uintptr, p_image uintptr, p_start_x TOPJ_INT32, p_start_y TOPJ_INT32, p_end_x TOPJ_INT32, p_end_y TOPJ_INT32) TOPJ_BOOL { /* openjpeg.c:531:23: */
	if p_codec != 0 {
		var l_codec uintptr = p_codec

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, TOPJ_INT32, TOPJ_INT32, TOPJ_INT32, TOPJ_INT32, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 64 /* &.opj_set_decode_area */))})).f(tls,
			(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			p_image,
			p_start_x, p_start_y,
			p_end_x, p_end_y,
			l_codec+104)
	}
	return DOPJ_FALSE
}

func Xopj_read_tile_header(tls *libc.TLS, p_codec uintptr, p_stream uintptr, p_tile_index uintptr, p_data_size uintptr, p_tile_x0 uintptr, p_tile_y0 uintptr, p_tile_x1 uintptr, p_tile_y1 uintptr, p_nb_comps uintptr, p_should_go_on uintptr) TOPJ_BOOL { /* openjpeg.c:554:23: */
	if p_codec != 0 && p_stream != 0 && p_data_size != 0 && p_tile_index != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 16 /* &.opj_read_tile_header */))})).f(tls,
			(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			p_tile_index,
			p_data_size,
			p_tile_x0, p_tile_y0,
			p_tile_x1, p_tile_y1,
			p_nb_comps,
			p_should_go_on,
			l_stream,
			l_codec+104)
	}
	return DOPJ_FALSE
}

func Xopj_decode_tile_data(tls *libc.TLS, p_codec uintptr, p_tile_index TOPJ_UINT32, p_data uintptr, p_data_size TOPJ_UINT32, p_stream uintptr) TOPJ_BOOL { /* openjpeg.c:585:23: */
	if p_codec != 0 && p_data != 0 && p_stream != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 24 /* &.opj_decode_tile_data */))})).f(tls,
			(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			p_tile_index,
			p_data,
			p_data_size,
			l_stream,
			l_codec+104)
	}
	return DOPJ_FALSE
}

func Xopj_get_decoded_tile(tls *libc.TLS, p_codec uintptr, p_stream uintptr, p_image uintptr, tile_index TOPJ_UINT32) TOPJ_BOOL { /* openjpeg.c:611:23: */
	if p_codec != 0 && p_stream != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, TOPJ_UINT32) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 72 /* &.opj_get_decoded_tile */))})).f(tls,
			(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			l_stream,
			p_image,
			l_codec+104,
			tile_index)
	}

	return DOPJ_FALSE
}

func Xopj_set_decoded_resolution_factor(tls *libc.TLS, p_codec uintptr, res_factor TOPJ_UINT32) TOPJ_BOOL { /* openjpeg.c:635:23: */
	var l_codec uintptr = p_codec

	if !(l_codec != 0) {
		return DOPJ_FALSE
	}

	return (*struct {
		f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL
	})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 80 /* &.opj_set_decoded_resolution_factor */))})).f(tls,
		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
		res_factor,
		l_codec+104)
}

// ----------------------------------------------------------------------
// COMPRESSION FUNCTIONS

func Xopj_create_compress(tls *libc.TLS, p_format TOPJ_CODEC_FORMAT) uintptr { /* openjpeg.c:653:12: */
	var l_codec uintptr = uintptr(00)

	l_codec = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_codec_private_t{})))
	if !(l_codec != 0) {
		return uintptr(00)
	}

	(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor = 0

	switch p_format {
	case OPJ_CODEC_J2K:
		*(*uintptr)(unsafe.Pointer(l_codec + 8 /* &.opj_encode */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_encode}))

		*(*uintptr)(unsafe.Pointer(l_codec + 24 /* &.opj_end_compress */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_end_compress}))

		*(*uintptr)(unsafe.Pointer(l_codec)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_start_compress}))

		*(*uintptr)(unsafe.Pointer(l_codec + 16 /* &.opj_write_tile */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_write_tile}))

		*(*uintptr)(unsafe.Pointer(l_codec + 32 /* &.opj_destroy */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{Xopj_j2k_destroy}))

		*(*uintptr)(unsafe.Pointer(l_codec + 40 /* &.opj_setup_encoder */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_setup_encoder}))

		*(*uintptr)(unsafe.Pointer(l_codec + 48 /* &.opj_encoder_set_extra_options */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_j2k_encoder_set_extra_options}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_set_threads = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32) TOPJ_BOOL
		}{Xopj_j2k_set_threads}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec = Xopj_j2k_create_compress(tls)
		if !(int32((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec) != 0) {
			Xopj_free(tls, l_codec)
			return uintptr(00)
		}

		break

	case OPJ_CODEC_JP2:
		// get a JP2 decoder handle
		*(*uintptr)(unsafe.Pointer(l_codec + 8 /* &.opj_encode */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_encode}))

		*(*uintptr)(unsafe.Pointer(l_codec + 24 /* &.opj_end_compress */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_end_compress}))

		*(*uintptr)(unsafe.Pointer(l_codec)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_start_compress}))

		*(*uintptr)(unsafe.Pointer(l_codec + 16 /* &.opj_write_tile */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_write_tile}))

		*(*uintptr)(unsafe.Pointer(l_codec + 32 /* &.opj_destroy */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{Xopj_jp2_destroy}))

		*(*uintptr)(unsafe.Pointer(l_codec + 40 /* &.opj_setup_encoder */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_setup_encoder}))

		*(*uintptr)(unsafe.Pointer(l_codec + 48 /* &.opj_encoder_set_extra_options */)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		}{Xopj_jp2_encoder_set_extra_options}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_set_threads = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32) TOPJ_BOOL
		}{Xopj_jp2_set_threads}))

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec = Xopj_jp2_create(tls, DOPJ_FALSE)
		if !(int32((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec) != 0) {
			Xopj_free(tls, l_codec)
			return uintptr(00)
		}

		break

	case OPJ_CODEC_UNKNOWN:
		fallthrough
	case OPJ_CODEC_JPT:
		fallthrough
	default:
		Xopj_free(tls, l_codec)
		return uintptr(00)
	}

	Xopj_set_default_event_handler(tls, l_codec+104)
	return l_codec
}

func Xopj_set_default_encoder_parameters(tls *libc.TLS, parameters uintptr) { /* openjpeg.c:767:19: */
	if parameters != 0 {
		libc.Xmemset(tls, parameters, 0, uint32(unsafe.Sizeof(Topj_cparameters_t{})))
		// default coding parameters
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_cinema = OPJ_OFF // DEPRECATED
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_NONE)
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmax_comp_size = 0
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fnumresolution = DOPJ_COMP_PARAM_DEFAULT_NUMRESOLUTION
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_rsiz = OPJ_STD_RSIZ // DEPRECATED
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockw_init = DOPJ_COMP_PARAM_DEFAULT_CBLOCKW
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcblockh_init = DOPJ_COMP_PARAM_DEFAULT_CBLOCKH
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fprog_order = OPJ_LRCP
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Froi_compno = -1 // no ROI
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fsubsampling_dx = 1
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fsubsampling_dy = 1
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftp_on = int8(0)
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fdecod_format = -1
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcod_format = -1
		*(*float32)(unsafe.Pointer(parameters + 4800)) = float32(0)
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_numlayers = 0
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_disto_alloc = 0
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_fixed_alloc = 0
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fcp_fixed_quality = 0
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fjpip_on = DOPJ_FALSE
		// UniPG>>
		// <<UniPG
	}
}

func Xopj_setup_encoder(tls *libc.TLS, p_codec uintptr, parameters uintptr, p_image uintptr) TOPJ_BOOL { /* openjpeg.c:828:23: */
	if p_codec != 0 && parameters != 0 && p_image != 0 {
		var l_codec uintptr = p_codec

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
			})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_compression */ + 40 /* &.opj_setup_encoder */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
				parameters,
				p_image,
				l_codec+104)
		}
	}

	return DOPJ_FALSE
}

// -----------------------------------------------------------------------

func Xopj_encoder_set_extra_options(tls *libc.TLS, p_codec uintptr, options uintptr) TOPJ_BOOL { /* openjpeg.c:848:23: */
	if p_codec != 0 {
		var l_codec uintptr = p_codec

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_compression */ + 48 /* &.opj_encoder_set_extra_options */))})).f(tls,
				(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
				options,
				l_codec+104)
		}
	}

	return DOPJ_FALSE
}

// -----------------------------------------------------------------------

func Xopj_start_compress(tls *libc.TLS, p_codec uintptr, p_image uintptr, p_stream uintptr) TOPJ_BOOL { /* openjpeg.c:867:23: */
	if p_codec != 0 && p_stream != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) TOPJ_BOOL
			})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_compression */ /* &.opj_start_compress */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
				l_stream,
				p_image,
				l_codec+104)
		}
	}

	return DOPJ_FALSE
}

func Xopj_encode(tls *libc.TLS, p_info uintptr, p_stream uintptr) TOPJ_BOOL { /* openjpeg.c:886:23: */
	if p_info != 0 && p_stream != 0 {
		var l_codec uintptr = p_info
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_compression */ + 8 /* &.opj_encode */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
				l_stream,
				l_codec+104)
		}
	}

	return DOPJ_FALSE

}

func Xopj_end_compress(tls *libc.TLS, p_codec uintptr, p_stream uintptr) TOPJ_BOOL { /* openjpeg.c:903:23: */
	if p_codec != 0 && p_stream != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
			})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_compression */ + 24 /* &.opj_end_compress */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
				l_stream,
				l_codec+104)
		}
	}
	return DOPJ_FALSE

}

func Xopj_end_decompress(tls *libc.TLS, p_codec uintptr, p_stream uintptr) TOPJ_BOOL { /* openjpeg.c:920:23: */
	if p_codec != 0 && p_stream != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if !((*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0) {
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 32 /* &.opj_end_decompress */))})).f(tls,
			(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			l_stream,
			l_codec+104)
	}

	return DOPJ_FALSE
}

func Xopj_set_MCT(tls *libc.TLS, parameters uintptr, pEncodingMatrix uintptr, p_dc_shift uintptr, pNbComp TOPJ_UINT32) TOPJ_BOOL { /* openjpeg.c:940:23: */
	var l_matrix_size TOPJ_UINT32 = pNbComp * pNbComp * TOPJ_UINT32(unsafe.Sizeof(TOPJ_FLOAT32(0)))
	var l_dc_shift_size TOPJ_UINT32 = pNbComp * TOPJ_UINT32(unsafe.Sizeof(TOPJ_INT32(0)))
	var l_mct_total_size TOPJ_UINT32 = l_matrix_size + l_dc_shift_size

	// add MCT capability
	if int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz)&DOPJ_PROFILE_PART2 != 0 {
		*(*TOPJ_UINT16)(unsafe.Pointer(parameters + 18716)) |= TOPJ_UINT16(DOPJ_EXTENSION_MCT)
	} else {
		(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Frsiz = TOPJ_UINT16(DOPJ_PROFILE_PART2 | DOPJ_EXTENSION_MCT)
	}
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Firreversible = 1

	// use array based MCT
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Ftcp_mct = int8(2)
	(*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data = Xopj_malloc(tls, uint32(l_mct_total_size))
	if !(int32((*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data) != 0) {
		return DOPJ_FALSE
	}

	libc.Xmemcpy(tls, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data, pEncodingMatrix, uint32(l_matrix_size))
	libc.Xmemcpy(tls, (*Topj_cparameters_t)(unsafe.Pointer(parameters)).Fmct_data+uintptr(l_matrix_size), p_dc_shift,
		uint32(l_dc_shift_size))

	return DOPJ_TRUE
}

func Xopj_write_tile(tls *libc.TLS, p_codec uintptr, p_tile_index TOPJ_UINT32, p_data uintptr, p_data_size TOPJ_UINT32, p_stream uintptr) TOPJ_BOOL { /* openjpeg.c:970:23: */
	if p_codec != 0 && p_stream != 0 && p_data != 0 {
		var l_codec uintptr = p_codec
		var l_stream uintptr = p_stream

		if (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0 {
			return DOPJ_FALSE
		}

		return (*struct {
			f func(*libc.TLS, uintptr, TOPJ_UINT32, uintptr, TOPJ_UINT32, uintptr, uintptr) TOPJ_BOOL
		})(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_compression */ + 16 /* &.opj_write_tile */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec,
			p_tile_index,
			p_data,
			p_data_size,
			l_stream,
			l_codec+104)
	}

	return DOPJ_FALSE
}

// ----------------------------------------------------------------------

func Xopj_destroy_codec(tls *libc.TLS, p_codec uintptr) { /* openjpeg.c:997:19: */
	if p_codec != 0 {
		var l_codec uintptr = p_codec

		if (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fis_decompressor != 0 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_decompression */ + 40 /* &.opj_destroy */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec)
		} else {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{*(*uintptr)(unsafe.Pointer(l_codec /* &.m_codec_data */ /* &.m_compression */ + 32 /* &.opj_destroy */))})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec)
		}

		(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec = uintptr(00)
		Xopj_free(tls, l_codec)
	}
}

// ----------------------------------------------------------------------

func Xopj_dump_codec(tls *libc.TLS, p_codec uintptr, info_flag TOPJ_INT32, output_stream uintptr) { /* openjpeg.c:1015:19: */
	if p_codec != 0 {
		var l_codec uintptr = p_codec

		(*struct {
			f func(*libc.TLS, uintptr, TOPJ_INT32, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_dump_codec})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec, info_flag, output_stream)
		return
	}

	// TODO return error
	// fprintf(stderr, "[ERROR] Input parameter of the dump_codec function are incorrect.\n");
	return
}

func Xopj_get_cstr_info(tls *libc.TLS, p_codec uintptr) uintptr { /* openjpeg.c:1031:25: */
	if p_codec != 0 {
		var l_codec uintptr = p_codec

		return (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_get_codec_info})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec)
	}

	return uintptr(0)
}

func Xopj_destroy_cstr_info(tls *libc.TLS, cstr_info uintptr) { /* openjpeg.c:1042:19: */
	if cstr_info != 0 {

		if (*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(cstr_info)))).Fm_default_tile_info.Ftccp_info != 0 {
			Xopj_free(tls, (*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(cstr_info)))).Fm_default_tile_info.Ftccp_info)
		}

		if (*Topj_codestream_info_v2_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(cstr_info)))).Ftile_info != 0 {
			// FIXME not used for the moment
		}

		Xopj_free(tls, *(*uintptr)(unsafe.Pointer(cstr_info)))
		*(*uintptr)(unsafe.Pointer(cstr_info)) = uintptr(0)
	}
}

func Xopj_get_cstr_index(tls *libc.TLS, p_codec uintptr) uintptr { /* openjpeg.c:1059:24: */
	if p_codec != 0 {
		var l_codec uintptr = p_codec

		return (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fopj_get_codec_index})).f(tls, (*Topj_codec_private_t)(unsafe.Pointer(l_codec)).Fm_codec)
	}

	return uintptr(0)
}

func Xopj_destroy_cstr_index(tls *libc.TLS, p_cstr_index uintptr) { /* openjpeg.c:1070:19: */
	if *(*uintptr)(unsafe.Pointer(p_cstr_index)) != 0 {
		Xj2k_destroy_cstr_index(tls, *(*uintptr)(unsafe.Pointer(p_cstr_index)))
		*(*uintptr)(unsafe.Pointer(p_cstr_index)) = uintptr(0)
	}
}

func Xopj_stream_create_default_file_stream(tls *libc.TLS, fname uintptr, p_is_read_stream TOPJ_BOOL) uintptr { /* openjpeg.c:1078:13: */
	return Xopj_stream_create_file_stream(tls, fname, uint32(DOPJ_J2K_STREAM_CHUNK_SIZE),
		p_is_read_stream)
}

func Xopj_stream_create_file_stream(tls *libc.TLS, fname uintptr, p_size TOPJ_SIZE_T, p_is_read_stream TOPJ_BOOL) uintptr { /* openjpeg.c:1085:13: */
	var l_stream uintptr = uintptr(00)
	var p_file uintptr
	var mode uintptr

	if !(fname != 0) {
		return uintptr(0)
	}

	if p_is_read_stream != 0 {
		mode = ts + 1519 /* "rb" */
	} else {
		mode = ts + 1522 /* "wb" */
	}

	p_file = libc.Xfopen(tls, fname, mode)

	if !(p_file != 0) {
		return uintptr(0)
	}

	l_stream = Xopj_stream_create(tls, p_size, p_is_read_stream)
	if !(l_stream != 0) {
		libc.Xfclose(tls, p_file)
		return uintptr(0)
	}

	Xopj_stream_set_user_data(tls, l_stream, p_file, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{opj_close_from_file})))
	Xopj_stream_set_user_data_length(tls, l_stream,
		opj_get_data_length_from_file(tls, p_file))
	Xopj_stream_set_read_function(tls, l_stream, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, TOPJ_SIZE_T, uintptr) TOPJ_SIZE_T
	}{opj_read_from_file})))
	Xopj_stream_set_write_function(tls, l_stream,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, TOPJ_SIZE_T, uintptr) TOPJ_SIZE_T
		}{opj_write_from_file})))
	Xopj_stream_set_skip_function(tls, l_stream, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_OFF_T
	}{opj_skip_from_file})))
	Xopj_stream_set_seek_function(tls, l_stream, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, TOPJ_OFF_T, uintptr) TOPJ_BOOL
	}{opj_seek_from_file})))

	return l_stream
}

func Xopj_image_data_alloc(tls *libc.TLS, size TOPJ_SIZE_T) uintptr { /* openjpeg.c:1129:5: */
	var ret uintptr = Xopj_aligned_malloc(tls, size)
	// printf("opj_image_data_alloc %p\n", ret);
	return ret
}

func Xopj_image_data_free(tls *libc.TLS, ptr uintptr) { /* openjpeg.c:1136:19: */
	// printf("opj_image_data_free %p\n", ptr);
	Xopj_aligned_free(tls, ptr)
}

func opj_aligned_alloc_n(tls *libc.TLS, alignment Tsize_t, size Tsize_t) uintptr { /* opj_malloc.c:47:20: */
	var ptr uintptr

	// alignment shall be power of 2
	if alignment != 0 && alignment&(alignment-1) == 0 {
	} else {
		libc.X__assert_fail(tls, ts+31522, ts+31582, uint32(52), uintptr(unsafe.Pointer(&__func__236)))
	}
	// alignment shall be at least sizeof(void*)
	if alignment >= Tsize_t(unsafe.Sizeof(uintptr(0))) {
	} else {
		libc.X__assert_fail(tls, ts+31614, ts+31582, uint32(54), uintptr(unsafe.Pointer(&__func__236)))
	}

	if size == 0 { // prevent implementation defined behavior of realloc
		return uintptr(0)
	}

	// Generic aligned malloc implementation.
	// Uses size_t offset for the integer manipulation of the pointer,
	// as uintptr_t is not available in C89 to do
	// bitwise operations on the pointer itself.
	alignment--
	{
		var offset Tsize_t
		var mem uintptr

		// Room for padding and extra pointer stored in front of allocated area
		var overhead Tsize_t = alignment + Tsize_t(unsafe.Sizeof(uintptr(0)))

		// let's be extra careful
		if uint64(alignment) <= libc.Uint64(18446744073709551615)-uint64(unsafe.Sizeof(uintptr(0))) {
		} else {
			libc.X__assert_fail(tls, ts+31641, ts+31582, uint32(90), uintptr(unsafe.Pointer(&__func__236)))
		}

		// Avoid integer overflow
		if uint64(size) > libc.Uint64(18446744073709551615)-uint64(overhead) {
			return uintptr(0)
		}

		mem = libc.Xmalloc(tls, size+overhead)
		if mem == uintptr(0) {
			return mem
		}
		// offset = ((alignment + 1U) - ((size_t)(mem + sizeof(void*)) & alignment)) & alignment;
		// Use the fact that alignment + 1U is a power of 2
		offset = (alignment ^ Tsize_t(mem+uintptr(uint32(unsafe.Sizeof(uintptr(0)))))&alignment + 1) & alignment
		ptr = mem + uintptr(uint32(unsafe.Sizeof(uintptr(0)))) + uintptr(offset)
		*(*uintptr)(unsafe.Pointer(ptr + libc.UintptrFromInt32(-1)*8)) = mem

	}
	return ptr
}

var __func__236 = *(*[20]int8)(unsafe.Pointer(ts + 31682)) /* opj_malloc.c:48:1 */

func opj_aligned_realloc_n(tls *libc.TLS, ptr uintptr, alignment Tsize_t, new_size Tsize_t) uintptr { /* opj_malloc.c:111:20: */
	var r_ptr uintptr

	// alignment shall be power of 2
	if alignment != 0 && alignment&(alignment-1) == 0 {
	} else {
		libc.X__assert_fail(tls, ts+31522, ts+31582, uint32(117), uintptr(unsafe.Pointer(&__func__237)))
	}
	// alignment shall be at least sizeof(void*)
	if alignment >= Tsize_t(unsafe.Sizeof(uintptr(0))) {
	} else {
		libc.X__assert_fail(tls, ts+31614, ts+31582, uint32(119), uintptr(unsafe.Pointer(&__func__237)))
	}

	if new_size == 0 { // prevent implementation defined behavior of realloc
		return uintptr(0)
	}

	// no portable aligned realloc
	if ptr == uintptr(0) {
		return opj_aligned_alloc_n(tls, alignment, new_size)
	}
	alignment--
	{
		var oldmem uintptr
		var newmem uintptr
		var overhead Tsize_t = alignment + Tsize_t(unsafe.Sizeof(uintptr(0)))

		// let's be extra careful
		if uint64(alignment) <= libc.Uint64(18446744073709551615)-uint64(unsafe.Sizeof(uintptr(0))) {
		} else {
			libc.X__assert_fail(tls, ts+31641, ts+31582, uint32(157), uintptr(unsafe.Pointer(&__func__237)))
		}

		// Avoid integer overflow
		if uint64(new_size) > libc.Uint64(18446744073709551615)-uint64(overhead) {
			return uintptr(0)
		}

		oldmem = *(*uintptr)(unsafe.Pointer(ptr + libc.UintptrFromInt32(-1)*8))
		newmem = libc.Xrealloc(tls, oldmem, new_size+overhead)
		if newmem == uintptr(0) {
			return newmem
		}

		if newmem == oldmem {
			r_ptr = ptr
		} else {
			var old_offset Tsize_t
			var new_offset Tsize_t

			// realloc created a new copy, realign the copied memory block
			old_offset = Tsize_t((int32(ptr) - int32(oldmem)) / 1)

			// offset = ((alignment + 1U) - ((size_t)(mem + sizeof(void*)) & alignment)) & alignment;
			// Use the fact that alignment + 1U is a power of 2
			new_offset = (alignment ^ Tsize_t(newmem+uintptr(uint32(unsafe.Sizeof(uintptr(0)))))&alignment + 1) & alignment
			new_offset = new_offset + Tsize_t(unsafe.Sizeof(uintptr(0)))
			r_ptr = newmem + uintptr(new_offset)

			if new_offset != old_offset {
				libc.Xmemmove(tls, newmem+uintptr(new_offset), newmem+uintptr(old_offset), new_size)
			}
			*(*uintptr)(unsafe.Pointer(r_ptr + libc.UintptrFromInt32(-1)*8)) = newmem
		}

	}
	return r_ptr
}

var __func__237 = *(*[22]int8)(unsafe.Pointer(ts + 31702)) /* opj_malloc.c:113:1 */

func Xopj_malloc(tls *libc.TLS, size Tsize_t) uintptr { /* opj_malloc.c:195:6: */
	if size == 0 { // prevent implementation defined behavior of realloc
		return uintptr(0)
	}
	return libc.Xmalloc(tls, size)
}

func Xopj_calloc(tls *libc.TLS, num Tsize_t, size Tsize_t) uintptr { /* opj_malloc.c:202:6: */
	if num == Tsize_t(0) || size == Tsize_t(0) {
		// prevent implementation defined behavior of realloc
		return uintptr(0)
	}
	return libc.Xcalloc(tls, num, size)
}

func Xopj_aligned_malloc(tls *libc.TLS, size Tsize_t) uintptr { /* opj_malloc.c:211:6: */
	return opj_aligned_alloc_n(tls, 16, size)
}

func Xopj_aligned_realloc(tls *libc.TLS, ptr uintptr, size Tsize_t) uintptr { /* opj_malloc.c:215:6: */
	return opj_aligned_realloc_n(tls, ptr, 16, size)
}

func Xopj_aligned_32_malloc(tls *libc.TLS, size Tsize_t) uintptr { /* opj_malloc.c:220:6: */
	return opj_aligned_alloc_n(tls, 32, size)
}

func Xopj_aligned_32_realloc(tls *libc.TLS, ptr uintptr, size Tsize_t) uintptr { /* opj_malloc.c:224:6: */
	return opj_aligned_realloc_n(tls, ptr, 32, size)
}

func Xopj_aligned_free(tls *libc.TLS, ptr uintptr) { /* opj_malloc.c:229:6: */
	// Generic implementation has malloced pointer stored in front of used area
	if ptr != uintptr(0) {
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(ptr + libc.UintptrFromInt32(-1)*8)))
	}
}

func Xopj_realloc(tls *libc.TLS, ptr uintptr, new_size Tsize_t) uintptr { /* opj_malloc.c:243:6: */
	if new_size == 0 { // prevent implementation defined behavior of realloc
		return uintptr(0)
	}
	return libc.Xrealloc(tls, ptr, new_size)
}

func Xopj_free(tls *libc.TLS, ptr uintptr) { /* opj_malloc.c:250:6: */
	libc.Xfree(tls, ptr)
}

//
// ==========================================================
//    codec typedef definitions
// ==========================================================

// *
// Progression order changes
//
type Topj_poc_t1 = struct {
	Fresno0      TOPJ_UINT32
	Fcompno0     TOPJ_UINT32
	Flayno1      TOPJ_UINT32
	Fresno1      TOPJ_UINT32
	Fcompno1     TOPJ_UINT32
	Flayno0      TOPJ_UINT32
	Fprecno0     TOPJ_UINT32
	Fprecno1     TOPJ_UINT32
	Fprg1        TOPJ_PROG_ORDER
	Fprg         TOPJ_PROG_ORDER
	Fprogorder   [5]TOPJ_CHAR
	F__ccgo_pad1 [3]byte
	Ftile        TOPJ_UINT32
	Ftx0         TOPJ_UINT32
	Ftx1         TOPJ_UINT32
	Fty0         TOPJ_UINT32
	Fty1         TOPJ_UINT32
	FlayS        TOPJ_UINT32
	FresS        TOPJ_UINT32
	FcompS       TOPJ_UINT32
	FprcS        TOPJ_UINT32
	FlayE        TOPJ_UINT32
	FresE        TOPJ_UINT32
	FcompE       TOPJ_UINT32
	FprcE        TOPJ_UINT32
	FtxS         TOPJ_UINT32
	FtxE         TOPJ_UINT32
	FtyS         TOPJ_UINT32
	FtyE         TOPJ_UINT32
	Fdx          TOPJ_UINT32
	Fdy          TOPJ_UINT32
	Flay_t       TOPJ_UINT32
	Fres_t       TOPJ_UINT32
	Fcomp_t      TOPJ_UINT32
	Fprc_t       TOPJ_UINT32
	Ftx0_t       TOPJ_UINT32
	Fty0_t       TOPJ_UINT32
} /* openjpeg.h:388:3 */

//*
// Packet iterator
type Topj_pi_iterator_t1 = struct {
	Ftp_on        TOPJ_BYTE
	F__ccgo_pad1  [7]byte
	Finclude      uintptr
	Finclude_size TOPJ_UINT32
	Fstep_l       TOPJ_UINT32
	Fstep_r       TOPJ_UINT32
	Fstep_c       TOPJ_UINT32
	Fstep_p       TOPJ_UINT32
	Fcompno       TOPJ_UINT32
	Fresno        TOPJ_UINT32
	Fprecno       TOPJ_UINT32
	Flayno        TOPJ_UINT32
	Ffirst        TOPJ_BOOL
	Fpoc          Topj_poc_t1
	Fnumcomps     TOPJ_UINT32
	Fcomps        uintptr
	Ftx0          TOPJ_UINT32
	Fty0          TOPJ_UINT32
	Ftx1          TOPJ_UINT32
	Fty1          TOPJ_UINT32
	Fx            TOPJ_UINT32
	Fy            TOPJ_UINT32
	Fdx           TOPJ_UINT32
	Fdy           TOPJ_UINT32
	Fmanager      uintptr
} /* pi.h:112:3 */

//@}

//@}

//
// ==========================================================
//    local functions
// ==========================================================

func opj_pi_next_lrcp(tls *libc.TLS, pi uintptr) TOPJ_BOOL { /* pi.c:237:17: */
	var comp uintptr
	var res uintptr
	var index TOPJ_UINT32
	comp = uintptr(0)
	res = uintptr(0)
	index = TOPJ_UINT32(0)

	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps+TOPJ_UINT32(1)) {
		goto __1
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR,
		ts+31724, 0)
	return DOPJ_FALSE
__1:
	;

	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst != 0) {
		goto __2
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno)*16
	goto LABEL_SKIP
	goto __3
__2:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst = 0
__3:
	;

	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno0
__4:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno1) {
		goto __6
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno0
__7:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno1) {
		goto __9
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0
__10:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1) {
		goto __12
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno >= (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions) {
		goto __13
	}
	goto __11
__13:
	;
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno)*16
	if !!(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftp_on) != 0) {
		goto __14
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fprecno1 = (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpw * (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fph
__14:
	;
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fprecno0
__15:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fprecno1) {
		goto __17
	}
	index = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_l + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_r + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_c + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_p
	// Avoids index out of bounds access with
	// id_000098,sig_11,src_005411,op_havoc,rep_2 of
	// https://github.com/uclouvain/openjpeg/issues/938
	// Not sure if this is the most clever fix. Perhaps
	// include should be resized when a POC arises, or
	// the POC should be rejected
	if !(index >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude_size) {
		goto __18
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR, ts+31769, 0)
	return DOPJ_FALSE
__18:
	;
	if !!(int32(*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2))) != 0) {
		goto __19
	}
	*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2)) = int16(1)
	return DOPJ_TRUE
__19:
	;
LABEL_SKIP:
	;
	goto __16
__16:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno++
	goto __15
	goto __17
__17:
	;
	goto __11
__11:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno++
	goto __10
	goto __12
__12:
	;
	goto __8
__8:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno++
	goto __7
	goto __9
__9:
	;
	goto __5
__5:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno++
	goto __4
	goto __6
__6:
	;

	return DOPJ_FALSE
}

func opj_pi_next_rlcp(tls *libc.TLS, pi uintptr) TOPJ_BOOL { /* pi.c:297:17: */
	var comp uintptr
	var res uintptr
	var index TOPJ_UINT32
	comp = uintptr(0)
	res = uintptr(0)
	index = TOPJ_UINT32(0)

	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps+TOPJ_UINT32(1)) {
		goto __1
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR,
		ts+31799, 0)
	return DOPJ_FALSE
__1:
	;

	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst != 0) {
		goto __2
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno)*16
	goto LABEL_SKIP
	goto __3
__2:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst = 0
__3:
	;

	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno0
__4:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno1) {
		goto __6
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno0
__7:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno1) {
		goto __9
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0
__10:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1) {
		goto __12
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno >= (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions) {
		goto __13
	}
	goto __11
__13:
	;
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno)*16
	if !!(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftp_on) != 0) {
		goto __14
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fprecno1 = (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpw * (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fph
__14:
	;
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fprecno0
__15:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fprecno1) {
		goto __17
	}
	index = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_l + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_r + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_c + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_p
	if !(index >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude_size) {
		goto __18
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR, ts+31769, 0)
	return DOPJ_FALSE
__18:
	;
	if !!(int32(*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2))) != 0) {
		goto __19
	}
	*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2)) = int16(1)
	return DOPJ_TRUE
__19:
	;
LABEL_SKIP:
	;
	goto __16
__16:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno++
	goto __15
	goto __17
__17:
	;
	goto __11
__11:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno++
	goto __10
	goto __12
__12:
	;
	goto __8
__8:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno++
	goto __7
	goto __9
__9:
	;
	goto __5
__5:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno++
	goto __4
	goto __6
__6:
	;

	return DOPJ_FALSE
}

func opj_pi_next_rpcl(tls *libc.TLS, pi uintptr) TOPJ_BOOL { /* pi.c:350:17: */
	var comp uintptr
	var res uintptr
	var index TOPJ_UINT32
	var dx TOPJ_UINT32
	var dy TOPJ_UINT32
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	var levelno TOPJ_UINT32
	var trx0 TOPJ_UINT32
	var try0 TOPJ_UINT32
	var trx1 TOPJ_UINT32
	var try1 TOPJ_UINT32
	var rpx TOPJ_UINT32
	var rpy TOPJ_UINT32
	var prci TOPJ_UINT32
	var prcj TOPJ_UINT32
	comp = uintptr(0)
	res = uintptr(0)
	index = TOPJ_UINT32(0)

	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps+TOPJ_UINT32(1)) {
		goto __1
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR,
		ts+31844, 0)
	return DOPJ_FALSE
__1:
	;

	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst != 0) {
		goto __2
	}
	goto LABEL_SKIP
	goto __3
__2:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst = 0
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx = TOPJ_UINT32(0)
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy = TOPJ_UINT32(0)
	compno = TOPJ_UINT32(0)
__4:
	if !(compno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps) {
		goto __6
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr(compno)*24
	resno = TOPJ_UINT32(0)
__7:
	if !(resno < (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions) {
		goto __9
	}
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr(resno)*16
	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno < TOPJ_UINT32(32) && (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx <= (uint32(0x7fffffff)*2+1)/(uint32(1)<<((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno))) {
		goto __10
	}
	dx = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx * (uint32(1) << ((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx + (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - resno))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx = func() uint32 {
		if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx) != 0) {
			return dx
		}
		return opj_uint_min(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx, dx)
	}()
__10:
	;
	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno < TOPJ_UINT32(32) && (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy <= (uint32(0x7fffffff)*2+1)/(uint32(1)<<((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno))) {
		goto __11
	}
	dy = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy * (uint32(1) << ((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy + (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - resno))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy = func() uint32 {
		if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy) != 0) {
			return dy
		}
		return opj_uint_min(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy, dy)
	}()
__11:
	;
	goto __8
__8:
	resno++
	goto __7
	goto __9
__9:
	;
	goto __5
__5:
	compno++
	goto __4
	goto __6
__6:
	;
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy == TOPJ_UINT32(0)) {
		goto __12
	}
	return DOPJ_FALSE
__12:
	;
__3:
	;
	if !!(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftp_on) != 0) {
		goto __13
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty0 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx0 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty1 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty1
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx1 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx1
__13:
	;
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno0
__14:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno1) {
		goto __16
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty0
__17:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty1) {
		goto __19
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx0
__20:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx1) {
		goto __22
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0
__23:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1) {
		goto __25
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno >= (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions) {
		goto __26
	}
	goto __24
__26:
	;
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno)*16
	levelno = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno
	// Avoids division by zero
	// Relates to id_000004,sig_06,src_000679,op_arith8,pos_49,val_-17
	// of  https://github.com/uclouvain/openjpeg/issues/938
	if !(levelno >= TOPJ_UINT32(32) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno>>levelno != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno>>levelno != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy) {
		goto __27
	}
	goto __24
__27:
	;
	if !((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno > TOPJ_UINT32(0x7fffffff) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno > TOPJ_UINT32(0x7fffffff)) {
		goto __28
	}
	goto __24
__28:
	;
	trx0 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno)
	try0 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno)
	trx1 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx1, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno)
	try1 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty1, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno)
	rpx = (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx + levelno
	rpy = (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy + levelno

	// To avoid divisions by zero / undefined behaviour on shift
	// in below tests
	// Fixes reading id:000026,sig:08,src:002419,op:int32,pos:60,val:+32
	// of https://github.com/uclouvain/openjpeg/issues/938
	if !(rpx >= TOPJ_UINT32(31) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<rpx>>rpx != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx || rpy >= TOPJ_UINT32(31) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<rpy>>rpy != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy) {
		goto __29
	}
	goto __24
__29:
	;

	// See ISO-15441. B.12.1.3 Resolution level-position-component-layer progression
	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy%((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<rpy) == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy == (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0 && try0<<levelno%(uint32(1)<<rpy) != 0) {
		goto __30
	}
	goto __24
__30:
	;
	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx%((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<rpx) == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx == (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0 && trx0<<levelno%(uint32(1)<<rpx) != 0) {
		goto __31
	}
	goto __24
__31:
	;

	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpw == TOPJ_UINT32(0) || (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fph == TOPJ_UINT32(0)) {
		goto __32
	}
	goto __24
__32:
	;

	if !(trx0 == trx1 || try0 == try1) {
		goto __33
	}
	goto __24
__33:
	;

	prci = opj_uint_floordivpow2(tls, opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx,
		(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno), (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx) -
		opj_uint_floordivpow2(tls, trx0, (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx)
	prcj = opj_uint_floordivpow2(tls, opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy,
		(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno), (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy) -
		opj_uint_floordivpow2(tls, try0, (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy)
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno = prci + prcj*(*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpw
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno0
__34:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno1) {
		goto __36
	}
	index = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_l + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_r + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_c + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_p
	if !(index >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude_size) {
		goto __37
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR, ts+31769, 0)
	return DOPJ_FALSE
__37:
	;
	if !!(int32(*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2))) != 0) {
		goto __38
	}
	*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2)) = int16(1)
	return DOPJ_TRUE
__38:
	;
LABEL_SKIP:
	;
	goto __35
__35:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno++
	goto __34
	goto __36
__36:
	;
	goto __24
__24:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno++
	goto __23
	goto __25
__25:
	;
	goto __21
__21:
	*(*TOPJ_UINT32)(unsafe.Pointer(pi + 232)) += (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx%(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx
	goto __20
	goto __22
__22:
	;
	goto __18
__18:
	*(*TOPJ_UINT32)(unsafe.Pointer(pi + 236)) += (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy%(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy
	goto __17
	goto __19
__19:
	;
	goto __15
__15:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno++
	goto __14
	goto __16
__16:
	;

	return DOPJ_FALSE
}

func opj_pi_next_pcrl(tls *libc.TLS, pi uintptr) TOPJ_BOOL { /* pi.c:489:17: */
	var comp uintptr
	var res uintptr
	var index TOPJ_UINT32
	var dx TOPJ_UINT32
	var dy TOPJ_UINT32
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	var levelno TOPJ_UINT32
	var trx0 TOPJ_UINT32
	var try0 TOPJ_UINT32
	var trx1 TOPJ_UINT32
	var try1 TOPJ_UINT32
	var rpx TOPJ_UINT32
	var rpy TOPJ_UINT32
	var prci TOPJ_UINT32
	var prcj TOPJ_UINT32
	comp = uintptr(0)
	res = uintptr(0)
	index = TOPJ_UINT32(0)

	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps+TOPJ_UINT32(1)) {
		goto __1
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR,
		ts+31889, 0)
	return DOPJ_FALSE
__1:
	;

	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst != 0) {
		goto __2
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	goto LABEL_SKIP
	goto __3
__2:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst = 0
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx = TOPJ_UINT32(0)
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy = TOPJ_UINT32(0)
	compno = TOPJ_UINT32(0)
__4:
	if !(compno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps) {
		goto __6
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr(compno)*24
	resno = TOPJ_UINT32(0)
__7:
	if !(resno < (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions) {
		goto __9
	}
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr(resno)*16
	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno < TOPJ_UINT32(32) && (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx <= (uint32(0x7fffffff)*2+1)/(uint32(1)<<((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno))) {
		goto __10
	}
	dx = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx * (uint32(1) << ((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx + (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - resno))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx = func() uint32 {
		if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx) != 0) {
			return dx
		}
		return opj_uint_min(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx, dx)
	}()
__10:
	;
	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno < TOPJ_UINT32(32) && (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy <= (uint32(0x7fffffff)*2+1)/(uint32(1)<<((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno))) {
		goto __11
	}
	dy = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy * (uint32(1) << ((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy + (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - resno))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy = func() uint32 {
		if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy) != 0) {
			return dy
		}
		return opj_uint_min(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy, dy)
	}()
__11:
	;
	goto __8
__8:
	resno++
	goto __7
	goto __9
__9:
	;
	goto __5
__5:
	compno++
	goto __4
	goto __6
__6:
	;
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy == TOPJ_UINT32(0)) {
		goto __12
	}
	return DOPJ_FALSE
__12:
	;
__3:
	;
	if !!(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftp_on) != 0) {
		goto __13
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty0 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx0 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty1 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty1
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx1 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx1
__13:
	;
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty0
__14:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty1) {
		goto __16
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx0
__17:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx1) {
		goto __19
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0
__20:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1) {
		goto __22
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno0
__23:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno < opj_uint_min(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno1, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions)) {
		goto __25
	}
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno)*16
	levelno = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno
	// Avoids division by zero
	// Relates to id_000004,sig_06,src_000679,op_arith8,pos_49,val_-17
	// of  https://github.com/uclouvain/openjpeg/issues/938
	if !(levelno >= TOPJ_UINT32(32) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno>>levelno != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno>>levelno != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy) {
		goto __26
	}
	goto __24
__26:
	;
	if !((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno > TOPJ_UINT32(0x7fffffff) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno > TOPJ_UINT32(0x7fffffff)) {
		goto __27
	}
	goto __24
__27:
	;
	trx0 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno)
	try0 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno)
	trx1 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx1, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno)
	try1 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty1, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno)
	rpx = (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx + levelno
	rpy = (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy + levelno

	// To avoid divisions by zero / undefined behaviour on shift
	// in below tests
	// Relates to id:000019,sig:08,src:001098,op:flip1,pos:49
	// of https://github.com/uclouvain/openjpeg/issues/938
	if !(rpx >= TOPJ_UINT32(31) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<rpx>>rpx != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx || rpy >= TOPJ_UINT32(31) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<rpy>>rpy != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy) {
		goto __28
	}
	goto __24
__28:
	;

	// See ISO-15441. B.12.1.4 Position-component-resolution level-layer progression
	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy%((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<rpy) == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy == (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0 && try0<<levelno%(uint32(1)<<rpy) != 0) {
		goto __29
	}
	goto __24
__29:
	;
	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx%((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<rpx) == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx == (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0 && trx0<<levelno%(uint32(1)<<rpx) != 0) {
		goto __30
	}
	goto __24
__30:
	;

	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpw == TOPJ_UINT32(0) || (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fph == TOPJ_UINT32(0)) {
		goto __31
	}
	goto __24
__31:
	;

	if !(trx0 == trx1 || try0 == try1) {
		goto __32
	}
	goto __24
__32:
	;

	prci = opj_uint_floordivpow2(tls, opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx,
		(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno), (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx) -
		opj_uint_floordivpow2(tls, trx0, (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx)
	prcj = opj_uint_floordivpow2(tls, opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy,
		(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno), (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy) -
		opj_uint_floordivpow2(tls, try0, (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy)
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno = prci + prcj*(*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpw
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno0
__33:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno1) {
		goto __35
	}
	index = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_l + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_r + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_c + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_p
	if !(index >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude_size) {
		goto __36
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR, ts+31769, 0)
	return DOPJ_FALSE
__36:
	;
	if !!(int32(*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2))) != 0) {
		goto __37
	}
	*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2)) = int16(1)
	return DOPJ_TRUE
__37:
	;
LABEL_SKIP:
	;
	goto __34
__34:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno++
	goto __33
	goto __35
__35:
	;
	goto __24
__24:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno++
	goto __23
	goto __25
__25:
	;
	goto __21
__21:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno++
	goto __20
	goto __22
__22:
	;
	goto __18
__18:
	*(*TOPJ_UINT32)(unsafe.Pointer(pi + 232)) += (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx%(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx
	goto __17
	goto __19
__19:
	;
	goto __15
__15:
	*(*TOPJ_UINT32)(unsafe.Pointer(pi + 236)) += (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy%(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy
	goto __14
	goto __16
__16:
	;

	return DOPJ_FALSE
}

func opj_pi_next_cprl(tls *libc.TLS, pi uintptr) TOPJ_BOOL { /* pi.c:627:17: */
	var comp uintptr
	var res uintptr
	var index TOPJ_UINT32
	var dx TOPJ_UINT32
	var dy TOPJ_UINT32
	var levelno TOPJ_UINT32
	var trx0 TOPJ_UINT32
	var try0 TOPJ_UINT32
	var trx1 TOPJ_UINT32
	var try1 TOPJ_UINT32
	var rpx TOPJ_UINT32
	var rpy TOPJ_UINT32
	var prci TOPJ_UINT32
	var prcj TOPJ_UINT32
	var resno TOPJ_UINT32
	comp = uintptr(0)
	res = uintptr(0)
	index = TOPJ_UINT32(0)

	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1 >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fnumcomps+TOPJ_UINT32(1)) {
		goto __1
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR,
		ts+31934, 0)
	return DOPJ_FALSE
__1:
	;

	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst != 0) {
		goto __2
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	goto LABEL_SKIP
	goto __3
__2:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ffirst = 0
__3:
	;

	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno0
__4:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fcompno1) {
		goto __6
	}
	comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcomps + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno)*24
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx = TOPJ_UINT32(0)
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy = TOPJ_UINT32(0)
	resno = TOPJ_UINT32(0)
__7:
	if !(resno < (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions) {
		goto __9
	}
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr(resno)*16
	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno < TOPJ_UINT32(32) && (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx <= (uint32(0x7fffffff)*2+1)/(uint32(1)<<((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno))) {
		goto __10
	}
	dx = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx * (uint32(1) << ((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx + (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - resno))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx = func() uint32 {
		if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx) != 0) {
			return dx
		}
		return opj_uint_min(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx, dx)
	}()
__10:
	;
	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno < TOPJ_UINT32(32) && (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy <= (uint32(0x7fffffff)*2+1)/(uint32(1)<<((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy+(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions-TOPJ_UINT32(1)-resno))) {
		goto __11
	}
	dy = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy * (uint32(1) << ((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy + (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - resno))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy = func() uint32 {
		if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy) != 0) {
			return dy
		}
		return opj_uint_min(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy, dy)
	}()
__11:
	;
	goto __8
__8:
	resno++
	goto __7
	goto __9
__9:
	;
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy == TOPJ_UINT32(0)) {
		goto __12
	}
	return DOPJ_FALSE
__12:
	;
	if !!(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftp_on) != 0) {
		goto __13
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty0 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx0 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty1 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty1
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx1 = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx1
__13:
	;
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty0
__14:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fty1) {
		goto __16
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx0
__17:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Ftx1) {
		goto __19
	}
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno0
__20:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno < opj_uint_min(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fresno1, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions)) {
		goto __22
	}
	res = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions + uintptr((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno)*16
	levelno = (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions - TOPJ_UINT32(1) - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno
	// Avoids division by zero on id_000004,sig_06,src_000679,op_arith8,pos_49,val_-17
	// of  https://github.com/uclouvain/openjpeg/issues/938
	if !(levelno >= TOPJ_UINT32(32) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno>>levelno != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno>>levelno != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy) {
		goto __23
	}
	goto __21
__23:
	;
	if !((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno > TOPJ_UINT32(0x7fffffff) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno > TOPJ_UINT32(0x7fffffff)) {
		goto __24
	}
	goto __21
__24:
	;
	trx0 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno)
	try0 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno)
	trx1 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx1, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno)
	try1 = opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty1, (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno)
	rpx = (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx + levelno
	rpy = (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy + levelno

	// To avoid divisions by zero / undefined behaviour on shift
	// in below tests
	// Fixes reading id:000019,sig:08,src:001098,op:flip1,pos:49
	// of https://github.com/uclouvain/openjpeg/issues/938
	if !(rpx >= TOPJ_UINT32(31) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<rpx>>rpx != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx || rpy >= TOPJ_UINT32(31) || (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<rpy>>rpy != (*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy) {
		goto __25
	}
	goto __21
__25:
	;

	// See ISO-15441. B.12.1.5 Component-position-resolution level-layer progression
	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy%((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<rpy) == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy == (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fty0 && try0<<levelno%(uint32(1)<<rpy) != 0) {
		goto __26
	}
	goto __21
__26:
	;
	if !!((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx%((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<rpx) == TOPJ_UINT32(0) || (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx == (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Ftx0 && trx0<<levelno%(uint32(1)<<rpx) != 0) {
		goto __27
	}
	goto __21
__27:
	;

	if !((*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpw == TOPJ_UINT32(0) || (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fph == TOPJ_UINT32(0)) {
		goto __28
	}
	goto __21
__28:
	;

	if !(trx0 == trx1 || try0 == try1) {
		goto __29
	}
	goto __21
__29:
	;

	prci = opj_uint_floordivpow2(tls, opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx,
		(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdx<<levelno), (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx) -
		opj_uint_floordivpow2(tls, trx0, (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdx)
	prcj = opj_uint_floordivpow2(tls, opj_uint_ceildiv(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy,
		(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fdy<<levelno), (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy) -
		opj_uint_floordivpow2(tls, try0, (*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpdy)
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno = prci + prcj*(*Topj_pi_resolution_t)(unsafe.Pointer(res)).Fpw
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno0
__30:
	if !((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno < (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Flayno1) {
		goto __32
	}
	index = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_l + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_r + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_c + (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fprecno*(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fstep_p
	if !(index >= (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude_size) {
		goto __33
	}
	Xopj_event_msg(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fmanager, DEVT_ERROR, ts+31769, 0)
	return DOPJ_FALSE
__33:
	;
	if !!(int32(*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2))) != 0) {
		goto __34
	}
	*(*TOPJ_INT16)(unsafe.Pointer((*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Finclude + uintptr(index)*2)) = int16(1)
	return DOPJ_TRUE
__34:
	;
LABEL_SKIP:
	;
	goto __31
__31:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Flayno++
	goto __30
	goto __32
__32:
	;
	goto __21
__21:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fresno++
	goto __20
	goto __22
__22:
	;
	goto __18
__18:
	*(*TOPJ_UINT32)(unsafe.Pointer(pi + 232)) += (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fx%(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdx
	goto __17
	goto __19
__19:
	;
	goto __15
__15:
	*(*TOPJ_UINT32)(unsafe.Pointer(pi + 236)) += (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy - (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fy%(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fdy
	goto __14
	goto __16
__16:
	;
	goto __5
__5:
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fcompno++
	goto __4
	goto __6
__6:
	;

	return DOPJ_FALSE
}

func opj_get_encoding_parameters(tls *libc.TLS, p_image uintptr, p_cp uintptr, p_tileno TOPJ_UINT32, p_tx0 uintptr, p_tx1 uintptr, p_ty0 uintptr, p_ty1 uintptr, p_dx_min uintptr, p_dy_min uintptr, p_max_prec uintptr, p_max_res uintptr) { /* pi.c:762:13: */
	// loop
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	// pointers
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)

	// position in x and y of tile
	var p TOPJ_UINT32
	var q TOPJ_UINT32

	// non-corrected (in regard to image offset) tile offset
	var l_tx0 TOPJ_UINT32
	var l_ty0 TOPJ_UINT32

	// preconditions
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+31979, uint32(788), uintptr(unsafe.Pointer(&__func__242)))
	}
	if p_image != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+32003, ts+31979, uint32(789), uintptr(unsafe.Pointer(&__func__242)))
	}
	if p_tileno < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32017, ts+31979, uint32(790), uintptr(unsafe.Pointer(&__func__242)))
	}

	// initializations
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps + uintptr(p_tileno)*5696
	l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps

	// here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy
	p = p_tileno % (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw
	q = p_tileno / (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw

	// find extent of tile
	l_tx0 = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftx0 + p*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftdx // can't be greater than p_image->x1 so won't overflow
	*(*TOPJ_UINT32)(unsafe.Pointer(p_tx0)) = opj_uint_max(tls, l_tx0, (*Topj_image_t)(unsafe.Pointer(p_image)).Fx0)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_tx1)) = opj_uint_min(tls, opj_uint_adds(tls, l_tx0, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftdx), (*Topj_image_t)(unsafe.Pointer(p_image)).Fx1)
	l_ty0 = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fty0 + q*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftdy // can't be greater than p_image->y1 so won't overflow
	*(*TOPJ_UINT32)(unsafe.Pointer(p_ty0)) = opj_uint_max(tls, l_ty0, (*Topj_image_t)(unsafe.Pointer(p_image)).Fy0)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_ty1)) = opj_uint_min(tls, opj_uint_adds(tls, l_ty0, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftdy), (*Topj_image_t)(unsafe.Pointer(p_image)).Fy1)

	// max precision is 0 (can only grow)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_max_prec)) = TOPJ_UINT32(0)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_max_res)) = TOPJ_UINT32(0)

	// take the largest value for dx_min and dy_min
	*(*TOPJ_UINT32)(unsafe.Pointer(p_dx_min)) = TOPJ_UINT32(0x7fffffff)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_dy_min)) = TOPJ_UINT32(0x7fffffff)

	for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; compno++ {
		// arithmetic variables to calculate
		var l_level_no TOPJ_UINT32
		var l_rx0 TOPJ_UINT32
		var l_ry0 TOPJ_UINT32
		var l_rx1 TOPJ_UINT32
		var l_ry1 TOPJ_UINT32
		var l_px0 TOPJ_UINT32
		var l_py0 TOPJ_UINT32
		var l_px1 TOPJ_UINT32
		var py1 TOPJ_UINT32
		var l_pdx TOPJ_UINT32
		var l_pdy TOPJ_UINT32
		var l_pw TOPJ_UINT32
		var l_ph TOPJ_UINT32
		var l_product TOPJ_UINT32
		var l_tcx0 TOPJ_UINT32
		var l_tcy0 TOPJ_UINT32
		var l_tcx1 TOPJ_UINT32
		var l_tcy1 TOPJ_UINT32

		l_tcx0 = opj_uint_ceildiv(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_tx0)), (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)
		l_tcy0 = opj_uint_ceildiv(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_ty0)), (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)
		l_tcx1 = opj_uint_ceildiv(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_tx1)), (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)
		l_tcy1 = opj_uint_ceildiv(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_ty1)), (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)

		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions > *(*TOPJ_UINT32)(unsafe.Pointer(p_max_res)) {
			*(*TOPJ_UINT32)(unsafe.Pointer(p_max_res)) = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions
		}

		// use custom size for precincts
		for resno = TOPJ_UINT32(0); resno < (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions; resno++ {
			var l_dx TOPJ_UINT32
			var l_dy TOPJ_UINT32

			// precinct width and height
			l_pdx = *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 812 + uintptr(resno)*4))
			l_pdy = *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 944 + uintptr(resno)*4))

			l_dx = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx * (uint32(1) << (l_pdx + (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions - TOPJ_UINT32(1) - resno))
			l_dy = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy * (uint32(1) << (l_pdy + (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions - TOPJ_UINT32(1) - resno))

			// take the minimum size for dx for each comp and resolution
			*(*TOPJ_UINT32)(unsafe.Pointer(p_dx_min)) = opj_uint_min(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_dx_min)), l_dx)
			*(*TOPJ_UINT32)(unsafe.Pointer(p_dy_min)) = opj_uint_min(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_dy_min)), l_dy)

			// various calculations of extents
			l_level_no = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions - TOPJ_UINT32(1) - resno

			l_rx0 = opj_uint_ceildivpow2(tls, l_tcx0, l_level_no)
			l_ry0 = opj_uint_ceildivpow2(tls, l_tcy0, l_level_no)
			l_rx1 = opj_uint_ceildivpow2(tls, l_tcx1, l_level_no)
			l_ry1 = opj_uint_ceildivpow2(tls, l_tcy1, l_level_no)

			l_px0 = opj_uint_floordivpow2(tls, l_rx0, l_pdx) << l_pdx
			l_py0 = opj_uint_floordivpow2(tls, l_ry0, l_pdy) << l_pdy
			l_px1 = opj_uint_ceildivpow2(tls, l_rx1, l_pdx) << l_pdx

			py1 = opj_uint_ceildivpow2(tls, l_ry1, l_pdy) << l_pdy

			if l_rx0 == l_rx1 {
				l_pw = uint32(0)
			} else {
				l_pw = (l_px1 - l_px0) >> l_pdx
			}
			if l_ry0 == l_ry1 {
				l_ph = uint32(0)
			} else {
				l_ph = (py1 - l_py0) >> l_pdy
			}

			l_product = l_pw * l_ph

			// update precision
			if l_product > *(*TOPJ_UINT32)(unsafe.Pointer(p_max_prec)) {
				*(*TOPJ_UINT32)(unsafe.Pointer(p_max_prec)) = l_product
			}
		}
		l_img_comp += 64
		l_tccp += 1080
	}
}

var __func__242 = *(*[28]int8)(unsafe.Pointer(ts + 32048)) /* pi.c:773:1 */

func opj_get_all_encoding_parameters(tls *libc.TLS, p_image uintptr, p_cp uintptr, tileno TOPJ_UINT32, p_tx0 uintptr, p_tx1 uintptr, p_ty0 uintptr, p_ty1 uintptr, p_dx_min uintptr, p_dy_min uintptr, p_max_prec uintptr, p_max_res uintptr, p_resolutions uintptr) { /* pi.c:883:13: */
	// loop
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32

	// pointers
	var tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)

	// to store l_dx, l_dy, w and h for each resolution and component.
	var lResolutionPtr uintptr

	// position in x and y of tile
	var p TOPJ_UINT32
	var q TOPJ_UINT32

	// non-corrected (in regard to image offset) tile offset
	var l_tx0 TOPJ_UINT32
	var l_ty0 TOPJ_UINT32

	// preconditions in debug
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+31979, uint32(914), uintptr(unsafe.Pointer(&__func__243)))
	}
	if p_image != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+32003, ts+31979, uint32(915), uintptr(unsafe.Pointer(&__func__243)))
	}
	if tileno < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32076, ts+31979, uint32(916), uintptr(unsafe.Pointer(&__func__243)))
	}

	// initializations
	tcp = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps + uintptr(tileno)*5696
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps

	// position in x and y of tile
	p = tileno % (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw
	q = tileno / (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw

	// here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy
	l_tx0 = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftx0 + p*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftdx // can't be greater than p_image->x1 so won't overflow
	*(*TOPJ_UINT32)(unsafe.Pointer(p_tx0)) = opj_uint_max(tls, l_tx0, (*Topj_image_t)(unsafe.Pointer(p_image)).Fx0)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_tx1)) = opj_uint_min(tls, opj_uint_adds(tls, l_tx0, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftdx), (*Topj_image_t)(unsafe.Pointer(p_image)).Fx1)
	l_ty0 = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Fty0 + q*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftdy // can't be greater than p_image->y1 so won't overflow
	*(*TOPJ_UINT32)(unsafe.Pointer(p_ty0)) = opj_uint_max(tls, l_ty0, (*Topj_image_t)(unsafe.Pointer(p_image)).Fy0)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_ty1)) = opj_uint_min(tls, opj_uint_adds(tls, l_ty0, (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftdy), (*Topj_image_t)(unsafe.Pointer(p_image)).Fy1)

	// max precision and resolution is 0 (can only grow)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_max_prec)) = TOPJ_UINT32(0)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_max_res)) = TOPJ_UINT32(0)

	// take the largest value for dx_min and dy_min
	*(*TOPJ_UINT32)(unsafe.Pointer(p_dx_min)) = TOPJ_UINT32(0x7fffffff)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_dy_min)) = TOPJ_UINT32(0x7fffffff)

	for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps; compno++ {
		// arithmetic variables to calculate
		var l_level_no TOPJ_UINT32
		var l_rx0 TOPJ_UINT32
		var l_ry0 TOPJ_UINT32
		var l_rx1 TOPJ_UINT32
		var l_ry1 TOPJ_UINT32
		var l_px0 TOPJ_UINT32
		var l_py0 TOPJ_UINT32
		var l_px1 TOPJ_UINT32
		var py1 TOPJ_UINT32
		var l_product TOPJ_UINT32
		var l_tcx0 TOPJ_UINT32
		var l_tcy0 TOPJ_UINT32
		var l_tcx1 TOPJ_UINT32
		var l_tcy1 TOPJ_UINT32
		var l_pdx TOPJ_UINT32
		var l_pdy TOPJ_UINT32
		var l_pw TOPJ_UINT32
		var l_ph TOPJ_UINT32

		if p_resolutions != 0 {
			lResolutionPtr = *(*uintptr)(unsafe.Pointer(p_resolutions + uintptr(compno)*8))
		} else {
			lResolutionPtr = uintptr(0)
		}

		l_tcx0 = opj_uint_ceildiv(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_tx0)), (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)
		l_tcy0 = opj_uint_ceildiv(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_ty0)), (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)
		l_tcx1 = opj_uint_ceildiv(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_tx1)), (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx)
		l_tcy1 = opj_uint_ceildiv(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_ty1)), (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy)

		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions > *(*TOPJ_UINT32)(unsafe.Pointer(p_max_res)) {
			*(*TOPJ_UINT32)(unsafe.Pointer(p_max_res)) = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions
		}

		// use custom size for precincts
		l_level_no = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions
		for resno = TOPJ_UINT32(0); resno < (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions; resno++ {
			var l_dx TOPJ_UINT32
			var l_dy TOPJ_UINT32

			l_level_no--

			// precinct width and height
			l_pdx = *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 812 + uintptr(resno)*4))
			l_pdy = *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 944 + uintptr(resno)*4))
			if lResolutionPtr != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&lResolutionPtr, 4))) = l_pdx
				*(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&lResolutionPtr, 4))) = l_pdy
			}
			if l_pdx+l_level_no < TOPJ_UINT32(32) && (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx <= (uint32(0x7fffffff)*2+1)/(uint32(1)<<(l_pdx+l_level_no)) {
				l_dx = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx * (uint32(1) << (l_pdx + l_level_no))
				// take the minimum size for l_dx for each comp and resolution
				*(*TOPJ_UINT32)(unsafe.Pointer(p_dx_min)) = opj_uint_min(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_dx_min)), l_dx)
			}
			if l_pdy+l_level_no < TOPJ_UINT32(32) && (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy <= (uint32(0x7fffffff)*2+1)/(uint32(1)<<(l_pdy+l_level_no)) {
				l_dy = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy * (uint32(1) << (l_pdy + l_level_no))
				*(*TOPJ_UINT32)(unsafe.Pointer(p_dy_min)) = opj_uint_min(tls, *(*TOPJ_UINT32)(unsafe.Pointer(p_dy_min)), l_dy)
			}

			// various calculations of extents
			l_rx0 = opj_uint_ceildivpow2(tls, l_tcx0, l_level_no)
			l_ry0 = opj_uint_ceildivpow2(tls, l_tcy0, l_level_no)
			l_rx1 = opj_uint_ceildivpow2(tls, l_tcx1, l_level_no)
			l_ry1 = opj_uint_ceildivpow2(tls, l_tcy1, l_level_no)
			l_px0 = opj_uint_floordivpow2(tls, l_rx0, l_pdx) << l_pdx
			l_py0 = opj_uint_floordivpow2(tls, l_ry0, l_pdy) << l_pdy
			l_px1 = opj_uint_ceildivpow2(tls, l_rx1, l_pdx) << l_pdx
			py1 = opj_uint_ceildivpow2(tls, l_ry1, l_pdy) << l_pdy
			if l_rx0 == l_rx1 {
				l_pw = uint32(0)
			} else {
				l_pw = (l_px1 - l_px0) >> l_pdx
			}
			if l_ry0 == l_ry1 {
				l_ph = uint32(0)
			} else {
				l_ph = (py1 - l_py0) >> l_pdy
			}
			if lResolutionPtr != 0 {
				*(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&lResolutionPtr, 4))) = l_pw
				*(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&lResolutionPtr, 4))) = l_ph
			}
			l_product = l_pw * l_ph

			// update precision
			if l_product > *(*TOPJ_UINT32)(unsafe.Pointer(p_max_prec)) {
				*(*TOPJ_UINT32)(unsafe.Pointer(p_max_prec)) = l_product
			}

		}
		l_tccp += 1080
		l_img_comp += 64
	}
}

var __func__243 = *(*[32]int8)(unsafe.Pointer(ts + 32105)) /* pi.c:895:1 */

func opj_pi_create(tls *libc.TLS, image uintptr, cp uintptr, tileno TOPJ_UINT32, manager uintptr) uintptr { /* pi.c:1019:26: */
	// loop
	var pino TOPJ_UINT32
	var compno TOPJ_UINT32
	// number of poc in the p_pi
	var l_poc_bound TOPJ_UINT32

	// pointers to tile coding parameters and components.
	var l_pi uintptr = uintptr(00)
	var tcp uintptr = uintptr(00)
	var tccp uintptr = uintptr(00)

	// current packet iterator being allocated
	var l_current_pi uintptr = uintptr(00)

	// preconditions in debug
	if cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3926, ts+31979, uint32(1038), uintptr(unsafe.Pointer(&__func__244)))
	}
	if image != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+3935, ts+31979, uint32(1039), uintptr(unsafe.Pointer(&__func__244)))
	}
	if tileno < (*Topj_cp_t)(unsafe.Pointer(cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32137, ts+31979, uint32(1040), uintptr(unsafe.Pointer(&__func__244)))
	}

	// initializations
	tcp = (*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps + uintptr(tileno)*5696
	l_poc_bound = (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fnumpocs + TOPJ_UINT32(1)

	// memory allocations
	l_pi = Xopj_calloc(tls, uint32(l_poc_bound),
		uint32(unsafe.Sizeof(Topj_pi_iterator_t1{})))
	if !(l_pi != 0) {
		return uintptr(0)
	}

	l_current_pi = l_pi
	for pino = TOPJ_UINT32(0); pino < l_poc_bound; pino++ {

		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fmanager = manager

		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps = Xopj_calloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps),
			uint32(unsafe.Sizeof(Topj_pi_comp_t{})))
		if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps) != 0) {
			Xopj_pi_destroy(tls, l_pi, l_poc_bound)
			return uintptr(0)
		}

		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fnumcomps = (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps

		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer(image)).Fnumcomps; compno++ {
			var comp uintptr = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps + uintptr(compno)*24

			tccp = (*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps + uintptr(compno)*1080

			(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions = Xopj_calloc(tls, uint32((*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumresolutions),
				uint32(unsafe.Sizeof(Topj_pi_resolution_t{})))
			if !(int32((*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fresolutions) != 0) {
				Xopj_pi_destroy(tls, l_pi, l_poc_bound)
				return uintptr(00)
			}

			(*Topj_pi_comp_t)(unsafe.Pointer(comp)).Fnumresolutions = (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fnumresolutions
		}
		l_current_pi += 256
	}
	return l_pi
}

var __func__244 = *(*[14]int8)(unsafe.Pointer(ts + 32162)) /* pi.c:1023:1 */

func opj_pi_update_encode_poc_and_final(tls *libc.TLS, p_cp uintptr, p_tileno TOPJ_UINT32, p_tx0 TOPJ_UINT32, p_tx1 TOPJ_UINT32, p_ty0 TOPJ_UINT32, p_ty1 TOPJ_UINT32, p_max_prec TOPJ_UINT32, p_max_res TOPJ_UINT32, p_dx_min TOPJ_UINT32, p_dy_min TOPJ_UINT32) { /* pi.c:1086:13: */
	// loop
	var pino TOPJ_UINT32
	// tile coding parameter
	var l_tcp uintptr = uintptr(00)
	// current poc being updated
	var l_current_poc uintptr = uintptr(00)

	// number of pocs
	var l_poc_bound TOPJ_UINT32

	_ = p_max_res

	// preconditions in debug
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+31979, uint32(1110), uintptr(unsafe.Pointer(&__func__245)))
	}
	if p_tileno < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32017, ts+31979, uint32(1111), uintptr(unsafe.Pointer(&__func__245)))
	}

	// initializations
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps + uintptr(p_tileno)*5696
	// number of iterations in the loop
	l_poc_bound = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs + TOPJ_UINT32(1)

	// start at first element, and to make sure the compiler will not make a calculation each time in the loop
	//        store a pointer to the current element to modify rather than l_tcp->pocs[i]
	l_current_poc = l_tcp + 424 /* &.pocs */

	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FcompS = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fcompno0
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FcompE = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fcompno1
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FresS = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fresno0
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FresE = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fresno1
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FlayE = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Flayno1

	// special treatment for the first element
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FlayS = TOPJ_UINT32(0)
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fprg = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fprg1
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FprcS = TOPJ_UINT32(0)

	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FprcE = p_max_prec
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtxS = p_tx0
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtxE = p_tx1
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtyS = p_ty0
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtyE = p_ty1
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fdx = p_dx_min
	(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fdy = p_dy_min

	l_current_poc += 148
	for pino = TOPJ_UINT32(1); pino < l_poc_bound; pino++ {
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FcompS = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fcompno0
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FcompE = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fcompno1
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FresS = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fresno0
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FresE = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fresno1
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FlayE = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Flayno1
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fprg = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fprg1
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FprcS = TOPJ_UINT32(0)
		// special treatment here different from the first element
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FlayS = func() uint32 {
			if (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FlayE > (*Topj_poc_t1)(unsafe.Pointer(l_current_poc-uintptr(1)*148)).FlayE {
				return (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FlayE
			}
			return uint32(0)
		}()

		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FprcE = p_max_prec
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtxS = p_tx0
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtxE = p_tx1
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtyS = p_ty0
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtyE = p_ty1
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fdx = p_dx_min
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fdy = p_dy_min
		l_current_poc += 148
	}
}

var __func__245 = *(*[35]int8)(unsafe.Pointer(ts + 32176)) /* pi.c:1096:1 */

func opj_pi_update_encode_not_poc(tls *libc.TLS, p_cp uintptr, p_num_comps TOPJ_UINT32, p_tileno TOPJ_UINT32, p_tx0 TOPJ_UINT32, p_tx1 TOPJ_UINT32, p_ty0 TOPJ_UINT32, p_ty1 TOPJ_UINT32, p_max_prec TOPJ_UINT32, p_max_res TOPJ_UINT32, p_dx_min TOPJ_UINT32, p_dy_min TOPJ_UINT32) { /* pi.c:1165:13: */
	// loop
	var pino TOPJ_UINT32
	// tile coding parameter
	var l_tcp uintptr = uintptr(00)
	// current poc being updated
	var l_current_poc uintptr = uintptr(00)
	// number of pocs
	var l_poc_bound TOPJ_UINT32

	// preconditions in debug
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+31979, uint32(1187), uintptr(unsafe.Pointer(&__func__246)))
	}
	if p_tileno < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32017, ts+31979, uint32(1188), uintptr(unsafe.Pointer(&__func__246)))
	}

	// initializations
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps + uintptr(p_tileno)*5696

	// number of iterations in the loop
	l_poc_bound = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs + TOPJ_UINT32(1)

	// start at first element, and to make sure the compiler will not make a calculation each time in the loop
	//        store a pointer to the current element to modify rather than l_tcp->pocs[i]
	l_current_poc = l_tcp + 424 /* &.pocs */

	for pino = TOPJ_UINT32(0); pino < l_poc_bound; pino++ {
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FcompS = TOPJ_UINT32(0)
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FcompE = p_num_comps //p_image->numcomps;
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FresS = TOPJ_UINT32(0)
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FresE = p_max_res
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FlayS = TOPJ_UINT32(0)
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FlayE = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fprg = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fprg
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FprcS = TOPJ_UINT32(0)
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FprcE = p_max_prec
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtxS = p_tx0
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtxE = p_tx1
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtyS = p_ty0
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).FtyE = p_ty1
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fdx = p_dx_min
		(*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fdy = p_dy_min
		l_current_poc += 148
	}
}

var __func__246 = *(*[29]int8)(unsafe.Pointer(ts + 32211)) /* pi.c:1176:1 */

func opj_pi_update_decode_poc(tls *libc.TLS, p_pi uintptr, p_tcp uintptr, p_max_precision TOPJ_UINT32, p_max_res TOPJ_UINT32) { /* pi.c:1220:13: */
	// loop
	var pino TOPJ_UINT32

	// encoding parameters to set
	var l_bound TOPJ_UINT32

	var l_current_pi uintptr = uintptr(00)
	var l_current_poc uintptr = uintptr(0)

	_ = p_max_res

	// preconditions in debug
	if p_pi != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+32240, ts+31979, uint32(1237), uintptr(unsafe.Pointer(&__func__247)))
	}
	if p_tcp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6868, ts+31979, uint32(1238), uintptr(unsafe.Pointer(&__func__247)))
	}

	// initializations
	l_bound = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fnumpocs + TOPJ_UINT32(1)
	l_current_pi = p_pi
	l_current_poc = p_tcp + 424 /* &.pocs */

	for pino = TOPJ_UINT32(0); pino < l_bound; pino++ {
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fprg = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fprg // Progression Order #0
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ffirst = 1

		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fresno0 = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fresno0   // Resolution Level Index #0 (Start)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fcompno0 = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fcompno0 // Component Index #0 (Start)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Flayno0 = TOPJ_UINT32(0)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fprecno0 = TOPJ_UINT32(0)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fresno1 = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fresno1   // Resolution Level Index #0 (End)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fcompno1 = (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Fcompno1 // Component Index #0 (End)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Flayno1 = opj_uint_min(tls, (*Topj_poc_t1)(unsafe.Pointer(l_current_poc)).Flayno1,
			(*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fnumlayers) // Layer Index #0 (End)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fprecno1 = p_max_precision
		l_current_pi += 256
		l_current_poc += 148
	}
}

var __func__247 = *(*[25]int8)(unsafe.Pointer(ts + 32251)) /* pi.c:1224:1 */

func opj_pi_update_decode_not_poc(tls *libc.TLS, p_pi uintptr, p_tcp uintptr, p_max_precision TOPJ_UINT32, p_max_res TOPJ_UINT32) { /* pi.c:1267:13: */
	// loop
	var pino TOPJ_UINT32

	// encoding parameters to set
	var l_bound TOPJ_UINT32

	var l_current_pi uintptr = uintptr(00)
	// preconditions in debug
	if p_tcp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6868, ts+31979, uint32(1280), uintptr(unsafe.Pointer(&__func__248)))
	}
	if p_pi != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+32240, ts+31979, uint32(1281), uintptr(unsafe.Pointer(&__func__248)))
	}

	// initializations
	l_bound = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fnumpocs + TOPJ_UINT32(1)
	l_current_pi = p_pi

	for pino = TOPJ_UINT32(0); pino < l_bound; pino++ {
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fprg = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fprg
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ffirst = 1
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fresno0 = TOPJ_UINT32(0)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fcompno0 = TOPJ_UINT32(0)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Flayno0 = TOPJ_UINT32(0)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fprecno0 = TOPJ_UINT32(0)
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fresno1 = p_max_res
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fcompno1 = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fnumcomps
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Flayno1 = (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fnumlayers
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fpoc.Fprecno1 = p_max_precision
		l_current_pi += 256
	}
}

var __func__248 = *(*[29]int8)(unsafe.Pointer(ts + 32276)) /* pi.c:1271:1 */

func opj_pi_check_next_level(tls *libc.TLS, pos TOPJ_INT32, cp uintptr, tileno TOPJ_UINT32, pino TOPJ_UINT32, prog uintptr) TOPJ_BOOL { /* pi.c:1304:17: */
	var i TOPJ_INT32
	var tcps uintptr = (*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps + uintptr(tileno)*5696
	var tcp uintptr = tcps + 424 + uintptr(pino)*148

	if pos >= 0 {
		for i = pos; i >= 0; i-- {
			switch int32(*(*TOPJ_CHAR)(unsafe.Pointer(prog + uintptr(i)))) {
			case 'R':
				if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FresE {
					if opj_pi_check_next_level(tls, pos-1, cp, tileno, pino, prog) != 0 {
						return DOPJ_TRUE
					} else {
						return DOPJ_FALSE
					}
				} else {
					return DOPJ_TRUE
				}
				break
				fallthrough
			case 'C':
				if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FcompE {
					if opj_pi_check_next_level(tls, pos-1, cp, tileno, pino, prog) != 0 {
						return DOPJ_TRUE
					} else {
						return DOPJ_FALSE
					}
				} else {
					return DOPJ_TRUE
				}
				break
				fallthrough
			case 'L':
				if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FlayE {
					if opj_pi_check_next_level(tls, pos-1, cp, tileno, pino, prog) != 0 {
						return DOPJ_TRUE
					} else {
						return DOPJ_FALSE
					}
				} else {
					return DOPJ_TRUE
				}
				break
				fallthrough
			case 'P':
				switch (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprg {
				case OPJ_LRCP:
					fallthrough // fall through
				case OPJ_RLCP:
					if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FprcE {
						if opj_pi_check_next_level(tls, i-1, cp, tileno, pino, prog) != 0 {
							return DOPJ_TRUE
						} else {
							return DOPJ_FALSE
						}
					} else {
						return DOPJ_TRUE
					}
					break
					fallthrough
				default:
					if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtxE {
						//TY
						if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtyE {
							if opj_pi_check_next_level(tls, i-1, cp, tileno, pino, prog) != 0 {
								return DOPJ_TRUE
							} else {
								return DOPJ_FALSE
							}
						} else {
							return DOPJ_TRUE
						} //TY
					} else {
						return DOPJ_TRUE
					}
					break
				} //end case P
			} //end switch
		} //end for
	} //end if
	return DOPJ_FALSE
}

//
// ==========================================================
//    Packet iterator interface
// ==========================================================
func Xopj_pi_create_decode(tls *libc.TLS, p_image uintptr, p_cp uintptr, p_tile_no TOPJ_UINT32, manager uintptr) uintptr { /* pi.c:1393:19: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var numcomps TOPJ_UINT32 = (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps

	// loop
	var pino TOPJ_UINT32
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32

	// to store w, h, dx and dy for all components and resolutions
	var l_tmp_data uintptr
	var l_tmp_ptr uintptr

	// encoding parameters to set
	// var l_max_res TOPJ_UINT32 at bp+28, 4

	// var l_max_prec TOPJ_UINT32 at bp+24, 4

	// var l_tx0 TOPJ_UINT32 at bp, 4

	// var l_tx1 TOPJ_UINT32 at bp+4, 4

	// var l_ty0 TOPJ_UINT32 at bp+8, 4

	// var l_ty1 TOPJ_UINT32 at bp+12, 4

	// var l_dx_min TOPJ_UINT32 at bp+16, 4

	// var l_dy_min TOPJ_UINT32 at bp+20, 4

	var l_bound TOPJ_UINT32
	var l_step_p TOPJ_UINT32
	var l_step_c TOPJ_UINT32
	var l_step_r TOPJ_UINT32
	var l_step_l TOPJ_UINT32
	var l_data_stride TOPJ_UINT32

	// pointers
	var l_pi uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_current_comp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)
	var l_current_pi uintptr = uintptr(00)
	var l_encoding_value_ptr uintptr = uintptr(00)

	// preconditions in debug
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+31979, uint32(1427), uintptr(unsafe.Pointer(&__func__249)))
	}
	if p_image != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+32003, ts+31979, uint32(1428), uintptr(unsafe.Pointer(&__func__249)))
	}
	if p_tile_no < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32305, ts+31979, uint32(1429), uintptr(unsafe.Pointer(&__func__249)))
	}

	// initializations
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_bound = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs + TOPJ_UINT32(1)

	l_data_stride = TOPJ_UINT32(4 * DOPJ_J2K_MAXRLVLS)
	l_tmp_data = Xopj_malloc(tls,
		uint32(l_data_stride*numcomps)*uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
	if !(l_tmp_data != 0) {
		return uintptr(00)
	}
	l_tmp_ptr = Xopj_malloc(tls,
		uint32(numcomps)*uint32(unsafe.Sizeof(uintptr(0))))
	if !(l_tmp_ptr != 0) {
		Xopj_free(tls, l_tmp_data)
		return uintptr(00)
	}

	// memory allocation for pi
	l_pi = opj_pi_create(tls, p_image, p_cp, p_tile_no, manager)
	if !(l_pi != 0) {
		Xopj_free(tls, l_tmp_data)
		Xopj_free(tls, l_tmp_ptr)
		return uintptr(00)
	}

	l_encoding_value_ptr = l_tmp_data
	// update pointer array
	for compno = TOPJ_UINT32(0); compno < numcomps; compno++ {
		*(*uintptr)(unsafe.Pointer(l_tmp_ptr + uintptr(compno)*8)) = l_encoding_value_ptr
		l_encoding_value_ptr += 4 * uintptr(l_data_stride)
	}
	// get encoding parameters
	opj_get_all_encoding_parameters(tls, p_image, p_cp, p_tile_no, bp, bp+4,
		bp+8, bp+12, bp+16, bp+20, bp+24, bp+28, l_tmp_ptr)

	// step calculations
	l_step_p = TOPJ_UINT32(1)
	l_step_c = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) * l_step_p
	l_step_r = numcomps * l_step_c
	l_step_l = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28)) * l_step_r

	// set values for first packet iterator
	l_current_pi = l_pi

	// memory allocation for include
	// prevent an integer overflow issue
	// 0 < l_tcp->numlayers < 65536 c.f. opj_j2k_read_cod in j2k.c
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude = uintptr(00)
	if l_step_l <= (uint32(0x7fffffff)*2+1)/((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers+1) {
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude_size = ((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers + 1) * l_step_l
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude = Xopj_calloc(tls,
			uint32((*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude_size), uint32(unsafe.Sizeof(TOPJ_INT16(0))))
	}

	if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude) != 0) {
		Xopj_free(tls, l_tmp_data)
		Xopj_free(tls, l_tmp_ptr)
		Xopj_pi_destroy(tls, l_pi, l_bound)
		return uintptr(00)
	}

	// special treatment for the first packet iterator
	l_current_comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps

	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ftx0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_tx0 */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fty0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_ty0 */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ftx1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_tx1 */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fty1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_ty1 */))

	//l_current_pi->dx = l_img_comp->dx;
	//l_current_pi->dy = l_img_comp->dy;

	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_p = l_step_p
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_c = l_step_c
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_r = l_step_r
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_l = l_step_l

	// allocation for components and number of components has already been calculated by opj_pi_create
	for compno = TOPJ_UINT32(0); compno < numcomps; compno++ {
		var l_res uintptr = (*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fresolutions
		l_encoding_value_ptr = *(*uintptr)(unsafe.Pointer(l_tmp_ptr + uintptr(compno)*8))

		(*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fdx = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx
		(*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fdy = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy
		// resolutions have already been initialized
		for resno = TOPJ_UINT32(0); resno < (*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fnumresolutions; resno++ {
			(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpdx = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
			(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpdy = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
			(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpw = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
			(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fph = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
			l_res += 16
		}
		l_current_comp += 24
		l_img_comp += 64
		l_tccp += 1080
	}
	l_current_pi += 256

	for pino = TOPJ_UINT32(1); pino < l_bound; pino++ {
		l_current_comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps
		l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps
		l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps

		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ftx0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_tx0 */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fty0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_ty0 */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ftx1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_tx1 */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fty1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_ty1 */))
		//l_current_pi->dx = l_dx_min;
		//l_current_pi->dy = l_dy_min;
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_p = l_step_p
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_c = l_step_c
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_r = l_step_r
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_l = l_step_l

		// allocation for components and number of components has already been calculated by opj_pi_create
		for compno = TOPJ_UINT32(0); compno < numcomps; compno++ {
			var l_res uintptr = (*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fresolutions
			l_encoding_value_ptr = *(*uintptr)(unsafe.Pointer(l_tmp_ptr + uintptr(compno)*8))

			(*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fdx = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx
			(*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fdy = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy
			// resolutions have already been initialized
			for resno = TOPJ_UINT32(0); resno < (*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fnumresolutions; resno++ {
				(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpdx = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
				(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpdy = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
				(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpw = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
				(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fph = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
				l_res += 16
			}
			l_current_comp += 24
			l_img_comp += 64
			l_tccp += 1080
		}
		// special treatment
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi - uintptr(1)*256)).Finclude
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude_size = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi - uintptr(1)*256)).Finclude_size
		l_current_pi += 256
	}
	Xopj_free(tls, l_tmp_data)
	l_tmp_data = uintptr(00)
	Xopj_free(tls, l_tmp_ptr)
	l_tmp_ptr = uintptr(00)
	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(l_tcp + 5688))&0x4>>2)) != 0 {
		opj_pi_update_decode_poc(tls, l_pi, l_tcp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* l_max_prec */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* l_max_res */)))
	} else {
		opj_pi_update_decode_not_poc(tls, l_pi, l_tcp, *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* l_max_prec */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* l_max_res */)))
	}
	return l_pi
}

var __func__249 = *(*[21]int8)(unsafe.Pointer(ts + 32337)) /* pi.c:1397:1 */

func Xopj_get_encoding_packet_count(tls *libc.TLS, p_image uintptr, p_cp uintptr, p_tile_no TOPJ_UINT32) TOPJ_UINT32 { /* pi.c:1592:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var l_max_res TOPJ_UINT32 at bp+28, 4

	// var l_max_prec TOPJ_UINT32 at bp+24, 4

	// var l_tx0 TOPJ_UINT32 at bp, 4

	// var l_tx1 TOPJ_UINT32 at bp+4, 4

	// var l_ty0 TOPJ_UINT32 at bp+8, 4

	// var l_ty1 TOPJ_UINT32 at bp+12, 4

	// var l_dx_min TOPJ_UINT32 at bp+16, 4

	// var l_dy_min TOPJ_UINT32 at bp+20, 4

	// preconditions in debug
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+31979, uint32(1602), uintptr(unsafe.Pointer(&__func__250)))
	}
	if p_image != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+32003, ts+31979, uint32(1603), uintptr(unsafe.Pointer(&__func__250)))
	}
	if p_tile_no < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32305, ts+31979, uint32(1604), uintptr(unsafe.Pointer(&__func__250)))
	}

	// get encoding parameters
	opj_get_all_encoding_parameters(tls, p_image, p_cp, p_tile_no, bp, bp+4,
		bp+8, bp+12, bp+16, bp+20, bp+24, bp+28, uintptr(0))

	return (*Topj_tcp_t)(unsafe.Pointer((*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps+uintptr(p_tile_no)*5696)).Fnumlayers * *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) * (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps * *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28))
}

var __func__250 = *(*[30]int8)(unsafe.Pointer(ts + 32358)) /* pi.c:1595:1 */

func Xopj_pi_initialise_encode(tls *libc.TLS, p_image uintptr, p_cp uintptr, p_tile_no TOPJ_UINT32, p_t2_mode TJ2K_T2_MODE, manager uintptr) uintptr { /* pi.c:1615:19: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var numcomps TOPJ_UINT32 = (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps

	// loop
	var pino TOPJ_UINT32
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32

	// to store w, h, dx and dy for all components and resolutions
	var l_tmp_data uintptr
	var l_tmp_ptr uintptr

	// encoding parameters to set
	// var l_max_res TOPJ_UINT32 at bp+28, 4

	// var l_max_prec TOPJ_UINT32 at bp+24, 4

	// var l_tx0 TOPJ_UINT32 at bp, 4

	// var l_tx1 TOPJ_UINT32 at bp+4, 4

	// var l_ty0 TOPJ_UINT32 at bp+8, 4

	// var l_ty1 TOPJ_UINT32 at bp+12, 4

	// var l_dx_min TOPJ_UINT32 at bp+16, 4

	// var l_dy_min TOPJ_UINT32 at bp+20, 4

	var l_bound TOPJ_UINT32
	var l_step_p TOPJ_UINT32
	var l_step_c TOPJ_UINT32
	var l_step_r TOPJ_UINT32
	var l_step_l TOPJ_UINT32
	var l_data_stride TOPJ_UINT32

	// pointers
	var l_pi uintptr = uintptr(00)
	var l_tcp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_current_comp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)
	var l_current_pi uintptr = uintptr(00)
	var l_encoding_value_ptr uintptr = uintptr(00)

	// preconditions in debug
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+31979, uint32(1650), uintptr(unsafe.Pointer(&__func__251)))
	}
	if p_image != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+32003, ts+31979, uint32(1651), uintptr(unsafe.Pointer(&__func__251)))
	}
	if p_tile_no < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32305, ts+31979, uint32(1652), uintptr(unsafe.Pointer(&__func__251)))
	}

	// initializations
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_bound = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs + TOPJ_UINT32(1)

	l_data_stride = TOPJ_UINT32(4 * DOPJ_J2K_MAXRLVLS)
	l_tmp_data = Xopj_malloc(tls,
		uint32(l_data_stride*numcomps)*uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
	if !(l_tmp_data != 0) {
		return uintptr(00)
	}

	l_tmp_ptr = Xopj_malloc(tls,
		uint32(numcomps)*uint32(unsafe.Sizeof(uintptr(0))))
	if !(l_tmp_ptr != 0) {
		Xopj_free(tls, l_tmp_data)
		return uintptr(00)
	}

	// memory allocation for pi
	l_pi = opj_pi_create(tls, p_image, p_cp, p_tile_no, manager)
	if !(l_pi != 0) {
		Xopj_free(tls, l_tmp_data)
		Xopj_free(tls, l_tmp_ptr)
		return uintptr(00)
	}

	l_encoding_value_ptr = l_tmp_data
	// update pointer array
	for compno = TOPJ_UINT32(0); compno < numcomps; compno++ {
		*(*uintptr)(unsafe.Pointer(l_tmp_ptr + uintptr(compno)*8)) = l_encoding_value_ptr
		l_encoding_value_ptr += 4 * uintptr(l_data_stride)
	}

	// get encoding parameters
	opj_get_all_encoding_parameters(tls, p_image, p_cp, p_tile_no, bp, bp+4,
		bp+8, bp+12, bp+16, bp+20, bp+24, bp+28, l_tmp_ptr)

	// step calculations
	l_step_p = TOPJ_UINT32(1)
	l_step_c = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24)) * l_step_p
	l_step_r = numcomps * l_step_c
	l_step_l = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28)) * l_step_r

	// set values for first packet iterator
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_pi)).Ftp_on = TOPJ_BYTE(int32(*(*uint8)(unsafe.Pointer(p_cp + 120 + 20)) & 0x8 >> 3))
	l_current_pi = l_pi

	// memory allocation for include
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude_size = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumlayers * l_step_l
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude = Xopj_calloc(tls, uint32((*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude_size),
		uint32(unsafe.Sizeof(TOPJ_INT16(0))))
	if !(int32((*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude) != 0) {
		Xopj_free(tls, l_tmp_data)
		Xopj_free(tls, l_tmp_ptr)
		Xopj_pi_destroy(tls, l_pi, l_bound)
		return uintptr(00)
	}

	// special treatment for the first packet iterator
	l_current_comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ftx0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_tx0 */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fty0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_ty0 */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ftx1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_tx1 */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fty1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_ty1 */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fdx = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_dx_min */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fdy = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* l_dy_min */))
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_p = l_step_p
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_c = l_step_c
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_r = l_step_r
	(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_l = l_step_l

	// allocation for components and number of components has already been calculated by opj_pi_create
	for compno = TOPJ_UINT32(0); compno < numcomps; compno++ {
		var l_res uintptr = (*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fresolutions
		l_encoding_value_ptr = *(*uintptr)(unsafe.Pointer(l_tmp_ptr + uintptr(compno)*8))

		(*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fdx = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx
		(*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fdy = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy

		// resolutions have already been initialized
		for resno = TOPJ_UINT32(0); resno < (*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fnumresolutions; resno++ {
			(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpdx = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
			(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpdy = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
			(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpw = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
			(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fph = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
			l_res += 16
		}

		l_current_comp += 24
		l_img_comp += 64
		l_tccp += 1080
	}
	l_current_pi += 256

	for pino = TOPJ_UINT32(1); pino < l_bound; pino++ {
		l_current_comp = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps
		l_img_comp = (*Topj_image_t)(unsafe.Pointer(p_image)).Fcomps
		l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps

		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ftx0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_tx0 */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fty0 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_ty0 */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Ftx1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_tx1 */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fty1 = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_ty1 */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fdx = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_dx_min */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fdy = *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* l_dy_min */))
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_p = l_step_p
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_c = l_step_c
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_r = l_step_r
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fstep_l = l_step_l

		// allocation for components and number of components has already been calculated by opj_pi_create
		for compno = TOPJ_UINT32(0); compno < numcomps; compno++ {
			var l_res uintptr = (*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fresolutions
			l_encoding_value_ptr = *(*uintptr)(unsafe.Pointer(l_tmp_ptr + uintptr(compno)*8))

			(*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fdx = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdx
			(*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fdy = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fdy
			// resolutions have already been initialized
			for resno = TOPJ_UINT32(0); resno < (*Topj_pi_comp_t)(unsafe.Pointer(l_current_comp)).Fnumresolutions; resno++ {
				(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpdx = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
				(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpdy = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
				(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fpw = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
				(*Topj_pi_resolution_t)(unsafe.Pointer(l_res)).Fph = *(*TOPJ_UINT32)(unsafe.Pointer(libc.PostIncUintptr(&l_encoding_value_ptr, 4)))
				l_res += 16
			}
			l_current_comp += 24
			l_img_comp += 64
			l_tccp += 1080
		}

		// special treatment
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi - uintptr(1)*256)).Finclude
		(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Finclude_size = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi - uintptr(1)*256)).Finclude_size
		l_current_pi += 256
	}

	Xopj_free(tls, l_tmp_data)
	l_tmp_data = uintptr(00)
	Xopj_free(tls, l_tmp_ptr)
	l_tmp_ptr = uintptr(00)

	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(l_tcp + 5688))&0x4>>2)) != 0 && (int32((*Topj_cp_t)(unsafe.Pointer(p_cp)).Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_cp_t)(unsafe.Pointer(p_cp)).Frsiz) <= DOPJ_PROFILE_CINEMA_S4K || p_t2_mode == FINAL_PASS) {
		opj_pi_update_encode_poc_and_final(tls, p_cp, p_tile_no, *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_tx0 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_tx1 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_ty0 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_ty1 */)),
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* l_max_prec */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* l_max_res */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_dx_min */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* l_dy_min */)))
	} else {
		opj_pi_update_encode_not_poc(tls, p_cp, numcomps, p_tile_no, *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_tx0 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_tx1 */)),
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_ty0 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_ty1 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* l_max_prec */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* l_max_res */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_dx_min */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* l_dy_min */)))
	}

	return l_pi
}

var __func__251 = *(*[25]int8)(unsafe.Pointer(ts + 32388)) /* pi.c:1620:1 */

func Xopj_pi_create_encode(tls *libc.TLS, pi uintptr, cp uintptr, tileno TOPJ_UINT32, pino TOPJ_UINT32, tpnum TOPJ_UINT32, tppos TOPJ_INT32, t2_mode TJ2K_T2_MODE) { /* pi.c:1808:6: */
	var prog uintptr
	var i TOPJ_INT32
	var incr_top TOPJ_UINT32 = TOPJ_UINT32(1)
	var resetX TOPJ_UINT32 = TOPJ_UINT32(0)
	var tcps uintptr = (*Topj_cp_t)(unsafe.Pointer(cp)).Ftcps + uintptr(tileno)*5696
	var tcp uintptr = tcps + 424 + uintptr(pino)*148

	prog = Xopj_j2k_convert_progression_order(tls, (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprg)

	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Ffirst = 1
	(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprg = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprg

	if !(TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(cp + 120 + 20))&0x8>>3)) != 0 && (!(int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) <= DOPJ_PROFILE_CINEMA_S4K) && !(int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) >= DOPJ_PROFILE_IMF_2K && int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) <= DOPJ_PROFILE_IMF_8K_R|0x009b) && t2_mode == FINAL_PASS || int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) <= DOPJ_PROFILE_CINEMA_S4K || int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) >= DOPJ_PROFILE_IMF_2K && int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) <= DOPJ_PROFILE_IMF_8K_R|0x009b)) {
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FresS
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FresE
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FcompS
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FcompE
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FlayS
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FlayE
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FprcS
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FprcE
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtxS
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtyS
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtxE
		(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtyE
	} else {
		for i = tppos + 1; i < 4; i++ {
			switch int32(*(*TOPJ_CHAR)(unsafe.Pointer(prog + uintptr(i)))) {
			case 'R':
				(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FresS
				(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FresE
				break
				fallthrough
			case 'C':
				(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FcompS
				(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FcompE
				break
				fallthrough
			case 'L':
				(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FlayS
				(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FlayE
				break
				fallthrough
			case 'P':
				switch (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprg {
				case OPJ_LRCP:
					fallthrough
				case OPJ_RLCP:
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FprcS
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FprcE
					break
					fallthrough
				default:
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtxS
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtyS
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtxE
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtyE
					break
				}
				break
			}
		}

		if tpnum == TOPJ_UINT32(0) {
			for i = tppos; i >= 0; i-- {
				switch int32(*(*TOPJ_CHAR)(unsafe.Pointer(prog + uintptr(i)))) {
				case 'C':
					(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FcompS
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t + TOPJ_UINT32(1)
					*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 132)) += TOPJ_UINT32(1)
					break
					fallthrough
				case 'R':
					(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FresS
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t + TOPJ_UINT32(1)
					*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 128)) += TOPJ_UINT32(1)
					break
					fallthrough
				case 'L':
					(*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FlayS
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t + TOPJ_UINT32(1)
					*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 124)) += TOPJ_UINT32(1)
					break
					fallthrough
				case 'P':
					switch (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprg {
					case OPJ_LRCP:
						fallthrough
					case OPJ_RLCP:
						(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FprcS
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t + TOPJ_UINT32(1)
						*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 136)) += TOPJ_UINT32(1)
						break
						fallthrough
					default:
						(*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtxS
						(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtyS
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t + (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdx - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t%(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdx
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t + (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdy - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t%(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdy
						(*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1
						(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1
						break
					}
					break
				}
			}
			incr_top = TOPJ_UINT32(1)
		} else {
			for i = tppos; i >= 0; i-- {
				switch int32(*(*TOPJ_CHAR)(unsafe.Pointer(prog + uintptr(i)))) {
				case 'C':
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t - TOPJ_UINT32(1)
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t
					break
					fallthrough
				case 'R':
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t - TOPJ_UINT32(1)
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t
					break
					fallthrough
				case 'L':
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t - TOPJ_UINT32(1)
					(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t
					break
					fallthrough
				case 'P':
					switch (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprg {
					case OPJ_LRCP:
						fallthrough
					case OPJ_RLCP:
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t - TOPJ_UINT32(1)
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t
						break
						fallthrough
					default:
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdx - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t%(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdx
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdy - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t%(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdy
						(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t
						break
					}
					break
				}
				if incr_top == TOPJ_UINT32(1) {
					switch int32(*(*TOPJ_CHAR)(unsafe.Pointer(prog + uintptr(i)))) {
					case 'R':
						if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FresE {
							if opj_pi_check_next_level(tls, i-1, cp, tileno, pino, prog) != 0 {
								(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FresS
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t + TOPJ_UINT32(1)
								*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 128)) += TOPJ_UINT32(1)
								incr_top = TOPJ_UINT32(1)
							} else {
								incr_top = TOPJ_UINT32(0)
							}
						} else {
							(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t
							(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fresno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fres_t + TOPJ_UINT32(1)
							*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 128)) += TOPJ_UINT32(1)
							incr_top = TOPJ_UINT32(0)
						}
						break
						fallthrough
					case 'C':
						if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FcompE {
							if opj_pi_check_next_level(tls, i-1, cp, tileno, pino, prog) != 0 {
								(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FcompS
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t + TOPJ_UINT32(1)
								*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 132)) += TOPJ_UINT32(1)
								incr_top = TOPJ_UINT32(1)
							} else {
								incr_top = TOPJ_UINT32(0)
							}
						} else {
							(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t
							(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fcompno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fcomp_t + TOPJ_UINT32(1)
							*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 132)) += TOPJ_UINT32(1)
							incr_top = TOPJ_UINT32(0)
						}
						break
						fallthrough
					case 'L':
						if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FlayE {
							if opj_pi_check_next_level(tls, i-1, cp, tileno, pino, prog) != 0 {
								(*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FlayS
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t + TOPJ_UINT32(1)
								*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 124)) += TOPJ_UINT32(1)
								incr_top = TOPJ_UINT32(1)
							} else {
								incr_top = TOPJ_UINT32(0)
							}
						} else {
							(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t
							(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Flayno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Flay_t + TOPJ_UINT32(1)
							*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 124)) += TOPJ_UINT32(1)
							incr_top = TOPJ_UINT32(0)
						}
						break
						fallthrough
					case 'P':
						switch (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprg {
						case OPJ_LRCP:
							fallthrough
						case OPJ_RLCP:
							if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t == (*Topj_poc_t1)(unsafe.Pointer(tcp)).FprcE {
								if opj_pi_check_next_level(tls, i-1, cp, tileno, pino, prog) != 0 {
									(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FprcS
									(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t
									(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t + TOPJ_UINT32(1)
									*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 136)) += TOPJ_UINT32(1)
									incr_top = TOPJ_UINT32(1)
								} else {
									incr_top = TOPJ_UINT32(0)
								}
							} else {
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fprecno1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fprc_t + TOPJ_UINT32(1)
								*(*TOPJ_UINT32)(unsafe.Pointer(tcp + 136)) += TOPJ_UINT32(1)
								incr_top = TOPJ_UINT32(0)
							}
							break
							fallthrough
						default:
							if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t >= (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtxE {
								if (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t >= (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtyE {
									if opj_pi_check_next_level(tls, i-1, cp, tileno, pino, prog) != 0 {
										(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtyS
										(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t
										(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t + (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdy - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t%(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdy
										(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1
										incr_top = TOPJ_UINT32(1)
										resetX = TOPJ_UINT32(1)
									} else {
										incr_top = TOPJ_UINT32(0)
										resetX = TOPJ_UINT32(0)
									}
								} else {
									(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t
									(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t + (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdy - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t%(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdy
									(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fty0_t = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Fty1
									incr_top = TOPJ_UINT32(0)
									resetX = TOPJ_UINT32(1)
								}
								if resetX == TOPJ_UINT32(1) {
									(*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t = (*Topj_poc_t1)(unsafe.Pointer(tcp)).FtxS
									(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t
									(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t + (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdx - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t%(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdx
									(*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1
								}
							} else {
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx0 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t
								(*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1 = (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t + (*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdx - (*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t%(*Topj_poc_t1)(unsafe.Pointer(tcp)).Fdx
								(*Topj_poc_t1)(unsafe.Pointer(tcp)).Ftx0_t = (*Topj_pi_iterator_t1)(unsafe.Pointer(pi + uintptr(pino)*256)).Fpoc.Ftx1
								incr_top = TOPJ_UINT32(0)
							}
							break
						}
						break
					}
				}
			}
		}
	}
}

func Xopj_pi_destroy(tls *libc.TLS, p_pi uintptr, p_nb_elements TOPJ_UINT32) { /* pi.c:2071:6: */
	var compno TOPJ_UINT32
	var pino TOPJ_UINT32
	var l_current_pi uintptr = p_pi
	if p_pi != 0 {
		if (*Topj_pi_iterator_t1)(unsafe.Pointer(p_pi)).Finclude != 0 {
			Xopj_free(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(p_pi)).Finclude)
			(*Topj_pi_iterator_t1)(unsafe.Pointer(p_pi)).Finclude = uintptr(00)
		}
		for pino = TOPJ_UINT32(0); pino < p_nb_elements; pino++ {
			if (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps != 0 {
				var l_current_component uintptr = (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps
				for compno = TOPJ_UINT32(0); compno < (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fnumcomps; compno++ {
					if (*Topj_pi_comp_t)(unsafe.Pointer(l_current_component)).Fresolutions != 0 {
						Xopj_free(tls, (*Topj_pi_comp_t)(unsafe.Pointer(l_current_component)).Fresolutions)
						(*Topj_pi_comp_t)(unsafe.Pointer(l_current_component)).Fresolutions = uintptr(00)
					}

					l_current_component += 24
				}
				Xopj_free(tls, (*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps)
				(*Topj_pi_iterator_t1)(unsafe.Pointer(l_current_pi)).Fcomps = uintptr(0)
			}
			l_current_pi += 256
		}
		Xopj_free(tls, p_pi)
	}
}

func Xopj_pi_update_encoding_parameters(tls *libc.TLS, p_image uintptr, p_cp uintptr, p_tile_no TOPJ_UINT32) { /* pi.c:2103:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// encoding parameters to set
	// var l_max_res TOPJ_UINT32 at bp+28, 4

	// var l_max_prec TOPJ_UINT32 at bp+24, 4

	// var l_tx0 TOPJ_UINT32 at bp, 4

	// var l_tx1 TOPJ_UINT32 at bp+4, 4

	// var l_ty0 TOPJ_UINT32 at bp+8, 4

	// var l_ty1 TOPJ_UINT32 at bp+12, 4

	// var l_dx_min TOPJ_UINT32 at bp+16, 4

	// var l_dy_min TOPJ_UINT32 at bp+20, 4

	// pointers
	var l_tcp uintptr = uintptr(00)

	// preconditions
	if p_cp != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+6525, ts+31979, uint32(2117), uintptr(unsafe.Pointer(&__func__252)))
	}
	if p_image != uintptr(00) {
	} else {
		libc.X__assert_fail(tls, ts+32003, ts+31979, uint32(2118), uintptr(unsafe.Pointer(&__func__252)))
	}
	if p_tile_no < (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftw*(*Topj_cp_t)(unsafe.Pointer(p_cp)).Fth {
	} else {
		libc.X__assert_fail(tls, ts+32305, ts+31979, uint32(2119), uintptr(unsafe.Pointer(&__func__252)))
	}

	l_tcp = (*Topj_cp_t)(unsafe.Pointer(p_cp)).Ftcps + uintptr(p_tile_no)*5696

	// get encoding parameters
	opj_get_encoding_parameters(tls, p_image, p_cp, p_tile_no, bp, bp+4, bp+8,
		bp+12, bp+16, bp+20, bp+24, bp+28)

	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(l_tcp + 5688))&0x4>>2)) != 0 {
		opj_pi_update_encode_poc_and_final(tls, p_cp, p_tile_no, *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_tx0 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_tx1 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_ty0 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_ty1 */)),
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* l_max_prec */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* l_max_res */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_dx_min */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* l_dy_min */)))
	} else {
		opj_pi_update_encode_not_poc(tls, p_cp, (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps, p_tile_no, *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_tx0 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_tx1 */)),
			*(*TOPJ_UINT32)(unsafe.Pointer(bp + 8 /* l_ty0 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 12 /* l_ty1 */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 24 /* l_max_prec */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 28 /* l_max_res */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 16 /* l_dx_min */)), *(*TOPJ_UINT32)(unsafe.Pointer(bp + 20 /* l_dy_min */)))
	}
}

var __func__252 = *(*[34]int8)(unsafe.Pointer(ts + 32413)) /* pi.c:2106:1 */

func Xopj_pi_next(tls *libc.TLS, pi uintptr) TOPJ_BOOL { /* pi.c:2136:10: */
	switch (*Topj_pi_iterator_t1)(unsafe.Pointer(pi)).Fpoc.Fprg {
	case OPJ_LRCP:
		return opj_pi_next_lrcp(tls, pi)
	case OPJ_RLCP:
		return opj_pi_next_rlcp(tls, pi)
	case OPJ_RPCL:
		return opj_pi_next_rpcl(tls, pi)
	case OPJ_PCRL:
		return opj_pi_next_pcrl(tls, pi)
	case OPJ_CPRL:
		return opj_pi_next_cprl(tls, pi)
	case OPJ_PROG_UNKNOWN:
		return DOPJ_FALSE
	}

	return DOPJ_FALSE
}

//
// ==========================================================
//    codec typedef definitions
// ==========================================================

// *
// Progression order changes
//
type Topj_poc_t2 = struct {
	Fresno0      TOPJ_UINT32
	Fcompno0     TOPJ_UINT32
	Flayno1      TOPJ_UINT32
	Fresno1      TOPJ_UINT32
	Fcompno1     TOPJ_UINT32
	Flayno0      TOPJ_UINT32
	Fprecno0     TOPJ_UINT32
	Fprecno1     TOPJ_UINT32
	Fprg1        TOPJ_PROG_ORDER
	Fprg         TOPJ_PROG_ORDER
	Fprogorder   [5]TOPJ_CHAR
	F__ccgo_pad1 [3]byte
	Ftile        TOPJ_UINT32
	Ftx0         TOPJ_INT32
	Ftx1         TOPJ_INT32
	Fty0         TOPJ_INT32
	Fty1         TOPJ_INT32
	FlayS        TOPJ_UINT32
	FresS        TOPJ_UINT32
	FcompS       TOPJ_UINT32
	FprcS        TOPJ_UINT32
	FlayE        TOPJ_UINT32
	FresE        TOPJ_UINT32
	FcompE       TOPJ_UINT32
	FprcE        TOPJ_UINT32
	FtxS         TOPJ_UINT32
	FtxE         TOPJ_UINT32
	FtyS         TOPJ_UINT32
	FtyE         TOPJ_UINT32
	Fdx          TOPJ_UINT32
	Fdy          TOPJ_UINT32
	Flay_t       TOPJ_UINT32
	Fres_t       TOPJ_UINT32
	Fcomp_t      TOPJ_UINT32
	Fprc_t       TOPJ_UINT32
	Ftx0_t       TOPJ_UINT32
	Fty0_t       TOPJ_UINT32
} /* openjpeg.h:388:3 */

//*
// Packet iterator
type Topj_pi_iterator_t2 = struct {
	Ftp_on        TOPJ_BYTE
	F__ccgo_pad1  [7]byte
	Finclude      uintptr
	Finclude_size TOPJ_UINT32
	Fstep_l       TOPJ_UINT32
	Fstep_r       TOPJ_UINT32
	Fstep_c       TOPJ_UINT32
	Fstep_p       TOPJ_UINT32
	Fcompno       TOPJ_UINT32
	Fresno        TOPJ_UINT32
	Fprecno       TOPJ_UINT32
	Flayno        TOPJ_UINT32
	Ffirst        TOPJ_BOOL
	Fpoc          Topj_poc_t2
	Fnumcomps     TOPJ_UINT32
	Fcomps        uintptr
	Ftx0          TOPJ_UINT32
	Fty0          TOPJ_UINT32
	Ftx1          TOPJ_UINT32
	Fty1          TOPJ_UINT32
	Fx            TOPJ_UINT32
	Fy            TOPJ_UINT32
	Fdx           TOPJ_UINT32
	Fdy           TOPJ_UINT32
	Fmanager      uintptr
} /* pi.h:112:3 */

// -----------------------------------------------------------------------
//@}

//@}

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2017, IntoPix SA <contact@intopix.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// The copyright in this software is being made available under the 2-clauses
// BSD License, included below. This software may be subject to other third
// party and contributor rights, including patent rights, and no such rights
// are granted under this license.
//
// Copyright (c) 2005, Herve Drolon, FreeImage Team
// Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR
// Copyright (c) 2012, CS Systemes d'Information, France
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//*
// @file sparse_array.h
// @brief Sparse array management
//
// The functions in this file manage sparse arrays. Sparse arrays are arrays with
// potential big dimensions, but with very few samples actually set. Such sparse
// arrays require allocating a low amount of memory, by just allocating memory
// for blocks of the array that are set. The minimum memory allocation unit is a
// a block. There is a trade-off to pick up an appropriate dimension for blocks.
// If it is too big, and pixels set are far from each other, too much memory will
// be used. If blocks are too small, the book-keeping costs of blocks will raise.

//* @defgroup SPARSE_ARRAY SPARSE ARRAYS - Sparse arrays
//@{

//* Opaque type for sparse arrays that contain int32 values
type Topj_sparse_array_int32_t = Sopj_sparse_array_int32 /* sparse_array.h:53:39 */

func Xopj_sparse_array_int32_create(tls *libc.TLS, width TOPJ_UINT32, height TOPJ_UINT32, block_width TOPJ_UINT32, block_height TOPJ_UINT32) uintptr { /* sparse_array.c:45:25: */
	var sa uintptr

	if width == TOPJ_UINT32(0) || height == TOPJ_UINT32(0) || block_width == TOPJ_UINT32(0) || block_height == TOPJ_UINT32(0) {
		return uintptr(0)
	}
	if uint32(block_width) > uint32(libc.CplUint32(0)/block_height)/uint32(unsafe.Sizeof(TOPJ_INT32(0))) {
		return uintptr(0)
	}

	sa = Xopj_calloc(tls, uint32(1),
		uint32(unsafe.Sizeof(Topj_sparse_array_int32_t{})))
	(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fwidth = width
	(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fheight = height
	(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_width = block_width
	(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_height = block_height
	(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_hor = opj_uint_ceildiv(tls, width, block_width)
	(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_ver = opj_uint_ceildiv(tls, height, block_height)
	if (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_hor > libc.CplUint32(0)/(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_ver {
		Xopj_free(tls, sa)
		return uintptr(0)
	}
	(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fdata_blocks = Xopj_calloc(tls, uint32(unsafe.Sizeof(uintptr(0))),
		Tsize_t((*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_hor)*Tsize_t((*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_ver))
	if (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fdata_blocks == uintptr(0) {
		Xopj_free(tls, sa)
		return uintptr(0)
	}

	return sa
}

func Xopj_sparse_array_int32_free(tls *libc.TLS, sa uintptr) { /* sparse_array.c:81:6: */
	if sa != 0 {
		var i TOPJ_UINT32
		for i = TOPJ_UINT32(0); i < (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_hor*(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_ver; i++ {
			if *(*uintptr)(unsafe.Pointer((*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fdata_blocks + uintptr(i)*8)) != 0 {
				Xopj_free(tls, *(*uintptr)(unsafe.Pointer((*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fdata_blocks + uintptr(i)*8)))
			}
		}
		Xopj_free(tls, (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fdata_blocks)
		Xopj_free(tls, sa)
	}
}

func Xopj_sparse_array_is_region_valid(tls *libc.TLS, sa uintptr, x0 TOPJ_UINT32, y0 TOPJ_UINT32, x1 TOPJ_UINT32, y1 TOPJ_UINT32) TOPJ_BOOL { /* sparse_array.c:95:10: */
	return libc.BoolInt32(!(x0 >= (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fwidth || x1 <= x0 || x1 > (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fwidth || y0 >= (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fheight || y1 <= y0 || y1 > (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fheight))
}

func opj_sparse_array_int32_read_or_write(tls *libc.TLS, sa uintptr, x0 TOPJ_UINT32, y0 TOPJ_UINT32, x1 TOPJ_UINT32, y1 TOPJ_UINT32, buf uintptr, buf_col_stride TOPJ_UINT32, buf_line_stride TOPJ_UINT32, forgiving TOPJ_BOOL, is_read_op TOPJ_BOOL) TOPJ_BOOL { /* sparse_array.c:105:17: */
	var y TOPJ_UINT32
	var block_y TOPJ_UINT32
	var y_incr TOPJ_UINT32 = TOPJ_UINT32(0)
	var block_width TOPJ_UINT32 = (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_width

	if !(Xopj_sparse_array_is_region_valid(tls, sa, x0, y0, x1, y1) != 0) {
		return forgiving
	}

	block_y = y0 / (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_height
	y = y0
__1:
	if !(y < y1) {
		goto __3
	}
	{
		var x TOPJ_UINT32
		var block_x TOPJ_UINT32
		var x_incr TOPJ_UINT32 = TOPJ_UINT32(0)
		_ = x_incr
		var block_y_offset TOPJ_UINT32
		if y == y0 {
			y_incr = (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_height - y0%(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_height
		} else {
			y_incr = (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_height
		}
		block_y_offset = (*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_height - y_incr
		y_incr = opj_uint_min(tls, y_incr, y1-y)
		block_x = x0 / block_width
		x = x0
	__4:
		if !(x < x1) {
			goto __6
		}
		{
			var j TOPJ_UINT32
			var block_x_offset TOPJ_UINT32
			var src_block uintptr
			if x == x0 {
				x_incr = block_width - x0%block_width
			} else {
				x_incr = block_width
			}
			block_x_offset = block_width - x_incr
			x_incr = opj_uint_min(tls, x_incr, x1-x)
			src_block = *(*uintptr)(unsafe.Pointer((*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fdata_blocks + uintptr(block_y*(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_hor+block_x)*8))
			if is_read_op != 0 {
				if src_block == uintptr(0) {
					if buf_col_stride == TOPJ_UINT32(1) {
						var dest_ptr uintptr = buf + uintptr(TOPJ_SIZE_T(y-y0)*TOPJ_SIZE_T(buf_line_stride))*4 + uintptr((x-x0)*buf_col_stride)*4
						for j = TOPJ_UINT32(0); j < y_incr; j++ {
							libc.Xmemset(tls, dest_ptr, 0, uint32(unsafe.Sizeof(TOPJ_INT32(0)))*uint32(x_incr))
							dest_ptr += 4 * uintptr(buf_line_stride)
						}
					} else {
						var dest_ptr uintptr = buf + uintptr(TOPJ_SIZE_T(y-y0)*TOPJ_SIZE_T(buf_line_stride))*4 + uintptr((x-x0)*buf_col_stride)*4
						for j = TOPJ_UINT32(0); j < y_incr; j++ {
							var k TOPJ_UINT32
							for k = TOPJ_UINT32(0); k < x_incr; k++ {
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k*buf_col_stride)*4)) = 0
							}
							dest_ptr += 4 * uintptr(buf_line_stride)
						}
					}
				} else {
					var src_ptr uintptr = src_block + uintptr(TOPJ_SIZE_T(block_y_offset)*TOPJ_SIZE_T(block_width))*4 + uintptr(block_x_offset)*4
					if buf_col_stride == TOPJ_UINT32(1) {
						var dest_ptr uintptr = buf + uintptr(TOPJ_SIZE_T(y-y0)*TOPJ_SIZE_T(buf_line_stride))*4 +
							uintptr((x-x0)*buf_col_stride)*4
						if x_incr == TOPJ_UINT32(4) {
							// Same code as general branch, but the compiler
							// can have an efficient memcpy()
							_ = x_incr // trick to silent cppcheck duplicateBranch warning
							for j = TOPJ_UINT32(0); j < y_incr; j++ {
								libc.Xmemcpy(tls, dest_ptr, src_ptr, uint32(unsafe.Sizeof(TOPJ_INT32(0)))*uint32(x_incr))
								dest_ptr += 4 * uintptr(buf_line_stride)
								src_ptr += 4 * uintptr(block_width)
							}
						} else {
							for j = TOPJ_UINT32(0); j < y_incr; j++ {
								libc.Xmemcpy(tls, dest_ptr, src_ptr, uint32(unsafe.Sizeof(TOPJ_INT32(0)))*uint32(x_incr))
								dest_ptr += 4 * uintptr(buf_line_stride)
								src_ptr += 4 * uintptr(block_width)
							}
						}
					} else {
						var dest_ptr uintptr = buf + uintptr(TOPJ_SIZE_T(y-y0)*TOPJ_SIZE_T(buf_line_stride))*4 +
							uintptr((x-x0)*buf_col_stride)*4
						if x_incr == TOPJ_UINT32(1) {
							for j = TOPJ_UINT32(0); j < y_incr; j++ {
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr))
								dest_ptr += 4 * uintptr(buf_line_stride)
								src_ptr += 4 * uintptr(block_width)
							}
						} else if y_incr == TOPJ_UINT32(1) && buf_col_stride == TOPJ_UINT32(2) {
							var k TOPJ_UINT32
							for k = TOPJ_UINT32(0); k < x_incr&libc.CplUint32(3); k = k + TOPJ_UINT32(4) {
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k)*4))
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr((k+TOPJ_UINT32(1))*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k+TOPJ_UINT32(1))*4))
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr((k+TOPJ_UINT32(2))*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k+TOPJ_UINT32(2))*4))
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr((k+TOPJ_UINT32(3))*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k+TOPJ_UINT32(3))*4))
							}
							for ; k < x_incr; k++ {
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k)*4))
							}
						} else if x_incr >= TOPJ_UINT32(8) && buf_col_stride == TOPJ_UINT32(8) {
							for j = TOPJ_UINT32(0); j < y_incr; j++ {
								var k TOPJ_UINT32
								for k = TOPJ_UINT32(0); k < x_incr&libc.CplUint32(3); k = k + TOPJ_UINT32(4) {
									*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k)*4))
									*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr((k+TOPJ_UINT32(1))*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k+TOPJ_UINT32(1))*4))
									*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr((k+TOPJ_UINT32(2))*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k+TOPJ_UINT32(2))*4))
									*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr((k+TOPJ_UINT32(3))*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k+TOPJ_UINT32(3))*4))
								}
								for ; k < x_incr; k++ {
									*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k)*4))
								}
								dest_ptr += 4 * uintptr(buf_line_stride)
								src_ptr += 4 * uintptr(block_width)
							}
						} else {
							// General case
							for j = TOPJ_UINT32(0); j < y_incr; j++ {
								var k TOPJ_UINT32
								for k = TOPJ_UINT32(0); k < x_incr; k++ {
									*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k*buf_col_stride)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k)*4))
								}
								dest_ptr += 4 * uintptr(buf_line_stride)
								src_ptr += 4 * uintptr(block_width)
							}
						}
					}
				}
			} else {
				if src_block == uintptr(0) {
					src_block = Xopj_calloc(tls, uint32(1),
						Tsize_t((*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_width)*Tsize_t((*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_height)*Tsize_t(unsafe.Sizeof(TOPJ_INT32(0))))
					if src_block == uintptr(0) {
						return DOPJ_FALSE
					}
					*(*uintptr)(unsafe.Pointer((*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fdata_blocks + uintptr(block_y*(*Topj_sparse_array_int32_t)(unsafe.Pointer(sa)).Fblock_count_hor+block_x)*8)) = src_block
				}

				if buf_col_stride == TOPJ_UINT32(1) {
					var dest_ptr uintptr = src_block + uintptr(TOPJ_SIZE_T(block_y_offset)*TOPJ_SIZE_T(block_width))*4 + uintptr(block_x_offset)*4
					var src_ptr uintptr = buf + uintptr(TOPJ_SIZE_T(y-y0)*TOPJ_SIZE_T(buf_line_stride))*4 + uintptr((x-x0)*buf_col_stride)*4
					if x_incr == TOPJ_UINT32(4) {
						// Same code as general branch, but the compiler
						// can have an efficient memcpy()
						_ = x_incr // trick to silent cppcheck duplicateBranch warning
						for j = TOPJ_UINT32(0); j < y_incr; j++ {
							libc.Xmemcpy(tls, dest_ptr, src_ptr, uint32(unsafe.Sizeof(TOPJ_INT32(0)))*uint32(x_incr))
							dest_ptr += 4 * uintptr(block_width)
							src_ptr += 4 * uintptr(buf_line_stride)
						}
					} else {
						for j = TOPJ_UINT32(0); j < y_incr; j++ {
							libc.Xmemcpy(tls, dest_ptr, src_ptr, uint32(unsafe.Sizeof(TOPJ_INT32(0)))*uint32(x_incr))
							dest_ptr += 4 * uintptr(block_width)
							src_ptr += 4 * uintptr(buf_line_stride)
						}
					}
				} else {
					var dest_ptr uintptr = src_block + uintptr(TOPJ_SIZE_T(block_y_offset)*TOPJ_SIZE_T(block_width))*4 + uintptr(block_x_offset)*4
					var src_ptr uintptr = buf + uintptr(TOPJ_SIZE_T(y-y0)*TOPJ_SIZE_T(buf_line_stride))*4 + uintptr((x-x0)*buf_col_stride)*4
					if x_incr == TOPJ_UINT32(1) {
						for j = TOPJ_UINT32(0); j < y_incr; j++ {
							*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr))
							src_ptr += 4 * uintptr(buf_line_stride)
							dest_ptr += 4 * uintptr(block_width)
						}
					} else if x_incr >= TOPJ_UINT32(8) && buf_col_stride == TOPJ_UINT32(8) {
						for j = TOPJ_UINT32(0); j < y_incr; j++ {
							var k TOPJ_UINT32
							for k = TOPJ_UINT32(0); k < x_incr&libc.CplUint32(3); k = k + TOPJ_UINT32(4) {
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k*buf_col_stride)*4))
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k+TOPJ_UINT32(1))*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr((k+TOPJ_UINT32(1))*buf_col_stride)*4))
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k+TOPJ_UINT32(2))*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr((k+TOPJ_UINT32(2))*buf_col_stride)*4))
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k+TOPJ_UINT32(3))*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr((k+TOPJ_UINT32(3))*buf_col_stride)*4))
							}
							for ; k < x_incr; k++ {
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k*buf_col_stride)*4))
							}
							src_ptr += 4 * uintptr(buf_line_stride)
							dest_ptr += 4 * uintptr(block_width)
						}
					} else {
						// General case
						for j = TOPJ_UINT32(0); j < y_incr; j++ {
							var k TOPJ_UINT32
							for k = TOPJ_UINT32(0); k < x_incr; k++ {
								*(*TOPJ_INT32)(unsafe.Pointer(dest_ptr + uintptr(k)*4)) = *(*TOPJ_INT32)(unsafe.Pointer(src_ptr + uintptr(k*buf_col_stride)*4))
							}
							src_ptr += 4 * uintptr(buf_line_stride)
							dest_ptr += 4 * uintptr(block_width)
						}
					}
				}
			}

		}
		goto __5
	__5:
		block_x++
		x = x + x_incr
		goto __4
		goto __6
	__6:
	}
	goto __2
__2:
	block_y++
	y = y + y_incr
	goto __1
	goto __3
__3:
	;

	return DOPJ_TRUE
}

func Xopj_sparse_array_int32_read(tls *libc.TLS, sa uintptr, x0 TOPJ_UINT32, y0 TOPJ_UINT32, x1 TOPJ_UINT32, y1 TOPJ_UINT32, dest uintptr, dest_col_stride TOPJ_UINT32, dest_line_stride TOPJ_UINT32, forgiving TOPJ_BOOL) TOPJ_BOOL { /* sparse_array.c:311:10: */
	return opj_sparse_array_int32_read_or_write(tls,
		sa, x0, y0, x1, y1,
		dest,
		dest_col_stride,
		dest_line_stride,
		forgiving,
		DOPJ_TRUE)
}

func Xopj_sparse_array_int32_write(tls *libc.TLS, sa uintptr, x0 TOPJ_UINT32, y0 TOPJ_UINT32, x1 TOPJ_UINT32, y1 TOPJ_UINT32, src uintptr, src_col_stride TOPJ_UINT32, src_line_stride TOPJ_UINT32, forgiving TOPJ_BOOL) TOPJ_BOOL { /* sparse_array.c:330:10: */
	return opj_sparse_array_int32_read_or_write(tls, sa, x0, y0, x1, y1,
		src,
		src_col_stride,
		src_line_stride,
		forgiving,
		DOPJ_FALSE)
}

//#ifdef __SSE__
//#include <xmmintrin.h>
//#endif
//#ifdef __SSE2__
//#include <emmintrin.h>
//#endif

// This file was automatically generated by t1_generate_luts.c

var lut_ctxno_zc = [2048]TOPJ_BYTE{
	TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(2), TOPJ_BYTE(2), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(6), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(3), TOPJ_BYTE(4), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7),
	TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(0), TOPJ_BYTE(3), TOPJ_BYTE(1), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(4), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(0), TOPJ_BYTE(3), TOPJ_BYTE(1), TOPJ_BYTE(4), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(4), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7),
	TOPJ_BYTE(1), TOPJ_BYTE(4), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(4), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7),
	TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8),
	TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8),
	TOPJ_BYTE(1), TOPJ_BYTE(4), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(1), TOPJ_BYTE(4), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7),
	TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(2), TOPJ_BYTE(5), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7),
	TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8),
	TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8),
	TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(3), TOPJ_BYTE(6), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8),
	TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8),
	TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(6), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(4), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8),
	TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(5), TOPJ_BYTE(7), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8),
	TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
	TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(7), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8), TOPJ_BYTE(8),
} /* t1_luts.h:3:23 */

var lut_ctxno_sc = [256]TOPJ_BYTE{
	TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb),
	TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd),
	TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0x9), TOPJ_BYTE(0xd), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0xc), TOPJ_BYTE(0xa), TOPJ_BYTE(0xb),
	TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0x9), TOPJ_BYTE(0xb), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0xc), TOPJ_BYTE(0xa), TOPJ_BYTE(0xd),
	TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb),
	TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd),
	TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0x9), TOPJ_BYTE(0xd), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0xc), TOPJ_BYTE(0xa), TOPJ_BYTE(0xb),
	TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0x9), TOPJ_BYTE(0xb), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0xc), TOPJ_BYTE(0xa), TOPJ_BYTE(0xd),
	TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb),
	TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc),
	TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xa), TOPJ_BYTE(0xd), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xb), TOPJ_BYTE(0xa), TOPJ_BYTE(0xb),
	TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xa), TOPJ_BYTE(0xc), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xb), TOPJ_BYTE(0x9), TOPJ_BYTE(0xc),
	TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0x9), TOPJ_BYTE(0x9), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc),
	TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd),
	TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xc), TOPJ_BYTE(0xc), TOPJ_BYTE(0xb), TOPJ_BYTE(0xa), TOPJ_BYTE(0xc), TOPJ_BYTE(0x9), TOPJ_BYTE(0xa), TOPJ_BYTE(0xd), TOPJ_BYTE(0x9), TOPJ_BYTE(0xc),
	TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xb), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xd), TOPJ_BYTE(0xb), TOPJ_BYTE(0xa), TOPJ_BYTE(0xb), TOPJ_BYTE(0xa), TOPJ_BYTE(0xa), TOPJ_BYTE(0xd), TOPJ_BYTE(0xa), TOPJ_BYTE(0xd),
} /* t1_luts.h:70:23 */

var lut_spb = [256]TOPJ_BYTE{
	TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1),
	TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1),
	TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1),
	TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1),
	TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1),
	TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1),
	TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1),
	TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(0), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1), TOPJ_BYTE(1),
} /* t1_luts.h:89:23 */

var lut_nmsedec_sig = [128]TOPJ_INT16{
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0180), int16(0x0300), int16(0x0480), int16(0x0600), int16(0x0780), int16(0x0900), int16(0x0a80),
	int16(0x0c00), int16(0x0d80), int16(0x0f00), int16(0x1080), int16(0x1200), int16(0x1380), int16(0x1500), int16(0x1680),
	int16(0x1800), int16(0x1980), int16(0x1b00), int16(0x1c80), int16(0x1e00), int16(0x1f80), int16(0x2100), int16(0x2280),
	int16(0x2400), int16(0x2580), int16(0x2700), int16(0x2880), int16(0x2a00), int16(0x2b80), int16(0x2d00), int16(0x2e80),
	int16(0x3000), int16(0x3180), int16(0x3300), int16(0x3480), int16(0x3600), int16(0x3780), int16(0x3900), int16(0x3a80),
	int16(0x3c00), int16(0x3d80), int16(0x3f00), int16(0x4080), int16(0x4200), int16(0x4380), int16(0x4500), int16(0x4680),
	int16(0x4800), int16(0x4980), int16(0x4b00), int16(0x4c80), int16(0x4e00), int16(0x4f80), int16(0x5100), int16(0x5280),
	int16(0x5400), int16(0x5580), int16(0x5700), int16(0x5880), int16(0x5a00), int16(0x5b80), int16(0x5d00), int16(0x5e80),
	int16(0x6000), int16(0x6180), int16(0x6300), int16(0x6480), int16(0x6600), int16(0x6780), int16(0x6900), int16(0x6a80),
	int16(0x6c00), int16(0x6d80), int16(0x6f00), int16(0x7080), int16(0x7200), int16(0x7380), int16(0x7500), int16(0x7680),
} /* t1_luts.h:100:24 */

var lut_nmsedec_sig0 = [128]TOPJ_INT16{
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0080), int16(0x0080),
	int16(0x0080), int16(0x0080), int16(0x0100), int16(0x0100), int16(0x0100), int16(0x0180), int16(0x0180), int16(0x0200),
	int16(0x0200), int16(0x0280), int16(0x0280), int16(0x0300), int16(0x0300), int16(0x0380), int16(0x0400), int16(0x0400),
	int16(0x0480), int16(0x0500), int16(0x0580), int16(0x0580), int16(0x0600), int16(0x0680), int16(0x0700), int16(0x0780),
	int16(0x0800), int16(0x0880), int16(0x0900), int16(0x0980), int16(0x0a00), int16(0x0a80), int16(0x0b80), int16(0x0c00),
	int16(0x0c80), int16(0x0d00), int16(0x0e00), int16(0x0e80), int16(0x0f00), int16(0x1000), int16(0x1080), int16(0x1180),
	int16(0x1200), int16(0x1300), int16(0x1380), int16(0x1480), int16(0x1500), int16(0x1600), int16(0x1700), int16(0x1780),
	int16(0x1880), int16(0x1980), int16(0x1a80), int16(0x1b00), int16(0x1c00), int16(0x1d00), int16(0x1e00), int16(0x1f00),
	int16(0x2000), int16(0x2100), int16(0x2200), int16(0x2300), int16(0x2400), int16(0x2500), int16(0x2680), int16(0x2780),
	int16(0x2880), int16(0x2980), int16(0x2b00), int16(0x2c00), int16(0x2d00), int16(0x2e80), int16(0x2f80), int16(0x3100),
	int16(0x3200), int16(0x3380), int16(0x3480), int16(0x3600), int16(0x3700), int16(0x3880), int16(0x3a00), int16(0x3b00),
	int16(0x3c80), int16(0x3e00), int16(0x3f80), int16(0x4080), int16(0x4200), int16(0x4380), int16(0x4500), int16(0x4680),
	int16(0x4800), int16(0x4980), int16(0x4b00), int16(0x4c80), int16(0x4e00), int16(0x4f80), int16(0x5180), int16(0x5300),
	int16(0x5480), int16(0x5600), int16(0x5800), int16(0x5980), int16(0x5b00), int16(0x5d00), int16(0x5e80), int16(0x6080),
	int16(0x6200), int16(0x6400), int16(0x6580), int16(0x6780), int16(0x6900), int16(0x6b00), int16(0x6d00), int16(0x6e80),
	int16(0x7080), int16(0x7280), int16(0x7480), int16(0x7600), int16(0x7800), int16(0x7a00), int16(0x7c00), int16(0x7e00),
} /* t1_luts.h:119:24 */

var lut_nmsedec_ref = [128]TOPJ_INT16{
	int16(0x1800), int16(0x1780), int16(0x1700), int16(0x1680), int16(0x1600), int16(0x1580), int16(0x1500), int16(0x1480),
	int16(0x1400), int16(0x1380), int16(0x1300), int16(0x1280), int16(0x1200), int16(0x1180), int16(0x1100), int16(0x1080),
	int16(0x1000), int16(0x0f80), int16(0x0f00), int16(0x0e80), int16(0x0e00), int16(0x0d80), int16(0x0d00), int16(0x0c80),
	int16(0x0c00), int16(0x0b80), int16(0x0b00), int16(0x0a80), int16(0x0a00), int16(0x0980), int16(0x0900), int16(0x0880),
	int16(0x0800), int16(0x0780), int16(0x0700), int16(0x0680), int16(0x0600), int16(0x0580), int16(0x0500), int16(0x0480),
	int16(0x0400), int16(0x0380), int16(0x0300), int16(0x0280), int16(0x0200), int16(0x0180), int16(0x0100), int16(0x0080),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0080), int16(0x0100), int16(0x0180), int16(0x0200), int16(0x0280), int16(0x0300), int16(0x0380),
	int16(0x0400), int16(0x0480), int16(0x0500), int16(0x0580), int16(0x0600), int16(0x0680), int16(0x0700), int16(0x0780),
	int16(0x0800), int16(0x0880), int16(0x0900), int16(0x0980), int16(0x0a00), int16(0x0a80), int16(0x0b00), int16(0x0b80),
	int16(0x0c00), int16(0x0c80), int16(0x0d00), int16(0x0d80), int16(0x0e00), int16(0x0e80), int16(0x0f00), int16(0x0f80),
	int16(0x1000), int16(0x1080), int16(0x1100), int16(0x1180), int16(0x1200), int16(0x1280), int16(0x1300), int16(0x1380),
	int16(0x1400), int16(0x1480), int16(0x1500), int16(0x1580), int16(0x1600), int16(0x1680), int16(0x1700), int16(0x1780),
} /* t1_luts.h:138:24 */

var lut_nmsedec_ref0 = [128]TOPJ_INT16{
	int16(0x2000), int16(0x1f00), int16(0x1e00), int16(0x1d00), int16(0x1c00), int16(0x1b00), int16(0x1a80), int16(0x1980),
	int16(0x1880), int16(0x1780), int16(0x1700), int16(0x1600), int16(0x1500), int16(0x1480), int16(0x1380), int16(0x1300),
	int16(0x1200), int16(0x1180), int16(0x1080), int16(0x1000), int16(0x0f00), int16(0x0e80), int16(0x0e00), int16(0x0d00),
	int16(0x0c80), int16(0x0c00), int16(0x0b80), int16(0x0a80), int16(0x0a00), int16(0x0980), int16(0x0900), int16(0x0880),
	int16(0x0800), int16(0x0780), int16(0x0700), int16(0x0680), int16(0x0600), int16(0x0580), int16(0x0580), int16(0x0500),
	int16(0x0480), int16(0x0400), int16(0x0400), int16(0x0380), int16(0x0300), int16(0x0300), int16(0x0280), int16(0x0280),
	int16(0x0200), int16(0x0200), int16(0x0180), int16(0x0180), int16(0x0100), int16(0x0100), int16(0x0100), int16(0x0080),
	int16(0x0080), int16(0x0080), int16(0x0080), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000),
	int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0000), int16(0x0080), int16(0x0080),
	int16(0x0080), int16(0x0080), int16(0x0100), int16(0x0100), int16(0x0100), int16(0x0180), int16(0x0180), int16(0x0200),
	int16(0x0200), int16(0x0280), int16(0x0280), int16(0x0300), int16(0x0300), int16(0x0380), int16(0x0400), int16(0x0400),
	int16(0x0480), int16(0x0500), int16(0x0580), int16(0x0580), int16(0x0600), int16(0x0680), int16(0x0700), int16(0x0780),
	int16(0x0800), int16(0x0880), int16(0x0900), int16(0x0980), int16(0x0a00), int16(0x0a80), int16(0x0b80), int16(0x0c00),
	int16(0x0c80), int16(0x0d00), int16(0x0e00), int16(0x0e80), int16(0x0f00), int16(0x1000), int16(0x1080), int16(0x1180),
	int16(0x1200), int16(0x1300), int16(0x1380), int16(0x1480), int16(0x1500), int16(0x1600), int16(0x1700), int16(0x1780),
	int16(0x1880), int16(0x1980), int16(0x1a80), int16(0x1b00), int16(0x1c00), int16(0x1d00), int16(0x1e00), int16(0x1f00),
} /* t1_luts.h:157:24 */

//@}

//@}

// -----------------------------------------------------------------------

func opj_t1_getctxno_zc(tls *libc.TLS, mqc uintptr, f TOPJ_UINT32) TOPJ_BYTE { /* t1.c:255:24: */
	return *(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Flut_ctxno_zc_orient + uintptr(f&(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8))))
}

func opj_t1_getctxtno_sc_or_spb_index(tls *libc.TLS, fX TOPJ_UINT32, pfX TOPJ_UINT32, nfX TOPJ_UINT32, ci TOPJ_UINT32) TOPJ_UINT32 { /* t1.c:260:26: */
	//
	//       0 pfX T1_CHI_THIS           T1_LUT_SGN_W
	//       1 tfX T1_SIGMA_1            T1_LUT_SIG_N
	//       2 nfX T1_CHI_THIS           T1_LUT_SGN_E
	//       3 tfX T1_SIGMA_3            T1_LUT_SIG_W
	//       4  fX T1_CHI_(THIS - 1)     T1_LUT_SGN_N
	//       5 tfX T1_SIGMA_5            T1_LUT_SIG_E
	//       6  fX T1_CHI_(THIS + 1)     T1_LUT_SGN_S
	//       7 tfX T1_SIGMA_7            T1_LUT_SIG_S
	//

	var lu TOPJ_UINT32 = fX >> (ci * 3) & (uint32(1)<<1 | uint32(1)<<3 | uint32(1)<<5 | uint32(1)<<7)

	lu = lu | pfX>>(TOPJ_UINT32(DT1_CHI_1_I)+ci*3)&(uint32(1)<<0)
	lu = lu | nfX>>(uint32(DT1_CHI_1_I)-2+ci*3)&(uint32(1)<<2)
	if ci == 0 {
		lu = lu | fX>>(uint32(DT1_CHI_0_I)-4)&(uint32(1)<<4)
	} else {
		lu = lu | fX>>(uint32(DT1_CHI_1_I)-4+(ci-1)*3)&(uint32(1)<<4)
	}
	lu = lu | fX>>(uint32(DT1_CHI_2_I)-6+ci*3)&(uint32(1)<<6)
	return lu
}

func opj_t1_getctxno_sc(tls *libc.TLS, lu TOPJ_UINT32) TOPJ_BYTE { /* t1.c:290:24: */
	return lut_ctxno_sc[lu]
}

func opj_t1_getctxno_mag(tls *libc.TLS, f TOPJ_UINT32) TOPJ_UINT32 { /* t1.c:295:26: */
	var tmp TOPJ_UINT32
	if f&(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8) != 0 {
		tmp = uint32(DT1_CTXNO_ZC + DT1_NUMCTXS_ZC + DT1_NUMCTXS_SC + 1)
	} else {
		tmp = uint32(DT1_CTXNO_ZC + DT1_NUMCTXS_ZC + DT1_NUMCTXS_SC)
	}
	var tmp2 TOPJ_UINT32
	if f&(uint32(1)<<20) != 0 {
		tmp2 = uint32(DT1_CTXNO_ZC + DT1_NUMCTXS_ZC + DT1_NUMCTXS_SC + 2)
	} else {
		tmp2 = tmp
	}
	return tmp2
}

func opj_t1_getspb(tls *libc.TLS, lu TOPJ_UINT32) TOPJ_BYTE { /* t1.c:302:24: */
	return lut_spb[lu]
}

func opj_t1_getnmsedec_sig(tls *libc.TLS, x TOPJ_UINT32, bitpos TOPJ_UINT32) TOPJ_INT16 { /* t1.c:307:18: */
	if bitpos > TOPJ_UINT32(0) {
		return lut_nmsedec_sig[x>>bitpos&TOPJ_UINT32(int32(1)<<DT1_NMSEDEC_BITS-1)]
	}

	return lut_nmsedec_sig0[x&TOPJ_UINT32(int32(1)<<DT1_NMSEDEC_BITS-1)]
}

func opj_t1_getnmsedec_ref(tls *libc.TLS, x TOPJ_UINT32, bitpos TOPJ_UINT32) TOPJ_INT16 { /* t1.c:316:18: */
	if bitpos > TOPJ_UINT32(0) {
		return lut_nmsedec_ref[x>>bitpos&TOPJ_UINT32(int32(1)<<DT1_NMSEDEC_BITS-1)]
	}

	return lut_nmsedec_ref0[x&TOPJ_UINT32(int32(1)<<DT1_NMSEDEC_BITS-1)]
}

func opj_t1_update_flags(tls *libc.TLS, flagsp uintptr, ci TOPJ_UINT32, s TOPJ_UINT32, stride TOPJ_UINT32, vsc TOPJ_UINT32) { /* t1.c:354:20: */
	{ /* east */
		*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * ci) /* mark target as significant */
		*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= (s<<DT1_CHI_1_I | uint32(1)<<4) << (3 * ci)                    /* west */
		*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * ci)                         /* north-west, north, north-east */
		if ci == 0 && !(vsc != 0) {
			var north uintptr = flagsp - uintptr(stride)*4
			*(*Topj_flag_t)(unsafe.Pointer(north)) |= s<<DT1_CHI_5_I | uint32(1)<<16
			*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
			*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
		} /* south-west, south, south-east */
		if ci == 3 {
			var south uintptr = flagsp + uintptr(stride)*4
			*(*Topj_flag_t)(unsafe.Pointer(south)) |= s<<DT1_CHI_0_I | uint32(1)<<1
			*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
			*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
		}
	}

}

//*
// Encode significant pass

func opj_t1_dec_sigpass_step_raw(tls *libc.TLS, t1 uintptr, flagsp uintptr, datap uintptr, oneplushalf TOPJ_INT32, vsc TOPJ_UINT32, ci TOPJ_UINT32) { /* t1.c:413:20: */
	var v TOPJ_UINT32
	var mqc uintptr = t1 // RAW component

	var flags TOPJ_UINT32 = *(*Topj_flag_t)(unsafe.Pointer(flagsp))

	if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(ci*3)) != 0 {
		if opj_mqc_raw_decode(tls, mqc) != 0 {
			v = opj_mqc_raw_decode(tls, mqc)
			*(*TOPJ_INT32)(unsafe.Pointer(datap)) = func() int32 {
				if v != 0 {
					return -oneplushalf
				}
				return oneplushalf
			}()
			opj_t1_update_flags(tls, flagsp, ci, v, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2), vsc)
		}
		*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<21) << (ci * 3)
	}
}

func opj_t1_dec_sigpass_step_mqc(tls *libc.TLS, t1 uintptr, flagsp uintptr, datap uintptr, oneplushalf TOPJ_INT32, ci TOPJ_UINT32, flags_stride TOPJ_UINT32, vsc TOPJ_UINT32) { /* t1.c:463:20: */
	var v TOPJ_UINT32

	var mqc uintptr = t1 /* MQC component */
	{
		if *(*Topj_flag_t)(unsafe.Pointer(flagsp))&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == 0 && *(*Topj_flag_t)(unsafe.Pointer(flagsp))&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(ci*3)) != 0 {
			var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, *(*Topj_flag_t)(unsafe.Pointer(flagsp))>>(ci*3)))
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40 + uintptr(ctxt1)*8
			{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
				if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
					{
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
							v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
						} else {
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
							v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
						}
					}
					{
						for __ccgo := true; __ccgo; __ccgo = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
								{
									var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
									l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										if l_c > TOPJ_UINT32(0x8f) {
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
										}
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
									}
								}
							}
							libc.AssignShlPtrUint32(mqc+4, int(1))
							libc.AssignShlPtrUint32(mqc, int(1))
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
						}
					}
				} else {
					*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
					if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
						{
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
								v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
								*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
								*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
							}
						}
						{
							for __ccgo1 := true; __ccgo1; __ccgo1 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
								if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
									{
										var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
										l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
										if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
											if l_c > TOPJ_UINT32(0x8f) {
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
											}
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
										}
									}
								}
								libc.AssignShlPtrUint32(mqc+4, int(1))
								libc.AssignShlPtrUint32(mqc, int(1))
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
							}
						}
					} else {
						v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
					}
				}
			}
			if v != 0 {
				var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
				var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
				var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
				(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40 + uintptr(ctxt2)*8
				{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
					*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
					if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
						{
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
								*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
							} else {
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
								v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
								*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
							}
						}
						{
							for __ccgo2 := true; __ccgo2; __ccgo2 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
								if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
									{
										var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
										l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
										if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
											if l_c > TOPJ_UINT32(0x8f) {
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
											}
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
										}
									}
								}
								libc.AssignShlPtrUint32(mqc+4, int(1))
								libc.AssignShlPtrUint32(mqc, int(1))
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
							}
						}
					} else {
						*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
							{
								if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
								} else {
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
									*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
								}
							}
							{
								for __ccgo3 := true; __ccgo3; __ccgo3 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
									if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											}
										}
									}
									libc.AssignShlPtrUint32(mqc+4, int(1))
									libc.AssignShlPtrUint32(mqc, int(1))
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
								}
							}
						} else {
							v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
						}
					}
				}
				v = v ^ spb
				*(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(ci*TOPJ_UINT32(0))*4)) = func() int32 {
					if v != 0 {
						return -oneplushalf
					}
					return oneplushalf
				}()
				{ /* east */
					*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * ci) /* mark target as significant */
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= (v<<DT1_CHI_1_I | uint32(1)<<4) << (3 * ci)                    /* west */
					*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * ci)                         /* north-west, north, north-east */
					if ci == 0 && !(vsc != 0) {
						var north uintptr = flagsp - uintptr(flags_stride)*4
						*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
						*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
						*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
					} /* south-west, south, south-east */
					if ci == 3 {
						var south uintptr = flagsp + uintptr(flags_stride)*4
						*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
						*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
						*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
					}
				}
			}
			*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<21) << (ci * 3)
		}
	}

}

func opj_t1_enc_sigpass(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32, nmsedec uintptr, type1 TOPJ_BYTE, cblksty TOPJ_UINT32) { /* t1.c:480:13: */
	var i TOPJ_UINT32
	var k TOPJ_UINT32
	var one TOPJ_INT32 = int32(1) << (bpno + (DT1_NMSEDEC_BITS - 1))
	var f uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr(TOPJ_UINT32(0+1)+TOPJ_UINT32(0/4+1)*((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2)))*4
	var extra TOPJ_UINT32 = TOPJ_UINT32(2)
	var mqc uintptr = t1
	var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
	var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
	var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
	var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
	var datap uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata

	*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) = 0
	k = TOPJ_UINT32(0)
__1:
	if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
		goto __3
	}
	{
		var w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
		i = TOPJ_UINT32(0)
	__4:
		if !(i < w) {
			goto __6
		}
		{
			if *(*Topj_flag_t)(unsafe.Pointer(f)) == 0 {
				// Nothing to do for any of the 4 data points
				goto __5
			}
			{
				var v TOPJ_UINT32
				var ci TOPJ_UINT32 = TOPJ_UINT32(0)
				var vsc TOPJ_UINT32 = cblksty & TOPJ_UINT32(DJ2K_CCP_CBLKSTY_VSC)
				var l_datap uintptr = datap
				var flagsp uintptr = f
				var flags TOPJ_UINT32 = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(ci*3)) != 0 {
					var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(ci*3)))
					if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF&TOPJ_UINT32(one) != 0 {
						v = uint32(1)
					} else {
						v = uint32(0)
					} /* #ifdef DEBUG_ENC_SIG */ /*        fprintf(stderr, "   ctxt1=%d\n", ctxt1); */ /* #endif */
					curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
					if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
						{
							if ct == DBYPASS_CT_INIT {
								ct = TOPJ_UINT32(8)
							}
							ct--
							c = c + v<<ct
							if ct == TOPJ_UINT32(0) {
								*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
								ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									ct = TOPJ_UINT32(7)
								}
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
								c = TOPJ_UINT32(0)
							}
						}
					} else {
						{
							if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										{
											for __ccgo := true; __ccgo; __ccgo = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}
									} else {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
								}
							} else {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									} else {
										a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									{
										for __ccgo1 := true; __ccgo1; __ccgo1 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											a <<= 1
											c <<= 1
											ct--
											if ct == TOPJ_UINT32(0) {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
												Xopj_mqc_byteout(tls, mqc)
												c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
												ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
											}
										}
									}

								}
							}
						}
					}
					if v != 0 {
						var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
						var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
						v = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap))) >> 31
						*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_sig(tls, TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF, TOPJ_UINT32(bpno))) /* #ifdef DEBUG_ENC_SIG */ /*            fprintf(stderr, "   ctxt2=%d\n", ctxt2); */ /* #endif */
						curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt2)*8
						if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
							{
								if ct == DBYPASS_CT_INIT {
									ct = TOPJ_UINT32(8)
								}
								ct--
								c = c + v<<ct
								if ct == TOPJ_UINT32(0) {
									*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
									ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										ct = TOPJ_UINT32(7)
									}
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									c = TOPJ_UINT32(0)
								}
							}
						} else {
							var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu)) /* #ifdef DEBUG_ENC_SIG */ /*                fprintf(stderr, "   spb=%d\n", spb); */ /* #endif */
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v^spb {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo2 := true; __ccgo2; __ccgo2 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo3 := true; __ccgo3; __ccgo3 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
						}
						opj_t1_update_flags(tls, flagsp, ci, v, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2), vsc)
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<21) << (ci * 3)
				}
			}

			{
				var v TOPJ_UINT32
				var ci TOPJ_UINT32 = TOPJ_UINT32(1)
				var vsc TOPJ_UINT32 = TOPJ_UINT32(0)
				var l_datap uintptr = datap + 1*4
				var flagsp uintptr = f
				var flags TOPJ_UINT32 = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(ci*3)) != 0 {
					var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(ci*3)))
					if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF&TOPJ_UINT32(one) != 0 {
						v = uint32(1)
					} else {
						v = uint32(0)
					} /* #ifdef DEBUG_ENC_SIG */ /*        fprintf(stderr, "   ctxt1=%d\n", ctxt1); */ /* #endif */
					curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
					if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
						{
							if ct == DBYPASS_CT_INIT {
								ct = TOPJ_UINT32(8)
							}
							ct--
							c = c + v<<ct
							if ct == TOPJ_UINT32(0) {
								*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
								ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									ct = TOPJ_UINT32(7)
								}
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
								c = TOPJ_UINT32(0)
							}
						}
					} else {
						{
							if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										{
											for __ccgo4 := true; __ccgo4; __ccgo4 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}
									} else {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
								}
							} else {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									} else {
										a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									{
										for __ccgo5 := true; __ccgo5; __ccgo5 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											a <<= 1
											c <<= 1
											ct--
											if ct == TOPJ_UINT32(0) {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
												Xopj_mqc_byteout(tls, mqc)
												c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
												ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
											}
										}
									}

								}
							}
						}
					}
					if v != 0 {
						var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
						var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
						v = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap))) >> 31
						*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_sig(tls, TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF, TOPJ_UINT32(bpno))) /* #ifdef DEBUG_ENC_SIG */ /*            fprintf(stderr, "   ctxt2=%d\n", ctxt2); */ /* #endif */
						curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt2)*8
						if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
							{
								if ct == DBYPASS_CT_INIT {
									ct = TOPJ_UINT32(8)
								}
								ct--
								c = c + v<<ct
								if ct == TOPJ_UINT32(0) {
									*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
									ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										ct = TOPJ_UINT32(7)
									}
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									c = TOPJ_UINT32(0)
								}
							}
						} else {
							var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu)) /* #ifdef DEBUG_ENC_SIG */ /*                fprintf(stderr, "   spb=%d\n", spb); */ /* #endif */
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v^spb {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo6 := true; __ccgo6; __ccgo6 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo7 := true; __ccgo7; __ccgo7 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
						}
						opj_t1_update_flags(tls, flagsp, ci, v, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2), vsc)
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<21) << (ci * 3)
				}
			}

			{
				var v TOPJ_UINT32
				var ci TOPJ_UINT32 = TOPJ_UINT32(2)
				var vsc TOPJ_UINT32 = TOPJ_UINT32(0)
				var l_datap uintptr = datap + 2*4
				var flagsp uintptr = f
				var flags TOPJ_UINT32 = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(ci*3)) != 0 {
					var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(ci*3)))
					if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF&TOPJ_UINT32(one) != 0 {
						v = uint32(1)
					} else {
						v = uint32(0)
					} /* #ifdef DEBUG_ENC_SIG */ /*        fprintf(stderr, "   ctxt1=%d\n", ctxt1); */ /* #endif */
					curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
					if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
						{
							if ct == DBYPASS_CT_INIT {
								ct = TOPJ_UINT32(8)
							}
							ct--
							c = c + v<<ct
							if ct == TOPJ_UINT32(0) {
								*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
								ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									ct = TOPJ_UINT32(7)
								}
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
								c = TOPJ_UINT32(0)
							}
						}
					} else {
						{
							if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										{
											for __ccgo8 := true; __ccgo8; __ccgo8 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}
									} else {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
								}
							} else {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									} else {
										a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									{
										for __ccgo9 := true; __ccgo9; __ccgo9 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											a <<= 1
											c <<= 1
											ct--
											if ct == TOPJ_UINT32(0) {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
												Xopj_mqc_byteout(tls, mqc)
												c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
												ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
											}
										}
									}

								}
							}
						}
					}
					if v != 0 {
						var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
						var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
						v = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap))) >> 31
						*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_sig(tls, TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF, TOPJ_UINT32(bpno))) /* #ifdef DEBUG_ENC_SIG */ /*            fprintf(stderr, "   ctxt2=%d\n", ctxt2); */ /* #endif */
						curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt2)*8
						if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
							{
								if ct == DBYPASS_CT_INIT {
									ct = TOPJ_UINT32(8)
								}
								ct--
								c = c + v<<ct
								if ct == TOPJ_UINT32(0) {
									*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
									ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										ct = TOPJ_UINT32(7)
									}
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									c = TOPJ_UINT32(0)
								}
							}
						} else {
							var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu)) /* #ifdef DEBUG_ENC_SIG */ /*                fprintf(stderr, "   spb=%d\n", spb); */ /* #endif */
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v^spb {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo10 := true; __ccgo10; __ccgo10 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo11 := true; __ccgo11; __ccgo11 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
						}
						opj_t1_update_flags(tls, flagsp, ci, v, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2), vsc)
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<21) << (ci * 3)
				}
			}

			{
				var v TOPJ_UINT32
				var ci TOPJ_UINT32 = TOPJ_UINT32(3)
				var vsc TOPJ_UINT32 = TOPJ_UINT32(0)
				var l_datap uintptr = datap + 3*4
				var flagsp uintptr = f
				var flags TOPJ_UINT32 = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(ci*3)) != 0 {
					var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(ci*3)))
					if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF&TOPJ_UINT32(one) != 0 {
						v = uint32(1)
					} else {
						v = uint32(0)
					} /* #ifdef DEBUG_ENC_SIG */ /*        fprintf(stderr, "   ctxt1=%d\n", ctxt1); */ /* #endif */
					curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
					if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
						{
							if ct == DBYPASS_CT_INIT {
								ct = TOPJ_UINT32(8)
							}
							ct--
							c = c + v<<ct
							if ct == TOPJ_UINT32(0) {
								*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
								ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									ct = TOPJ_UINT32(7)
								}
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
								c = TOPJ_UINT32(0)
							}
						}
					} else {
						{
							if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										{
											for __ccgo12 := true; __ccgo12; __ccgo12 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}
									} else {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
								}
							} else {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									} else {
										a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									{
										for __ccgo13 := true; __ccgo13; __ccgo13 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											a <<= 1
											c <<= 1
											ct--
											if ct == TOPJ_UINT32(0) {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
												Xopj_mqc_byteout(tls, mqc)
												c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
												ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
											}
										}
									}

								}
							}
						}
					}
					if v != 0 {
						var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
						var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
						v = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap))) >> 31
						*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_sig(tls, TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF, TOPJ_UINT32(bpno))) /* #ifdef DEBUG_ENC_SIG */ /*            fprintf(stderr, "   ctxt2=%d\n", ctxt2); */ /* #endif */
						curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt2)*8
						if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
							{
								if ct == DBYPASS_CT_INIT {
									ct = TOPJ_UINT32(8)
								}
								ct--
								c = c + v<<ct
								if ct == TOPJ_UINT32(0) {
									*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
									ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										ct = TOPJ_UINT32(7)
									}
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									c = TOPJ_UINT32(0)
								}
							}
						} else {
							var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu)) /* #ifdef DEBUG_ENC_SIG */ /*                fprintf(stderr, "   spb=%d\n", spb); */ /* #endif */
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v^spb {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo14 := true; __ccgo14; __ccgo14 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo15 := true; __ccgo15; __ccgo15 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
						}
						opj_t1_update_flags(tls, flagsp, ci, v, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2), vsc)
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<21) << (ci * 3)
				}
			}

		}
		goto __5
	__5:
		i++
		f += 4
		datap += 4 * uintptr(4)
		goto __4
		goto __6
	__6:
	}
	goto __2
__2:
	k = k + TOPJ_UINT32(4)
	f += 4 * uintptr(extra)
	goto __1
	goto __3
__3:
	;

	if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
		var j TOPJ_UINT32
		i = TOPJ_UINT32(0)
	__7:
		if !(i < (*Topj_t1_t)(unsafe.Pointer(t1)).Fw) {
			goto __9
		}
		{
			if *(*Topj_flag_t)(unsafe.Pointer(f)) == 0 {
				// Nothing to do for any of the 4 data points
				datap += 4 * uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k)
				goto __8
			}
			j = k
		__10:
			if !(j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh) {
				goto __12
			}
			{
				{
					var v TOPJ_UINT32
					var ci TOPJ_UINT32 = j - k
					var vsc TOPJ_UINT32 = TOPJ_UINT32(libc.Bool32(j == k && cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_VSC) != TOPJ_UINT32(0)))
					var l_datap uintptr = datap
					var flagsp uintptr = f
					var flags TOPJ_UINT32 = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
					if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(ci*3)) != 0 {
						var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(ci*3)))
						if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF&TOPJ_UINT32(one) != 0 {
							v = uint32(1)
						} else {
							v = uint32(0)
						} /* #ifdef DEBUG_ENC_SIG */ /*        fprintf(stderr, "   ctxt1=%d\n", ctxt1); */ /* #endif */
						curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
						if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
							{
								if ct == DBYPASS_CT_INIT {
									ct = TOPJ_UINT32(8)
								}
								ct--
								c = c + v<<ct
								if ct == TOPJ_UINT32(0) {
									*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
									ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										ct = TOPJ_UINT32(7)
									}
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									c = TOPJ_UINT32(0)
								}
							}
						} else {
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo16 := true; __ccgo16; __ccgo16 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo17 := true; __ccgo17; __ccgo17 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
						}
						if v != 0 {
							var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
							var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
							v = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap))) >> 31
							*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_sig(tls, TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF, TOPJ_UINT32(bpno))) /* #ifdef DEBUG_ENC_SIG */ /*            fprintf(stderr, "   ctxt2=%d\n", ctxt2); */ /* #endif */
							curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt2)*8
							if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
								{
									if ct == DBYPASS_CT_INIT {
										ct = TOPJ_UINT32(8)
									}
									ct--
									c = c + v<<ct
									if ct == TOPJ_UINT32(0) {
										*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
										ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
										if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
											ct = TOPJ_UINT32(7)
										}
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										c = TOPJ_UINT32(0)
									}
								}
							} else {
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu)) /* #ifdef DEBUG_ENC_SIG */ /*                fprintf(stderr, "   spb=%d\n", spb); */ /* #endif */
								{
									if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v^spb {
										{
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												} else {
													c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												}
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												{
													for __ccgo18 := true; __ccgo18; __ccgo18 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
														a <<= 1
														c <<= 1
														ct--
														if ct == TOPJ_UINT32(0) {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
															Xopj_mqc_byteout(tls, mqc)
															c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
															ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
														}
													}
												}
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
										}
									} else {
										{
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											{
												for __ccgo19 := true; __ccgo19; __ccgo19 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}

										}
									}
								}
							}
							opj_t1_update_flags(tls, flagsp, ci, v, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2), vsc)
						}
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<21) << (ci * 3)
					}
				}

			}
			goto __11
		__11:
			j++
			datap += 4
			goto __10
			goto __12
		__12:
		}
		goto __8
	__8:
		i++
		f += 4
		goto __7
		goto __9
	__9:
	}

	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct

}

func opj_t1_dec_sigpass_raw(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32, cblksty TOPJ_INT32) { /* t1.c:583:13: */
	var one TOPJ_INT32
	var half TOPJ_INT32
	var oneplushalf TOPJ_INT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var k TOPJ_UINT32
	var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
	var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr(TOPJ_UINT32(0+1)+TOPJ_UINT32(0/4+1)*((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2)))*4
	var l_w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
	one = int32(1) << bpno
	half = one >> 1
	oneplushalf = one | half

	k = TOPJ_UINT32(0)
__1:
	if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
		goto __3
	}
	{
		i = TOPJ_UINT32(0)
	__4:
		if !(i < l_w) {
			goto __6
		}
		{
			var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
			if flags != Topj_flag_t(0) {
				opj_t1_dec_sigpass_step_raw(tls,
					t1,
					flagsp,
					data,
					oneplushalf,
					uint32(cblksty&DJ2K_CCP_CBLKSTY_VSC),
					0)
				opj_t1_dec_sigpass_step_raw(tls,
					t1,
					flagsp,
					data+uintptr(l_w)*4,
					oneplushalf,
					uint32(DOPJ_FALSE), // vsc
					1)
				opj_t1_dec_sigpass_step_raw(tls,
					t1,
					flagsp,
					data+uintptr(TOPJ_UINT32(2)*l_w)*4,
					oneplushalf,
					uint32(DOPJ_FALSE), // vsc
					2)
				opj_t1_dec_sigpass_step_raw(tls,
					t1,
					flagsp,
					data+uintptr(TOPJ_UINT32(3)*l_w)*4,
					oneplushalf,
					uint32(DOPJ_FALSE), // vsc
					3)
			}

		}
		goto __5
	__5:
		i++
		flagsp += 4
		data += 4
		goto __4
		goto __6
	__6:
	}
	goto __2
__2:
	k = k + TOPJ_UINT32(4)
	flagsp += 4 * uintptr(2)
	data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
	goto __1
	goto __3
__3:
	;
	if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
		i = TOPJ_UINT32(0)
	__7:
		if !(i < l_w) {
			goto __9
		}
		{
			for j = TOPJ_UINT32(0); j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k; j++ {
				opj_t1_dec_sigpass_step_raw(tls,
					t1,
					flagsp,
					data+uintptr(j*l_w)*4,
					oneplushalf,
					uint32(cblksty&DJ2K_CCP_CBLKSTY_VSC),
					j)
			}

		}
		goto __8
	__8:
		i++
		flagsp += 4
		data += 4
		goto __7
		goto __9
	__9:
	}
}

func opj_t1_dec_sigpass_mqc_64x64_novsc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:691:13: */
	{
		var one TOPJ_INT32
		var half TOPJ_INT32
		var oneplushalf TOPJ_INT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + 67*4
		var l_w TOPJ_UINT32 = TOPJ_UINT32(64)
		var mqc uintptr = t1
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		half = one >> 1
		oneplushalf = one | half
		k = TOPJ_UINT32(0)
	__1:
		if !(k < uint32(64)&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags != Topj_flag_t(0) {
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(0)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
									if uint32(0) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(0) == 3 {
										var south uintptr = flagsp + uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(0)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(1)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo6 := true; __ccgo6; __ccgo6 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
									if uint32(1) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(1) == 3 {
										var south uintptr = flagsp + uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(1)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(2)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo8 := true; __ccgo8; __ccgo8 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo9 := true; __ccgo9; __ccgo9 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo10 := true; __ccgo10; __ccgo10 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo11 := true; __ccgo11; __ccgo11 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
									if uint32(2) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(2) == 3 {
										var south uintptr = flagsp + uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(2)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(3)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo12 := true; __ccgo12; __ccgo12 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo13 := true; __ccgo13; __ccgo13 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo14 := true; __ccgo14; __ccgo14 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo15 := true; __ccgo15; __ccgo15 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
									if uint32(3) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(3) == 3 {
										var south uintptr = flagsp + uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(3)*3)
						}
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags
				}
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < TOPJ_UINT32(64) {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < TOPJ_UINT32(64)-k; j++ {
					opj_t1_dec_sigpass_step_mqc(tls, t1, flagsp, data+uintptr(j*l_w)*4, oneplushalf, j, uint32(66), uint32(DOPJ_FALSE))
				}
			}
			goto __8
		__8:
			i++
			data += 4
			flagsp += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_sigpass_mqc_64x64_vsc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:698:13: */
	{
		var one TOPJ_INT32
		var half TOPJ_INT32
		var oneplushalf TOPJ_INT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + 67*4
		var l_w TOPJ_UINT32 = TOPJ_UINT32(64)
		var mqc uintptr = t1
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		half = one >> 1
		oneplushalf = one | half
		k = TOPJ_UINT32(0)
	__1:
		if !(k < uint32(64)&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags != Topj_flag_t(0) {
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(0)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
									if uint32(0) == 0 && !(1 != 0) {
										var north uintptr = flagsp - uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(0) == 3 {
										var south uintptr = flagsp + uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(0)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(1)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo6 := true; __ccgo6; __ccgo6 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
									if uint32(1) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(1) == 3 {
										var south uintptr = flagsp + uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(1)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(2)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo8 := true; __ccgo8; __ccgo8 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo9 := true; __ccgo9; __ccgo9 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo10 := true; __ccgo10; __ccgo10 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo11 := true; __ccgo11; __ccgo11 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
									if uint32(2) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(2) == 3 {
										var south uintptr = flagsp + uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(2)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(3)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo12 := true; __ccgo12; __ccgo12 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo13 := true; __ccgo13; __ccgo13 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo14 := true; __ccgo14; __ccgo14 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo15 := true; __ccgo15; __ccgo15 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
									if uint32(3) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(3) == 3 {
										var south uintptr = flagsp + uintptr(66)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(3)*3)
						}
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags
				}
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < TOPJ_UINT32(64) {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < TOPJ_UINT32(64)-k; j++ {
					opj_t1_dec_sigpass_step_mqc(tls, t1, flagsp, data+uintptr(j*l_w)*4, oneplushalf, j, uint32(66), uint32(DOPJ_TRUE))
				}
			}
			goto __8
		__8:
			i++
			data += 4
			flagsp += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_sigpass_mqc_generic_novsc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:705:13: */
	{
		var one TOPJ_INT32
		var half TOPJ_INT32
		var oneplushalf TOPJ_INT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2+TOPJ_UINT32(1))*4
		var l_w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
		var mqc uintptr = t1
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		half = one >> 1
		oneplushalf = one | half
		k = TOPJ_UINT32(0)
	__1:
		if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags != Topj_flag_t(0) {
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(0)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
									if uint32(0) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(0) == 3 {
										var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(0)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(1)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo6 := true; __ccgo6; __ccgo6 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
									if uint32(1) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(1) == 3 {
										var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(1)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(2)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo8 := true; __ccgo8; __ccgo8 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo9 := true; __ccgo9; __ccgo9 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo10 := true; __ccgo10; __ccgo10 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo11 := true; __ccgo11; __ccgo11 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
									if uint32(2) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(2) == 3 {
										var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(2)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(3)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo12 := true; __ccgo12; __ccgo12 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo13 := true; __ccgo13; __ccgo13 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo14 := true; __ccgo14; __ccgo14 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo15 := true; __ccgo15; __ccgo15 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
									if uint32(3) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(3) == 3 {
										var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(3)*3)
						}
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags
				}
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k; j++ {
					opj_t1_dec_sigpass_step_mqc(tls, t1, flagsp, data+uintptr(j*l_w)*4, oneplushalf, j, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2, uint32(DOPJ_FALSE))
				}
			}
			goto __8
		__8:
			i++
			data += 4
			flagsp += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_sigpass_mqc_generic_vsc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:713:13: */
	{
		var one TOPJ_INT32
		var half TOPJ_INT32
		var oneplushalf TOPJ_INT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2+TOPJ_UINT32(1))*4
		var l_w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
		var mqc uintptr = t1
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		half = one >> 1
		oneplushalf = one | half
		k = TOPJ_UINT32(0)
	__1:
		if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags != Topj_flag_t(0) {
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(0)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
									if uint32(0) == 0 && !(1 != 0) {
										var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(0) == 3 {
										var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(0)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(1)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo6 := true; __ccgo6; __ccgo6 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
									if uint32(1) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(1) == 3 {
										var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(1)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(2)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo8 := true; __ccgo8; __ccgo8 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo9 := true; __ccgo9; __ccgo9 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo10 := true; __ccgo10; __ccgo10 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo11 := true; __ccgo11; __ccgo11 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
									if uint32(2) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(2) == 3 {
										var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(2)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) == 0 && flags&(uint32(uint32(1)<<0|uint32(1)<<1|uint32(1)<<2|uint32(1)<<3|uint32(1)<<5|uint32(1)<<6|uint32(1)<<7|uint32(1)<<8)<<(uint32(3)*3)) != 0 {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
							curctx = mqc + 40 + uintptr(ctxt1)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo12 := true; __ccgo12; __ccgo12 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo13 := true; __ccgo13; __ccgo13 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							if v != 0 {
								var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
								var ctxt2 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu))
								var spb TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getspb(tls, lu))
								curctx = mqc + 40 + uintptr(ctxt2)*8
								{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											} else {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											}
										}
										{
											for __ccgo14 := true; __ccgo14; __ccgo14 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												}
											}
											{
												for __ccgo15 := true; __ccgo15; __ccgo15 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										}
									}
								}
								v = v ^ spb
								*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
									if v != 0 {
										return -oneplushalf
									}
									return oneplushalf
								}()
								{ /* east */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
									flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
									*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
									if uint32(3) == 0 && !(0 != 0) {
										var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
										*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
										*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
									} /* south-west, south, south-east */
									if uint32(3) == 3 {
										var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
										*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
										*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
										*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
									}
								}
							}
							flags = flags | uint32(uint32(1)<<21)<<(uint32(3)*3)
						}
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags
				}
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k; j++ {
					opj_t1_dec_sigpass_step_mqc(tls, t1, flagsp, data+uintptr(j*l_w)*4, oneplushalf, j, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2, uint32(DOPJ_TRUE))
				}
			}
			goto __8
		__8:
			i++
			data += 4
			flagsp += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_sigpass_mqc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32, cblksty TOPJ_INT32) { /* t1.c:721:13: */
	if (*Topj_t1_t)(unsafe.Pointer(t1)).Fw == TOPJ_UINT32(64) && (*Topj_t1_t)(unsafe.Pointer(t1)).Fh == TOPJ_UINT32(64) {
		if cblksty&DJ2K_CCP_CBLKSTY_VSC != 0 {
			opj_t1_dec_sigpass_mqc_64x64_vsc(tls, t1, bpno)
		} else {
			opj_t1_dec_sigpass_mqc_64x64_novsc(tls, t1, bpno)
		}
	} else {
		if cblksty&DJ2K_CCP_CBLKSTY_VSC != 0 {
			opj_t1_dec_sigpass_mqc_generic_vsc(tls, t1, bpno)
		} else {
			opj_t1_dec_sigpass_mqc_generic_novsc(tls, t1, bpno)
		}
	}
}

//*
// Encode refinement pass step

func opj_t1_dec_refpass_step_raw(tls *libc.TLS, t1 uintptr, flagsp uintptr, datap uintptr, poshalf TOPJ_INT32, ci TOPJ_UINT32) { /* t1.c:768:20: */
	var v TOPJ_UINT32

	var mqc uintptr = t1 // RAW component

	if *(*Topj_flag_t)(unsafe.Pointer(flagsp))&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == uint32(uint32(1)<<4)<<(ci*3) {
		v = opj_mqc_raw_decode(tls, mqc)
		*(*TOPJ_INT32)(unsafe.Pointer(datap)) += func() int32 {
			if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(datap)) < 0)) != 0 {
				return poshalf
			}
			return -poshalf
		}()
		*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<20) << (ci * 3)
	}
}

func opj_t1_dec_refpass_step_mqc(tls *libc.TLS, t1 uintptr, flagsp uintptr, datap uintptr, poshalf TOPJ_INT32, ci TOPJ_UINT32) { /* t1.c:800:20: */
	var v TOPJ_UINT32

	var mqc uintptr = t1 /* MQC component */
	{
		if *(*Topj_flag_t)(unsafe.Pointer(flagsp))&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) == uint32(uint32(1)<<4)<<(ci*3) {
			var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp))>>(ci*3))
			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40 + uintptr(ctxt)*8
			{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
				if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
					{
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
							v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
						} else {
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
							v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
						}
					}
					{
						for __ccgo := true; __ccgo; __ccgo = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
								{
									var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
									l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										if l_c > TOPJ_UINT32(0x8f) {
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
										}
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
									}
								}
							}
							libc.AssignShlPtrUint32(mqc+4, int(1))
							libc.AssignShlPtrUint32(mqc, int(1))
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
						}
					}
				} else {
					*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
					if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
						{
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
								v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
								*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
								*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
							}
						}
						{
							for __ccgo1 := true; __ccgo1; __ccgo1 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
								if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
									{
										var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
										l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
										if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
											if l_c > TOPJ_UINT32(0x8f) {
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
											}
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
										}
									}
								}
								libc.AssignShlPtrUint32(mqc+4, int(1))
								libc.AssignShlPtrUint32(mqc, int(1))
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
							}
						}
					} else {
						v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
					}
				}
			}
			*(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(ci*TOPJ_UINT32(0))*4)) += func() int32 {
				if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(ci*TOPJ_UINT32(0))*4)) < 0)) != 0 {
					return poshalf
				}
				return -poshalf
			}()
			*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= uint32(uint32(1)<<20) << (ci * 3)
		}
	}

}

func opj_t1_enc_refpass(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32, nmsedec uintptr, type1 TOPJ_BYTE) { /* t1.c:815:13: */
	var i TOPJ_UINT32
	var k TOPJ_UINT32
	var one TOPJ_INT32 = int32(1) << (bpno + (DT1_NMSEDEC_BITS - 1))
	var f uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr(TOPJ_UINT32(0+1)+TOPJ_UINT32(0/4+1)*((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2)))*4
	var extra TOPJ_UINT32 = 2
	var mqc uintptr = t1
	var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
	var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
	var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
	var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
	var datap uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata

	*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) = 0
	k = TOPJ_UINT32(0)
__1:
	if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
		goto __3
	}
	{
		i = TOPJ_UINT32(0)
	__4:
		if !(i < (*Topj_t1_t)(unsafe.Pointer(t1)).Fw) {
			goto __6
		}
		{
			var flags TOPJ_UINT32 = *(*Topj_flag_t)(unsafe.Pointer(f))
			var flagsUpdated TOPJ_UINT32 = flags
			if flags&(uint32(1)<<4|uint32(1)<<7|uint32(1)<<10|uint32(1)<<13) == TOPJ_UINT32(0) {
				// none significant
				goto __5
			}
			if flags&(uint32(1)<<21|uint32(1)<<24|uint32(1)<<27|uint32(1)<<30) == uint32(1)<<21|uint32(1)<<24|uint32(1)<<27|uint32(1)<<30 {
				// all processed by sigpass
				goto __5
			}

			{
				var v TOPJ_UINT32
				if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) == uint32(uint32(1)<<4)<<(uint32(0)*3) {
					var shift_flags TOPJ_UINT32 = flags >> (uint32(0) * 3)
					var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, shift_flags)
					var abs_data TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(datap))) & 0x7FFFFFFF
					*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_ref(tls, abs_data, TOPJ_UINT32(bpno)))
					if TOPJ_INT32(abs_data)&one != 0 {
						v = uint32(1)
					} else {
						v = uint32(0)
					} /* #ifdef DEBUG_ENC_REF */ /*        fprintf(stderr, "  ctxt=%d\n", ctxt); */ /* #endif */
					curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt)*8
					if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
						{
							if ct == DBYPASS_CT_INIT {
								ct = TOPJ_UINT32(8)
							}
							ct--
							c = c + v<<ct
							if ct == TOPJ_UINT32(0) {
								*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
								ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									ct = TOPJ_UINT32(7)
								}
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
								c = TOPJ_UINT32(0)
							}
						}
					} else {
						{
							if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										{
											for __ccgo := true; __ccgo; __ccgo = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}
									} else {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
								}
							} else {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									} else {
										a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									{
										for __ccgo1 := true; __ccgo1; __ccgo1 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											a <<= 1
											c <<= 1
											ct--
											if ct == TOPJ_UINT32(0) {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
												Xopj_mqc_byteout(tls, mqc)
												c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
												ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
											}
										}
									}

								}
							}
						}
					}
					flagsUpdated = flagsUpdated | uint32(uint32(1)<<20)<<(uint32(0)*3)
				}
			}

			{
				var v TOPJ_UINT32
				if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) == uint32(uint32(1)<<4)<<(uint32(1)*3) {
					var shift_flags TOPJ_UINT32 = flags >> (uint32(1) * 3)
					var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, shift_flags)
					var abs_data TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(datap + 1*4))) & 0x7FFFFFFF
					*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_ref(tls, abs_data, TOPJ_UINT32(bpno)))
					if TOPJ_INT32(abs_data)&one != 0 {
						v = uint32(1)
					} else {
						v = uint32(0)
					} /* #ifdef DEBUG_ENC_REF */ /*        fprintf(stderr, "  ctxt=%d\n", ctxt); */ /* #endif */
					curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt)*8
					if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
						{
							if ct == DBYPASS_CT_INIT {
								ct = TOPJ_UINT32(8)
							}
							ct--
							c = c + v<<ct
							if ct == TOPJ_UINT32(0) {
								*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
								ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									ct = TOPJ_UINT32(7)
								}
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
								c = TOPJ_UINT32(0)
							}
						}
					} else {
						{
							if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										{
											for __ccgo2 := true; __ccgo2; __ccgo2 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}
									} else {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
								}
							} else {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									} else {
										a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									{
										for __ccgo3 := true; __ccgo3; __ccgo3 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											a <<= 1
											c <<= 1
											ct--
											if ct == TOPJ_UINT32(0) {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
												Xopj_mqc_byteout(tls, mqc)
												c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
												ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
											}
										}
									}

								}
							}
						}
					}
					flagsUpdated = flagsUpdated | uint32(uint32(1)<<20)<<(uint32(1)*3)
				}
			}

			{
				var v TOPJ_UINT32
				if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) == uint32(uint32(1)<<4)<<(uint32(2)*3) {
					var shift_flags TOPJ_UINT32 = flags >> (uint32(2) * 3)
					var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, shift_flags)
					var abs_data TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(datap + 2*4))) & 0x7FFFFFFF
					*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_ref(tls, abs_data, TOPJ_UINT32(bpno)))
					if TOPJ_INT32(abs_data)&one != 0 {
						v = uint32(1)
					} else {
						v = uint32(0)
					} /* #ifdef DEBUG_ENC_REF */ /*        fprintf(stderr, "  ctxt=%d\n", ctxt); */ /* #endif */
					curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt)*8
					if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
						{
							if ct == DBYPASS_CT_INIT {
								ct = TOPJ_UINT32(8)
							}
							ct--
							c = c + v<<ct
							if ct == TOPJ_UINT32(0) {
								*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
								ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									ct = TOPJ_UINT32(7)
								}
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
								c = TOPJ_UINT32(0)
							}
						}
					} else {
						{
							if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										{
											for __ccgo4 := true; __ccgo4; __ccgo4 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}
									} else {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
								}
							} else {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									} else {
										a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									{
										for __ccgo5 := true; __ccgo5; __ccgo5 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											a <<= 1
											c <<= 1
											ct--
											if ct == TOPJ_UINT32(0) {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
												Xopj_mqc_byteout(tls, mqc)
												c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
												ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
											}
										}
									}

								}
							}
						}
					}
					flagsUpdated = flagsUpdated | uint32(uint32(1)<<20)<<(uint32(2)*3)
				}
			}

			{
				var v TOPJ_UINT32
				if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) == uint32(uint32(1)<<4)<<(uint32(3)*3) {
					var shift_flags TOPJ_UINT32 = flags >> (uint32(3) * 3)
					var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, shift_flags)
					var abs_data TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(datap + 3*4))) & 0x7FFFFFFF
					*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_ref(tls, abs_data, TOPJ_UINT32(bpno)))
					if TOPJ_INT32(abs_data)&one != 0 {
						v = uint32(1)
					} else {
						v = uint32(0)
					} /* #ifdef DEBUG_ENC_REF */ /*        fprintf(stderr, "  ctxt=%d\n", ctxt); */ /* #endif */
					curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt)*8
					if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
						{
							if ct == DBYPASS_CT_INIT {
								ct = TOPJ_UINT32(8)
							}
							ct--
							c = c + v<<ct
							if ct == TOPJ_UINT32(0) {
								*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
								ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									ct = TOPJ_UINT32(7)
								}
								(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
								c = TOPJ_UINT32(0)
							}
						}
					} else {
						{
							if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										{
											for __ccgo6 := true; __ccgo6; __ccgo6 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}
									} else {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
								}
							} else {
								{
									a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									} else {
										a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									}
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									{
										for __ccgo7 := true; __ccgo7; __ccgo7 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											a <<= 1
											c <<= 1
											ct--
											if ct == TOPJ_UINT32(0) {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
												Xopj_mqc_byteout(tls, mqc)
												c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
												ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
											}
										}
									}

								}
							}
						}
					}
					flagsUpdated = flagsUpdated | uint32(uint32(1)<<20)<<(uint32(3)*3)
				}
			}

			*(*Topj_flag_t)(unsafe.Pointer(f)) = flagsUpdated

		}
		goto __5
	__5:
		i++
		f += 4
		datap += 4 * uintptr(4)
		goto __4
		goto __6
	__6:
	}
	goto __2
__2:
	k = k + TOPJ_UINT32(4)
	f += 4 * uintptr(extra)
	goto __1
	goto __3
__3:
	;

	if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
		var j TOPJ_UINT32
		var remaining_lines TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fh - k
		i = TOPJ_UINT32(0)
	__7:
		if !(i < (*Topj_t1_t)(unsafe.Pointer(t1)).Fw) {
			goto __9
		}
		{
			if *(*Topj_flag_t)(unsafe.Pointer(f))&(uint32(1)<<4|uint32(1)<<7|uint32(1)<<10|uint32(1)<<13) == Topj_flag_t(0) {
				// none significant
				datap += 4 * uintptr(remaining_lines)
				goto __8
			}
			j = TOPJ_UINT32(0)
		__10:
			if !(j < remaining_lines) {
				goto __12
			}
			{
				{
					var v TOPJ_UINT32
					if *(*Topj_flag_t)(unsafe.Pointer(f))&(uint32(uint32(1)<<4|uint32(1)<<21)<<(j*3)) == uint32(uint32(1)<<4)<<(j*3) {
						var shift_flags TOPJ_UINT32 = *(*Topj_flag_t)(unsafe.Pointer(f)) >> (j * 3)
						var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, shift_flags)
						var abs_data TOPJ_UINT32 = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(datap))) & 0x7FFFFFFF
						*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_ref(tls, abs_data, TOPJ_UINT32(bpno)))
						if TOPJ_INT32(abs_data)&one != 0 {
							v = uint32(1)
						} else {
							v = uint32(0)
						} /* #ifdef DEBUG_ENC_REF */ /*        fprintf(stderr, "  ctxt=%d\n", ctxt); */ /* #endif */
						curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt)*8
						if int32(type1) == DT1_TYPE_RAW { /* BYPASS/LAZY MODE */
							{
								if ct == DBYPASS_CT_INIT {
									ct = TOPJ_UINT32(8)
								}
								ct--
								c = c + v<<ct
								if ct == TOPJ_UINT32(0) {
									*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)) = TOPJ_BYTE(c)
									ct = TOPJ_UINT32(8) /* If the previous byte was 0xff, make sure that the next msb is 0 */
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										ct = TOPJ_UINT32(7)
									}
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									c = TOPJ_UINT32(0)
								}
							}
						} else {
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo8 := true; __ccgo8; __ccgo8 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo9 := true; __ccgo9; __ccgo9 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
						}
						*(*Topj_flag_t)(unsafe.Pointer(f)) |= uint32(uint32(1)<<20) << (j * 3)
					}
				}

			}
			goto __11
		__11:
			j++
			datap += 4
			goto __10
			goto __12
		__12:
		}
		goto __8
	__8:
		i++
		f += 4
		goto __7
		goto __9
	__9:
	}

	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct

}

func opj_t1_dec_refpass_raw(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:926:13: */
	var one TOPJ_INT32
	var poshalf TOPJ_INT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var k TOPJ_UINT32
	var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
	var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr(TOPJ_UINT32(0+1)+TOPJ_UINT32(0/4+1)*((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2)))*4
	var l_w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
	one = int32(1) << bpno
	poshalf = one >> 1
	k = TOPJ_UINT32(0)
__1:
	if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
		goto __3
	}
	{
		i = TOPJ_UINT32(0)
	__4:
		if !(i < l_w) {
			goto __6
		}
		{
			var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
			if flags != Topj_flag_t(0) {
				opj_t1_dec_refpass_step_raw(tls,
					t1,
					flagsp,
					data,
					poshalf,
					0)
				opj_t1_dec_refpass_step_raw(tls,
					t1,
					flagsp,
					data+uintptr(l_w)*4,
					poshalf,
					1)
				opj_t1_dec_refpass_step_raw(tls,
					t1,
					flagsp,
					data+uintptr(TOPJ_UINT32(2)*l_w)*4,
					poshalf,
					2)
				opj_t1_dec_refpass_step_raw(tls,
					t1,
					flagsp,
					data+uintptr(TOPJ_UINT32(3)*l_w)*4,
					poshalf,
					3)
			}

		}
		goto __5
	__5:
		i++
		flagsp += 4
		data += 4
		goto __4
		goto __6
	__6:
	}
	goto __2
__2:
	k = k + TOPJ_UINT32(4)
	flagsp += 4 * uintptr(2)
	data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
	goto __1
	goto __3
__3:
	;
	if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
		i = TOPJ_UINT32(0)
	__7:
		if !(i < l_w) {
			goto __9
		}
		{
			for j = TOPJ_UINT32(0); j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k; j++ {
				opj_t1_dec_refpass_step_raw(tls,
					t1,
					flagsp,
					data+uintptr(j*l_w)*4,
					poshalf,
					j)
			}

		}
		goto __8
	__8:
		i++
		flagsp += 4
		data += 4
		goto __7
		goto __9
	__9:
	}
}

func opj_t1_dec_refpass_mqc_64x64(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:1024:13: */
	{
		var one TOPJ_INT32
		var poshalf TOPJ_INT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + 67*4
		var l_w TOPJ_UINT32 = TOPJ_UINT32(64)
		var mqc uintptr = t1
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		poshalf = one >> 1
		k = TOPJ_UINT32(0)
	__1:
		if !(k < uint32(64)&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags != Topj_flag_t(0) {
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) == uint32(uint32(1)<<4)<<(uint32(0)*3) {
							var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, flags>>(uint32(0)*3))
							curctx = mqc + 40 + uintptr(ctxt)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) += func() int32 {
								if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) < 0)) != 0 {
									return poshalf
								}
								return -poshalf
							}()
							flags = flags | uint32(uint32(1)<<20)<<(uint32(0)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) == uint32(uint32(1)<<4)<<(uint32(1)*3) {
							var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, flags>>(uint32(1)*3))
							curctx = mqc + 40 + uintptr(ctxt)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) += func() int32 {
								if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) < 0)) != 0 {
									return poshalf
								}
								return -poshalf
							}()
							flags = flags | uint32(uint32(1)<<20)<<(uint32(1)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) == uint32(uint32(1)<<4)<<(uint32(2)*3) {
							var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, flags>>(uint32(2)*3))
							curctx = mqc + 40 + uintptr(ctxt)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) += func() int32 {
								if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) < 0)) != 0 {
									return poshalf
								}
								return -poshalf
							}()
							flags = flags | uint32(uint32(1)<<20)<<(uint32(2)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) == uint32(uint32(1)<<4)<<(uint32(3)*3) {
							var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, flags>>(uint32(3)*3))
							curctx = mqc + 40 + uintptr(ctxt)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo6 := true; __ccgo6; __ccgo6 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) += func() int32 {
								if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) < 0)) != 0 {
									return poshalf
								}
								return -poshalf
							}()
							flags = flags | uint32(uint32(1)<<20)<<(uint32(3)*3)
						}
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags
				}
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < TOPJ_UINT32(64) {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < TOPJ_UINT32(64)-k; j++ {
					opj_t1_dec_refpass_step_mqc(tls, t1, flagsp, data+uintptr(j*l_w)*4, poshalf, j)
				}
			}
			goto __8
		__8:
			i++
			data += 4
			flagsp += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_refpass_mqc_generic(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:1031:13: */
	{
		var one TOPJ_INT32
		var poshalf TOPJ_INT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2+TOPJ_UINT32(1))*4
		var l_w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
		var mqc uintptr = t1
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		poshalf = one >> 1
		k = TOPJ_UINT32(0)
	__1:
		if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags != Topj_flag_t(0) {
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) == uint32(uint32(1)<<4)<<(uint32(0)*3) {
							var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, flags>>(uint32(0)*3))
							curctx = mqc + 40 + uintptr(ctxt)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) += func() int32 {
								if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) < 0)) != 0 {
									return poshalf
								}
								return -poshalf
							}()
							flags = flags | uint32(uint32(1)<<20)<<(uint32(0)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) == uint32(uint32(1)<<4)<<(uint32(1)*3) {
							var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, flags>>(uint32(1)*3))
							curctx = mqc + 40 + uintptr(ctxt)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) += func() int32 {
								if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) < 0)) != 0 {
									return poshalf
								}
								return -poshalf
							}()
							flags = flags | uint32(uint32(1)<<20)<<(uint32(1)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) == uint32(uint32(1)<<4)<<(uint32(2)*3) {
							var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, flags>>(uint32(2)*3))
							curctx = mqc + 40 + uintptr(ctxt)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) += func() int32 {
								if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) < 0)) != 0 {
									return poshalf
								}
								return -poshalf
							}()
							flags = flags | uint32(uint32(1)<<20)<<(uint32(2)*3)
						}
					}
					{
						if flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) == uint32(uint32(1)<<4)<<(uint32(3)*3) {
							var ctxt TOPJ_UINT32 = opj_t1_getctxno_mag(tls, flags>>(uint32(3)*3))
							curctx = mqc + 40 + uintptr(ctxt)*8
							{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
								a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									{
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										}
									}
									{
										for __ccgo6 := true; __ccgo6; __ccgo6 = a < TOPJ_UINT32(0x8000) {
											if ct == TOPJ_UINT32(0) {
												{
													var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
													l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
													if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
														if l_c > TOPJ_UINT32(0x8f) {
															c = c + TOPJ_UINT32(0xff00)
															ct = TOPJ_UINT32(8)
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<9
															ct = TOPJ_UINT32(7)
														}
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<8
														ct = TOPJ_UINT32(8)
													}
												}
											}
											a <<= 1
											c <<= 1
											ct--
										}
									}
								} else {
									c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
									if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										{
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											}
										}
										{
											for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
												if ct == TOPJ_UINT32(0) {
													{
														var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
														l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
														if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
															if l_c > TOPJ_UINT32(0x8f) {
																c = c + TOPJ_UINT32(0xff00)
																ct = TOPJ_UINT32(8)
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<9
																ct = TOPJ_UINT32(7)
															}
														} else {
															(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
															c = c + l_c<<8
															ct = TOPJ_UINT32(8)
														}
													}
												}
												a <<= 1
												c <<= 1
												ct--
											}
										}
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									}
								}
							}
							*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) += func() int32 {
								if v^TOPJ_UINT32(libc.Bool32(*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) < 0)) != 0 {
									return poshalf
								}
								return -poshalf
							}()
							flags = flags | uint32(uint32(1)<<20)<<(uint32(3)*3)
						}
					}
					*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags
				}
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k; j++ {
					opj_t1_dec_refpass_step_mqc(tls, t1, flagsp, data+uintptr(j*l_w)*4, poshalf, j)
				}
			}
			goto __8
		__8:
			i++
			data += 4
			flagsp += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_refpass_mqc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:1038:13: */
	if (*Topj_t1_t)(unsafe.Pointer(t1)).Fw == TOPJ_UINT32(64) && (*Topj_t1_t)(unsafe.Pointer(t1)).Fh == TOPJ_UINT32(64) {
		opj_t1_dec_refpass_mqc_64x64(tls, t1, bpno)
	} else {
		opj_t1_dec_refpass_mqc_generic(tls, t1, bpno)
	}
}

//*
// Encode clean-up pass step

func opj_t1_dec_clnpass_step(tls *libc.TLS, t1 uintptr, flagsp uintptr, datap uintptr, oneplushalf TOPJ_INT32, ci TOPJ_UINT32, vsc TOPJ_UINT32) { /* t1.c:1147:13: */
	var v TOPJ_UINT32

	var mqc uintptr = t1 /* MQC component */
	{
		if !(1 != 0) || !(*(*Topj_flag_t)(unsafe.Pointer(flagsp))&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) != 0) {
			for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
				if !(0 != 0) {
					var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, *(*Topj_flag_t)(unsafe.Pointer(flagsp))>>(ci*3)))
					(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40 + uintptr(ctxt1)*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
							{
								if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
									*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
								} else {
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
								}
							}
							{
								for __ccgo1 := true; __ccgo1; __ccgo1 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
									if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											}
										}
									}
									libc.AssignShlPtrUint32(mqc+4, int(1))
									libc.AssignShlPtrUint32(mqc, int(1))
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
								}
							}
						} else {
							*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
										*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
									}
								}
								{
									for __ccgo2 := true; __ccgo2; __ccgo2 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
										if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
												}
											}
										}
										libc.AssignShlPtrUint32(mqc+4, int(1))
										libc.AssignShlPtrUint32(mqc, int(1))
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
							}
						}
					}
					if !(v != 0) {
						break
					}
				}
				{
					var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
					(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
							{
								if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
									*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
								} else {
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
								}
							}
							{
								for __ccgo3 := true; __ccgo3; __ccgo3 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
									if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											}
										}
									}
									libc.AssignShlPtrUint32(mqc+4, int(1))
									libc.AssignShlPtrUint32(mqc, int(1))
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
								}
							}
						} else {
							*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
										*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
									}
								}
								{
									for __ccgo4 := true; __ccgo4; __ccgo4 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
										if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
												}
											}
										}
										libc.AssignShlPtrUint32(mqc+4, int(1))
										libc.AssignShlPtrUint32(mqc, int(1))
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
							}
						}
					}
					v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
					*(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(ci*TOPJ_UINT32(0))*4)) = func() int32 {
						if v != 0 {
							return -oneplushalf
						}
						return oneplushalf
					}()
					{ /* east */
						*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * ci) /* mark target as significant */
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) |= (v<<DT1_CHI_1_I | uint32(1)<<4) << (3 * ci)                    /* west */
						*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * ci)                         /* north-west, north, north-east */
						if ci == 0 && !(vsc != 0) {
							var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
							*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
							*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
							*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
						} /* south-west, south, south-east */
						if ci == 3 {
							var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
							*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
							*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
							*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
						}
					}

				}
			}
		}
	}

}

func opj_t1_enc_clnpass(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32, nmsedec uintptr, cblksty TOPJ_UINT32) { /* t1.c:1164:13: */
	var i TOPJ_UINT32
	var k TOPJ_UINT32
	var one TOPJ_INT32 = int32(1) << (bpno + (DT1_NMSEDEC_BITS - 1))
	var mqc uintptr = t1
	var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
	var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
	var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
	var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
	var datap uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
	var f uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr(TOPJ_UINT32(0+1)+TOPJ_UINT32(0/4+1)*((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+TOPJ_UINT32(2)))*4
	var extra TOPJ_UINT32 = 2

	*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) = 0
	k = TOPJ_UINT32(0)
__1:
	if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
		goto __3
	}
	{
		i = TOPJ_UINT32(0)
	__4:
		if !(i < (*Topj_t1_t)(unsafe.Pointer(t1)).Fw) {
			goto __6
		}
		{
			var agg TOPJ_UINT32
			var runlen TOPJ_UINT32
			agg = libc.BoolUint32(!(*(*Topj_flag_t)(unsafe.Pointer(f)) != 0))
			if agg != 0 {
				runlen = TOPJ_UINT32(0)
			__7:
				if !(runlen < TOPJ_UINT32(4)) {
					goto __9
				}
				{
					if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(datap)))&0x7FFFFFFF&TOPJ_UINT32(one) != 0 {
						goto __9
					}

				}
				goto __8
			__8:
				runlen++
				datap += 4
				goto __7
				goto __9
			__9:
				;
				curctx = mqc + 40 + 17*8
				{
					if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == TOPJ_UINT32(libc.Bool32(runlen != TOPJ_UINT32(4))) {
						{
							a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								} else {
									c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								}
								*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								{
									for __ccgo := true; __ccgo; __ccgo = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										a <<= 1
										c <<= 1
										ct--
										if ct == TOPJ_UINT32(0) {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
											Xopj_mqc_byteout(tls, mqc)
											c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
											ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
										}
									}
								}
							} else {
								c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							}
						}
					} else {
						{
							a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
								c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							} else {
								a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							}
							*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
							{
								for __ccgo1 := true; __ccgo1; __ccgo1 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
									a <<= 1
									c <<= 1
									ct--
									if ct == TOPJ_UINT32(0) {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
										Xopj_mqc_byteout(tls, mqc)
										c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
										ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
									}
								}
							}

						}
					}
				}

				if runlen == TOPJ_UINT32(4) {
					goto __5
				}
				curctx = mqc + 40 + 18*8
				{
					if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == runlen>>1 {
						{
							a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								} else {
									c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								}
								*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								{
									for __ccgo2 := true; __ccgo2; __ccgo2 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										a <<= 1
										c <<= 1
										ct--
										if ct == TOPJ_UINT32(0) {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
											Xopj_mqc_byteout(tls, mqc)
											c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
											ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
										}
									}
								}
							} else {
								c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							}
						}
					} else {
						{
							a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
								c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							} else {
								a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							}
							*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
							{
								for __ccgo3 := true; __ccgo3; __ccgo3 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
									a <<= 1
									c <<= 1
									ct--
									if ct == TOPJ_UINT32(0) {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
										Xopj_mqc_byteout(tls, mqc)
										c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
										ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
									}
								}
							}

						}
					}
				}

				{
					if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == runlen&TOPJ_UINT32(1) {
						{
							a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								} else {
									c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
								}
								*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								{
									for __ccgo4 := true; __ccgo4; __ccgo4 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
										a <<= 1
										c <<= 1
										ct--
										if ct == TOPJ_UINT32(0) {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
											Xopj_mqc_byteout(tls, mqc)
											c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
											ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
										}
									}
								}
							} else {
								c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							}
						}
					} else {
						{
							a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
								c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							} else {
								a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
							}
							*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
							{
								for __ccgo5 := true; __ccgo5; __ccgo5 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
									a <<= 1
									c <<= 1
									ct--
									if ct == TOPJ_UINT32(0) {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
										Xopj_mqc_byteout(tls, mqc)
										c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
										ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
									}
								}
							}

						}
					}
				}

			} else {
				runlen = TOPJ_UINT32(0)
			}
			{
				var v TOPJ_UINT32
				var ci TOPJ_UINT32
				var flagsp uintptr = f
				var l_datap uintptr = datap
				var check TOPJ_UINT32 = uint32(1)<<4 | uint32(1)<<7 | uint32(1)<<10 | uint32(1)<<13 | uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30
				if *(*Topj_flag_t)(unsafe.Pointer(flagsp))&check == check {
					if runlen == TOPJ_UINT32(0) {
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
					} else if runlen == TOPJ_UINT32(1) {
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
					} else if runlen == TOPJ_UINT32(2) {
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<27 | uint32(1)<<30)
					} else if runlen == TOPJ_UINT32(3) {
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1) << 30)
					}
				} else {
					for ci = runlen; ci < 4; ci++ {
						var goto_PARTIAL TOPJ_BOOL = DOPJ_FALSE
						if agg != TOPJ_UINT32(0) && ci == runlen {
							goto_PARTIAL = DOPJ_TRUE
						} else if !(*(*Topj_flag_t)(unsafe.Pointer(flagsp))&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) != 0) {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, *(*Topj_flag_t)(unsafe.Pointer(flagsp))>>(ci*3))) /* #ifdef DEBUG_ENC_CLN */ /*            printf("   ctxt1=%d\n", ctxt1); */ /* #endif */
							curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
							if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF&TOPJ_UINT32(one) != 0 {
								v = uint32(1)
							} else {
								v = uint32(0)
							}
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo6 := true; __ccgo6; __ccgo6 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo7 := true; __ccgo7; __ccgo7 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
							if v != 0 {
								goto_PARTIAL = DOPJ_TRUE
							}
						}
						if goto_PARTIAL != 0 {
							var vsc TOPJ_UINT32
							var ctxt2 TOPJ_UINT32
							var spb TOPJ_UINT32
							var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
							*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_sig(tls, TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF, TOPJ_UINT32(bpno)))
							ctxt2 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)) /* #ifdef DEBUG_ENC_CLN */ /*           printf("   ctxt2=%d\n", ctxt2); */ /* #endif */
							curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt2)*8
							v = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap))) >> 31
							spb = TOPJ_UINT32(opj_t1_getspb(tls, lu)) /* #ifdef DEBUG_ENC_CLN */ /*           printf("   spb=%d\n", spb); */ /* #endif */
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v^spb {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo8 := true; __ccgo8; __ccgo8 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo9 := true; __ccgo9; __ccgo9 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
							if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_VSC) != 0 && ci == TOPJ_UINT32(0) {
								vsc = uint32(1)
							} else {
								vsc = uint32(0)
							}
							opj_t1_update_flags(tls, flagsp, ci, v, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2, vsc)
						}
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= ^(uint32(uint32(1)<<21) << (3 * ci))
						l_datap += 4
					}
				}
			}

			datap += 4 * uintptr(TOPJ_UINT32(4)-runlen)

		}
		goto __5
	__5:
		i++
		f += 4
		goto __4
		goto __6
	__6:
	}
	goto __2
__2:
	k = k + TOPJ_UINT32(4)
	f += 4 * uintptr(extra)
	goto __1
	goto __3
__3:
	;
	if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
		var agg TOPJ_UINT32 = TOPJ_UINT32(0)
		var runlen TOPJ_UINT32 = TOPJ_UINT32(0)
		i = TOPJ_UINT32(0)
	__10:
		if !(i < (*Topj_t1_t)(unsafe.Pointer(t1)).Fw) {
			goto __12
		}
		{
			{
				var v TOPJ_UINT32
				var ci TOPJ_UINT32
				var flagsp uintptr = f
				var l_datap uintptr = datap
				var check TOPJ_UINT32 = uint32(1)<<4 | uint32(1)<<7 | uint32(1)<<10 | uint32(1)<<13 | uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30
				if *(*Topj_flag_t)(unsafe.Pointer(flagsp))&check == check {
					if runlen == TOPJ_UINT32(0) {
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
					} else if runlen == TOPJ_UINT32(1) {
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
					} else if runlen == TOPJ_UINT32(2) {
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<27 | uint32(1)<<30)
					} else if runlen == TOPJ_UINT32(3) {
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1) << 30)
					}
				} else {
					for ci = runlen; ci < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k; ci++ {
						var goto_PARTIAL TOPJ_BOOL = DOPJ_FALSE
						if agg != TOPJ_UINT32(0) && ci == runlen {
							goto_PARTIAL = DOPJ_TRUE
						} else if !(*(*Topj_flag_t)(unsafe.Pointer(flagsp))&(uint32(uint32(1)<<4|uint32(1)<<21)<<(ci*3)) != 0) {
							var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, *(*Topj_flag_t)(unsafe.Pointer(flagsp))>>(ci*3))) /* #ifdef DEBUG_ENC_CLN */ /*            printf("   ctxt1=%d\n", ctxt1); */ /* #endif */
							curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
							if TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF&TOPJ_UINT32(one) != 0 {
								v = uint32(1)
							} else {
								v = uint32(0)
							}
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo10 := true; __ccgo10; __ccgo10 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo11 := true; __ccgo11; __ccgo11 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
							if v != 0 {
								goto_PARTIAL = DOPJ_TRUE
							}
						}
						if goto_PARTIAL != 0 {
							var vsc TOPJ_UINT32
							var ctxt2 TOPJ_UINT32
							var spb TOPJ_UINT32
							var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, *(*Topj_flag_t)(unsafe.Pointer(flagsp)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), ci)
							*(*TOPJ_INT32)(unsafe.Pointer(nmsedec)) += TOPJ_INT32(opj_t1_getnmsedec_sig(tls, TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap)))&0x7FFFFFFF, TOPJ_UINT32(bpno)))
							ctxt2 = TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)) /* #ifdef DEBUG_ENC_CLN */ /*           printf("   ctxt2=%d\n", ctxt2); */ /* #endif */
							curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt2)*8
							v = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(l_datap))) >> 31
							spb = TOPJ_UINT32(opj_t1_getspb(tls, lu)) /* #ifdef DEBUG_ENC_CLN */ /*           printf("   spb=%d\n", spb); */ /* #endif */
							{
								if (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps == v^spb {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
											if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											} else {
												c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											}
											*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
											{
												for __ccgo12 := true; __ccgo12; __ccgo12 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													a <<= 1
													c <<= 1
													ct--
													if ct == TOPJ_UINT32(0) {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
														Xopj_mqc_byteout(tls, mqc)
														c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
														ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
													}
												}
											}
										} else {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
									}
								} else {
									{
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											c = c + (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										} else {
											a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										}
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
										{
											for __ccgo13 := true; __ccgo13; __ccgo13 = a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												a <<= 1
												c <<= 1
												ct--
												if ct == TOPJ_UINT32(0) {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
													Xopj_mqc_byteout(tls, mqc)
													c = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
													ct = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
												}
											}
										}

									}
								}
							}
							if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_VSC) != 0 && ci == TOPJ_UINT32(0) {
								vsc = uint32(1)
							} else {
								vsc = uint32(0)
							}
							opj_t1_update_flags(tls, flagsp, ci, v, (*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2, vsc)
						}
						*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= ^(uint32(uint32(1)<<21) << (3 * ci))
						l_datap += 4
					}
				}
			}

			datap += 4 * uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k)

		}
		goto __11
	__11:
		i++
		f += 4
		goto __10
		goto __12
	__12:
	}

	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct

}

func opj_t1_dec_clnpass_check_segsym(tls *libc.TLS, t1 uintptr, cblksty TOPJ_INT32) { /* t1.c:1344:13: */
	if cblksty&DJ2K_CCP_CBLKSTY_SEGSYM != 0 {
		var mqc uintptr = t1
		var v TOPJ_UINT32
		var v2 TOPJ_UINT32
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = mqc + 40 + 18*8
		{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
			if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
				{
					if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
						*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
					} else {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
						*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
					}
				}
				{
					for __ccgo := true; __ccgo; __ccgo = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
							{
								var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
								l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									if l_c > TOPJ_UINT32(0x8f) {
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
									}
								} else {
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
								}
							}
						}
						libc.AssignShlPtrUint32(mqc+4, int(1))
						libc.AssignShlPtrUint32(mqc, int(1))
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
					}
				}
			} else {
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
				if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
					{
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
							v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
						} else {
							v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
						}
					}
					{
						for __ccgo1 := true; __ccgo1; __ccgo1 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
								{
									var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
									l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										if l_c > TOPJ_UINT32(0x8f) {
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
										}
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
									}
								}
							}
							libc.AssignShlPtrUint32(mqc+4, int(1))
							libc.AssignShlPtrUint32(mqc, int(1))
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
						}
					}
				} else {
					v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
				}
			}
		}

		{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
			if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
				{
					if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
						*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
					} else {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						v2 = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
						*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
					}
				}
				{
					for __ccgo2 := true; __ccgo2; __ccgo2 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
							{
								var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
								l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									if l_c > TOPJ_UINT32(0x8f) {
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
									}
								} else {
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
								}
							}
						}
						libc.AssignShlPtrUint32(mqc+4, int(1))
						libc.AssignShlPtrUint32(mqc, int(1))
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
					}
				}
			} else {
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
				if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
					{
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
							v2 = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
						} else {
							v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
						}
					}
					{
						for __ccgo3 := true; __ccgo3; __ccgo3 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
								{
									var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
									l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										if l_c > TOPJ_UINT32(0x8f) {
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
										}
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
									}
								}
							}
							libc.AssignShlPtrUint32(mqc+4, int(1))
							libc.AssignShlPtrUint32(mqc, int(1))
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
						}
					}
				} else {
					v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
				}
			}
		}

		v = v<<1 | v2
		{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
			if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
				{
					if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
						*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
					} else {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						v2 = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
						*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
					}
				}
				{
					for __ccgo4 := true; __ccgo4; __ccgo4 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
							{
								var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
								l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									if l_c > TOPJ_UINT32(0x8f) {
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
									}
								} else {
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
								}
							}
						}
						libc.AssignShlPtrUint32(mqc+4, int(1))
						libc.AssignShlPtrUint32(mqc, int(1))
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
					}
				}
			} else {
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
				if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
					{
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
							v2 = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
						} else {
							v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
						}
					}
					{
						for __ccgo5 := true; __ccgo5; __ccgo5 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
								{
									var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
									l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										if l_c > TOPJ_UINT32(0x8f) {
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
										}
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
									}
								}
							}
							libc.AssignShlPtrUint32(mqc+4, int(1))
							libc.AssignShlPtrUint32(mqc, int(1))
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
						}
					}
				} else {
					v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
				}
			}
		}

		v = v<<1 | v2
		{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
			*(*TOPJ_UINT32)(unsafe.Pointer(mqc + 4)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
			if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
				{
					if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
						*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
					} else {
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval
						v2 = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
						*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
					}
				}
				{
					for __ccgo6 := true; __ccgo6; __ccgo6 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
							{
								var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
								l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
								if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
									if l_c > TOPJ_UINT32(0x8f) {
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
									}
								} else {
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
									*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
									(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
								}
							}
						}
						libc.AssignShlPtrUint32(mqc+4, int(1))
						libc.AssignShlPtrUint32(mqc, int(1))
						(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
					}
				}
			} else {
				*(*TOPJ_UINT32)(unsafe.Pointer(mqc)) -= (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval << 16
				if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
					{
						if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fqeval {
							v2 = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps != 0))
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnlps
						} else {
							v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
							*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fnmps
						}
					}
					{
						for __ccgo7 := true; __ccgo7; __ccgo7 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa < TOPJ_UINT32(0x8000) {
							if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct == TOPJ_UINT32(0) {
								{
									var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
									l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
									if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
										if l_c > TOPJ_UINT32(0x8f) {
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += TOPJ_UINT32(0xff00)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
										} else {
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
											*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 9
											(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(7)
										}
									} else {
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
										*(*TOPJ_UINT32)(unsafe.Pointer(mqc /* &.c */)) += l_c << 8
										(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = TOPJ_UINT32(8)
									}
								}
							}
							libc.AssignShlPtrUint32(mqc+4, int(1))
							libc.AssignShlPtrUint32(mqc, int(1))
							(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct--
						}
					}
				} else {
					v2 = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx)))).Fmps
				}
			}
		}

		v = v<<1 | v2
		//
		//         if (v!=0xa) {
		//             opj_event_msg(t1->cinfo, EVT_WARNING, "Bad segmentation symbol %x\n", v);
		//         }
		//
	}
}

func opj_t1_dec_clnpass_64x64_novsc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:1365:13: */
	{
		var one TOPJ_INT32
		var half TOPJ_INT32
		var oneplushalf TOPJ_INT32
		var runlen TOPJ_UINT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var l_w TOPJ_UINT32 = TOPJ_UINT32(64)
		var mqc uintptr = t1
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + 67*4
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		half = one >> 1
		oneplushalf = one | half
		k = TOPJ_UINT32(0)
	__1:
		if !(k < uint32(64)&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags == Topj_flag_t(0) {
					var partial TOPJ_UINT32 = TOPJ_UINT32(DOPJ_TRUE)
					curctx = mqc + 40 + 17*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					if !(v != 0) {
						goto __5
					}
					curctx = mqc + 40 + 18*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									runlen = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										runlen = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					runlen = runlen<<1 | v
					switch runlen {
					case TOPJ_UINT32(0):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) != 0) {
								for __ccgo6 := true; __ccgo6; __ccgo6 = 0 != 0 {
									if !(1 != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
										curctx = mqc + 40 + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo8 := true; __ccgo8; __ccgo8 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo9 := true; __ccgo9; __ccgo9 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo10 := true; __ccgo10; __ccgo10 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
											if uint32(0) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(0) == 3 {
												var south uintptr = flagsp + uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(1):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) != 0) {
								for __ccgo11 := true; __ccgo11; __ccgo11 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo12 := true; __ccgo12; __ccgo12 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo13 := true; __ccgo13; __ccgo13 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo14 := true; __ccgo14; __ccgo14 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo15 := true; __ccgo15; __ccgo15 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
											if uint32(1) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(1) == 3 {
												var south uintptr = flagsp + uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(2):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) != 0) {
								for __ccgo16 := true; __ccgo16; __ccgo16 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo17 := true; __ccgo17; __ccgo17 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo18 := true; __ccgo18; __ccgo18 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo19 := true; __ccgo19; __ccgo19 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo20 := true; __ccgo20; __ccgo20 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
											if uint32(2) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(2) == 3 {
												var south uintptr = flagsp + uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(3):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) != 0) {
								for __ccgo21 := true; __ccgo21; __ccgo21 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo22 := true; __ccgo22; __ccgo22 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo23 := true; __ccgo23; __ccgo23 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo24 := true; __ccgo24; __ccgo24 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo25 := true; __ccgo25; __ccgo25 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
											if uint32(3) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(3) == 3 {
												var south uintptr = flagsp + uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						break
					}
				} else {
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) != 0) {
							for __ccgo26 := true; __ccgo26; __ccgo26 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo27 := true; __ccgo27; __ccgo27 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo28 := true; __ccgo28; __ccgo28 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo29 := true; __ccgo29; __ccgo29 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo30 := true; __ccgo30; __ccgo30 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
										if uint32(0) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(0) == 3 {
											var south uintptr = flagsp + uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) != 0) {
							for __ccgo31 := true; __ccgo31; __ccgo31 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo32 := true; __ccgo32; __ccgo32 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo33 := true; __ccgo33; __ccgo33 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo34 := true; __ccgo34; __ccgo34 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo35 := true; __ccgo35; __ccgo35 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
										if uint32(1) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(1) == 3 {
											var south uintptr = flagsp + uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) != 0) {
							for __ccgo36 := true; __ccgo36; __ccgo36 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo37 := true; __ccgo37; __ccgo37 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo38 := true; __ccgo38; __ccgo38 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo39 := true; __ccgo39; __ccgo39 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo40 := true; __ccgo40; __ccgo40 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
										if uint32(2) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(2) == 3 {
											var south uintptr = flagsp + uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) != 0) {
							for __ccgo41 := true; __ccgo41; __ccgo41 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo42 := true; __ccgo42; __ccgo42 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo43 := true; __ccgo43; __ccgo43 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo44 := true; __ccgo44; __ccgo44 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo45 := true; __ccgo45; __ccgo45 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
										if uint32(3) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(3) == 3 {
											var south uintptr = flagsp + uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
				}
				*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags & libc.CplUint32(uint32(1)<<21|uint32(1)<<24|uint32(1)<<27|uint32(1)<<30)
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < TOPJ_UINT32(64) {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < TOPJ_UINT32(64)-k; j++ {
					opj_t1_dec_clnpass_step(tls, t1, flagsp, data+uintptr(j*l_w)*4, oneplushalf, j, uint32(DOPJ_FALSE))
				}
				*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
			}
			goto __8
		__8:
			i++
			flagsp += 4
			data += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_clnpass_64x64_vsc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:1372:13: */
	{
		var one TOPJ_INT32
		var half TOPJ_INT32
		var oneplushalf TOPJ_INT32
		var runlen TOPJ_UINT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var l_w TOPJ_UINT32 = TOPJ_UINT32(64)
		var mqc uintptr = t1
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + 67*4
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		half = one >> 1
		oneplushalf = one | half
		k = TOPJ_UINT32(0)
	__1:
		if !(k < uint32(64)&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags == Topj_flag_t(0) {
					var partial TOPJ_UINT32 = TOPJ_UINT32(DOPJ_TRUE)
					curctx = mqc + 40 + 17*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					if !(v != 0) {
						goto __5
					}
					curctx = mqc + 40 + 18*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									runlen = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										runlen = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					runlen = runlen<<1 | v
					switch runlen {
					case TOPJ_UINT32(0):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) != 0) {
								for __ccgo6 := true; __ccgo6; __ccgo6 = 0 != 0 {
									if !(1 != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
										curctx = mqc + 40 + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo8 := true; __ccgo8; __ccgo8 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo9 := true; __ccgo9; __ccgo9 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo10 := true; __ccgo10; __ccgo10 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
											if uint32(0) == 0 && !(1 != 0) {
												var north uintptr = flagsp - uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(0) == 3 {
												var south uintptr = flagsp + uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(1):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) != 0) {
								for __ccgo11 := true; __ccgo11; __ccgo11 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo12 := true; __ccgo12; __ccgo12 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo13 := true; __ccgo13; __ccgo13 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo14 := true; __ccgo14; __ccgo14 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo15 := true; __ccgo15; __ccgo15 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
											if uint32(1) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(1) == 3 {
												var south uintptr = flagsp + uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(2):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) != 0) {
								for __ccgo16 := true; __ccgo16; __ccgo16 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo17 := true; __ccgo17; __ccgo17 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo18 := true; __ccgo18; __ccgo18 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo19 := true; __ccgo19; __ccgo19 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo20 := true; __ccgo20; __ccgo20 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
											if uint32(2) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(2) == 3 {
												var south uintptr = flagsp + uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(3):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) != 0) {
								for __ccgo21 := true; __ccgo21; __ccgo21 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo22 := true; __ccgo22; __ccgo22 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo23 := true; __ccgo23; __ccgo23 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo24 := true; __ccgo24; __ccgo24 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo25 := true; __ccgo25; __ccgo25 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
											if uint32(3) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(3) == 3 {
												var south uintptr = flagsp + uintptr(66)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						break
					}
				} else {
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) != 0) {
							for __ccgo26 := true; __ccgo26; __ccgo26 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo27 := true; __ccgo27; __ccgo27 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo28 := true; __ccgo28; __ccgo28 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo29 := true; __ccgo29; __ccgo29 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo30 := true; __ccgo30; __ccgo30 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
										if uint32(0) == 0 && !(1 != 0) {
											var north uintptr = flagsp - uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(0) == 3 {
											var south uintptr = flagsp + uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) != 0) {
							for __ccgo31 := true; __ccgo31; __ccgo31 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo32 := true; __ccgo32; __ccgo32 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo33 := true; __ccgo33; __ccgo33 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo34 := true; __ccgo34; __ccgo34 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo35 := true; __ccgo35; __ccgo35 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
										if uint32(1) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(1) == 3 {
											var south uintptr = flagsp + uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) != 0) {
							for __ccgo36 := true; __ccgo36; __ccgo36 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo37 := true; __ccgo37; __ccgo37 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo38 := true; __ccgo38; __ccgo38 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo39 := true; __ccgo39; __ccgo39 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo40 := true; __ccgo40; __ccgo40 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
										if uint32(2) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(2) == 3 {
											var south uintptr = flagsp + uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) != 0) {
							for __ccgo41 := true; __ccgo41; __ccgo41 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo42 := true; __ccgo42; __ccgo42 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo43 := true; __ccgo43; __ccgo43 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo44 := true; __ccgo44; __ccgo44 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo45 := true; __ccgo45; __ccgo45 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
										if uint32(3) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(3) == 3 {
											var south uintptr = flagsp + uintptr(66)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
				}
				*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags & libc.CplUint32(uint32(1)<<21|uint32(1)<<24|uint32(1)<<27|uint32(1)<<30)
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < TOPJ_UINT32(64) {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < TOPJ_UINT32(64)-k; j++ {
					opj_t1_dec_clnpass_step(tls, t1, flagsp, data+uintptr(j*l_w)*4, oneplushalf, j, uint32(DOPJ_TRUE))
				}
				*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
			}
			goto __8
		__8:
			i++
			flagsp += 4
			data += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_clnpass_generic_novsc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:1379:13: */
	{
		var one TOPJ_INT32
		var half TOPJ_INT32
		var oneplushalf TOPJ_INT32
		var runlen TOPJ_UINT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var l_w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
		var mqc uintptr = t1
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2+TOPJ_UINT32(1))*4
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		half = one >> 1
		oneplushalf = one | half
		k = TOPJ_UINT32(0)
	__1:
		if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags == Topj_flag_t(0) {
					var partial TOPJ_UINT32 = TOPJ_UINT32(DOPJ_TRUE)
					curctx = mqc + 40 + 17*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					if !(v != 0) {
						goto __5
					}
					curctx = mqc + 40 + 18*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									runlen = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										runlen = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					runlen = runlen<<1 | v
					switch runlen {
					case TOPJ_UINT32(0):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) != 0) {
								for __ccgo6 := true; __ccgo6; __ccgo6 = 0 != 0 {
									if !(1 != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
										curctx = mqc + 40 + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo8 := true; __ccgo8; __ccgo8 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo9 := true; __ccgo9; __ccgo9 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo10 := true; __ccgo10; __ccgo10 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
											if uint32(0) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(0) == 3 {
												var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(1):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) != 0) {
								for __ccgo11 := true; __ccgo11; __ccgo11 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo12 := true; __ccgo12; __ccgo12 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo13 := true; __ccgo13; __ccgo13 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo14 := true; __ccgo14; __ccgo14 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo15 := true; __ccgo15; __ccgo15 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
											if uint32(1) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(1) == 3 {
												var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(2):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) != 0) {
								for __ccgo16 := true; __ccgo16; __ccgo16 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo17 := true; __ccgo17; __ccgo17 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo18 := true; __ccgo18; __ccgo18 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo19 := true; __ccgo19; __ccgo19 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo20 := true; __ccgo20; __ccgo20 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
											if uint32(2) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(2) == 3 {
												var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(3):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) != 0) {
								for __ccgo21 := true; __ccgo21; __ccgo21 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo22 := true; __ccgo22; __ccgo22 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo23 := true; __ccgo23; __ccgo23 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo24 := true; __ccgo24; __ccgo24 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo25 := true; __ccgo25; __ccgo25 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
											if uint32(3) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(3) == 3 {
												var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						break
					}
				} else {
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) != 0) {
							for __ccgo26 := true; __ccgo26; __ccgo26 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo27 := true; __ccgo27; __ccgo27 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo28 := true; __ccgo28; __ccgo28 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo29 := true; __ccgo29; __ccgo29 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo30 := true; __ccgo30; __ccgo30 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
										if uint32(0) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(0) == 3 {
											var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) != 0) {
							for __ccgo31 := true; __ccgo31; __ccgo31 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo32 := true; __ccgo32; __ccgo32 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo33 := true; __ccgo33; __ccgo33 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo34 := true; __ccgo34; __ccgo34 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo35 := true; __ccgo35; __ccgo35 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
										if uint32(1) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(1) == 3 {
											var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) != 0) {
							for __ccgo36 := true; __ccgo36; __ccgo36 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo37 := true; __ccgo37; __ccgo37 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo38 := true; __ccgo38; __ccgo38 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo39 := true; __ccgo39; __ccgo39 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo40 := true; __ccgo40; __ccgo40 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
										if uint32(2) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(2) == 3 {
											var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) != 0) {
							for __ccgo41 := true; __ccgo41; __ccgo41 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo42 := true; __ccgo42; __ccgo42 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo43 := true; __ccgo43; __ccgo43 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo44 := true; __ccgo44; __ccgo44 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo45 := true; __ccgo45; __ccgo45 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
										if uint32(3) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(3) == 3 {
											var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
				}
				*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags & libc.CplUint32(uint32(1)<<21|uint32(1)<<24|uint32(1)<<27|uint32(1)<<30)
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k; j++ {
					opj_t1_dec_clnpass_step(tls, t1, flagsp, data+uintptr(j*l_w)*4, oneplushalf, j, uint32(DOPJ_FALSE))
				}
				*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
			}
			goto __8
		__8:
			i++
			flagsp += 4
			data += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_clnpass_generic_vsc(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32) { /* t1.c:1387:13: */
	{
		var one TOPJ_INT32
		var half TOPJ_INT32
		var oneplushalf TOPJ_INT32
		var runlen TOPJ_UINT32
		var i TOPJ_UINT32
		var j TOPJ_UINT32
		var k TOPJ_UINT32
		var l_w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
		var mqc uintptr = t1
		var data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		var flagsp uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2+TOPJ_UINT32(1))*4
		var curctx uintptr = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx
		var c TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc
		var a TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa
		var ct TOPJ_UINT32 = (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct
		var v TOPJ_UINT32
		one = int32(1) << bpno
		half = one >> 1
		oneplushalf = one | half
		k = TOPJ_UINT32(0)
	__1:
		if !(k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh&libc.CplUint32(3)) {
			goto __3
		}
		{
			i = TOPJ_UINT32(0)
		__4:
			if !(i < l_w) {
				goto __6
			}
			{
				var flags Topj_flag_t = *(*Topj_flag_t)(unsafe.Pointer(flagsp))
				if flags == Topj_flag_t(0) {
					var partial TOPJ_UINT32 = TOPJ_UINT32(DOPJ_TRUE)
					curctx = mqc + 40 + 17*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo := true; __ccgo; __ccgo = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo1 := true; __ccgo1; __ccgo1 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					if !(v != 0) {
						goto __5
					}
					curctx = mqc + 40 + 18*8
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									runlen = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo2 := true; __ccgo2; __ccgo2 = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										runlen = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo3 := true; __ccgo3; __ccgo3 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								runlen = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
						a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
						if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
							{
								if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
								} else {
									a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
									v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
									*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
								}
							}
							{
								for __ccgo4 := true; __ccgo4; __ccgo4 = a < TOPJ_UINT32(0x8000) {
									if ct == TOPJ_UINT32(0) {
										{
											var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
											l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
											if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
												if l_c > TOPJ_UINT32(0x8f) {
													c = c + TOPJ_UINT32(0xff00)
													ct = TOPJ_UINT32(8)
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<9
													ct = TOPJ_UINT32(7)
												}
											} else {
												(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
												c = c + l_c<<8
												ct = TOPJ_UINT32(8)
											}
										}
									}
									a <<= 1
									c <<= 1
									ct--
								}
							}
						} else {
							c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
							if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
								{
									if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
										v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
									} else {
										v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
										*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
									}
								}
								{
									for __ccgo5 := true; __ccgo5; __ccgo5 = a < TOPJ_UINT32(0x8000) {
										if ct == TOPJ_UINT32(0) {
											{
												var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
												l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
												if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
													if l_c > TOPJ_UINT32(0x8f) {
														c = c + TOPJ_UINT32(0xff00)
														ct = TOPJ_UINT32(8)
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
													} else {
														(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
														c = c + l_c<<9
														ct = TOPJ_UINT32(7)
													}
												} else {
													(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
													c = c + l_c<<8
													ct = TOPJ_UINT32(8)
												}
											}
										}
										a <<= 1
										c <<= 1
										ct--
									}
								}
							} else {
								v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
							}
						}
					}
					runlen = runlen<<1 | v
					switch runlen {
					case TOPJ_UINT32(0):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) != 0) {
								for __ccgo6 := true; __ccgo6; __ccgo6 = 0 != 0 {
									if !(1 != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
										curctx = mqc + 40 + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo7 := true; __ccgo7; __ccgo7 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo8 := true; __ccgo8; __ccgo8 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo9 := true; __ccgo9; __ccgo9 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo10 := true; __ccgo10; __ccgo10 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
											if uint32(0) == 0 && !(1 != 0) {
												var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(0) == 3 {
												var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(1):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) != 0) {
								for __ccgo11 := true; __ccgo11; __ccgo11 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo12 := true; __ccgo12; __ccgo12 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo13 := true; __ccgo13; __ccgo13 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo14 := true; __ccgo14; __ccgo14 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo15 := true; __ccgo15; __ccgo15 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
											if uint32(1) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(1) == 3 {
												var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(2):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) != 0) {
								for __ccgo16 := true; __ccgo16; __ccgo16 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo17 := true; __ccgo17; __ccgo17 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo18 := true; __ccgo18; __ccgo18 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo19 := true; __ccgo19; __ccgo19 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo20 := true; __ccgo20; __ccgo20 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
											if uint32(2) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(2) == 3 {
												var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						partial = TOPJ_UINT32(DOPJ_FALSE)
						fallthrough /* FALLTHRU */
					case TOPJ_UINT32(3):
						{
							if !(0 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) != 0) {
								for __ccgo21 := true; __ccgo21; __ccgo21 = 0 != 0 {
									if !(partial != 0) {
										var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
										curctx = mqc + 40 /* &.ctxs */ + uintptr(ctxt1)*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo22 := true; __ccgo22; __ccgo22 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo23 := true; __ccgo23; __ccgo23 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										if !(v != 0) {
											break
										}
									}
									{
										var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
										curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
										{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
											a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
											if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													} else {
														a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													}
												}
												{
													for __ccgo24 := true; __ccgo24; __ccgo24 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
												if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
													{
														if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
															v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
														} else {
															v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
															*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
														}
													}
													{
														for __ccgo25 := true; __ccgo25; __ccgo25 = a < TOPJ_UINT32(0x8000) {
															if ct == TOPJ_UINT32(0) {
																{
																	var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																	l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																	if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																		if l_c > TOPJ_UINT32(0x8f) {
																			c = c + TOPJ_UINT32(0xff00)
																			ct = TOPJ_UINT32(8)
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																		} else {
																			(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																			c = c + l_c<<9
																			ct = TOPJ_UINT32(7)
																		}
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<8
																		ct = TOPJ_UINT32(8)
																	}
																}
															}
															a <<= 1
															c <<= 1
															ct--
														}
													}
												} else {
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
												}
											}
										}
										v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
										*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
											if v != 0 {
												return -oneplushalf
											}
											return oneplushalf
										}()
										{ /* east */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
											flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
											*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
											if uint32(3) == 0 && !(0 != 0) {
												var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
												*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
												*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
											} /* south-west, south, south-east */
											if uint32(3) == 3 {
												var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
												*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
												*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
												*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
											}
										}

									}
								}
							}
						}
						break
					}
				} else {
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(0)*3)) != 0) {
							for __ccgo26 := true; __ccgo26; __ccgo26 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(0)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo27 := true; __ccgo27; __ccgo27 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo28 := true; __ccgo28; __ccgo28 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(0))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo29 := true; __ccgo29; __ccgo29 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo30 := true; __ccgo30; __ccgo30 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(0)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(0)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(0))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(0))                         /* north-west, north, north-east */
										if uint32(0) == 0 && !(1 != 0) {
											var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(0) == 3 {
											var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(1)*3)) != 0) {
							for __ccgo31 := true; __ccgo31; __ccgo31 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(1)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo32 := true; __ccgo32; __ccgo32 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo33 := true; __ccgo33; __ccgo33 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(1))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo34 := true; __ccgo34; __ccgo34 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo35 := true; __ccgo35; __ccgo35 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(1)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(1)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(1))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(1))                         /* north-west, north, north-east */
										if uint32(1) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(1) == 3 {
											var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(2)*3)) != 0) {
							for __ccgo36 := true; __ccgo36; __ccgo36 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(2)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo37 := true; __ccgo37; __ccgo37 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo38 := true; __ccgo38; __ccgo38 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(2))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo39 := true; __ccgo39; __ccgo39 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo40 := true; __ccgo40; __ccgo40 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(2)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(2)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(2))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(2))                         /* north-west, north, north-east */
										if uint32(2) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(2) == 3 {
											var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
					{
						if !(1 != 0) || !(flags&(uint32(uint32(1)<<4|uint32(1)<<21)<<(uint32(3)*3)) != 0) {
							for __ccgo41 := true; __ccgo41; __ccgo41 = 0 != 0 {
								if !(0 != 0) {
									var ctxt1 TOPJ_UINT32 = TOPJ_UINT32(opj_t1_getctxno_zc(tls, mqc, flags>>(uint32(3)*3)))
									curctx = mqc + 40 + uintptr(ctxt1)*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo42 := true; __ccgo42; __ccgo42 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo43 := true; __ccgo43; __ccgo43 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									if !(v != 0) {
										break
									}
								}
								{
									var lu TOPJ_UINT32 = opj_t1_getctxtno_sc_or_spb_index(tls, flags, *(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)), *(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)), uint32(3))
									curctx = mqc + 40 + uintptr(TOPJ_UINT32(opj_t1_getctxno_sc(tls, lu)))*8
									{ /* Implements ISO 15444-1 C.3.2 Decoding a decision (DECODE) */ /* Note: alternate "J.2 - Decoding an MPS or an LPS in the */ /* software-conventions decoder" has been tried, but does not bring any */ /* improvement. See https://github.com/uclouvain/openjpeg/issues/921 */
										a = a - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
										if c>>16 < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
											{
												if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
												} else {
													a = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval
													v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
													*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
												}
											}
											{
												for __ccgo44 := true; __ccgo44; __ccgo44 = a < TOPJ_UINT32(0x8000) {
													if ct == TOPJ_UINT32(0) {
														{
															var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
															l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
															if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																if l_c > TOPJ_UINT32(0x8f) {
																	c = c + TOPJ_UINT32(0xff00)
																	ct = TOPJ_UINT32(8)
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<9
																	ct = TOPJ_UINT32(7)
																}
															} else {
																(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																c = c + l_c<<8
																ct = TOPJ_UINT32(8)
															}
														}
													}
													a <<= 1
													c <<= 1
													ct--
												}
											}
										} else {
											c = c - (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval<<16
											if a&TOPJ_UINT32(0x8000) == TOPJ_UINT32(0) {
												{
													if a < (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fqeval {
														v = libc.BoolUint32(!((*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps != 0))
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnlps
													} else {
														v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
														*(*uintptr)(unsafe.Pointer(curctx)) = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fnmps
													}
												}
												{
													for __ccgo45 := true; __ccgo45; __ccgo45 = a < TOPJ_UINT32(0x8000) {
														if ct == TOPJ_UINT32(0) {
															{
																var l_c TOPJ_UINT32 /* Given opj_mqc_init_dec() we know that at some point we will */ /* have a 0xFF 0xFF artificial marker */
																l_c = TOPJ_UINT32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp + uintptr(1))))
																if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))) == 0xff {
																	if l_c > TOPJ_UINT32(0x8f) {
																		c = c + TOPJ_UINT32(0xff00)
																		ct = TOPJ_UINT32(8)
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter++
																	} else {
																		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																		c = c + l_c<<9
																		ct = TOPJ_UINT32(7)
																	}
																} else {
																	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp++
																	c = c + l_c<<8
																	ct = TOPJ_UINT32(8)
																}
															}
														}
														a <<= 1
														c <<= 1
														ct--
													}
												}
											} else {
												v = (*Topj_mqc_state_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(curctx)))).Fmps
											}
										}
									}
									v = v ^ TOPJ_UINT32(opj_t1_getspb(tls, lu))
									*(*TOPJ_INT32)(unsafe.Pointer(data + uintptr(TOPJ_UINT32(3)*l_w)*4)) = func() int32 {
										if v != 0 {
											return -oneplushalf
										}
										return oneplushalf
									}()
									{ /* east */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + libc.UintptrFromInt32(-1)*4)) |= uint32(uint32(1)<<5) << (3 * uint32(3)) /* mark target as significant */
										flags = flags | (v<<DT1_CHI_1_I|uint32(1)<<4)<<(3*uint32(3))                                                     /* west */
										*(*Topj_flag_t)(unsafe.Pointer(flagsp + 1*4)) |= uint32(uint32(1)<<3) << (3 * uint32(3))                         /* north-west, north, north-east */
										if uint32(3) == 0 && !(0 != 0) {
											var north uintptr = flagsp - uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(north)) |= v<<DT1_CHI_5_I | uint32(1)<<16
											*(*Topj_flag_t)(unsafe.Pointer(north + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 17
											*(*Topj_flag_t)(unsafe.Pointer(north + 1*4)) |= uint32(1) << 15
										} /* south-west, south, south-east */
										if uint32(3) == 3 {
											var south uintptr = flagsp + uintptr((*Topj_t1_t)(unsafe.Pointer(t1)).Fw+2)*4
											*(*Topj_flag_t)(unsafe.Pointer(south)) |= v<<DT1_CHI_0_I | uint32(1)<<1
											*(*Topj_flag_t)(unsafe.Pointer(south + libc.UintptrFromInt32(-1)*4)) |= uint32(1) << 2
											*(*Topj_flag_t)(unsafe.Pointer(south + 1*4)) |= uint32(1) << 0
										}
									}

								}
							}
						}
					}
				}
				*(*Topj_flag_t)(unsafe.Pointer(flagsp)) = flags & libc.CplUint32(uint32(1)<<21|uint32(1)<<24|uint32(1)<<27|uint32(1)<<30)
			}
			goto __5
		__5:
			i++
			data += 4
			flagsp += 4
			goto __4
			goto __6
		__6:
		}
		goto __2
	__2:
		k = k + TOPJ_UINT32(4)
		data += 4 * uintptr(TOPJ_UINT32(3)*l_w)
		flagsp += 4 * uintptr(2)
		goto __1
		goto __3
	__3:
		;
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fcurctx = curctx
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fc = c
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fa = a
		(*Topj_mqc_t)(unsafe.Pointer(mqc)).Fct = ct
		if k < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh {
			i = TOPJ_UINT32(0)
		__7:
			if !(i < l_w) {
				goto __9
			}
			{
				for j = TOPJ_UINT32(0); j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh-k; j++ {
					opj_t1_dec_clnpass_step(tls, t1, flagsp, data+uintptr(j*l_w)*4, oneplushalf, j, uint32(DOPJ_TRUE))
				}
				*(*Topj_flag_t)(unsafe.Pointer(flagsp)) &= libc.CplUint32(uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
			}
			goto __8
		__8:
			i++
			flagsp += 4
			data += 4
			goto __7
			goto __9
		__9:
		}
	}

}

func opj_t1_dec_clnpass(tls *libc.TLS, t1 uintptr, bpno TOPJ_INT32, cblksty TOPJ_INT32) { /* t1.c:1395:13: */
	if (*Topj_t1_t)(unsafe.Pointer(t1)).Fw == TOPJ_UINT32(64) && (*Topj_t1_t)(unsafe.Pointer(t1)).Fh == TOPJ_UINT32(64) {
		if cblksty&DJ2K_CCP_CBLKSTY_VSC != 0 {
			opj_t1_dec_clnpass_64x64_vsc(tls, t1, bpno)
		} else {
			opj_t1_dec_clnpass_64x64_novsc(tls, t1, bpno)
		}
	} else {
		if cblksty&DJ2K_CCP_CBLKSTY_VSC != 0 {
			opj_t1_dec_clnpass_generic_vsc(tls, t1, bpno)
		} else {
			opj_t1_dec_clnpass_generic_novsc(tls, t1, bpno)
		}
	}
	opj_t1_dec_clnpass_check_segsym(tls, t1, cblksty)
}

//* mod fixed_quality
func opj_t1_getwmsedec(tls *libc.TLS, nmsedec TOPJ_INT32, compno TOPJ_UINT32, level TOPJ_UINT32, orient TOPJ_UINT32, bpno TOPJ_INT32, qmfbid TOPJ_UINT32, stepsize TOPJ_FLOAT64, numcomps TOPJ_UINT32, mct_norms uintptr, mct_numcomps TOPJ_UINT32) TOPJ_FLOAT64 { /* t1.c:1418:20: */
	var w1 TOPJ_FLOAT64 = TOPJ_FLOAT64(1)
	var w2 TOPJ_FLOAT64
	var wmsedec TOPJ_FLOAT64
	_ = numcomps

	if mct_norms != 0 && compno < mct_numcomps {
		w1 = *(*TOPJ_FLOAT64)(unsafe.Pointer(mct_norms + uintptr(compno)*8))
	}

	if qmfbid == TOPJ_UINT32(1) {
		w2 = Xopj_dwt_getnorm(tls, level, orient)
	} else { // if (qmfbid == 0)
		var log2_gain TOPJ_INT32
		if orient == TOPJ_UINT32(0) {
			log2_gain = 0
		} else {
			if orient == TOPJ_UINT32(3) {
				log2_gain = 2
			} else {
				log2_gain = 1
			}
		}
		w2 = Xopj_dwt_getnorm_real(tls, level, orient)
		// Not sure this is right. But preserves past behaviour
		stepsize = stepsize / float64(int32(1)<<log2_gain)
	}

	wmsedec = w1 * w2 * stepsize * float64(int32(1)<<bpno)
	wmsedec = wmsedec * (wmsedec * float64(nmsedec) / 8192.0)

	return wmsedec
}

func opj_t1_allocate_buffers1(tls *libc.TLS, t1 uintptr, w TOPJ_UINT32, h TOPJ_UINT32) TOPJ_BOOL { /* t1.c:1453:17: */
	var flagssize TOPJ_UINT32
	var flags_stride TOPJ_UINT32

	// No risk of overflow. Prior checks ensure those assert are met
	// They are per the specification
	if w <= TOPJ_UINT32(1024) {
	} else {
		libc.X__assert_fail(tls, ts+2049, ts+32447, uint32(1463), uintptr(unsafe.Pointer(&__func__261)))
	}
	if h <= TOPJ_UINT32(1024) {
	} else {
		libc.X__assert_fail(tls, ts+2059, ts+32447, uint32(1464), uintptr(unsafe.Pointer(&__func__261)))
	}
	if w*h <= TOPJ_UINT32(4096) {
	} else {
		libc.X__assert_fail(tls, ts+2069, ts+32447, uint32(1465), uintptr(unsafe.Pointer(&__func__261)))
	}

	/* encoder uses tile buffer, so no need to allocate */
	{
		var datasize TOPJ_UINT32 = w * h

		if datasize > (*Topj_t1_t)(unsafe.Pointer(t1)).Fdatasize {
			Xopj_aligned_free(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata)
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fdata = Xopj_aligned_malloc(tls, uint32(datasize)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
			if !(int32((*Topj_t1_t)(unsafe.Pointer(t1)).Fdata) != 0) {
				// FIXME event manager error callback
				return DOPJ_FALSE
			}
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fdatasize = datasize
		}
		// memset first arg is declared to never be null by gcc
		if (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata != uintptr(0) {
			libc.Xmemset(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata, 0, uint32(datasize)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
		}

	}

	flags_stride = w + 2 // can't be 0U

	flagssize = (h+3)/4 + 2

	flagssize = flagssize * flags_stride
	{
		var p uintptr
		var x TOPJ_UINT32
		var flags_height TOPJ_UINT32 = (h + 3) / 4

		if flagssize > (*Topj_t1_t)(unsafe.Pointer(t1)).Fflagssize {

			Xopj_aligned_free(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags)
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fflags = Xopj_aligned_malloc(tls, uint32(flagssize)*uint32(unsafe.Sizeof(Topj_flag_t(0))))
			if !(int32((*Topj_t1_t)(unsafe.Pointer(t1)).Fflags) != 0) {
				// FIXME event manager error callback
				return DOPJ_FALSE
			}
		}
		(*Topj_t1_t)(unsafe.Pointer(t1)).Fflagssize = flagssize

		libc.Xmemset(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags, 0, uint32(flagssize)*uint32(unsafe.Sizeof(Topj_flag_t(0))))

		p = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags
		for x = TOPJ_UINT32(0); x < flags_stride; x++ {
			// magic value to hopefully stop any passes being interested in this entry
			*(*Topj_flag_t)(unsafe.Pointer(libc.PostIncUintptr(&p, 4))) = uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30
		}

		p = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr((flags_height+TOPJ_UINT32(1))*flags_stride)*4
		for x = TOPJ_UINT32(0); x < flags_stride; x++ {
			// magic value to hopefully stop any passes being interested in this entry
			*(*Topj_flag_t)(unsafe.Pointer(libc.PostIncUintptr(&p, 4))) = uint32(1)<<21 | uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30
		}

		if h%TOPJ_UINT32(4) != 0 {
			var v TOPJ_UINT32 = TOPJ_UINT32(0)
			p = (*Topj_t1_t)(unsafe.Pointer(t1)).Fflags + uintptr(flags_height*flags_stride)*4
			if h%TOPJ_UINT32(4) == TOPJ_UINT32(1) {
				v = v | (uint32(1)<<24 | uint32(1)<<27 | uint32(1)<<30)
			} else if h%TOPJ_UINT32(4) == TOPJ_UINT32(2) {
				v = v | (uint32(1)<<27 | uint32(1)<<30)
			} else if h%TOPJ_UINT32(4) == TOPJ_UINT32(3) {
				v = v | uint32(1)<<30
			}
			for x = TOPJ_UINT32(0); x < flags_stride; x++ {
				*(*Topj_flag_t)(unsafe.Pointer(libc.PostIncUintptr(&p, 4))) = v
			}
		}

	}

	(*Topj_t1_t)(unsafe.Pointer(t1)).Fw = w
	(*Topj_t1_t)(unsafe.Pointer(t1)).Fh = h

	return DOPJ_TRUE
}

var __func__261 = *(*[24]int8)(unsafe.Pointer(ts + 2083)) /* t1.c:1457:1 */

// -----------------------------------------------------------------------

// -----------------------------------------------------------------------
// *
// Creates a new Tier 1 handle
// and initializes the look-up tables of the Tier-1 coder/decoder
// @return a new T1 handle if successful, returns NULL otherwise
func Xopj_t1_create(tls *libc.TLS, isEncoder TOPJ_BOOL) uintptr { /* t1.c:1552:9: */
	var l_t1 uintptr = uintptr(00)

	l_t1 = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_t1_t{})))
	if !(l_t1 != 0) {
		return uintptr(00)
	}

	(*Topj_t1_t)(unsafe.Pointer(l_t1)).Fencoder = isEncoder

	return l_t1
}

// *
// Destroys a previously created T1 handle
//
// @param p_t1 Tier 1 handle to destroy
func Xopj_t1_destroy(tls *libc.TLS, p_t1 uintptr) { /* t1.c:1572:6: */
	if !(p_t1 != 0) {
		return
	}

	if (*Topj_t1_t)(unsafe.Pointer(p_t1)).Fdata != 0 {
		Xopj_aligned_free(tls, (*Topj_t1_t)(unsafe.Pointer(p_t1)).Fdata)
		(*Topj_t1_t)(unsafe.Pointer(p_t1)).Fdata = uintptr(00)
	}

	if (*Topj_t1_t)(unsafe.Pointer(p_t1)).Fflags != 0 {
		Xopj_aligned_free(tls, (*Topj_t1_t)(unsafe.Pointer(p_t1)).Fflags)
		(*Topj_t1_t)(unsafe.Pointer(p_t1)).Fflags = uintptr(00)
	}

	Xopj_free(tls, (*Topj_t1_t)(unsafe.Pointer(p_t1)).Fcblkdatabuffer)

	Xopj_free(tls, p_t1)
}

type Topj_t1_cblk_decode_processing_job_t = struct {
	Fwhole_tile_decoding    TOPJ_BOOL
	Fresno                  TOPJ_UINT32
	Fcblk                   uintptr
	Fband                   uintptr
	Ftilec                  uintptr
	Ftccp                   uintptr
	Fmustuse_cblkdatabuffer TOPJ_BOOL
	F__ccgo_pad1            [4]byte
	Fpret                   uintptr
	Fp_manager              uintptr
	Fp_manager_mutex        uintptr
	Fcheck_pterm            TOPJ_BOOL
	F__ccgo_pad2            [4]byte
} /* t1.c:1605:3 */

func opj_t1_destroy_wrapper(tls *libc.TLS, t1 uintptr) { /* t1.c:1607:13: */
	Xopj_t1_destroy(tls, t1)
}

func opj_t1_clbl_decode_processor(tls *libc.TLS, user_data uintptr, tls1 uintptr) { /* t1.c:1612:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var cblk uintptr
	var band uintptr
	var tilec uintptr
	var tccp uintptr
	var datap uintptr
	var cblk_w TOPJ_UINT32
	var cblk_h TOPJ_UINT32
	var x TOPJ_INT32
	var y TOPJ_INT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var job uintptr
	var t1 uintptr
	var resno TOPJ_UINT32
	var tile_w TOPJ_UINT32

	job = user_data

	cblk = (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fcblk

	if !((*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fwhole_tile_decoding != 0) {
		cblk_w = TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx1 - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0)
		cblk_h = TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy1 - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0)

		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data = Xopj_aligned_malloc(tls, uint32(unsafe.Sizeof(TOPJ_INT32(0)))*uint32(cblk_w)*uint32(cblk_h))
		if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data == uintptr(0) {
			if (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager_mutex != 0 {
				Xopj_mutex_lock(tls, (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager_mutex)
			}
			Xopj_event_msg(tls, (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager, DEVT_ERROR,
				ts+32471, 0)
			if (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager_mutex != 0 {
				Xopj_mutex_unlock(tls, (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager_mutex)
			}
			*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fpret)) = DOPJ_FALSE
			Xopj_free(tls, job)
			return
		}
		// Zero-init required
		libc.Xmemset(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data, 0, uint32(unsafe.Sizeof(TOPJ_INT32(0)))*uint32(cblk_w)*uint32(cblk_h))
	} else if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != 0 {
		// Not sure if that code path can happen, but better be
		// safe than sorry
		Xopj_aligned_free(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data)
		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data = uintptr(0)
	}

	resno = (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fresno
	band = (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fband
	tilec = (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Ftilec
	tccp = (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Ftccp
	tile_w = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx1 -
		(*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx0)

	if !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fpret)) != 0) {
		Xopj_free(tls, job)
		return
	}

	t1 = Xopj_tls_get(tls, tls1, DOPJ_TLS_KEY_T1)
	if t1 == uintptr(0) {
		t1 = Xopj_t1_create(tls, DOPJ_FALSE)
		if t1 == uintptr(0) {
			Xopj_event_msg(tls, (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager, DEVT_ERROR,
				ts+32507, 0)
			*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fpret)) = DOPJ_FALSE
			Xopj_free(tls, job)
			return
		}
		if !(Xopj_tls_set(tls, tls1, DOPJ_TLS_KEY_T1, t1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{opj_t1_destroy_wrapper}))) != 0) {
			Xopj_event_msg(tls, (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager, DEVT_ERROR,
				ts+32538, 0)
			Xopj_t1_destroy(tls, t1)
			*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fpret)) = DOPJ_FALSE
			Xopj_free(tls, job)
			return
		}
	}
	(*Topj_t1_t)(unsafe.Pointer(t1)).Fmustuse_cblkdatabuffer = (*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fmustuse_cblkdatabuffer

	if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fcblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_HT) != TOPJ_UINT32(0) {
		if DOPJ_FALSE == Xopj_t1_ht_decode_cblk(tls,
			t1,
			cblk,
			(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno,
			TOPJ_UINT32((*Topj_tccp_t)(unsafe.Pointer(tccp)).Froishift),
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fcblksty,
			(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager,
			(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager_mutex,
			(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fcheck_pterm) {
			*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fpret)) = DOPJ_FALSE
			Xopj_free(tls, job)
			return
		}
	} else {
		if DOPJ_FALSE == opj_t1_decode_cblk(tls,
			t1,
			cblk,
			(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno,
			TOPJ_UINT32((*Topj_tccp_t)(unsafe.Pointer(tccp)).Froishift),
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fcblksty,
			(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager,
			(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager_mutex,
			(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fcheck_pterm) {
			*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fpret)) = DOPJ_FALSE
			Xopj_free(tls, job)
			return
		}
	}

	x = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0 - (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fx0
	y = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0 - (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fy0
	if (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno&TOPJ_UINT32(1) != 0 {
		var pres uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno-TOPJ_UINT32(1))*192
		x = x + ((*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fx0)
	}
	if (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno&TOPJ_UINT32(2) != 0 {
		var pres uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno-TOPJ_UINT32(1))*192
		y = y + ((*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fy0)
	}

	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != 0 {
		datap = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data
	} else {
		datap = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
	}
	cblk_w = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
	cblk_h = (*Topj_t1_t)(unsafe.Pointer(t1)).Fh

	if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Froishift != 0 {
		if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Froishift >= 31 {
			for j = TOPJ_UINT32(0); j < cblk_h; j++ {
				for i = TOPJ_UINT32(0); i < cblk_w; i++ {
					*(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(j*cblk_w+i)*4)) = 0
				}
			}
		} else {
			var thresh TOPJ_INT32 = int32(1) << (*Topj_tccp_t)(unsafe.Pointer(tccp)).Froishift
			for j = TOPJ_UINT32(0); j < cblk_h; j++ {
				for i = TOPJ_UINT32(0); i < cblk_w; i++ {
					var val TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(j*cblk_w+i)*4))
					var mag TOPJ_INT32 = libc.Xabs(tls, val)
					if mag >= thresh {
						mag >>= (*Topj_tccp_t)(unsafe.Pointer(tccp)).Froishift
						*(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(j*cblk_w+i)*4)) = func() int32 {
							if val < 0 {
								return -mag
							}
							return mag
						}()
					}
				}
			}
		}
	}

	// Both can be non NULL if for example decoding a full tile and then
	// partially a tile. In which case partial decoding should be the
	// priority
	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != uintptr(0) || (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+32570, ts+32447, uint32(1763), uintptr(unsafe.Pointer(&__func__262)))
	}

	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != 0 {
		var cblk_size TOPJ_UINT32 = cblk_w * cblk_h
		if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fqmfbid == TOPJ_UINT32(1) {
			for i = TOPJ_UINT32(0); i < cblk_size; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(i)*4)) /= 2
			}
		} else { // if (tccp->qmfbid == 0)
			var stepsize float32 = 0.5 * (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fstepsize
			i = TOPJ_UINT32(0)
			for ; i < cblk_size; i++ {
				*(*TOPJ_FLOAT32)(unsafe.Pointer(bp /* tmp */)) = TOPJ_FLOAT32(*(*TOPJ_INT32)(unsafe.Pointer(datap))) * stepsize
				libc.Xmemcpy(tls, datap, bp, uint32(unsafe.Sizeof(TOPJ_FLOAT32(0))))
				datap += 4
			}
		}
	} else if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fqmfbid == TOPJ_UINT32(1) {
		var tiledp uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata + uintptr(TOPJ_SIZE_T(y)*TOPJ_SIZE_T(tile_w)+TOPJ_SIZE_T(x))*4
		for j = TOPJ_UINT32(0); j < cblk_h; j++ {
			i = TOPJ_UINT32(0)
			for ; i < cblk_w&libc.CplUint32(3); i = i + 4 {
				var tmp0 TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(j*cblk_w+i+0)*4))
				var tmp1 TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(j*cblk_w+i+1)*4))
				var tmp2 TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(j*cblk_w+i+2)*4))
				var tmp3 TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(j*cblk_w+i+3)*4))
				*(*TOPJ_INT32)(unsafe.Pointer(tiledp + uintptr(TOPJ_SIZE_T(j)*TOPJ_SIZE_T(tile_w)+TOPJ_SIZE_T(i)+0)*4)) = tmp0 / 2
				*(*TOPJ_INT32)(unsafe.Pointer(tiledp + uintptr(TOPJ_SIZE_T(j)*TOPJ_SIZE_T(tile_w)+TOPJ_SIZE_T(i)+1)*4)) = tmp1 / 2
				*(*TOPJ_INT32)(unsafe.Pointer(tiledp + uintptr(TOPJ_SIZE_T(j)*TOPJ_SIZE_T(tile_w)+TOPJ_SIZE_T(i)+2)*4)) = tmp2 / 2
				*(*TOPJ_INT32)(unsafe.Pointer(tiledp + uintptr(TOPJ_SIZE_T(j)*TOPJ_SIZE_T(tile_w)+TOPJ_SIZE_T(i)+3)*4)) = tmp3 / 2
			}
			for ; i < cblk_w; i++ {
				var tmp TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(datap + uintptr(j*cblk_w+i)*4))
				*(*TOPJ_INT32)(unsafe.Pointer(tiledp + uintptr(TOPJ_SIZE_T(j)*TOPJ_SIZE_T(tile_w)+TOPJ_SIZE_T(i))*4)) = tmp / 2
			}
		}
	} else { // if (tccp->qmfbid == 0)
		var stepsize float32 = 0.5 * (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fstepsize
		var tiledp uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata + uintptr(TOPJ_SIZE_T(y)*TOPJ_SIZE_T(tile_w)+TOPJ_SIZE_T(x))*4
		for j = TOPJ_UINT32(0); j < cblk_h; j++ {
			var tiledp2 uintptr = tiledp
			for i = TOPJ_UINT32(0); i < cblk_w; i++ {
				var tmp TOPJ_FLOAT32 = TOPJ_FLOAT32(*(*TOPJ_INT32)(unsafe.Pointer(datap))) * stepsize
				*(*TOPJ_FLOAT32)(unsafe.Pointer(tiledp2)) = tmp
				datap += 4
				tiledp2 += 4
			}
			tiledp += 4 * uintptr(tile_w)
		}
	}

	Xopj_free(tls, job)
}

var __func__262 = *(*[29]int8)(unsafe.Pointer(ts + 32624)) /* t1.c:1613:1 */

func Xopj_t1_decode_cblks(tls *libc.TLS, tcd uintptr, pret uintptr, tilec uintptr, tccp uintptr, p_manager uintptr, p_manager_mutex uintptr, check_pterm TOPJ_BOOL) { /* t1.c:1840:6: */
	var tp uintptr = (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fthread_pool
	var resno TOPJ_UINT32
	var bandno TOPJ_UINT32
	var precno TOPJ_UINT32
	var cblkno TOPJ_UINT32

	for resno = TOPJ_UINT32(0); resno < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions; resno++ {
		var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno)*192

		for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands; bandno++ {
			var band uintptr = res + 32 + uintptr(bandno)*48

			for precno = TOPJ_UINT32(0); precno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph; precno++ {
				var precinct uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56

				if !(Xopj_tcd_is_subband_area_of_interest(tls, tcd,
					(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fcompno,
					resno,
					(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno,
					TOPJ_UINT32((*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fx0),
					TOPJ_UINT32((*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fy0),
					TOPJ_UINT32((*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fx1),
					TOPJ_UINT32((*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fy1)) != 0) {
					for cblkno = TOPJ_UINT32(0); cblkno < (*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fcw*(*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fch; cblkno++ {
						var cblk uintptr = *(*uintptr)(unsafe.Pointer(precinct + 24)) + uintptr(cblkno)*80
						if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != 0 {
							Xopj_aligned_free(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data)
							(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data = uintptr(0)
						}
					}
					continue
				}

				for cblkno = TOPJ_UINT32(0); cblkno < (*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fcw*(*Topj_tcd_precinct_t)(unsafe.Pointer(precinct)).Fch; cblkno++ {
					var cblk uintptr = *(*uintptr)(unsafe.Pointer(precinct + 24)) + uintptr(cblkno)*80
					var job uintptr

					if !(Xopj_tcd_is_subband_area_of_interest(tls, tcd,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fcompno,
						resno,
						(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno,
						TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0),
						TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0),
						TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx1),
						TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy1)) != 0) {
						if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != 0 {
							Xopj_aligned_free(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data)
							(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data = uintptr(0)
						}
						continue
					}

					if !((*Topj_tcd_t)(unsafe.Pointer(tcd)).Fwhole_tile_decoding != 0) {
						var cblk_w TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx1 - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0)
						var cblk_h TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy1 - (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0)
						if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != uintptr(0) {
							continue
						}
						if cblk_w == TOPJ_UINT32(0) || cblk_h == TOPJ_UINT32(0) {
							continue
						}
					}

					job = Xopj_calloc(tls, uint32(1),
						uint32(unsafe.Sizeof(Topj_t1_cblk_decode_processing_job_t{})))
					if !(job != 0) {
						*(*TOPJ_BOOL)(unsafe.Pointer(pret)) = DOPJ_FALSE
						return
					}
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fwhole_tile_decoding = (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fwhole_tile_decoding
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fresno = resno
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fcblk = cblk
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fband = band
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Ftilec = tilec
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Ftccp = tccp
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fpret = pret
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager_mutex = p_manager_mutex
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fp_manager = p_manager
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fcheck_pterm = check_pterm
					(*Topj_t1_cblk_decode_processing_job_t)(unsafe.Pointer(job)).Fmustuse_cblkdatabuffer = libc.Bool32(Xopj_thread_pool_get_thread_count(tls, tp) > 1)
					Xopj_thread_pool_submit_job(tls, tp, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr)
					}{opj_t1_clbl_decode_processor})), job)
					if !(*(*TOPJ_BOOL)(unsafe.Pointer(pret)) != 0) {
						return
					}
				} // cblkno
			} // precno
		} // bandno
	} // resno

	return
}

func opj_t1_decode_cblk(tls *libc.TLS, t1 uintptr, cblk uintptr, orient TOPJ_UINT32, roishift TOPJ_UINT32, cblksty TOPJ_UINT32, p_manager uintptr, p_manager_mutex uintptr, check_pterm TOPJ_BOOL) TOPJ_BOOL { /* t1.c:1966:17: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var mqc uintptr = t1 // MQC component

	var bpno_plus_one TOPJ_INT32
	var passtype TOPJ_UINT32
	var segno TOPJ_UINT32
	var passno TOPJ_UINT32
	var cblkdata uintptr = uintptr(0)
	var cblkdataindex TOPJ_UINT32 = TOPJ_UINT32(0)
	var type1 TOPJ_BYTE = TOPJ_BYTE(DT1_TYPE_MQ) // BYPASS mode
	var original_t1_data uintptr = uintptr(0)

	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Flut_ctxno_zc_orient = uintptr(unsafe.Pointer(&lut_ctxno_zc)) + uintptr(orient<<9)

	if !(opj_t1_allocate_buffers1(tls,
		t1,
		TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx1-(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fx0),
		TOPJ_UINT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy1-(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fy0)) != 0) {
		return DOPJ_FALSE
	}

	bpno_plus_one = TOPJ_INT32(roishift + (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumbps)
	if bpno_plus_one >= 31 {
		if p_manager_mutex != 0 {
			Xopj_mutex_lock(tls, p_manager_mutex)
		}
		Xopj_event_msg(tls, p_manager, DEVT_WARNING,
			ts+32653,
			libc.VaList(bp, bpno_plus_one))
		if p_manager_mutex != 0 {
			Xopj_mutex_unlock(tls, p_manager_mutex)
		}
		return DOPJ_FALSE
	}
	passtype = TOPJ_UINT32(2)

	Xopj_mqc_resetstates(tls, mqc)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC+DT1_NUMCTXS_ZC+DT1_NUMCTXS_SC+DT1_NUMCTXS_MAG+DT1_NUMCTXS_AGG), uint32(0), 46)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC+DT1_NUMCTXS_ZC+DT1_NUMCTXS_SC+DT1_NUMCTXS_MAG), uint32(0), 3)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC), uint32(0), 4)

	// Even if we have a single chunk, in multi-threaded decoding
	// the insertion of our synthetic marker might potentially override
	// valid codestream of other codeblocks decoded in parallel.
	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumchunks > TOPJ_UINT32(1) || (*Topj_t1_t)(unsafe.Pointer(t1)).Fmustuse_cblkdatabuffer != 0 {
		var i TOPJ_UINT32
		var cblk_len TOPJ_UINT32

		// Compute whole codeblock length from chunk lengths
		cblk_len = TOPJ_UINT32(0)
		for i = TOPJ_UINT32(0); i < (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumchunks; i++ {
			cblk_len = cblk_len + (*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks+uintptr(i)*16)).Flen
		}

		// Allocate temporary memory if needed
		if cblk_len+TOPJ_UINT32(DOPJ_COMMON_CBLK_DATA_EXTRA) > (*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffersize {
			cblkdata = Xopj_realloc(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffer,
				uint32(cblk_len+TOPJ_UINT32(DOPJ_COMMON_CBLK_DATA_EXTRA)))
			if cblkdata == uintptr(0) {
				return DOPJ_FALSE
			}
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffer = cblkdata
			libc.Xmemset(tls, (*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffer+uintptr(cblk_len), 0, uint32(DOPJ_COMMON_CBLK_DATA_EXTRA))
			(*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffersize = cblk_len + TOPJ_UINT32(DOPJ_COMMON_CBLK_DATA_EXTRA)
		}

		// Concatenate all chunks
		cblkdata = (*Topj_t1_t)(unsafe.Pointer(t1)).Fcblkdatabuffer
		cblk_len = TOPJ_UINT32(0)
		for i = TOPJ_UINT32(0); i < (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumchunks; i++ {
			libc.Xmemcpy(tls, cblkdata+uintptr(cblk_len), (*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks+uintptr(i)*16)).Fdata, uint32((*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks+uintptr(i)*16)).Flen))
			cblk_len = cblk_len + (*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks+uintptr(i)*16)).Flen
		}
	} else if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumchunks == TOPJ_UINT32(1) {
		cblkdata = (*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fchunks)).Fdata
	} else {
		// Not sure if that can happen in practice, but avoid Coverity to
		// think we will dereference a null cblkdta pointer
		return DOPJ_TRUE
	}

	// For subtile decoding, directly decode in the decoded_data buffer of
	// the code-block. Hack t1->data to point to it, and restore it later
	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != 0 {
		original_t1_data = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		(*Topj_t1_t)(unsafe.Pointer(t1)).Fdata = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data
	}

	for segno = TOPJ_UINT32(0); segno < (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Freal_num_segs; segno++ {
		var seg uintptr = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fsegs + uintptr(segno)*24

		// BYPASS mode
		if bpno_plus_one <= TOPJ_INT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fnumbps)-4 && passtype < TOPJ_UINT32(2) && cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_LAZY) != 0 {
			type1 = uint8(DT1_TYPE_RAW)
		} else {
			type1 = uint8(DT1_TYPE_MQ)
		}

		if int32(type1) == DT1_TYPE_RAW {
			Xopj_mqc_raw_init_dec(tls, mqc, cblkdata+uintptr(cblkdataindex), (*Topj_tcd_seg_t)(unsafe.Pointer(seg)).Flen,
				uint32(DOPJ_COMMON_CBLK_DATA_EXTRA))
		} else {
			Xopj_mqc_init_dec(tls, mqc, cblkdata+uintptr(cblkdataindex), (*Topj_tcd_seg_t)(unsafe.Pointer(seg)).Flen,
				uint32(DOPJ_COMMON_CBLK_DATA_EXTRA))
		}
		cblkdataindex = cblkdataindex + (*Topj_tcd_seg_t)(unsafe.Pointer(seg)).Flen

		for passno = TOPJ_UINT32(0); passno < (*Topj_tcd_seg_t)(unsafe.Pointer(seg)).Freal_num_passes && bpno_plus_one >= 1; passno++ {
			switch passtype {
			case TOPJ_UINT32(0):
				if int32(type1) == DT1_TYPE_RAW {
					opj_t1_dec_sigpass_raw(tls, t1, bpno_plus_one, TOPJ_INT32(cblksty))
				} else {
					opj_t1_dec_sigpass_mqc(tls, t1, bpno_plus_one, TOPJ_INT32(cblksty))
				}
				break
			case TOPJ_UINT32(1):
				if int32(type1) == DT1_TYPE_RAW {
					opj_t1_dec_refpass_raw(tls, t1, bpno_plus_one)
				} else {
					opj_t1_dec_refpass_mqc(tls, t1, bpno_plus_one)
				}
				break
			case TOPJ_UINT32(2):
				opj_t1_dec_clnpass(tls, t1, bpno_plus_one, TOPJ_INT32(cblksty))
				break
			}

			if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_RESET) != 0 && int32(type1) == DT1_TYPE_MQ {
				Xopj_mqc_resetstates(tls, mqc)
				Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC+DT1_NUMCTXS_ZC+DT1_NUMCTXS_SC+DT1_NUMCTXS_MAG+DT1_NUMCTXS_AGG), uint32(0), 46)
				Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC+DT1_NUMCTXS_ZC+DT1_NUMCTXS_SC+DT1_NUMCTXS_MAG), uint32(0), 3)
				Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC), uint32(0), 4)
			}
			if libc.PreIncUint32(&passtype, 1) == TOPJ_UINT32(3) {
				passtype = TOPJ_UINT32(0)
				bpno_plus_one--
			}
		}

		Xopq_mqc_finish_dec(tls, mqc)
	}

	if check_pterm != 0 {
		if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp+uintptr(2) < (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend {
			if p_manager_mutex != 0 {
				Xopj_mutex_lock(tls, p_manager_mutex)
			}
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+32713,
				libc.VaList(bp+8, int32((int32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend)-int32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp))/1)-2,
					int32((int32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fbp)-int32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fstart))/1),
					int32((int32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend)-int32((*Topj_mqc_t)(unsafe.Pointer(mqc)).Fstart))/1)))
			if p_manager_mutex != 0 {
				Xopj_mutex_unlock(tls, p_manager_mutex)
			}
		} else if (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter > TOPJ_UINT32(2) {
			if p_manager_mutex != 0 {
				Xopj_mutex_lock(tls, p_manager_mutex)
			}
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+32783,
				libc.VaList(bp+32, (*Topj_mqc_t)(unsafe.Pointer(mqc)).Fend_of_byte_stream_counter))
			if p_manager_mutex != 0 {
				Xopj_mutex_unlock(tls, p_manager_mutex)
			}
		}
	}

	// Restore original t1->data is needed
	if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fdecoded_data != 0 {
		(*Topj_t1_t)(unsafe.Pointer(t1)).Fdata = original_t1_data
	}

	return DOPJ_TRUE
}

type Topj_t1_cblk_encode_processing_job_t = struct {
	Fcompno       TOPJ_UINT32
	Fresno        TOPJ_UINT32
	Fcblk         uintptr
	Ftile         uintptr
	Fband         uintptr
	Ftilec        uintptr
	Ftccp         uintptr
	Fmct_norms    uintptr
	Fmct_numcomps TOPJ_UINT32
	F__ccgo_pad1  [4]byte
	Fpret         uintptr
	Fmutex        uintptr
} /* t1.c:2161:3 */

// * Procedure to deal with a asynchronous code-block encoding job.
//
// @param user_data Pointer to a opj_t1_cblk_encode_processing_job_t* structure
// @param tls       TLS handle.
func opj_t1_cblk_encode_processor(tls *libc.TLS, user_data uintptr, tls1 uintptr) { /* t1.c:2168:13: */
	var job uintptr = user_data
	var cblk uintptr = (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fcblk
	var band uintptr = (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fband
	var tilec uintptr = (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Ftilec
	var tccp uintptr = (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Ftccp
	var resno TOPJ_UINT32 = (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fresno
	var t1 uintptr
	var tile_w TOPJ_UINT32 = TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx1 - (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx0)
	var tiledp uintptr
	var cblk_w TOPJ_UINT32
	var cblk_h TOPJ_UINT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32

	var x TOPJ_INT32 = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fx0 - (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fx0
	var y TOPJ_INT32 = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fy0 - (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fy0

	if !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fpret)) != 0) {
		Xopj_free(tls, job)
		return
	}

	t1 = Xopj_tls_get(tls, tls1, DOPJ_TLS_KEY_T1)
	if t1 == uintptr(0) {
		t1 = Xopj_t1_create(tls, DOPJ_TRUE) // OPJ_TRUE == T1 for encoding
		Xopj_tls_set(tls, tls1, DOPJ_TLS_KEY_T1, t1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{opj_t1_destroy_wrapper})))
	}

	if (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno&TOPJ_UINT32(1) != 0 {
		var pres uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno-TOPJ_UINT32(1))*192
		x = x + ((*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fx0)
	}
	if (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno&TOPJ_UINT32(2) != 0 {
		var pres uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno-TOPJ_UINT32(1))*192
		y = y + ((*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(pres)).Fy0)
	}

	if !(opj_t1_allocate_buffers1(tls,
		t1,
		TOPJ_UINT32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fx1-(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fx0),
		TOPJ_UINT32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fy1-(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fy0)) != 0) {
		*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fpret)) = DOPJ_FALSE
		Xopj_free(tls, job)
		return
	}

	cblk_w = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
	cblk_h = (*Topj_t1_t)(unsafe.Pointer(t1)).Fh

	tiledp = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata + uintptr(TOPJ_SIZE_T(y)*TOPJ_SIZE_T(tile_w)+TOPJ_SIZE_T(x))*4

	if (*Topj_tccp_t)(unsafe.Pointer(tccp)).Fqmfbid == TOPJ_UINT32(1) {
		// Do multiplication on unsigned type, even if the
		// underlying type is signed, to avoid potential
		// int overflow on large value (the output will be
		// incorrect in such situation, but whatever...)
		// This assumes complement-to-2 signed integer
		// representation
		// Fixes https://github.com/uclouvain/openjpeg/issues/1053
		var tiledp_u uintptr = tiledp
		var t1data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		// Change from "natural" order to "zigzag" order of T1 passes
		for j = TOPJ_UINT32(0); j < cblk_h&libc.CplUint32(3); j = j + TOPJ_UINT32(4) {
			for i = TOPJ_UINT32(0); i < cblk_w; i++ {
				*(*TOPJ_UINT32)(unsafe.Pointer(t1data)) = *(*TOPJ_UINT32)(unsafe.Pointer(tiledp_u + uintptr((j+TOPJ_UINT32(0))*tile_w+i)*4)) << (DT1_NMSEDEC_BITS - 1)
				*(*TOPJ_UINT32)(unsafe.Pointer(t1data + 1*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(tiledp_u + uintptr((j+TOPJ_UINT32(1))*tile_w+i)*4)) << (DT1_NMSEDEC_BITS - 1)
				*(*TOPJ_UINT32)(unsafe.Pointer(t1data + 2*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(tiledp_u + uintptr((j+TOPJ_UINT32(2))*tile_w+i)*4)) << (DT1_NMSEDEC_BITS - 1)
				*(*TOPJ_UINT32)(unsafe.Pointer(t1data + 3*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(tiledp_u + uintptr((j+TOPJ_UINT32(3))*tile_w+i)*4)) << (DT1_NMSEDEC_BITS - 1)
				t1data += 4 * uintptr(4)
			}
		}
		if j < cblk_h {
			for i = TOPJ_UINT32(0); i < cblk_w; i++ {
				var k TOPJ_UINT32
				for k = j; k < cblk_h; k++ {
					*(*TOPJ_UINT32)(unsafe.Pointer(t1data)) = *(*TOPJ_UINT32)(unsafe.Pointer(tiledp_u + uintptr(k*tile_w+i)*4)) << (DT1_NMSEDEC_BITS - 1)
					t1data += 4
				}
			}
		}
	} else { // if (tccp->qmfbid == 0)
		var tiledp_f uintptr = tiledp
		var t1data uintptr = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
		// Change from "natural" order to "zigzag" order of T1 passes
		for j = TOPJ_UINT32(0); j < cblk_h&libc.CplUint32(3); j = j + TOPJ_UINT32(4) {
			for i = TOPJ_UINT32(0); i < cblk_w; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(t1data)) = TOPJ_INT32(opj_lrintf(tls, *(*TOPJ_FLOAT32)(unsafe.Pointer(tiledp_f + uintptr((j+TOPJ_UINT32(0))*tile_w+i)*4))/(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fstepsize*float32(int32(1)<<(DT1_NMSEDEC_BITS-1))))
				*(*TOPJ_INT32)(unsafe.Pointer(t1data + 1*4)) = TOPJ_INT32(opj_lrintf(tls, *(*TOPJ_FLOAT32)(unsafe.Pointer(tiledp_f + uintptr((j+TOPJ_UINT32(1))*tile_w+i)*4))/(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fstepsize*float32(int32(1)<<(DT1_NMSEDEC_BITS-1))))
				*(*TOPJ_INT32)(unsafe.Pointer(t1data + 2*4)) = TOPJ_INT32(opj_lrintf(tls, *(*TOPJ_FLOAT32)(unsafe.Pointer(tiledp_f + uintptr((j+TOPJ_UINT32(2))*tile_w+i)*4))/(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fstepsize*float32(int32(1)<<(DT1_NMSEDEC_BITS-1))))
				*(*TOPJ_INT32)(unsafe.Pointer(t1data + 3*4)) = TOPJ_INT32(opj_lrintf(tls, *(*TOPJ_FLOAT32)(unsafe.Pointer(tiledp_f + uintptr((j+TOPJ_UINT32(3))*tile_w+i)*4))/(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fstepsize*float32(int32(1)<<(DT1_NMSEDEC_BITS-1))))
				t1data += 4 * uintptr(4)
			}
		}
		if j < cblk_h {
			for i = TOPJ_UINT32(0); i < cblk_w; i++ {
				var k TOPJ_UINT32
				for k = j; k < cblk_h; k++ {
					*(*TOPJ_INT32)(unsafe.Pointer(t1data)) = TOPJ_INT32(opj_lrintf(tls, *(*TOPJ_FLOAT32)(unsafe.Pointer(tiledp_f + uintptr(k*tile_w+i)*4))/(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fstepsize*
						float32(int32(1)<<(DT1_NMSEDEC_BITS-1))))
					t1data += 4
				}
			}
		}
	}

	{
		var cumwmsedec TOPJ_FLOAT64 = opj_t1_encode_cblk(tls,
			t1,
			cblk,
			(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno,
			(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fcompno,
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions-TOPJ_UINT32(1)-resno,
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fqmfbid,
			float64((*Topj_tcd_band_t)(unsafe.Pointer(band)).Fstepsize),
			(*Topj_tccp_t)(unsafe.Pointer(tccp)).Fcblksty,
			(*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Ftile)).Fnumcomps,
			(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmct_norms,
			(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmct_numcomps)
		if (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmutex != 0 {
			Xopj_mutex_lock(tls, (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmutex)
		}
		*(*TOPJ_FLOAT64)(unsafe.Pointer((*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Ftile + 40)) += cumwmsedec
		if (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmutex != 0 {
			Xopj_mutex_unlock(tls, (*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmutex)
		}

	}

	Xopj_free(tls, job)
}

func Xopj_t1_encode_cblks(tls *libc.TLS, tcd uintptr, tile uintptr, tcp uintptr, mct_norms uintptr, mct_numcomps TOPJ_UINT32) TOPJ_BOOL { /* t1.c:2308:10: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var ret TOPJ_BOOL at bp, 4

	var tp uintptr
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	var bandno TOPJ_UINT32
	var precno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var mutex uintptr
	var cblk uintptr
	var job uintptr
	var prc uintptr
	var band uintptr
	var res uintptr
	var tilec uintptr
	var tccp uintptr
	*(*TOPJ_BOOL)(unsafe.Pointer(bp /* ret */)) = DOPJ_TRUE
	tp = (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fthread_pool
	mutex = Xopj_mutex_create(tls)

	(*Topj_tcd_tile_t)(unsafe.Pointer(tile)).Fdistotile = TOPJ_FLOAT64(0) // fixed_quality

	compno = TOPJ_UINT32(0)
__1:
	if !(compno < (*Topj_tcd_tile_t)(unsafe.Pointer(tile)).Fnumcomps) {
		goto __3
	}
	tilec = (*Topj_tcd_tile_t)(unsafe.Pointer(tile)).Fcomps + uintptr(compno)*104
	tccp = (*Topj_tcp_t)(unsafe.Pointer(tcp)).Ftccps + uintptr(compno)*1080

	resno = TOPJ_UINT32(0)
__4:
	if !(resno < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions) {
		goto __6
	}
	res = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno)*192

	bandno = TOPJ_UINT32(0)
__7:
	if !(bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands) {
		goto __9
	}
	band = res + 32 + uintptr(bandno)*48

	// Skip empty bands
	if !(Xopj_tcd_is_band_empty(tls, band) != 0) {
		goto __10
	}
	goto __8
__10:
	;
	precno = TOPJ_UINT32(0)
__11:
	if !(precno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph) {
		goto __13
	}
	prc = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56

	cblkno = TOPJ_UINT32(0)
__14:
	if !(cblkno < (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fcw*(*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fch) {
		goto __16
	}
	cblk = *(*uintptr)(unsafe.Pointer(prc + 24)) + uintptr(cblkno)*64

	job =
		Xopj_calloc(tls, uint32(1),
			uint32(unsafe.Sizeof(Topj_t1_cblk_encode_processing_job_t{})))
	if !!(job != 0) {
		goto __17
	}
	*(*TOPJ_BOOL)(unsafe.Pointer(bp /* ret */)) = DOPJ_FALSE
	goto end
__17:
	;
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fcompno = compno
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Ftile = tile
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fresno = resno
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fcblk = cblk
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fband = band
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Ftilec = tilec
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Ftccp = tccp
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmct_norms = mct_norms
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmct_numcomps = mct_numcomps
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fpret = bp /* &ret */
	(*Topj_t1_cblk_encode_processing_job_t)(unsafe.Pointer(job)).Fmutex = mutex
	Xopj_thread_pool_submit_job(tls, tp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{opj_t1_cblk_encode_processor})), job)

	goto __15
__15:
	cblkno++
	goto __14
	goto __16
__16:
	; // cblkno
	goto __12
__12:
	precno++
	goto __11
	goto __13
__13:
	; // precno
	goto __8
__8:
	bandno++
	goto __7
	goto __9
__9:
	; // bandno
	goto __5
__5:
	resno++
	goto __4
	goto __6
__6:
	; // resno
	goto __2
__2:
	compno++
	goto __1
	goto __3
__3:
	; // compno

end:
	Xopj_thread_pool_wait_completion(tls, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fthread_pool, 0)
	if !(mutex != 0) {
		goto __18
	}
	Xopj_mutex_destroy(tls, mutex)
__18:
	;

	return *(*TOPJ_BOOL)(unsafe.Pointer(bp /* ret */))
}

// Returns whether the pass (bpno, passtype) is terminated
func opj_t1_enc_is_term_pass(tls *libc.TLS, cblk uintptr, cblksty TOPJ_UINT32, bpno TOPJ_INT32, passtype TOPJ_UINT32) int32 { /* t1.c:2378:12: */
	// Is it the last cleanup pass ?
	if passtype == TOPJ_UINT32(2) && bpno == 0 {
		return DOPJ_TRUE
	}

	if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_TERMALL) != 0 {
		return DOPJ_TRUE
	}

	if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_LAZY) != 0 {
		// For bypass arithmetic bypass, terminate the 4th cleanup pass
		if bpno == TOPJ_INT32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumbps)-4 && passtype == TOPJ_UINT32(2) {
			return DOPJ_TRUE
		}
		// and beyond terminate all the magnitude refinement passes (in raw)
		// and cleanup passes (in MQC)
		if bpno < TOPJ_INT32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumbps)-4 && passtype > TOPJ_UINT32(0) {
			return DOPJ_TRUE
		}
	}

	return DOPJ_FALSE
}

//* mod fixed_quality
func opj_t1_encode_cblk(tls *libc.TLS, t1 uintptr, cblk uintptr, orient TOPJ_UINT32, compno TOPJ_UINT32, level TOPJ_UINT32, qmfbid TOPJ_UINT32, stepsize TOPJ_FLOAT64, cblksty TOPJ_UINT32, numcomps TOPJ_UINT32, mct_norms uintptr, mct_numcomps TOPJ_UINT32) TOPJ_FLOAT64 { /* t1.c:2409:20: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var cumwmsedec TOPJ_FLOAT64 = 0.0

	var mqc uintptr = t1 // MQC component

	var passno TOPJ_UINT32
	var bpno TOPJ_INT32
	var passtype TOPJ_UINT32
	*(*TOPJ_INT32)(unsafe.Pointer(bp + 4 /* nmsedec */)) = 0
	var max TOPJ_INT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var type1 TOPJ_BYTE = TOPJ_BYTE(DT1_TYPE_MQ)
	var tempwmsedec TOPJ_FLOAT64
	var datap uintptr

	(*Topj_mqc_t)(unsafe.Pointer(mqc)).Flut_ctxno_zc_orient = uintptr(unsafe.Pointer(&lut_ctxno_zc)) + uintptr(orient<<9)

	max = 0
	datap = (*Topj_t1_t)(unsafe.Pointer(t1)).Fdata
	for j = TOPJ_UINT32(0); j < (*Topj_t1_t)(unsafe.Pointer(t1)).Fh; j++ {
		var w TOPJ_UINT32 = (*Topj_t1_t)(unsafe.Pointer(t1)).Fw
		i = TOPJ_UINT32(0)
	__1:
		if !(i < w) {
			goto __3
		}
		{
			var tmp TOPJ_INT32 = *(*TOPJ_INT32)(unsafe.Pointer(datap))
			if tmp < 0 {
				// var tmp_unsigned TOPJ_UINT32 at bp, 4

				max = opj_int_max(tls, max, -tmp)
				*(*TOPJ_UINT32)(unsafe.Pointer(bp /* tmp_unsigned */)) = func() uint32 {
					if tmp >= 0 {
						return TOPJ_UINT32(tmp)
					}
					return TOPJ_UINT32(-tmp) | 0x80000000
				}()
				libc.Xmemcpy(tls, datap, bp, uint32(unsafe.Sizeof(TOPJ_INT32(0))))
			} else {
				max = opj_int_max(tls, max, tmp)
			}

		}
		goto __2
	__2:
		i++
		datap += 4
		goto __1
		goto __3
	__3:
	}

	(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumbps = func() uint32 {
		if max != 0 {
			return TOPJ_UINT32(opj_int_floorlog2(tls, max) + 1 - (DT1_NMSEDEC_BITS - 1))
		}
		return uint32(0)
	}()
	if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumbps == TOPJ_UINT32(0) {
		(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Ftotalpasses = TOPJ_UINT32(0)
		return cumwmsedec
	}

	bpno = TOPJ_INT32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumbps - TOPJ_UINT32(1))
	passtype = TOPJ_UINT32(2)

	Xopj_mqc_resetstates(tls, mqc)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC+DT1_NUMCTXS_ZC+DT1_NUMCTXS_SC+DT1_NUMCTXS_MAG+DT1_NUMCTXS_AGG), uint32(0), 46)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC+DT1_NUMCTXS_ZC+DT1_NUMCTXS_SC+DT1_NUMCTXS_MAG), uint32(0), 3)
	Xopj_mqc_setstate(tls, mqc, uint32(DT1_CTXNO_ZC), uint32(0), 4)
	Xopj_mqc_init_enc(tls, mqc, (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fdata)

	for passno = TOPJ_UINT32(0); bpno >= 0; passno++ {
		var pass uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(passno)*24
		if bpno < TOPJ_INT32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumbps)-4 && passtype < TOPJ_UINT32(2) && cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_LAZY) != 0 {
			type1 = uint8(DT1_TYPE_RAW)
		} else {
			type1 = uint8(DT1_TYPE_MQ)
		}

		// If the previous pass was terminating, we need to reset the encoder
		if passno > TOPJ_UINT32(0) && TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(passno-TOPJ_UINT32(1))*24 + 20))&0x1>>0)) != 0 {
			if int32(type1) == DT1_TYPE_RAW {
				Xopj_mqc_bypass_init_enc(tls, mqc)
			} else {
				Xopj_mqc_restart_init_enc(tls, mqc)
			}
		}

		switch passtype {
		case TOPJ_UINT32(0):
			opj_t1_enc_sigpass(tls, t1, bpno, bp+4, type1, cblksty)
			break
		case TOPJ_UINT32(1):
			opj_t1_enc_refpass(tls, t1, bpno, bp+4, type1)
			break
		case TOPJ_UINT32(2):
			opj_t1_enc_clnpass(tls, t1, bpno, bp+4, cblksty)
			// code switch SEGMARK (i.e. SEGSYM)
			if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_SEGSYM) != 0 {
				Xopj_mqc_segmark_enc(tls, mqc)
			}
			break
		}

		// fixed_quality
		tempwmsedec = opj_t1_getwmsedec(tls, *(*TOPJ_INT32)(unsafe.Pointer(bp + 4 /* nmsedec */)), compno, level, orient, bpno, qmfbid,
			stepsize, numcomps, mct_norms, mct_numcomps)
		cumwmsedec = cumwmsedec + tempwmsedec
		(*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Fdistortiondec = cumwmsedec

		if opj_t1_enc_is_term_pass(tls, cblk, cblksty, bpno, passtype) != 0 {
			// If it is a terminated pass, terminate it
			if int32(type1) == DT1_TYPE_RAW {
				Xopj_mqc_bypass_flush_enc(tls, mqc, int32(cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_PTERM)))
			} else {
				if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_PTERM) != 0 {
					Xopj_mqc_erterm_enc(tls, mqc)
				} else {
					Xopj_mqc_flush(tls, mqc)
				}
			}
			libc.SetBitFieldPtr8Uint32(pass+20, TOPJ_BITFIELD(1), 0, 0x1)
			(*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate = Xopj_mqc_numbytes(tls, mqc)
		} else {
			// Non terminated pass
			var rate_extra_bytes TOPJ_UINT32
			if int32(type1) == DT1_TYPE_RAW {
				rate_extra_bytes = Xopj_mqc_bypass_get_extra_bytes(tls,
					mqc, int32(cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_PTERM)))
			} else {
				rate_extra_bytes = TOPJ_UINT32(3)
			}
			libc.SetBitFieldPtr8Uint32(pass+20, TOPJ_BITFIELD(0), 0, 0x1)
			(*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate = Xopj_mqc_numbytes(tls, mqc) + rate_extra_bytes
		}

		if libc.PreIncUint32(&passtype, 1) == TOPJ_UINT32(3) {
			passtype = TOPJ_UINT32(0)
			bpno--
		}

		// Code-switch "RESET"
		if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_RESET) != 0 {
			Xopj_mqc_reset_enc(tls, mqc)
		}
	}

	(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Ftotalpasses = passno

	if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Ftotalpasses != 0 {
		// Make sure that pass rates are increasing
		var last_pass_rate TOPJ_UINT32 = Xopj_mqc_numbytes(tls, mqc)
		for passno = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Ftotalpasses; passno > TOPJ_UINT32(0); {
			var pass uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(libc.PreDecUint32(&passno, 1))*24
			if (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate > last_pass_rate {
				(*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate = last_pass_rate
			} else {
				last_pass_rate = (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate
			}
		}
	}

	for passno = TOPJ_UINT32(0); passno < (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Ftotalpasses; passno++ {
		var pass uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(passno)*24

		// Prevent generation of FF as last data byte of a pass
		// For terminating passes, the flushing procedure ensured this already
		if (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate > TOPJ_UINT32(0) {
		} else {
			libc.X__assert_fail(tls, ts+32838, ts+32447, uint32(2568), uintptr(unsafe.Pointer(&__func__263)))
		}
		if int32(*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fdata + uintptr((*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate-TOPJ_UINT32(1))))) == 0xFF {
			(*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate--
		}
		(*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Flen = (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate - func() uint32 {
			if passno == TOPJ_UINT32(0) {
				return uint32(0)
			}
			return (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(passno-TOPJ_UINT32(1))*24)).Frate
		}()
	}

	return cumwmsedec
}

var __func__263 = *(*[19]int8)(unsafe.Pointer(ts + 32853)) /* t1.c:2420:1 */

//@}

//@}

// -----------------------------------------------------------------------

// #define RESTART 0x04
func opj_t2_putcommacode(tls *libc.TLS, bio uintptr, n TOPJ_INT32) { /* t2.c:167:13: */
	for libc.PreDecInt32(&n, 1) >= 0 {
		Xopj_bio_write(tls, bio, uint32(1), uint32(1))
	}
	Xopj_bio_write(tls, bio, uint32(0), uint32(1))
}

func opj_t2_getcommacode(tls *libc.TLS, bio uintptr) TOPJ_UINT32 { /* t2.c:175:19: */
	var n TOPJ_UINT32 = TOPJ_UINT32(0)
	for Xopj_bio_read(tls, bio, uint32(1)) != 0 {
		n++
	}
	return n
}

func opj_t2_putnumpasses(tls *libc.TLS, bio uintptr, n TOPJ_UINT32) { /* t2.c:184:13: */
	if n == TOPJ_UINT32(1) {
		Xopj_bio_write(tls, bio, uint32(0), uint32(1))
	} else if n == TOPJ_UINT32(2) {
		Xopj_bio_write(tls, bio, uint32(2), uint32(2))
	} else if n <= TOPJ_UINT32(5) {
		Xopj_bio_write(tls, bio, TOPJ_UINT32(0xc)|(n-TOPJ_UINT32(3)), uint32(4))
	} else if n <= TOPJ_UINT32(36) {
		Xopj_bio_write(tls, bio, TOPJ_UINT32(0x1e0)|(n-TOPJ_UINT32(6)), uint32(9))
	} else if n <= TOPJ_UINT32(164) {
		Xopj_bio_write(tls, bio, TOPJ_UINT32(0xff80)|(n-TOPJ_UINT32(37)), uint32(16))
	}
}

func opj_t2_getnumpasses(tls *libc.TLS, bio uintptr) TOPJ_UINT32 { /* t2.c:199:19: */
	var n TOPJ_UINT32
	if !(Xopj_bio_read(tls, bio, uint32(1)) != 0) {
		return TOPJ_UINT32(1)
	}
	if !(Xopj_bio_read(tls, bio, uint32(1)) != 0) {
		return TOPJ_UINT32(2)
	}
	if libc.AssignUint32(&n, Xopj_bio_read(tls, bio, uint32(2))) != TOPJ_UINT32(3) {
		return TOPJ_UINT32(3) + n
	}
	if libc.AssignUint32(&n, Xopj_bio_read(tls, bio, uint32(5))) != TOPJ_UINT32(31) {
		return TOPJ_UINT32(6) + n
	}
	return TOPJ_UINT32(37) + Xopj_bio_read(tls, bio, uint32(7))
}

// -----------------------------------------------------------------------

func Xopj_t2_encode_packets(tls *libc.TLS, p_t2 uintptr, p_tile_no TOPJ_UINT32, p_tile uintptr, p_maxlayers TOPJ_UINT32, p_dest uintptr, p_data_written uintptr, p_max_len TOPJ_UINT32, cstr_info uintptr, p_marker_info uintptr, p_tp_num TOPJ_UINT32, p_tp_pos TOPJ_INT32, p_pino TOPJ_UINT32, p_t2_mode TJ2K_T2_MODE, p_manager uintptr) TOPJ_BOOL { /* t2.c:219:10: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_current_data uintptr = p_dest
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes */)) = TOPJ_UINT32(0)
	var compno TOPJ_UINT32
	var poc TOPJ_UINT32
	var l_pi uintptr = uintptr(00)
	var l_current_pi uintptr = uintptr(00)
	var l_image uintptr = (*Topj_t2_t)(unsafe.Pointer(p_t2)).Fimage
	var l_cp uintptr = (*Topj_t2_t)(unsafe.Pointer(p_t2)).Fcp
	var l_tcp uintptr = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	var pocno TOPJ_UINT32
	if int32((*Topj_cp_t)(unsafe.Pointer(l_cp)).Frsiz) == DOPJ_PROFILE_CINEMA_4K {
		pocno = uint32(2)
	} else {
		pocno = uint32(1)
	}
	var l_max_comp TOPJ_UINT32
	if (*Topj_encoding_param_t)(unsafe.Pointer(l_cp+120)).Fm_max_comp_size > TOPJ_UINT32(0) {
		l_max_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps
	} else {
		l_max_comp = uint32(1)
	}
	var l_nb_pocs TOPJ_UINT32 = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs + TOPJ_UINT32(1)

	l_pi = Xopj_pi_initialise_encode(tls, l_image, l_cp, p_tile_no, p_t2_mode, p_manager)
	if !(l_pi != 0) {
		return DOPJ_FALSE
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) = TOPJ_UINT32(0)

	if p_t2_mode == THRESH_CALC { // Calculating threshold
		l_current_pi = l_pi

		for compno = TOPJ_UINT32(0); compno < l_max_comp; compno++ {
			var l_comp_len TOPJ_UINT32 = TOPJ_UINT32(0)
			l_current_pi = l_pi

			for poc = TOPJ_UINT32(0); poc < pocno; poc++ {
				var l_tp_num TOPJ_UINT32 = compno

				// TODO MSD : check why this function cannot fail (cf. v1)
				Xopj_pi_create_encode(tls, l_pi, l_cp, p_tile_no, poc, l_tp_num, p_tp_pos, p_t2_mode)

				if (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fpoc.Fprg == OPJ_PROG_UNKNOWN {
					// TODO ADE : add an error
					Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
					return DOPJ_FALSE
				}
				for Xopj_pi_next(tls, l_current_pi) != 0 {
					if (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Flayno < p_maxlayers {
						*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes */)) = TOPJ_UINT32(0)

						if !(opj_t2_encode_packet(tls, p_tile_no, p_tile, l_tcp, l_current_pi,
							l_current_data, bp,
							p_max_len, cstr_info,
							p_t2_mode,
							p_manager) != 0) {
							Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
							return DOPJ_FALSE
						}

						l_comp_len = l_comp_len + *(*TOPJ_UINT32)(unsafe.Pointer(bp))
						l_current_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes */)))
						p_max_len = p_max_len - *(*TOPJ_UINT32)(unsafe.Pointer(bp))

						*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) += *(*TOPJ_UINT32)(unsafe.Pointer(bp))
					}
				}

				if (*Topj_encoding_param_t)(unsafe.Pointer(l_cp+120)).Fm_max_comp_size != 0 {
					if l_comp_len > (*Topj_encoding_param_t)(unsafe.Pointer(l_cp+120)).Fm_max_comp_size {
						Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
						return DOPJ_FALSE
					}
				}

				l_current_pi += 256
			}
		}
	} else { // t2_mode == FINAL_PASS
		Xopj_pi_create_encode(tls, l_pi, l_cp, p_tile_no, p_pino, p_tp_num, p_tp_pos,
			p_t2_mode)

		l_current_pi = l_pi + uintptr(p_pino)*256
		if (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fpoc.Fprg == OPJ_PROG_UNKNOWN {
			// TODO ADE : add an error
			Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
			return DOPJ_FALSE
		}

		if p_marker_info != 0 && (*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fneed_PLT != 0 {
			// One time use intended
			if (*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fpacket_count == TOPJ_UINT32(0) {
			} else {
				libc.X__assert_fail(tls, ts+32872, ts+32905, uint32(317), uintptr(unsafe.Pointer(&__func__268)))
			}
			if (*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fp_packet_size == uintptr(0) {
			} else {
				libc.X__assert_fail(tls, ts+32929, ts+32905, uint32(318), uintptr(unsafe.Pointer(&__func__268)))
			}

			(*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fp_packet_size = Xopj_malloc(tls,
				uint32(Xopj_get_encoding_packet_count(tls, l_image, l_cp, p_tile_no))*uint32(unsafe.Sizeof(TOPJ_UINT32(0))))
			if (*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fp_packet_size == uintptr(0) {
				Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
				return DOPJ_FALSE
			}
		}

		for Xopj_pi_next(tls, l_current_pi) != 0 {
			if (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Flayno < p_maxlayers {
				*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes */)) = TOPJ_UINT32(0)

				if !(opj_t2_encode_packet(tls, p_tile_no, p_tile, l_tcp, l_current_pi,
					l_current_data, bp, p_max_len,
					cstr_info, p_t2_mode, p_manager) != 0) {
					Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
					return DOPJ_FALSE
				}

				l_current_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes */)))
				p_max_len = p_max_len - *(*TOPJ_UINT32)(unsafe.Pointer(bp))

				*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) += *(*TOPJ_UINT32)(unsafe.Pointer(bp))

				if p_marker_info != 0 && (*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fneed_PLT != 0 {
					*(*TOPJ_UINT32)(unsafe.Pointer((*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fp_packet_size + uintptr((*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fpacket_count)*4)) = *(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_bytes */))
					(*Topj_tcd_marker_info_t)(unsafe.Pointer(p_marker_info)).Fpacket_count++
				}

				// INDEX >>
				if cstr_info != 0 {
					if (*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Findex_write != 0 {
						var info_TL uintptr = (*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Ftile + uintptr(p_tile_no)*608
						var info_PK uintptr = (*Topj_tile_info_t)(unsafe.Pointer(info_TL)).Fpacket + uintptr((*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Fpackno)*24
						if !((*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Fpackno != 0) {
							(*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fstart_pos = TOPJ_OFF_T((*Topj_tile_info_t)(unsafe.Pointer(info_TL)).Fend_header + 1)
						} else {
							(*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fstart_pos = func() int32 {
								if int32(*(*uint8)(unsafe.Pointer(l_cp + 120 + 20))&0x8>>3)|int32(*(*uint8)(unsafe.Pointer(l_tcp + 5688))&0x4>>2) != 0 && (*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fstart_pos != 0 {
									return (*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fstart_pos
								}
								return (*Topj_packet_info_t)(unsafe.Pointer((*Topj_tile_info_t)(unsafe.Pointer(info_TL)).Fpacket+uintptr((*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Fpackno-1)*24)).Fend_pos + 1
							}()
						}
						(*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fend_pos = TOPJ_OFF_T(uint32((*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fstart_pos) + uint32(*(*TOPJ_UINT32)(unsafe.Pointer(bp))) - uint32(1))
						*(*TOPJ_OFF_T)(unsafe.Pointer(info_PK + 4)) += (*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fstart_pos - 1 // End of packet header which now only represents the distance
						//                                                                                                                                                                                                                                                    to start of packet is incremented by value of start of packet
					}

					(*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Fpackno++
				}
				// << INDEX
				(*Topj_tcd_tile_t)(unsafe.Pointer(p_tile)).Fpackno++
			}
		}
	}

	Xopj_pi_destroy(tls, l_pi, l_nb_pocs)

	return DOPJ_TRUE
}

var __func__268 = *(*[22]int8)(unsafe.Pointer(ts + 32966)) /* t2.c:233:1 */

// see issue 80
// issue 290
func opj_null_jas_fprintf(tls *libc.TLS, file uintptr, format uintptr, va uintptr) { /* t2.c:385:13: */
	_ = file
	_ = format
}

func Xopj_t2_decode_packets(tls *libc.TLS, tcd uintptr, p_t2 uintptr, p_tile_no TOPJ_UINT32, p_tile uintptr, p_src uintptr, p_data_read uintptr, p_max_len TOPJ_UINT32, p_cstr_index uintptr, p_manager uintptr) TOPJ_BOOL { /* t2.c:393:10: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var l_current_data uintptr = p_src
	var l_pi uintptr = uintptr(00)
	var pino TOPJ_UINT32
	var l_image uintptr = (*Topj_t2_t)(unsafe.Pointer(p_t2)).Fimage
	var l_cp uintptr = (*Topj_t2_t)(unsafe.Pointer(p_t2)).Fcp
	var l_tcp uintptr = (*Topj_cp_t)(unsafe.Pointer((*Topj_t2_t)(unsafe.Pointer(p_t2)).Fcp)).Ftcps + uintptr(p_tile_no)*5696
	// var l_nb_bytes_read TOPJ_UINT32 at bp+40, 4

	var l_nb_pocs TOPJ_UINT32 = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs + TOPJ_UINT32(1)
	var l_current_pi uintptr = uintptr(00)
	var l_pack_info uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)

	_ = p_cstr_index

	// create a packet iterator
	l_pi = Xopj_pi_create_decode(tls, l_image, l_cp, p_tile_no, p_manager)
	if !(l_pi != 0) {
		return DOPJ_FALSE
	}

	l_current_pi = l_pi

	for pino = TOPJ_UINT32(0); pino <= (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnumpocs; pino++ {

		// if the resolution needed is too low, one dim of the tilec could be equal to zero
		// and no packets are used to decode this resolution and
		// l_current_pi->resno is always >= p_tile->comps[l_current_pi->compno].minimum_num_resolutions
		// and no l_img_comp->resno_decoded are computed
		var first_pass_failed uintptr = uintptr(0)

		if (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fpoc.Fprg == OPJ_PROG_UNKNOWN {
			// TODO ADE : add an error
			Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
			return DOPJ_FALSE
		}

		first_pass_failed = Xopj_malloc(tls, uint32((*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps)*uint32(unsafe.Sizeof(TOPJ_BOOL(0))))
		if !(first_pass_failed != 0) {
			Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
			return DOPJ_FALSE
		}
		libc.Xmemset(tls, first_pass_failed, DOPJ_TRUE, uint32((*Topj_image_t)(unsafe.Pointer(l_image)).Fnumcomps)*uint32(unsafe.Sizeof(TOPJ_BOOL(0))))

		for Xopj_pi_next(tls, l_current_pi) != 0 {
			var skip_packet TOPJ_BOOL = DOPJ_FALSE
			opj_null_jas_fprintf(tls, libc.Xstderr,
				ts+32988,
				libc.VaList(bp, (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fpoc.Fprg1, (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno, (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fresno,
					(*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fprecno, (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Flayno))

			// If the packet layer is greater or equal than the maximum
			// number of layers, skip the packet
			if (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Flayno >= (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fnum_layers_to_decode {
				skip_packet = DOPJ_TRUE
			} else if (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fresno >= (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(p_tile)).Fcomps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno)*104)).Fminimum_num_resolutions {
				skip_packet = DOPJ_TRUE
			} else {
				// If no precincts of any band intersects the area of interest,
				// skip the packet
				var bandno TOPJ_UINT32
				var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer(p_tile)).Fcomps + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno)*104
				var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fresno)*192

				skip_packet = DOPJ_TRUE
				for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands; bandno++ {
					var band uintptr = res + 32 + uintptr(bandno)*48
					var prec uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fprecno)*56

					if Xopj_tcd_is_subband_area_of_interest(tls, tcd,
						(*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno,
						(*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fresno,
						(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fbandno,
						TOPJ_UINT32((*Topj_tcd_precinct_t)(unsafe.Pointer(prec)).Fx0),
						TOPJ_UINT32((*Topj_tcd_precinct_t)(unsafe.Pointer(prec)).Fy0),
						TOPJ_UINT32((*Topj_tcd_precinct_t)(unsafe.Pointer(prec)).Fx1),
						TOPJ_UINT32((*Topj_tcd_precinct_t)(unsafe.Pointer(prec)).Fy1)) != 0 {
						skip_packet = DOPJ_FALSE
						break
					}
				}
				//
				//                                 printf("packet cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d -> %s\n",
				//                                     l_current_pi->compno, l_current_pi->resno,
				//                                     l_current_pi->precno, l_current_pi->layno, skip_packet ? "skipped" : "kept");
				//
			}
			if !(skip_packet != 0) {
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 40 /* l_nb_bytes_read */)) = TOPJ_UINT32(0)

				*(*TOPJ_BOOL)(unsafe.Pointer(first_pass_failed + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno)*4)) = DOPJ_FALSE

				if !(opj_t2_decode_packet(tls, p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
					bp+40, p_max_len, l_pack_info, p_manager) != 0) {
					Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
					Xopj_free(tls, first_pass_failed)
					return DOPJ_FALSE
				}

				l_img_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno)*64
				(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded = opj_uint_max(tls, (*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fresno,
					(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded)
			} else {
				*(*TOPJ_UINT32)(unsafe.Pointer(bp + 40 /* l_nb_bytes_read */)) = TOPJ_UINT32(0)
				if !(opj_t2_skip_packet(tls, p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
					bp+40, p_max_len, l_pack_info, p_manager) != 0) {
					Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
					Xopj_free(tls, first_pass_failed)
					return DOPJ_FALSE
				}
			}

			if *(*TOPJ_BOOL)(unsafe.Pointer(first_pass_failed + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno)*4)) != 0 {
				l_img_comp = (*Topj_image_t)(unsafe.Pointer(l_image)).Fcomps + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno)*64
				if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded == TOPJ_UINT32(0) {
					(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(p_tile)).Fcomps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(l_current_pi)).Fcompno)*104)).Fminimum_num_resolutions - TOPJ_UINT32(1)
				}
			}

			l_current_data += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 40 /* l_nb_bytes_read */)))
			p_max_len = p_max_len - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 40))

			// INDEX >>
			// << INDEX
		}
		l_current_pi += 256

		Xopj_free(tls, first_pass_failed)
	}
	// INDEX >>
	// << INDEX

	// don't forget to release pi
	Xopj_pi_destroy(tls, l_pi, l_nb_pocs)
	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = TOPJ_UINT32((int32(l_current_data) - int32(p_src)) / 1)
	return DOPJ_TRUE
}

// -----------------------------------------------------------------------

// *
// Creates a Tier 2 handle
//
// @param       p_image         Source or destination image
// @param       p_cp            Image coding parameters.
// @return              a new T2 handle if successful, NULL otherwise.
func Xopj_t2_create(tls *libc.TLS, p_image uintptr, p_cp uintptr) uintptr { /* t2.c:599:9: */
	// create the t2 structure
	var l_t2 uintptr = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_t2_t{})))
	if !(l_t2 != 0) {
		return uintptr(0)
	}

	(*Topj_t2_t)(unsafe.Pointer(l_t2)).Fimage = p_image
	(*Topj_t2_t)(unsafe.Pointer(l_t2)).Fcp = p_cp

	return l_t2
}

func Xopj_t2_destroy(tls *libc.TLS, t2 uintptr) { /* t2.c:613:6: */
	if t2 != 0 {
		Xopj_free(tls, t2)
	}
}

func opj_t2_decode_packet(tls *libc.TLS, p_t2 uintptr, p_tile uintptr, p_tcp uintptr, p_pi uintptr, p_src uintptr, p_data_read uintptr, p_max_length TOPJ_UINT32, p_pack_info uintptr, p_manager uintptr) TOPJ_BOOL { /* t2.c:620:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var l_read_data TOPJ_BOOL at bp, 4

	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_nb_bytes_read */)) = TOPJ_UINT32(0)
	var l_nb_total_bytes_read TOPJ_UINT32 = TOPJ_UINT32(0)

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = TOPJ_UINT32(0)

	if !(opj_t2_read_packet_header(tls, p_t2, p_tile, p_tcp, p_pi, bp, p_src,
		bp+4, p_max_length, p_pack_info, p_manager) != 0) {
		return DOPJ_FALSE
	}

	p_src += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_nb_bytes_read */)))
	l_nb_total_bytes_read = l_nb_total_bytes_read + *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))
	p_max_length = p_max_length - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))

	// we should read data for the packet
	if *(*TOPJ_BOOL)(unsafe.Pointer(bp)) != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_nb_bytes_read */)) = TOPJ_UINT32(0)

		if !(opj_t2_read_packet_data(tls, p_t2, p_tile, p_pi, p_src, bp+4,
			p_max_length, p_pack_info, p_manager) != 0) {
			return DOPJ_FALSE
		}

		l_nb_total_bytes_read = l_nb_total_bytes_read + *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))
	}

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = l_nb_total_bytes_read

	return DOPJ_TRUE
}

func opj_t2_encode_packet(tls *libc.TLS, tileno TOPJ_UINT32, tile uintptr, tcp uintptr, pi uintptr, dest uintptr, p_data_written uintptr, length TOPJ_UINT32, cstr_info uintptr, p_t2_mode TJ2K_T2_MODE, p_manager uintptr) TOPJ_BOOL { /* t2.c:662:17: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var bandno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var c uintptr = dest
	var l_nb_bytes TOPJ_UINT32
	var compno TOPJ_UINT32 = (*Topj_pi_iterator_t2)(unsafe.Pointer(pi)).Fcompno // component value
	var resno TOPJ_UINT32 = (*Topj_pi_iterator_t2)(unsafe.Pointer(pi)).Fresno   // resolution level value
	var precno TOPJ_UINT32 = (*Topj_pi_iterator_t2)(unsafe.Pointer(pi)).Fprecno // precinct value
	var layno TOPJ_UINT32 = (*Topj_pi_iterator_t2)(unsafe.Pointer(pi)).Flayno   // quality layer value
	var l_nb_blocks TOPJ_UINT32
	var band uintptr = uintptr(00)
	var cblk uintptr = uintptr(00)
	var pass uintptr = uintptr(00)

	var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer(tile)).Fcomps + uintptr(compno)*104
	var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno)*192

	var bio uintptr = uintptr(00) // BIO component
	var packet_empty TOPJ_BOOL = DOPJ_FALSE

	// <SOP 0xff91>
	if (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fcsty&TOPJ_UINT32(DJ2K_CP_CSTY_SOP) != 0 {
		if length < TOPJ_UINT32(6) {
			if p_t2_mode == FINAL_PASS {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,

					ts+33066,
					libc.VaList(bp, length, 6))
			}
			return DOPJ_FALSE
		}
		*(*TOPJ_BYTE)(unsafe.Pointer(c)) = TOPJ_BYTE(255)
		*(*TOPJ_BYTE)(unsafe.Pointer(c + 1)) = TOPJ_BYTE(145)
		*(*TOPJ_BYTE)(unsafe.Pointer(c + 2)) = TOPJ_BYTE(0)
		*(*TOPJ_BYTE)(unsafe.Pointer(c + 3)) = TOPJ_BYTE(4)
		*(*TOPJ_BYTE)(unsafe.Pointer(c + 4)) = TOPJ_BYTE((*Topj_tcd_tile_t)(unsafe.Pointer(tile)).Fpackno >> 8 & TOPJ_UINT32(0xff)) // packno is uint32_t
		*(*TOPJ_BYTE)(unsafe.Pointer(c + 5)) = TOPJ_BYTE((*Topj_tcd_tile_t)(unsafe.Pointer(tile)).Fpackno & TOPJ_UINT32(0xff))
		c += uintptr(6)
		length = length - TOPJ_UINT32(6)
	}
	// </SOP>

	if !(layno != 0) {
		band = res + 32 /* &.bands */

		bandno = TOPJ_UINT32(0)
	__1:
		if !(bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands) {
			goto __3
		}
		{
			var prc uintptr

			// Skip empty bands
			if Xopj_tcd_is_band_empty(tls, band) != 0 {
				goto __2
			}

			// Avoid out of bounds access of https://github.com/uclouvain/openjpeg/issues/1294
			// but likely not a proper fix.
			if precno >= (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+33144,
					libc.VaList(bp+16, precno, (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph))
				return DOPJ_FALSE
			}

			prc = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56
			Xopj_tgt_reset(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fincltree)
			Xopj_tgt_reset(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fimsbtree)

			l_nb_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fcw * (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fch
			for cblkno = TOPJ_UINT32(0); cblkno < l_nb_blocks; cblkno++ {
				cblk = *(*uintptr)(unsafe.Pointer(prc + 24)) + uintptr(cblkno)*64

				(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses = TOPJ_UINT32(0)
				Xopj_tgt_setvalue(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fimsbtree, cblkno, (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fnumbps-TOPJ_INT32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumbps))
			}

		}
		goto __2
	__2:
		bandno++
		band += 48
		goto __1
		goto __3
	__3:
	}

	bio = Xopj_bio_create(tls)
	if !(bio != 0) {
		// FIXME event manager error callback
		return DOPJ_FALSE
	}
	Xopj_bio_init_enc(tls, bio, c, length)

	Xopj_bio_write(tls, bio, func() uint32 {
		if packet_empty != 0 {
			return uint32(0)
		}
		return uint32(1)
	}(), uint32(1)) // Empty header bit

	// Writing Packet header
	band = res + 32 /* &.bands */
	bandno = TOPJ_UINT32(0)
__4:
	if !(!(packet_empty != 0) && bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands) {
		goto __6
	}
	{
		var prc uintptr

		// Skip empty bands
		if Xopj_tcd_is_band_empty(tls, band) != 0 {
			goto __5
		}

		// Avoid out of bounds access of https://github.com/uclouvain/openjpeg/issues/1297
		// but likely not a proper fix.
		if precno >= (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph {
			Xopj_event_msg(tls, p_manager, DEVT_ERROR,
				ts+33144,
				libc.VaList(bp+32, precno, (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph))
			return DOPJ_FALSE
		}

		prc = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56
		l_nb_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fcw * (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fch
		cblk = *(*uintptr)(unsafe.Pointer(prc + 24))

		for cblkno = TOPJ_UINT32(0); cblkno < l_nb_blocks; cblkno++ {
			var layer uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Flayers + uintptr(layno)*24

			if !(int32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses) != 0) && (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses != 0 {
				Xopj_tgt_setvalue(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fincltree, cblkno, TOPJ_INT32(layno))
			}

			cblk += 64
		}

		cblk = *(*uintptr)(unsafe.Pointer(prc + 24))
		for cblkno = TOPJ_UINT32(0); cblkno < l_nb_blocks; cblkno++ {
			var layer uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Flayers + uintptr(layno)*24
			var increment TOPJ_UINT32 = TOPJ_UINT32(0)
			var nump TOPJ_UINT32 = TOPJ_UINT32(0)
			var len TOPJ_UINT32 = TOPJ_UINT32(0)
			var passno TOPJ_UINT32
			var l_nb_passes TOPJ_UINT32

			// cblk inclusion bits
			if !(int32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses) != 0) {
				Xopj_tgt_encode(tls, bio, (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fincltree, cblkno, TOPJ_INT32(layno+TOPJ_UINT32(1)))
			} else {
				Xopj_bio_write(tls, bio, uint32(libc.Bool32((*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses != TOPJ_UINT32(0))), uint32(1))
			}

			// if cblk not included, go to the next cblk
			if !(int32((*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses) != 0) {
				cblk += 64
				continue
			}

			// if first instance of cblk --> zero bit-planes information
			if !(int32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses) != 0) {
				(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumlenbits = TOPJ_UINT32(3)
				Xopj_tgt_encode(tls, bio, (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fimsbtree, cblkno, 999)
			}

			// number of coding passes included
			opj_t2_putnumpasses(tls, bio, (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses)
			l_nb_passes = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses + (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses
			pass = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses)*24

			// computation of the increase of the length indicator and insertion in the header
			for passno = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses; passno < l_nb_passes; passno++ {
				nump++
				len = len + (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Flen

				if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(pass + 20))&0x1>>0)) != 0 || passno == (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses+(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses-TOPJ_UINT32(1) {
					increment = TOPJ_UINT32(opj_int_max(tls, TOPJ_INT32(increment),
						opj_int_floorlog2(tls, TOPJ_INT32(len))+1-
							(TOPJ_INT32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumlenbits)+opj_int_floorlog2(tls, TOPJ_INT32(nump)))))
					len = TOPJ_UINT32(0)
					nump = TOPJ_UINT32(0)
				}

				pass += 24
			}
			opj_t2_putcommacode(tls, bio, TOPJ_INT32(increment))

			// computation of the new Length indicator
			*(*TOPJ_UINT32)(unsafe.Pointer(cblk + 44)) += increment

			pass = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses)*24
			// insertion of the codeword segment length
			for passno = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses; passno < l_nb_passes; passno++ {
				nump++
				len = len + (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Flen

				if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(pass + 20))&0x1>>0)) != 0 || passno == (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpasses+(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses-TOPJ_UINT32(1) {
					Xopj_bio_write(tls, bio, len,
						(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumlenbits+TOPJ_UINT32(opj_int_floorlog2(tls, TOPJ_INT32(nump))))
					len = TOPJ_UINT32(0)
					nump = TOPJ_UINT32(0)
				}
				pass += 24
			}

			cblk += 64
		}

	}
	goto __5
__5:
	bandno++
	band += 48
	goto __4
	goto __6
__6:
	;

	if !(Xopj_bio_flush(tls, bio) != 0) {
		Xopj_bio_destroy(tls, bio)
		return DOPJ_FALSE // modified to eliminate longjmp !!
	}

	l_nb_bytes = TOPJ_UINT32(Xopj_bio_numbytes(tls, bio))
	c += uintptr(l_nb_bytes)
	length = length - l_nb_bytes

	Xopj_bio_destroy(tls, bio)

	// <EPH 0xff92>
	if (*Topj_tcp_t)(unsafe.Pointer(tcp)).Fcsty&TOPJ_UINT32(DJ2K_CP_CSTY_EPH) != 0 {
		if length < TOPJ_UINT32(2) {
			if p_t2_mode == FINAL_PASS {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,

					ts+33066,
					libc.VaList(bp+48, length, 2))
			}
			return DOPJ_FALSE
		}
		*(*TOPJ_BYTE)(unsafe.Pointer(c)) = TOPJ_BYTE(255)
		*(*TOPJ_BYTE)(unsafe.Pointer(c + 1)) = TOPJ_BYTE(146)
		c += uintptr(2)
		length = length - TOPJ_UINT32(2)
	}
	// </EPH>

	// << INDEX
	// End of packet header position. Currently only represents the distance to start of packet
	//        Will be updated later by incrementing with packet start value
	if cstr_info != 0 && (*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Findex_write != 0 {
		var info_PK uintptr = (*Topj_tile_info_t)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Ftile+uintptr(tileno)*608)).Fpacket + uintptr((*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Fpackno)*24
		(*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fend_ph_pos = TOPJ_OFF_T(TOPJ_INT32((int32(c) - int32(dest)) / 1))
	}
	// INDEX >>

	// Writing the packet body
	band = res + 32 /* &.bands */
	bandno = TOPJ_UINT32(0)
__7:
	if !(!(packet_empty != 0) && bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands) {
		goto __9
	}
	{
		var prc uintptr

		// Skip empty bands
		if Xopj_tcd_is_band_empty(tls, band) != 0 {
			goto __8
		}

		prc = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56
		l_nb_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fcw * (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fch
		cblk = *(*uintptr)(unsafe.Pointer(prc + 24))

		for cblkno = TOPJ_UINT32(0); cblkno < l_nb_blocks; cblkno++ {
			var layer uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Flayers + uintptr(layno)*24

			if !(int32((*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses) != 0) {
				cblk += 64
				continue
			}

			if (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen > length {
				if p_t2_mode == FINAL_PASS {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,

						ts+33066,
						libc.VaList(bp+64, length, (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen))
				}
				return DOPJ_FALSE
			}

			libc.Xmemcpy(tls, c, (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdata, uint32((*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen))
			*(*TOPJ_UINT32)(unsafe.Pointer(cblk + 52)) += (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses
			c += uintptr((*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen)
			length = length - (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen

			// << INDEX
			if cstr_info != 0 && (*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Findex_write != 0 {
				var info_PK uintptr = (*Topj_tile_info_t)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Ftile+uintptr(tileno)*608)).Fpacket + uintptr((*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Fpackno)*24
				*(*float64)(unsafe.Pointer(info_PK + 16)) += (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdisto
				if (*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).FD_max < (*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fdisto {
					(*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).FD_max = (*Topj_packet_info_t)(unsafe.Pointer(info_PK)).Fdisto
				}
			}

			cblk += 64
			// INDEX >>
		}

	}
	goto __8
__8:
	bandno++
	band += 48
	goto __7
	goto __9
__9:
	;

	if c >= dest {
	} else {
		libc.X__assert_fail(tls, ts+33195, ts+32905, uint32(1000), uintptr(unsafe.Pointer(&__func__269)))
	}
	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_written)) += TOPJ_UINT32((int32(c) - int32(dest)) / 1)

	return DOPJ_TRUE
}

var __func__269 = *(*[21]int8)(unsafe.Pointer(ts + 33205)) /* t2.c:672:1 */

func opj_t2_skip_packet(tls *libc.TLS, p_t2 uintptr, p_tile uintptr, p_tcp uintptr, p_pi uintptr, p_src uintptr, p_data_read uintptr, p_max_length TOPJ_UINT32, p_pack_info uintptr, p_manager uintptr) TOPJ_BOOL { /* t2.c:1006:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var l_read_data TOPJ_BOOL at bp, 4

	*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_nb_bytes_read */)) = TOPJ_UINT32(0)
	var l_nb_total_bytes_read TOPJ_UINT32 = TOPJ_UINT32(0)

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = TOPJ_UINT32(0)

	if !(opj_t2_read_packet_header(tls, p_t2, p_tile, p_tcp, p_pi, bp, p_src,
		bp+4, p_max_length, p_pack_info, p_manager) != 0) {
		return DOPJ_FALSE
	}

	p_src += uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_nb_bytes_read */)))
	l_nb_total_bytes_read = l_nb_total_bytes_read + *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))
	p_max_length = p_max_length - *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))

	// we should read data for the packet
	if *(*TOPJ_BOOL)(unsafe.Pointer(bp)) != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 4 /* l_nb_bytes_read */)) = TOPJ_UINT32(0)

		if !(opj_t2_skip_packet_data(tls, p_t2, p_tile, p_pi, bp+4,
			p_max_length, p_pack_info, p_manager) != 0) {
			return DOPJ_FALSE
		}

		l_nb_total_bytes_read = l_nb_total_bytes_read + *(*TOPJ_UINT32)(unsafe.Pointer(bp + 4))
	}
	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = l_nb_total_bytes_read

	return DOPJ_TRUE
}

func opj_t2_read_packet_header(tls *libc.TLS, p_t2 uintptr, p_tile uintptr, p_tcp uintptr, p_pi uintptr, p_is_data_present uintptr, p_src_data uintptr, p_data_read uintptr, p_max_length TOPJ_UINT32, p_pack_info uintptr, p_manager uintptr) TOPJ_BOOL { /* t2.c:1048:17: */
	bp := tls.Alloc(116)
	defer tls.Free(116)

	// loop
	var bandno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var l_nb_code_blocks TOPJ_UINT32
	// var l_remaining_length TOPJ_UINT32 at bp+112, 4

	var l_header_length TOPJ_UINT32
	var l_modified_length_ptr uintptr = uintptr(00)
	*(*uintptr)(unsafe.Pointer(bp + 104 /* l_current_data */)) = p_src_data
	var l_cp uintptr = (*Topj_t2_t)(unsafe.Pointer(p_t2)).Fcp
	var l_bio uintptr = uintptr(00) // BIO component
	var l_band uintptr = uintptr(00)
	var l_cblk uintptr = uintptr(00)
	var l_res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(p_tile)).Fcomps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno)*104)).Fresolutions + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fresno)*192

	var l_header_data uintptr = uintptr(00)
	var l_header_data_start uintptr = uintptr(00)
	var l_present TOPJ_UINT32

	if (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Flayno == TOPJ_UINT32(0) {
		l_band = l_res + 32 /* &.bands */

		// reset tagtrees
		for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fnumbands; bandno++ {
			if !(Xopj_tcd_is_band_empty(tls, l_band) != 0) {
				var l_prc uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno)*56
				if !(uint32((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno) < uint32((*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts_data_size)/uint32(unsafe.Sizeof(Topj_tcd_precinct_t{}))) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+33226, 0)
					return DOPJ_FALSE
				}

				Xopj_tgt_reset(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fincltree)
				Xopj_tgt_reset(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fimsbtree)
				l_cblk = *(*uintptr)(unsafe.Pointer(l_prc + 24))

				l_nb_code_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fcw * (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fch
				for cblkno = TOPJ_UINT32(0); cblkno < l_nb_code_blocks; cblkno++ {
					(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs = TOPJ_UINT32(0)
					(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Freal_num_segs = TOPJ_UINT32(0)
					l_cblk += 80
				}
			}

			l_band += 48
		}
	}

	// SOP markers

	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fcsty&TOPJ_UINT32(DJ2K_CP_CSTY_SOP) != 0 {
		if p_max_length < TOPJ_UINT32(6) {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+33244, 0)
		} else if int32(*(*TOPJ_BYTE)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 104))))) != 0xff || int32(*(*TOPJ_BYTE)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 104)) + uintptr(1)))) != 0x91 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+33286, 0)
		} else {
			*(*uintptr)(unsafe.Pointer(bp + 104 /* l_current_data */)) += uintptr(6)
		}

		//* TODO : check the Nsop value
	}

	//
	//     When the marker PPT/PPM is used the packet header are store in PPT/PPM marker
	//     This part deal with this characteristic
	//     step 1: Read packet header in the saved structure
	//     step 2: Return to codestream for decoding
	//

	l_bio = Xopj_bio_create(tls)
	if !(l_bio != 0) {
		return DOPJ_FALSE
	}

	if int32(*(*uint8)(unsafe.Pointer(l_cp + 148))&0x1>>0) == 1 { // PPM
		l_header_data_start = l_cp + 56
		l_header_data = *(*uintptr)(unsafe.Pointer(l_header_data_start))
		l_modified_length_ptr = l_cp + 64

	} else if int32(*(*uint8)(unsafe.Pointer(p_tcp + 5688))&0x2>>1) == 1 { // PPT
		l_header_data_start = p_tcp + 5176
		l_header_data = *(*uintptr)(unsafe.Pointer(l_header_data_start))
		l_modified_length_ptr = p_tcp + 5196
	} else { // Normal Case
		l_header_data_start = bp + 104 /* &l_current_data */
		l_header_data = *(*uintptr)(unsafe.Pointer(l_header_data_start))
		*(*TOPJ_UINT32)(unsafe.Pointer(bp + 112 /* l_remaining_length */)) = TOPJ_UINT32((int32(p_src_data+uintptr(p_max_length)) - int32(l_header_data)) / 1)
		l_modified_length_ptr = bp + 112 /* &l_remaining_length */
	}

	Xopj_bio_init_dec(tls, l_bio, l_header_data, *(*TOPJ_UINT32)(unsafe.Pointer(l_modified_length_ptr)))

	l_present = Xopj_bio_read(tls, l_bio, uint32(1))
	opj_null_jas_fprintf(tls, libc.Xstderr, ts+33307, libc.VaList(bp, l_present))
	if !(l_present != 0) {
		// TODO MSD: no test to control the output of this function
		Xopj_bio_inalign(tls, l_bio)
		l_header_data += uintptr(Xopj_bio_numbytes(tls, l_bio))
		Xopj_bio_destroy(tls, l_bio)

		// EPH markers
		if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fcsty&TOPJ_UINT32(DJ2K_CP_CSTY_EPH) != 0 {
			if *(*TOPJ_UINT32)(unsafe.Pointer(l_modified_length_ptr))-TOPJ_UINT32((int32(l_header_data)-int32(*(*uintptr)(unsafe.Pointer(l_header_data_start))))/1) < 2 {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING,
					ts+33320, 0)
			} else if int32(*(*TOPJ_BYTE)(unsafe.Pointer(l_header_data))) != 0xff || int32(*(*TOPJ_BYTE)(unsafe.Pointer(l_header_data + uintptr(1)))) != 0x92 {
				Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+33362, 0)
			} else {
				l_header_data += uintptr(2)
			}
		}

		l_header_length = TOPJ_UINT32((int32(l_header_data) - int32(*(*uintptr)(unsafe.Pointer(l_header_data_start)))) / 1)
		*(*TOPJ_UINT32)(unsafe.Pointer(l_modified_length_ptr)) -= l_header_length
		*(*uintptr)(unsafe.Pointer(l_header_data_start)) += uintptr(l_header_length)

		// << INDEX
		// End of packet header position. Currently only represents the distance to start of packet
		//            Will be updated later by incrementing with packet start value
		if p_pack_info != 0 {
			(*Topj_packet_info_t)(unsafe.Pointer(p_pack_info)).Fend_ph_pos = TOPJ_OFF_T(TOPJ_INT32((int32(*(*uintptr)(unsafe.Pointer(bp + 104))) - int32(p_src_data)) / 1))
		}
		// INDEX >>

		*(*TOPJ_BOOL)(unsafe.Pointer(p_is_data_present)) = DOPJ_FALSE
		*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = TOPJ_UINT32((int32(*(*uintptr)(unsafe.Pointer(bp + 104))) - int32(p_src_data)) / 1)
		return DOPJ_TRUE
	}

	l_band = l_res + 32 /* &.bands */
	bandno = TOPJ_UINT32(0)
__1:
	if !(bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fnumbands) {
		goto __3
	}
	{
		var l_prc uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno)*56

		if Xopj_tcd_is_band_empty(tls, l_band) != 0 {
			goto __2
		}

		l_nb_code_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fcw * (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fch
		l_cblk = *(*uintptr)(unsafe.Pointer(l_prc + 24))
		for cblkno = TOPJ_UINT32(0); cblkno < l_nb_code_blocks; cblkno++ {
			var l_included TOPJ_UINT32
			var l_increment TOPJ_UINT32
			var l_segno TOPJ_UINT32
			var n TOPJ_INT32

			// if cblk not yet included before --> inclusion tagtree
			if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs) != 0) {
				l_included = Xopj_tgt_decode(tls, l_bio, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fincltree, cblkno,
					TOPJ_INT32((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Flayno+TOPJ_UINT32(1)))
				// else one bit
			} else {
				l_included = Xopj_bio_read(tls, l_bio, uint32(1))
			}

			// if cblk not included
			if !(l_included != 0) {
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses = TOPJ_UINT32(0)
				l_cblk += 80
				opj_null_jas_fprintf(tls, libc.Xstderr, ts+33383, libc.VaList(bp+8, l_included))
				continue
			}

			// if cblk not yet included --> zero-bitplane tagtree
			if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs) != 0) {
				var i TOPJ_UINT32 = TOPJ_UINT32(0)

				for !(Xopj_tgt_decode(tls, l_bio, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fimsbtree, cblkno, TOPJ_INT32(i)) != 0) {
					i++
				}

				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).FMb = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fnumbps)
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumbps = TOPJ_UINT32((*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fnumbps) + TOPJ_UINT32(1) - i
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumlenbits = TOPJ_UINT32(3)
			}

			// number of coding passes
			(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses = opj_t2_getnumpasses(tls, l_bio)
			l_increment = opj_t2_getcommacode(tls, l_bio)

			// length indicator increment
			*(*TOPJ_UINT32)(unsafe.Pointer(l_cblk + 40)) += l_increment
			l_segno = TOPJ_UINT32(0)

			if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs) != 0) {
				if !(opj_t2_init_seg(tls, l_cblk, l_segno, (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno)*1080)).Fcblksty, uint32(1)) != 0) {
					Xopj_bio_destroy(tls, l_bio)
					return DOPJ_FALSE
				}
			} else {
				l_segno = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs - TOPJ_UINT32(1)
				if (*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnumpasses == (*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fmaxpasses {
					l_segno++
					if !(opj_t2_init_seg(tls, l_cblk, l_segno, (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno)*1080)).Fcblksty, uint32(0)) != 0) {
						Xopj_bio_destroy(tls, l_bio)
						return DOPJ_FALSE
					}
				}
			}
			n = TOPJ_INT32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses)

			if (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno)*1080)).Fcblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_HT) != TOPJ_UINT32(0) {
				for __ccgo := true; __ccgo; __ccgo = n > 0 {
					var bit_number TOPJ_UINT32
					(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs + uintptr(l_segno)*24)).Fnumnewpasses = func() uint32 {
						if l_segno == TOPJ_UINT32(0) {
							return uint32(1)
						}
						return TOPJ_UINT32(n)
					}()
					bit_number = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumlenbits + opj_uint_floorlog2(tls,
						(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnumnewpasses)
					if bit_number > TOPJ_UINT32(32) {
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+33397,
							libc.VaList(bp+16, bit_number))
						Xopj_bio_destroy(tls, l_bio)
						return DOPJ_FALSE
					}
					(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs + uintptr(l_segno)*24)).Fnewlen = Xopj_bio_read(tls, l_bio, bit_number)
					opj_null_jas_fprintf(tls, libc.Xstderr, ts+33451,
						libc.VaList(bp+24, l_included, (*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnumnewpasses, l_increment,
							(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnewlen))

					n = n - TOPJ_INT32((*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnumnewpasses)
					if n > 0 {
						l_segno++

						if !(opj_t2_init_seg(tls, l_cblk, l_segno, (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno)*1080)).Fcblksty, uint32(0)) != 0) {
							Xopj_bio_destroy(tls, l_bio)
							return DOPJ_FALSE
						}
					}
				}
			} else {
				for __ccgo1 := true; __ccgo1; __ccgo1 = n > 0 {
					var bit_number TOPJ_UINT32
					(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs + uintptr(l_segno)*24)).Fnumnewpasses = TOPJ_UINT32(opj_int_min(tls, TOPJ_INT32((*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fmaxpasses-(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnumpasses), n))
					bit_number = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumlenbits + opj_uint_floorlog2(tls,
						(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnumnewpasses)
					if bit_number > TOPJ_UINT32(32) {
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+33397,
							libc.VaList(bp+56, bit_number))
						Xopj_bio_destroy(tls, l_bio)
						return DOPJ_FALSE
					}
					(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs + uintptr(l_segno)*24)).Fnewlen = Xopj_bio_read(tls, l_bio, bit_number)
					opj_null_jas_fprintf(tls, libc.Xstderr, ts+33451,
						libc.VaList(bp+64, l_included, (*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnumnewpasses, l_increment,
							(*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnewlen))

					n = n - TOPJ_INT32((*Topj_tcd_seg_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs+uintptr(l_segno)*24)).Fnumnewpasses)
					if n > 0 {
						l_segno++

						if !(opj_t2_init_seg(tls, l_cblk, l_segno, (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Ftccps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno)*1080)).Fcblksty, uint32(0)) != 0) {
							Xopj_bio_destroy(tls, l_bio)
							return DOPJ_FALSE
						}
					}
				}
			}

			l_cblk += 80
		}

	}
	goto __2
__2:
	bandno++
	l_band += 48
	goto __1
	goto __3
__3:
	;

	if !(Xopj_bio_inalign(tls, l_bio) != 0) {
		Xopj_bio_destroy(tls, l_bio)
		return DOPJ_FALSE
	}

	l_header_data += uintptr(Xopj_bio_numbytes(tls, l_bio))
	Xopj_bio_destroy(tls, l_bio)

	// EPH markers
	if (*Topj_tcp_t)(unsafe.Pointer(p_tcp)).Fcsty&TOPJ_UINT32(DJ2K_CP_CSTY_EPH) != 0 {
		if *(*TOPJ_UINT32)(unsafe.Pointer(l_modified_length_ptr))-TOPJ_UINT32((int32(l_header_data)-int32(*(*uintptr)(unsafe.Pointer(l_header_data_start))))/1) < 2 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING,
				ts+33320, 0)
		} else if int32(*(*TOPJ_BYTE)(unsafe.Pointer(l_header_data))) != 0xff || int32(*(*TOPJ_BYTE)(unsafe.Pointer(l_header_data + uintptr(1)))) != 0x92 {
			Xopj_event_msg(tls, p_manager, DEVT_WARNING, ts+33362, 0)
		} else {
			l_header_data += uintptr(2)
		}
	}

	l_header_length = TOPJ_UINT32((int32(l_header_data) - int32(*(*uintptr)(unsafe.Pointer(l_header_data_start)))) / 1)
	opj_null_jas_fprintf(tls, libc.Xstderr, ts+33501, libc.VaList(bp+96, l_header_length))
	opj_null_jas_fprintf(tls, libc.Xstderr, ts+33513, 0)
	*(*TOPJ_UINT32)(unsafe.Pointer(l_modified_length_ptr)) -= l_header_length
	*(*uintptr)(unsafe.Pointer(l_header_data_start)) += uintptr(l_header_length)

	// << INDEX
	// End of packet header position. Currently only represents the distance to start of packet
	//      Will be updated later by incrementing with packet start value
	if p_pack_info != 0 {
		(*Topj_packet_info_t)(unsafe.Pointer(p_pack_info)).Fend_ph_pos = TOPJ_OFF_T(TOPJ_INT32((int32(*(*uintptr)(unsafe.Pointer(bp + 104))) - int32(p_src_data)) / 1))
	}
	// INDEX >>

	*(*TOPJ_BOOL)(unsafe.Pointer(p_is_data_present)) = DOPJ_TRUE
	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = TOPJ_UINT32((int32(*(*uintptr)(unsafe.Pointer(bp + 104))) - int32(p_src_data)) / 1)

	return DOPJ_TRUE
}

func opj_t2_read_packet_data(tls *libc.TLS, p_t2 uintptr, p_tile uintptr, p_pi uintptr, p_src_data uintptr, p_data_read uintptr, p_max_length TOPJ_UINT32, pack_info uintptr, p_manager uintptr) TOPJ_BOOL { /* t2.c:1364:17: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var bandno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var l_nb_code_blocks TOPJ_UINT32
	var l_current_data uintptr = p_src_data
	var l_band uintptr = uintptr(00)
	var l_cblk uintptr = uintptr(00)
	var l_res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(p_tile)).Fcomps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno)*104)).Fresolutions + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fresno)*192
	var partial_buffer TOPJ_BOOL = DOPJ_FALSE

	_ = p_t2
	_ = pack_info

	l_band = l_res + 32 /* &.bands */
	for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fnumbands; bandno++ {
		var l_prc uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno)*56

		if (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx1-(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx0 == 0 || (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy1-(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy0 == 0 {
			l_band += 48
			continue
		}

		l_nb_code_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fcw * (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fch
		l_cblk = *(*uintptr)(unsafe.Pointer(l_prc + 24))

		for cblkno = TOPJ_UINT32(0); cblkno < l_nb_code_blocks; cblkno++ {
			var l_seg uintptr = uintptr(00)

			// if we have a partial data stream, set numchunks to zero
			// since we have no data to actually decode.
			if partial_buffer != 0 {
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunks = TOPJ_UINT32(0)
			}

			if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses) != 0) {
				// nothing to do
				l_cblk += 80
				continue
			}

			if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs) != 0) {
				l_seg = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs++
			} else {
				l_seg = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs + uintptr((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs-TOPJ_UINT32(1))*24

				if (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumpasses == (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fmaxpasses {
					l_seg += 24
					(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs++
				}
			}

			for __ccgo := true; __ccgo; __ccgo = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses > TOPJ_UINT32(0) {
				// Check possible overflow (on l_current_data only, assumes input args already checked) then size
				if TOPJ_SIZE_T(l_current_data)+TOPJ_SIZE_T((*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen) < TOPJ_SIZE_T(l_current_data) || l_current_data+uintptr((*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen) > p_src_data+uintptr(p_max_length) || partial_buffer != 0 {
					if (*Topj_cp_t)(unsafe.Pointer((*Topj_t2_t)(unsafe.Pointer(p_t2)).Fcp)).Fstrict != 0 {
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+33526,
							libc.VaList(bp, (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen, p_max_length, cblkno, (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno, bandno, (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fresno,
								(*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno))
						return DOPJ_FALSE
					} else {
						Xopj_event_msg(tls, p_manager, DEVT_WARNING,
							ts+33526,
							libc.VaList(bp+56, (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen, p_max_length, cblkno, (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno, bandno, (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fresno,
								(*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno))
						// skip this codeblock since it is a partial read
						partial_buffer = DOPJ_TRUE
						(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunks = TOPJ_UINT32(0)

						*(*TOPJ_UINT32)(unsafe.Pointer(l_seg + 4)) += (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumnewpasses
						*(*TOPJ_UINT32)(unsafe.Pointer(l_cblk + 44)) -= (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumnewpasses
						if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses > TOPJ_UINT32(0) {
							l_seg += 24
							(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs++
							break
						}
						continue
					}
				}

				if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunks == (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunksalloc {
					var l_numchunksalloc TOPJ_UINT32 = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunksalloc*TOPJ_UINT32(2) + TOPJ_UINT32(1)
					var l_chunks uintptr = Xopj_realloc(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fchunks,
						uint32(l_numchunksalloc)*uint32(unsafe.Sizeof(Topj_tcd_seg_data_chunk_t{})))
					if l_chunks == uintptr(0) {
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+33611, 0)
						return DOPJ_FALSE
					}
					(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fchunks = l_chunks
					(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunksalloc = l_numchunksalloc
				}

				(*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fchunks + uintptr((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunks)*16)).Fdata = l_current_data
				(*Topj_tcd_seg_data_chunk_t)(unsafe.Pointer((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fchunks + uintptr((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunks)*16)).Flen = (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumchunks++

				l_current_data += uintptr((*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen)
				*(*TOPJ_UINT32)(unsafe.Pointer(l_seg)) += (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen
				*(*TOPJ_UINT32)(unsafe.Pointer(l_seg + 4)) += (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumnewpasses
				*(*TOPJ_UINT32)(unsafe.Pointer(l_cblk + 44)) -= (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumnewpasses

				(*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Freal_num_passes = (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumpasses

				if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses > TOPJ_UINT32(0) {
					l_seg += 24
					(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs++
				}
			}

			(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Freal_num_segs = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs
			l_cblk += 80
		} // next code_block

		l_band += 48
	}

	// return the number of bytes read
	if partial_buffer != 0 {
		*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = p_max_length
	} else {
		*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = TOPJ_UINT32((int32(l_current_data) - int32(p_src_data)) / 1)
	}

	return DOPJ_TRUE
}

func opj_t2_skip_packet_data(tls *libc.TLS, p_t2 uintptr, p_tile uintptr, p_pi uintptr, p_data_read uintptr, p_max_length TOPJ_UINT32, pack_info uintptr, p_manager uintptr) TOPJ_BOOL { /* t2.c:1525:17: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var bandno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var l_nb_code_blocks TOPJ_UINT32
	var l_band uintptr = uintptr(00)
	var l_cblk uintptr = uintptr(00)
	var l_res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(p_tile)).Fcomps+uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno)*104)).Fresolutions + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fresno)*192

	_ = p_t2
	_ = pack_info

	*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) = TOPJ_UINT32(0)
	l_band = l_res + 32 /* &.bands */

	for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fnumbands; bandno++ {
		var l_prc uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts + uintptr((*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno)*56

		if (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx1-(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx0 == 0 || (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy1-(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy0 == 0 {
			l_band += 48
			continue
		}

		l_nb_code_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fcw * (*Topj_tcd_precinct_t)(unsafe.Pointer(l_prc)).Fch
		l_cblk = *(*uintptr)(unsafe.Pointer(l_prc + 24))

		for cblkno = TOPJ_UINT32(0); cblkno < l_nb_code_blocks; cblkno++ {
			var l_seg uintptr = uintptr(00)

			if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses) != 0) {
				// nothing to do
				l_cblk += 80
				continue
			}

			if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs) != 0) {
				l_seg = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs++
			} else {
				l_seg = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fsegs + uintptr((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs-TOPJ_UINT32(1))*24

				if (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumpasses == (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fmaxpasses {
					l_seg += 24
					(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs++
				}
			}

			for __ccgo := true; __ccgo; __ccgo = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses > TOPJ_UINT32(0) {
				// Check possible overflow then size
				if *(*TOPJ_UINT32)(unsafe.Pointer(p_data_read))+(*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen < *(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) || *(*TOPJ_UINT32)(unsafe.Pointer(p_data_read))+(*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen > p_max_length {
					if (*Topj_cp_t)(unsafe.Pointer((*Topj_t2_t)(unsafe.Pointer(p_t2)).Fcp)).Fstrict != 0 {
						Xopj_event_msg(tls, p_manager, DEVT_ERROR,
							ts+33659,
							libc.VaList(bp, (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen, p_max_length, cblkno, (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno, bandno, (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fresno,
								(*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno))
						return DOPJ_FALSE
					} else {
						Xopj_event_msg(tls, p_manager, DEVT_WARNING,
							ts+33659,
							libc.VaList(bp+56, (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen, p_max_length, cblkno, (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fprecno, bandno, (*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fresno,
								(*Topj_pi_iterator_t2)(unsafe.Pointer(p_pi)).Fcompno))
					}
				}

				opj_null_jas_fprintf(tls, libc.Xstderr, ts+33744, libc.VaList(bp+112, *(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)),
					(*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen))
				*(*TOPJ_UINT32)(unsafe.Pointer(p_data_read)) += (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnewlen

				*(*TOPJ_UINT32)(unsafe.Pointer(l_seg + 4)) += (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumnewpasses
				*(*TOPJ_UINT32)(unsafe.Pointer(l_cblk + 44)) -= (*Topj_tcd_seg_t)(unsafe.Pointer(l_seg)).Fnumnewpasses
				if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumnewpasses > TOPJ_UINT32(0) {
					l_seg += 24
					(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_cblk)).Fnumsegs++
				}
			}

			l_cblk += 80
		}

		l_band += 48
	}

	return DOPJ_TRUE
}

func opj_t2_init_seg(tls *libc.TLS, cblk uintptr, index TOPJ_UINT32, cblksty TOPJ_UINT32, first TOPJ_UINT32) TOPJ_BOOL { /* t2.c:1638:17: */
	var seg uintptr = uintptr(00)
	var l_nb_segs TOPJ_UINT32 = index + TOPJ_UINT32(1)

	if l_nb_segs > (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fm_current_max_segs {
		var new_segs uintptr
		var l_m_current_max_segs TOPJ_UINT32 = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fm_current_max_segs + TOPJ_UINT32(DOPJ_J2K_DEFAULT_NB_SEGS)

		new_segs = Xopj_realloc(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fsegs,
			uint32(l_m_current_max_segs)*uint32(unsafe.Sizeof(Topj_tcd_seg_t{})))
		if !(new_segs != 0) {
			// opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to initialize segment %d\n", l_nb_segs);
			return DOPJ_FALSE
		}
		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fsegs = new_segs
		libc.Xmemset(tls, new_segs+uintptr((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fm_current_max_segs)*24,
			0, uint32(DOPJ_J2K_DEFAULT_NB_SEGS)*uint32(unsafe.Sizeof(Topj_tcd_seg_t{})))
		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fm_current_max_segs = l_m_current_max_segs
	}

	seg = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(cblk)).Fsegs + uintptr(index)*24
	Xopj_tcd_reinit_segment(tls, seg)

	if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_TERMALL) != 0 {
		(*Topj_tcd_seg_t)(unsafe.Pointer(seg)).Fmaxpasses = TOPJ_UINT32(1)
	} else if cblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_LAZY) != 0 {
		if first != 0 {
			(*Topj_tcd_seg_t)(unsafe.Pointer(seg)).Fmaxpasses = TOPJ_UINT32(10)
		} else {
			(*Topj_tcd_seg_t)(unsafe.Pointer(seg)).Fmaxpasses = func() uint32 {
				if (*Topj_tcd_seg_t)(unsafe.Pointer(seg-uintptr(1)*24)).Fmaxpasses == TOPJ_UINT32(1) || (*Topj_tcd_seg_t)(unsafe.Pointer(seg-uintptr(1)*24)).Fmaxpasses == TOPJ_UINT32(10) {
					return uint32(2)
				}
				return uint32(1)
			}()
		}
	} else {
		// See paragraph "B.10.6 Number of coding passes" of the standard.
		// Probably that 109 must be interpreted a (Mb-1)*3 + 1 with Mb=37,
		// Mb being the maximum number of bit-planes available for the
		// representation of coefficients in the sub-band
		(*Topj_tcd_seg_t)(unsafe.Pointer(seg)).Fmaxpasses = TOPJ_UINT32(109)
	}

	return DOPJ_TRUE
}

// -----------------------------------------------------------------------

//*
// Create a new TCD handle
func Xopj_tcd_create(tls *libc.TLS, p_is_decoder TOPJ_BOOL) uintptr { /* tcd.c:203:10: */
	var l_tcd uintptr = uintptr(00)

	// create the tcd structure
	l_tcd = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_tcd_t{})))
	if !(l_tcd != 0) {
		return uintptr(00)
	}

	libc.SetBitFieldPtr8Uint32(l_tcd+60, func() uint32 {
		if p_is_decoder != 0 {
			return uint32(1)
		}
		return uint32(0)
	}(), 0, 0x1)

	(*Topj_tcd_t)(unsafe.Pointer(l_tcd)).Ftcd_image = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_tcd_image_t{})))
	if !(int32((*Topj_tcd_t)(unsafe.Pointer(l_tcd)).Ftcd_image) != 0) {
		Xopj_free(tls, l_tcd)
		return uintptr(00)
	}

	return l_tcd
}

// -----------------------------------------------------------------------

func Xopj_tcd_rateallocate_fixed(tls *libc.TLS, tcd uintptr) { /* tcd.c:227:6: */
	var layno TOPJ_UINT32

	for layno = TOPJ_UINT32(0); layno < (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcp)).Fnumlayers; layno++ {
		Xopj_tcd_makelayer_fixed(tls, tcd, layno, uint32(1))
	}
}

func Xopj_tcd_makelayer(tls *libc.TLS, tcd uintptr, layno TOPJ_UINT32, thresh TOPJ_FLOAT64, final TOPJ_UINT32) { /* tcd.c:237:6: */
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	var bandno TOPJ_UINT32
	var precno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var passno TOPJ_UINT32

	var tcd_tile uintptr = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_image)).Ftiles

	*(*TOPJ_FLOAT64)(unsafe.Pointer(tcd_tile + 48 + uintptr(layno)*8)) = TOPJ_FLOAT64(0) // fixed_quality

	for compno = TOPJ_UINT32(0); compno < (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fnumcomps; compno++ {
		var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fcomps + uintptr(compno)*104

		for resno = TOPJ_UINT32(0); resno < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions; resno++ {
			var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno)*192

			for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands; bandno++ {
				var band uintptr = res + 32 + uintptr(bandno)*48

				// Skip empty bands
				if Xopj_tcd_is_band_empty(tls, band) != 0 {
					continue
				}

				for precno = TOPJ_UINT32(0); precno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph; precno++ {
					var prc uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56

					for cblkno = TOPJ_UINT32(0); cblkno < (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fcw*(*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fch; cblkno++ {
						var cblk uintptr = *(*uintptr)(unsafe.Pointer(prc + 24)) + uintptr(cblkno)*64
						var layer uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Flayers + uintptr(layno)*24
						var n TOPJ_UINT32

						if layno == TOPJ_UINT32(0) {
							(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers = TOPJ_UINT32(0)
						}

						n = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers

						if thresh < float64(0) {
							// Special value to indicate to use all passes
							n = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Ftotalpasses
						} else {
							for passno = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers; passno < (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Ftotalpasses; passno++ {
								var dr TOPJ_UINT32
								var dd TOPJ_FLOAT64
								var pass uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(passno)*24

								if n == TOPJ_UINT32(0) {
									dr = (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate
									dd = (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Fdistortiondec
								} else {
									dr = (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate - (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr(n-TOPJ_UINT32(1))*24)).Frate
									dd = (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Fdistortiondec - (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr(n-TOPJ_UINT32(1))*24)).Fdistortiondec
								}

								if !(dr != 0) {
									if dd != float64(0) {
										n = passno + TOPJ_UINT32(1)
									}
									continue
								}
								if thresh-dd/float64(dr) < 2.22044604925031308084726333618164062e-16 { // do not rely on float equality, check with DBL_EPSILON margin
									n = passno + TOPJ_UINT32(1)
								}
							}
						}

						(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses = n - (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers

						if !(int32((*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses) != 0) {
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdisto = TOPJ_FLOAT64(0)
							continue
						}

						if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers == TOPJ_UINT32(0) {
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen = (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(n-TOPJ_UINT32(1))*24)).Frate
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdata = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fdata
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdisto = (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(n-TOPJ_UINT32(1))*24)).Fdistortiondec
						} else {
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen = (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr(n-TOPJ_UINT32(1))*24)).Frate - (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers-TOPJ_UINT32(1))*24)).Frate
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdata = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fdata + uintptr((*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers-TOPJ_UINT32(1))*24)).Frate)
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdisto = (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr(n-TOPJ_UINT32(1))*24)).Fdistortiondec - (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers-TOPJ_UINT32(1))*24)).Fdistortiondec
						}

						*(*TOPJ_FLOAT64)(unsafe.Pointer(tcd_tile + 48 + uintptr(layno)*8)) += (*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdisto // fixed_quality

						if final != 0 {
							(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers = n
						}
					}
				}
			}
		}
	}
}

func Xopj_tcd_makelayer_fixed(tls *libc.TLS, tcd uintptr, layno TOPJ_UINT32, final TOPJ_UINT32) { /* tcd.c:338:6: */
	bp := tls.Alloc(1200)
	defer tls.Free(1200)

	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	var bandno TOPJ_UINT32
	var precno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var value TOPJ_INT32 //, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3];
	// var matrice [10][10][3]TOPJ_INT32 at bp, 1200

	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var k TOPJ_UINT32

	var cp uintptr = (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fcp
	var tcd_tile uintptr = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_image)).Ftiles
	var tcd_tcp uintptr = (*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcp

	for compno = TOPJ_UINT32(0); compno < (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fnumcomps; compno++ {
		var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fcomps + uintptr(compno)*104

		for i = TOPJ_UINT32(0); i < (*Topj_tcp_t)(unsafe.Pointer(tcd_tcp)).Fnumlayers; i++ {
			for j = TOPJ_UINT32(0); j < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions; j++ {
				for k = TOPJ_UINT32(0); k < TOPJ_UINT32(3); k++ {
					*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(i)*120 + uintptr(j)*12 + uintptr(k)*4)) = libc.Int32FromFloat32(TOPJ_FLOAT32(*(*TOPJ_INT32)(unsafe.Pointer((*Topj_encoding_param_t)(unsafe.Pointer(cp+120)).Fm_matrice + uintptr(i*(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions*TOPJ_UINT32(3)+j*TOPJ_UINT32(3)+k)*4))) *
						TOPJ_FLOAT32(float64((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Fimage)).Fcomps+uintptr(compno)*64)).Fprec)/16.0))
				}
			}
		}

		for resno = TOPJ_UINT32(0); resno < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions; resno++ {
			var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno)*192

			for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands; bandno++ {
				var band uintptr = res + 32 + uintptr(bandno)*48

				// Skip empty bands
				if Xopj_tcd_is_band_empty(tls, band) != 0 {
					continue
				}

				for precno = TOPJ_UINT32(0); precno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph; precno++ {
					var prc uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56

					for cblkno = TOPJ_UINT32(0); cblkno < (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fcw*(*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fch; cblkno++ {
						var cblk uintptr = *(*uintptr)(unsafe.Pointer(prc + 24)) + uintptr(cblkno)*64
						var layer uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Flayers + uintptr(layno)*24
						var n TOPJ_UINT32
						var imsb TOPJ_INT32 = TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Fimage)).Fcomps+uintptr(compno)*64)).Fprec - (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumbps) // number of bit-plan equal to zero

						// Correction of the matrix of coefficient to include the IMSB information
						if layno == TOPJ_UINT32(0) {
							value = *(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(layno)*120 + uintptr(resno)*12 + uintptr(bandno)*4))
							if imsb >= value {
								value = 0
							} else {
								value = value - imsb
							}
						} else {
							value = *(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(layno)*120 + uintptr(resno)*12 + uintptr(bandno)*4)) - *(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(layno-TOPJ_UINT32(1))*120 + uintptr(resno)*12 + uintptr(bandno)*4))
							if imsb >= *(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(layno-TOPJ_UINT32(1))*120 + uintptr(resno)*12 + uintptr(bandno)*4)) {
								value = value - (imsb - *(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(layno-TOPJ_UINT32(1))*120 + uintptr(resno)*12 + uintptr(bandno)*4)))
								if value < 0 {
									value = 0
								}
							}
						}

						if layno == TOPJ_UINT32(0) {
							(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers = TOPJ_UINT32(0)
						}

						n = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers
						if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers == TOPJ_UINT32(0) {
							if value != 0 {
								n = TOPJ_UINT32(3)*TOPJ_UINT32(value) - TOPJ_UINT32(2) + (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers
							} else {
								n = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers
							}
						} else {
							n = TOPJ_UINT32(3)*TOPJ_UINT32(value) + (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers
						}

						(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses = n - (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers

						if !(int32((*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fnumpasses) != 0) {
							continue
						}

						if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers == TOPJ_UINT32(0) {
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen = (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(n-TOPJ_UINT32(1))*24)).Frate
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdata = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fdata
						} else {
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Flen = (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr(n-TOPJ_UINT32(1))*24)).Frate - (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers-TOPJ_UINT32(1))*24)).Frate
							(*Topj_tcd_layer_t)(unsafe.Pointer(layer)).Fdata = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fdata + uintptr((*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers-TOPJ_UINT32(1))*24)).Frate)
						}

						if final != 0 {
							(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fnumpassesinlayers = n
						}
					}
				}
			}
		}
	}
}

func Xopj_tcd_rateallocate(tls *libc.TLS, tcd uintptr, dest uintptr, p_data_written uintptr, len TOPJ_UINT32, cstr_info uintptr, p_manager uintptr) TOPJ_BOOL { /* tcd.c:443:10: */
	bp := tls.Alloc(800)
	defer tls.Free(800)

	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	var bandno TOPJ_UINT32
	var precno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var layno TOPJ_UINT32
	var passno TOPJ_UINT32
	var min TOPJ_FLOAT64
	var max TOPJ_FLOAT64
	// var cumdisto [100]TOPJ_FLOAT64 at bp, 800
	// fixed_quality
	var K TOPJ_FLOAT64 = TOPJ_FLOAT64(1) // 1.1; fixed_quality
	var maxSE TOPJ_FLOAT64 = TOPJ_FLOAT64(0)

	var cp uintptr = (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fcp
	var tcd_tile uintptr = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_image)).Ftiles
	var tcd_tcp uintptr = (*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcp

	min = 1.79769313486231570814527423731704357e+308
	max = TOPJ_FLOAT64(0)

	(*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fnumpix = 0 // fixed_quality

	for compno = TOPJ_UINT32(0); compno < (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fnumcomps; compno++ {
		var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fcomps + uintptr(compno)*104
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumpix = 0

		for resno = TOPJ_UINT32(0); resno < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions; resno++ {
			var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno)*192

			for bandno = TOPJ_UINT32(0); bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fnumbands; bandno++ {
				var band uintptr = res + 32 + uintptr(bandno)*48

				// Skip empty bands
				if Xopj_tcd_is_band_empty(tls, band) != 0 {
					continue
				}

				for precno = TOPJ_UINT32(0); precno < (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fph; precno++ {
					var prc uintptr = (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fprecincts + uintptr(precno)*56

					for cblkno = TOPJ_UINT32(0); cblkno < (*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fcw*(*Topj_tcd_precinct_t)(unsafe.Pointer(prc)).Fch; cblkno++ {
						var cblk uintptr = *(*uintptr)(unsafe.Pointer(prc + 24)) + uintptr(cblkno)*64

						for passno = TOPJ_UINT32(0); passno < (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Ftotalpasses; passno++ {
							var pass uintptr = (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses + uintptr(passno)*24
							var dr TOPJ_INT32
							var dd TOPJ_FLOAT64
							var rdslope TOPJ_FLOAT64

							if passno == TOPJ_UINT32(0) {
								dr = TOPJ_INT32((*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate)
								dd = (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Fdistortiondec
							} else {
								dr = TOPJ_INT32((*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Frate - (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr(passno-TOPJ_UINT32(1))*24)).Frate)
								dd = (*Topj_tcd_pass_t)(unsafe.Pointer(pass)).Fdistortiondec - (*Topj_tcd_pass_t)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fpasses+uintptr(passno-TOPJ_UINT32(1))*24)).Fdistortiondec
							}

							if dr == 0 {
								continue
							}

							rdslope = dd / float64(dr)
							if rdslope < min {
								min = rdslope
							}

							if rdslope > max {
								max = rdslope
							}
						} // passno

						// fixed_quality
						*(*TOPJ_INT32)(unsafe.Pointer(tcd_tile + 32)) += ((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fx1 - (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fx0) * ((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fy1 - (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fy0)
						*(*TOPJ_INT32)(unsafe.Pointer(tilec + 96)) += ((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fx1 - (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fx0) * ((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fy1 - (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(cblk)).Fy0)
					} // cbklno
				} // precno
			} // bandno
		} // resno

		maxSE = maxSE + (TOPJ_FLOAT64(int32(1)<<(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Fimage)).Fcomps+uintptr(compno)*64)).Fprec)-1.0)*
			(TOPJ_FLOAT64(int32(1)<<(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Fimage)).Fcomps+uintptr(compno)*64)).Fprec)-1.0)*
			TOPJ_FLOAT64((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumpix)
	} // compno

	// index file
	if cstr_info != 0 {
		var tile_info uintptr = (*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Ftile + uintptr((*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_tileno)*608
		(*Topj_tile_info_t)(unsafe.Pointer(tile_info)).Fnumpix = (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fnumpix
		(*Topj_tile_info_t)(unsafe.Pointer(tile_info)).Fdistotile = (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fdistotile
		(*Topj_tile_info_t)(unsafe.Pointer(tile_info)).Fthresh = Xopj_malloc(tls, uint32((*Topj_tcp_t)(unsafe.Pointer(tcd_tcp)).Fnumlayers)*uint32(unsafe.Sizeof(TOPJ_FLOAT64(0))))
		if !(int32((*Topj_tile_info_t)(unsafe.Pointer(tile_info)).Fthresh) != 0) {
			// FIXME event manager error callback
			return DOPJ_FALSE
		}
	}

	for layno = TOPJ_UINT32(0); layno < (*Topj_tcp_t)(unsafe.Pointer(tcd_tcp)).Fnumlayers; layno++ {
		var lo TOPJ_FLOAT64 = min
		var hi TOPJ_FLOAT64 = max
		var maxlen TOPJ_UINT32
		if *(*TOPJ_FLOAT32)(unsafe.Pointer(tcd_tcp + 20 + uintptr(layno)*4)) > 0.0 {
			maxlen = opj_uint_min(tls, libc.Uint32FromFloat64(libc.Xceil(tls, float64(*(*TOPJ_FLOAT32)(unsafe.Pointer(tcd_tcp + 20 + uintptr(layno)*4))))), len)
		} else {
			maxlen = len
		}
		var goodthresh TOPJ_FLOAT64 = TOPJ_FLOAT64(0)
		var stable_thresh TOPJ_FLOAT64 = TOPJ_FLOAT64(0)
		var i TOPJ_UINT32
		var distotarget TOPJ_FLOAT64 // fixed_quality

		// fixed_quality
		distotarget = (*Topj_tcd_tile_t)(unsafe.Pointer(tcd_tile)).Fdistotile - K*maxSE/libc.Xpow(tls, float64(TOPJ_FLOAT32(10)),
			float64(*(*TOPJ_FLOAT32)(unsafe.Pointer(tcd_tcp + 5200 + uintptr(layno)*4))/float32(10)))

		// Don't try to find an optimal threshold but rather take everything not included yet, if
		//           -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)
		//           -q xx,yy,zz,0   (fixed_quality == 1 and distoratio == 0)
		//           ==> possible to have some lossy layers and the last layer for sure lossless
		if int32(*(*uint8)(unsafe.Pointer(cp + 120 + 20))&0x1>>0) == 1 && *(*TOPJ_FLOAT32)(unsafe.Pointer(tcd_tcp + 20 + uintptr(layno)*4)) > 0.0 || int32(*(*uint8)(unsafe.Pointer(cp + 120 + 20))&0x4>>2) == 1 && float64(*(*TOPJ_FLOAT32)(unsafe.Pointer(tcd_tcp + 5200 + uintptr(layno)*4))) > 0.0 {
			var t2 uintptr = Xopj_t2_create(tls, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fimage, cp)
			var thresh TOPJ_FLOAT64 = TOPJ_FLOAT64(0)

			if t2 == uintptr(00) {
				return DOPJ_FALSE
			}

			for i = TOPJ_UINT32(0); i < TOPJ_UINT32(128); i++ {
				var distoachieved TOPJ_FLOAT64 = TOPJ_FLOAT64(0) // fixed_quality

				thresh = (lo + hi) / float64(2)

				Xopj_tcd_makelayer(tls, tcd, layno, thresh, uint32(0))

				if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(cp + 120 + 20))&0x4>>2)) != 0 { // fixed_quality
					if int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) >= DOPJ_PROFILE_CINEMA_2K && int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) <= DOPJ_PROFILE_CINEMA_S4K || int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) >= DOPJ_PROFILE_IMF_2K && int32((*Topj_cp_t)(unsafe.Pointer(cp)).Frsiz) <= DOPJ_PROFILE_IMF_8K_R|0x009b {
						if !(Xopj_t2_encode_packets(tls, t2, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_tileno, tcd_tile, layno+TOPJ_UINT32(1), dest,
							p_data_written, maxlen, cstr_info, uintptr(0), (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fcur_tp_num, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftp_pos,
							(*Topj_tcd_t)(unsafe.Pointer(tcd)).Fcur_pino,
							THRESH_CALC, p_manager) != 0) {

							lo = thresh
							continue
						} else {
							if layno == TOPJ_UINT32(0) {
								distoachieved = *(*TOPJ_FLOAT64)(unsafe.Pointer(tcd_tile + 48))
							} else {
								distoachieved = *(*TOPJ_FLOAT64)(unsafe.Pointer(bp + uintptr(layno-TOPJ_UINT32(1))*8)) + *(*TOPJ_FLOAT64)(unsafe.Pointer(tcd_tile + 48 + uintptr(layno)*8))
							}

							if distoachieved < distotarget {
								hi = thresh
								stable_thresh = thresh
								continue
							} else {
								lo = thresh
							}
						}
					} else {
						if layno == TOPJ_UINT32(0) {
							distoachieved = *(*TOPJ_FLOAT64)(unsafe.Pointer(tcd_tile + 48))
						} else {
							distoachieved = *(*TOPJ_FLOAT64)(unsafe.Pointer(bp + uintptr(layno-TOPJ_UINT32(1))*8)) + *(*TOPJ_FLOAT64)(unsafe.Pointer(tcd_tile + 48 + uintptr(layno)*8))
						}

						if distoachieved < distotarget {
							hi = thresh
							stable_thresh = thresh
							continue
						}
						lo = thresh
					}
				} else {
					if !(Xopj_t2_encode_packets(tls, t2, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_tileno, tcd_tile, layno+TOPJ_UINT32(1), dest,
						p_data_written, maxlen, cstr_info, uintptr(0), (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fcur_tp_num, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftp_pos,
						(*Topj_tcd_t)(unsafe.Pointer(tcd)).Fcur_pino,
						THRESH_CALC, p_manager) != 0) {
						// TODO: what to do with l ??? seek / tell ???
						// opj_event_msg(tcd->cinfo, EVT_INFO, "rate alloc: len=%d, max=%d\n", l, maxlen);
						lo = thresh
						continue
					}

					hi = thresh
					stable_thresh = thresh
				}
			}

			if stable_thresh == float64(0) {
				goodthresh = thresh
			} else {
				goodthresh = stable_thresh
			}

			Xopj_t2_destroy(tls, t2)
		} else {
			// Special value to indicate to use all passes
			goodthresh = TOPJ_FLOAT64(-1)
		}

		if cstr_info != 0 { // Threshold for Marcela Index
			*(*float64)(unsafe.Pointer((*Topj_tile_info_t)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(cstr_info)).Ftile+uintptr((*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_tileno)*608)).Fthresh + uintptr(layno)*8)) = goodthresh
		}

		Xopj_tcd_makelayer(tls, tcd, layno, goodthresh, uint32(1))

		// fixed_quality
		*(*TOPJ_FLOAT64)(unsafe.Pointer(bp + uintptr(layno)*8)) = func() float64 {
			if layno == TOPJ_UINT32(0) {
				return *(*TOPJ_FLOAT64)(unsafe.Pointer(tcd_tile + 48))
			}
			return *(*TOPJ_FLOAT64)(unsafe.Pointer(bp + uintptr(layno-TOPJ_UINT32(1))*8)) + *(*TOPJ_FLOAT64)(unsafe.Pointer(tcd_tile + 48 + uintptr(layno)*8))
		}()
	}

	return DOPJ_TRUE
}

func Xopj_tcd_init(tls *libc.TLS, p_tcd uintptr, p_image uintptr, p_cp uintptr, p_tp uintptr) TOPJ_BOOL { /* tcd.c:646:10: */
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage = p_image
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcp = p_cp

	(*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles = Xopj_calloc(tls, uint32(1),
		uint32(unsafe.Sizeof(Topj_tcd_tile_t{})))
	if !(int32((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles) != 0) {
		return DOPJ_FALSE
	}

	(*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps = Xopj_calloc(tls,
		uint32((*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps), uint32(unsafe.Sizeof(Topj_tcd_tilecomp_t{})))
	if !(int32((*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps) != 0) {
		return DOPJ_FALSE
	}

	(*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fnumcomps = (*Topj_image_t)(unsafe.Pointer(p_image)).Fnumcomps
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftp_pos = (*Topj_encoding_param_t)(unsafe.Pointer(p_cp + 120)).Fm_tp_pos
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fthread_pool = p_tp

	return DOPJ_TRUE
}

//*
// Destroy a previously created TCD handle
func Xopj_tcd_destroy(tls *libc.TLS, tcd uintptr) { /* tcd.c:676:6: */
	if tcd != 0 {
		opj_tcd_free_tile(tls, tcd)

		if (*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_image != 0 {
			Xopj_free(tls, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_image)
			(*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_image = uintptr(00)
		}

		Xopj_free(tls, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fused_component)

		Xopj_free(tls, tcd)
	}
}

func Xopj_alloc_tile_component_data(tls *libc.TLS, l_tilec uintptr) TOPJ_BOOL { /* tcd.c:692:10: */
	if (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata == uintptr(00) || (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed > (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size && (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).FownsData == DOPJ_FALSE {
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata = Xopj_image_data_alloc(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed)
		if !(int32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata) != 0) && (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed != Tsize_t(0) {
			return DOPJ_FALSE
		}
		//fprintf(stderr, "tAllocate data of tilec (int): %d x OPJ_UINT32n",l_data_size);
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).FownsData = DOPJ_TRUE
	} else if (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed > (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size {
		// We don't need to keep old data
		Xopj_image_data_free(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata)
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata = Xopj_image_data_alloc(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed)
		if !(int32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata) != 0) {
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size = Tsize_t(0)
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed = Tsize_t(0)
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).FownsData = DOPJ_FALSE
			return DOPJ_FALSE
		}
		//fprintf(stderr, "tReallocate data of tilec (int): from %d to %d x OPJ_UINT32n", l_tilec->data_size, l_data_size);
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).FownsData = DOPJ_TRUE
	}
	return DOPJ_TRUE
}

// -----------------------------------------------------------------------

func opj_tcd_init_tile(tls *libc.TLS, p_tcd uintptr, p_tile_no TOPJ_UINT32, isEncoder TOPJ_BOOL, sizeof_block TOPJ_SIZE_T, manager uintptr) TOPJ_BOOL { /* tcd.c:723:24: */
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	var bandno TOPJ_UINT32
	var precno TOPJ_UINT32
	var cblkno TOPJ_UINT32
	var l_tcp uintptr = uintptr(00)
	var l_cp uintptr = uintptr(00)
	var l_tile uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_tilec uintptr = uintptr(00)
	var l_image_comp uintptr = uintptr(00)
	var l_res uintptr = uintptr(00)
	var l_band uintptr = uintptr(00)
	var l_step_size uintptr = uintptr(00)
	var l_current_precinct uintptr = uintptr(00)
	var l_image uintptr = uintptr(00)
	var p TOPJ_UINT32
	var q TOPJ_UINT32
	var l_level_no TOPJ_UINT32
	var l_pdx TOPJ_UINT32
	var l_pdy TOPJ_UINT32
	var l_x0b TOPJ_INT32
	var l_y0b TOPJ_INT32
	var l_tx0 TOPJ_UINT32
	var l_ty0 TOPJ_UINT32
	// extent of precincts , top left, bottom right*
	var l_tl_prc_x_start TOPJ_INT32
	var l_tl_prc_y_start TOPJ_INT32
	var l_br_prc_x_end TOPJ_INT32
	var l_br_prc_y_end TOPJ_INT32
	// number of precinct for a resolution
	var l_nb_precincts TOPJ_UINT32
	// room needed to store l_nb_precinct precinct for a resolution
	var l_nb_precinct_size TOPJ_UINT32
	// number of code blocks for a precinct
	var l_nb_code_blocks TOPJ_UINT32
	// room needed to store l_nb_code_blocks code blocks for a precinct
	var l_nb_code_blocks_size TOPJ_UINT32
	// size of data for a tile
	var l_data_size TOPJ_UINT32

	l_cp = (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcp
	l_tcp = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftcps + uintptr(p_tile_no)*5696
	l_tile = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps
	l_tilec = (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps
	l_image = (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage
	l_image_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps

	p = p_tile_no % (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw // tile coordinates
	q = p_tile_no / (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftw
	//fprintf(stderr, "Tile coordinate = %d,%d\n", p, q);

	// 4 borders of the tile rescale on the image if necessary
	l_tx0 = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftx0 + p*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx // can't be greater than l_image->x1 so won't overflow
	(*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fx0 = TOPJ_INT32(opj_uint_max(tls, l_tx0, (*Topj_image_t)(unsafe.Pointer(l_image)).Fx0))
	(*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fx1 = TOPJ_INT32(opj_uint_min(tls, opj_uint_adds(tls, l_tx0, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdx),
		(*Topj_image_t)(unsafe.Pointer(l_image)).Fx1))
	// all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check
	if (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fx0 < 0 || (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fx1 <= (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fx0 {
		Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33775, 0)
		return DOPJ_FALSE
	}
	l_ty0 = (*Topj_cp_t)(unsafe.Pointer(l_cp)).Fty0 + q*(*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy // can't be greater than l_image->y1 so won't overflow
	(*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fy0 = TOPJ_INT32(opj_uint_max(tls, l_ty0, (*Topj_image_t)(unsafe.Pointer(l_image)).Fy0))
	(*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fy1 = TOPJ_INT32(opj_uint_min(tls, opj_uint_adds(tls, l_ty0, (*Topj_cp_t)(unsafe.Pointer(l_cp)).Ftdy),
		(*Topj_image_t)(unsafe.Pointer(l_image)).Fy1))
	// all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check
	if (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fy0 < 0 || (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fy1 <= (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fy0 {
		Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33813, 0)
		return DOPJ_FALSE
	}

	// testcase 1888.pdf.asan.35.988
	if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions == TOPJ_UINT32(0) {
		Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33851, 0)
		return DOPJ_FALSE
	}
	//fprintf(stderr, "Tile border = %d,%d,%d,%d\n", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);

	//tile->numcomps = image->numcomps;
	for compno = TOPJ_UINT32(0); compno < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps; compno++ {
		//fprintf(stderr, "compno = %d/%d\n", compno, l_tile->numcomps);
		(*Topj_image_comp_t)(unsafe.Pointer(l_image_comp)).Fresno_decoded = TOPJ_UINT32(0)
		// border of each l_tile component (global)
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0 = opj_int_ceildiv(tls, (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fx0, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_image_comp)).Fdx))
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0 = opj_int_ceildiv(tls, (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fy0, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_image_comp)).Fdy))
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx1 = opj_int_ceildiv(tls, (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fx1, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_image_comp)).Fdx))
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy1 = opj_int_ceildiv(tls, (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fy1, TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_image_comp)).Fdy))
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fcompno = compno
		//fprintf(stderr, "\tTile compo border = %d,%d,%d,%d\n", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);

		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fnumresolutions = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions
		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions < (*Topj_decoding_param_t)(unsafe.Pointer(l_cp+120)).Fm_reduce {
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fminimum_num_resolutions = TOPJ_UINT32(1)
		} else {
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fminimum_num_resolutions = (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumresolutions - (*Topj_decoding_param_t)(unsafe.Pointer(l_cp+120)).Fm_reduce
		}

		if isEncoder != 0 {
			var l_tile_data_size TOPJ_SIZE_T

			// compute l_data_size with overflow check
			var w TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx1 - (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0)
			var h TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy1 - (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0)

			// issue 733, l_data_size == 0U, probably something wrong should be checked before getting here
			if h > TOPJ_SIZE_T(0) && uint64(w) > libc.Uint64(18446744073709551615)/uint64(h) {
				Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33890, 0)
				return DOPJ_FALSE
			}
			l_tile_data_size = w * h

			if libc.Uint64(18446744073709551615)/uint64(unsafe.Sizeof(TOPJ_UINT32(0))) < uint64(l_tile_data_size) {
				Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33890, 0)
				return DOPJ_FALSE
			}
			l_tile_data_size = l_tile_data_size * TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_UINT32(0)))

			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_size_needed = l_tile_data_size
		}

		l_data_size = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fnumresolutions * TOPJ_UINT32(unsafe.Sizeof(Topj_tcd_resolution_t{}))

		Xopj_image_data_free(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_win)
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_win = uintptr(0)
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fwin_x0 = TOPJ_UINT32(0)
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fwin_y0 = TOPJ_UINT32(0)
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fwin_x1 = TOPJ_UINT32(0)
		(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fwin_y1 = TOPJ_UINT32(0)

		if (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions == uintptr(00) {
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions = Xopj_malloc(tls, uint32(l_data_size))
			if !(int32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions) != 0) {
				return DOPJ_FALSE
			}
			//fprintf(stderr, "\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\n",l_data_size);
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions_size = l_data_size
			libc.Xmemset(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions, 0, uint32(l_data_size))
		} else if l_data_size > (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions_size {
			var new_resolutions uintptr = Xopj_realloc(tls,
				(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions, uint32(l_data_size))
			if !(new_resolutions != 0) {
				Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33931, 0)
				Xopj_free(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions)
				(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions = uintptr(0)
				(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions_size = TOPJ_UINT32(0)
				return DOPJ_FALSE
			}
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions = new_resolutions
			//fprintf(stderr, "\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\n", l_tilec->resolutions_size, l_data_size);
			libc.Xmemset(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions_size), 0,
				uint32(l_data_size-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions_size))
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions_size = l_data_size
		}

		l_level_no = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fnumresolutions
		l_res = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions
		l_step_size = l_tccp + 28 /* &.stepsizes */
		//fprintf(stderr, "\tlevel_no=%d\n",l_level_no);

		for resno = TOPJ_UINT32(0); resno < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fnumresolutions; resno++ {
			//fprintf(stderr, "\t\tresno = %d/%d\n", resno, l_tilec->numresolutions);
			var tlcbgxstart TOPJ_INT32
			var tlcbgystart TOPJ_INT32
			var cbgwidthexpn TOPJ_UINT32
			var cbgheightexpn TOPJ_UINT32
			var cblkwidthexpn TOPJ_UINT32
			var cblkheightexpn TOPJ_UINT32

			l_level_no--

			// border for each resolution level (global)
			(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx0 = opj_int_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0, TOPJ_INT32(l_level_no))
			(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy0 = opj_int_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0, TOPJ_INT32(l_level_no))
			(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx1 = opj_int_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx1, TOPJ_INT32(l_level_no))
			(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy1 = opj_int_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy1, TOPJ_INT32(l_level_no))

			//fprintf(stderr, "\t\t\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\n", l_res->x0, l_res->y0, l_res->x1, l_res->y1);
			// p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000)
			l_pdx = *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 812 + uintptr(resno)*4))
			l_pdy = *(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 944 + uintptr(resno)*4))
			//fprintf(stderr, "\t\t\tpdx=%d, pdy=%d\n", l_pdx, l_pdy);
			// p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)
			l_tl_prc_x_start = opj_int_floordivpow2(tls, (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx0, TOPJ_INT32(l_pdx)) << l_pdx
			l_tl_prc_y_start = opj_int_floordivpow2(tls, (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy0, TOPJ_INT32(l_pdy)) << l_pdy
			{
				var tmp TOPJ_UINT32 = TOPJ_UINT32(opj_int_ceildivpow2(tls, (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx1,
					TOPJ_INT32(l_pdx))) << l_pdx
				if tmp > TOPJ_UINT32(0x7fffffff) {
					Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33971, 0)
					return DOPJ_FALSE
				}
				l_br_prc_x_end = TOPJ_INT32(tmp)

			}
			{
				var tmp TOPJ_UINT32 = TOPJ_UINT32(opj_int_ceildivpow2(tls, (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy1,
					TOPJ_INT32(l_pdy))) << l_pdy
				if tmp > TOPJ_UINT32(0x7fffffff) {
					Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33971, 0)
					return DOPJ_FALSE
				}
				l_br_prc_y_end = TOPJ_INT32(tmp)

			}
			//fprintf(stderr, "\t\t\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \n", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );

			(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fpw = func() uint32 {
				if (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx0 == (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx1 {
					return 0
				}
				return TOPJ_UINT32((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx)
			}()
			(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fph = func() uint32 {
				if (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy0 == (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy1 {
					return 0
				}
				return TOPJ_UINT32((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy)
			}()
			//fprintf(stderr, "\t\t\tres_pw=%d, res_ph=%d\n", l_res->pw, l_res->ph );

			if (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fpw != 0 && libc.Uint32(libc.Uint32FromInt32(-1))/(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fpw < (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fph {
				Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33890, 0)
				return DOPJ_FALSE
			}
			l_nb_precincts = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fpw * (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fph

			if libc.Uint32(libc.Uint32FromInt32(-1))/TOPJ_UINT32(unsafe.Sizeof(Topj_tcd_precinct_t{})) < l_nb_precincts {
				Xopj_event_msg(tls, manager, DEVT_ERROR, ts+33890, 0)
				return DOPJ_FALSE
			}
			l_nb_precinct_size = l_nb_precincts * TOPJ_UINT32(unsafe.Sizeof(Topj_tcd_precinct_t{}))

			if resno == TOPJ_UINT32(0) {
				tlcbgxstart = l_tl_prc_x_start
				tlcbgystart = l_tl_prc_y_start
				//brcbgxend = l_br_prc_x_end;
				// brcbgyend = l_br_prc_y_end;
				cbgwidthexpn = l_pdx
				cbgheightexpn = l_pdy
				(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fnumbands = TOPJ_UINT32(1)
			} else {
				tlcbgxstart = opj_int_ceildivpow2(tls, l_tl_prc_x_start, 1)
				tlcbgystart = opj_int_ceildivpow2(tls, l_tl_prc_y_start, 1)
				//brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);
				//brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);
				cbgwidthexpn = l_pdx - TOPJ_UINT32(1)
				cbgheightexpn = l_pdy - TOPJ_UINT32(1)
				(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fnumbands = TOPJ_UINT32(3)
			}

			cblkwidthexpn = opj_uint_min(tls, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkw, cbgwidthexpn)
			cblkheightexpn = opj_uint_min(tls, (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblkh, cbgheightexpn)
			l_band = l_res + 32 /* &.bands */

			bandno = TOPJ_UINT32(0)
		__1:
			if !(bandno < (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fnumbands) {
				goto __3
			}
			{
				//fprintf(stderr, "\t\t\tband_no=%d/%d\n", bandno, l_res->numbands );

				if resno == TOPJ_UINT32(0) {
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fbandno = TOPJ_UINT32(0)
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx0 = opj_int_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0, TOPJ_INT32(l_level_no))
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy0 = opj_int_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0, TOPJ_INT32(l_level_no))
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx1 = opj_int_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx1, TOPJ_INT32(l_level_no))
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy1 = opj_int_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy1, TOPJ_INT32(l_level_no))
				} else {
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fbandno = bandno + TOPJ_UINT32(1)
					// x0b = 1 if bandno = 1 or 3
					l_x0b = TOPJ_INT32((*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fbandno & TOPJ_UINT32(1))
					// y0b = 1 if bandno = 2 or 3
					l_y0b = TOPJ_INT32((*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fbandno >> 1)
					// l_band border (global)
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx0 = opj_int64_ceildivpow2(tls, TOPJ_INT64((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0)-TOPJ_INT64(l_x0b)<<l_level_no, TOPJ_INT32(l_level_no+TOPJ_UINT32(1)))
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy0 = opj_int64_ceildivpow2(tls, TOPJ_INT64((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0)-TOPJ_INT64(l_y0b)<<l_level_no, TOPJ_INT32(l_level_no+TOPJ_UINT32(1)))
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx1 = opj_int64_ceildivpow2(tls, TOPJ_INT64((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx1)-TOPJ_INT64(l_x0b)<<l_level_no, TOPJ_INT32(l_level_no+TOPJ_UINT32(1)))
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy1 = opj_int64_ceildivpow2(tls, TOPJ_INT64((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy1)-TOPJ_INT64(l_y0b)<<l_level_no, TOPJ_INT32(l_level_no+TOPJ_UINT32(1)))
				}

				if isEncoder != 0 {
					// Skip empty bands
					if Xopj_tcd_is_band_empty(tls, l_band) != 0 {
						// Do not zero l_band->precints to avoid leaks
						// but make sure we don't use it later, since
						// it will point to precincts of previous bands...
						goto __2
					}
				}

				{
					// Table E-1 - Sub-band gains
					// BUG_WEIRD_TWO_INVK (look for this identifier in dwt.c):
					// the test (!isEncoder && l_tccp->qmfbid == 0) is strongly
					// linked to the use of two_invK instead of invK
					var log2_gain TOPJ_INT32
					if !(isEncoder != 0) && (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid == TOPJ_UINT32(0) {
						log2_gain = 0
					} else {
						if (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fbandno == TOPJ_UINT32(0) {
							log2_gain = 0
						} else {
							if (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fbandno == TOPJ_UINT32(3) {
								log2_gain = 2
							} else {
								log2_gain = 1
							}
						}
					}

					// Nominal dynamic range. Equation E-4
					var Rb TOPJ_INT32 = TOPJ_INT32((*Topj_image_comp_t)(unsafe.Pointer(l_image_comp)).Fprec) + log2_gain

					// Delta_b value of Equation E-3 in "E.1 Inverse quantization
					// procedure" of the standard
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fstepsize = TOPJ_FLOAT32((1.0 + float64((*Topj_stepsize_t)(unsafe.Pointer(l_step_size)).Fmant)/2048.0) * libc.Xpow(tls, 2.0,
						float64(Rb-(*Topj_stepsize_t)(unsafe.Pointer(l_step_size)).Fexpn)))

				}

				// Mb value of Equation E-2 in "E.1 Inverse quantization
				// procedure" of the standard
				(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fnumbps = (*Topj_stepsize_t)(unsafe.Pointer(l_step_size)).Fexpn + TOPJ_INT32((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fnumgbits) - 1

				if !(int32((*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts) != 0) && l_nb_precincts > 0 {
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts = Xopj_malloc(tls, //3 *
						uint32(l_nb_precinct_size))
					if !(int32((*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts) != 0) {
						Xopj_event_msg(tls, manager, DEVT_ERROR,
							ts+33989, 0)
						return DOPJ_FALSE
					}
					//fprintf(stderr, "\t\t\t\tAllocate precincts of a band (opj_tcd_precinct_t): %d\n",l_nb_precinct_size);
					libc.Xmemset(tls, (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts, 0, uint32(l_nb_precinct_size))
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts_data_size = l_nb_precinct_size
				} else if (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts_data_size < l_nb_precinct_size {

					var new_precincts uintptr = Xopj_realloc(tls,
						(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts /*3 * */, uint32(l_nb_precinct_size))
					if !(new_precincts != 0) {
						Xopj_event_msg(tls, manager, DEVT_ERROR,
							ts+33989, 0)
						Xopj_free(tls, (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts)
						(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts = uintptr(0)
						(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts_data_size = TOPJ_UINT32(0)
						return DOPJ_FALSE
					}
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts = new_precincts
					//fprintf(stderr, "\t\t\t\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\n",l_band->precincts_data_size, l_nb_precinct_size);
					libc.Xmemset(tls, (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts+uintptr((*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts_data_size), 0,
						uint32(l_nb_precinct_size-(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts_data_size))
					(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts_data_size = l_nb_precinct_size
				}

				l_current_precinct = (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts
				for precno = TOPJ_UINT32(0); precno < l_nb_precincts; precno++ {
					var tlcblkxstart TOPJ_INT32
					var tlcblkystart TOPJ_INT32
					var brcblkxend TOPJ_INT32
					var brcblkyend TOPJ_INT32
					var cbgxstart TOPJ_INT32 = tlcbgxstart + TOPJ_INT32(precno%(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fpw)*(int32(1)<<cbgwidthexpn)
					var cbgystart TOPJ_INT32 = tlcbgystart + TOPJ_INT32(precno/(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fpw)*(int32(1)<<cbgheightexpn)
					var cbgxend TOPJ_INT32 = cbgxstart + int32(1)<<cbgwidthexpn
					var cbgyend TOPJ_INT32 = cbgystart + int32(1)<<cbgheightexpn
					//fprintf(stderr, "\t precno=%d; bandno=%d, resno=%d; compno=%d\n", precno, bandno , resno, compno);
					//fprintf(stderr, "\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \n",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);

					// precinct size (global)
					//fprintf(stderr, "\t cbgxstart=%d, l_band->x0 = %d \n",cbgxstart, l_band->x0);

					(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fx0 = opj_int_max(tls, cbgxstart, (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx0)
					(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fy0 = opj_int_max(tls, cbgystart, (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy0)
					(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fx1 = opj_int_min(tls, cbgxend, (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fx1)
					(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fy1 = opj_int_min(tls, cbgyend, (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fy1)
					//fprintf(stderr, "\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\n",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);

					tlcblkxstart = opj_int_floordivpow2(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fx0,
						TOPJ_INT32(cblkwidthexpn)) << cblkwidthexpn
					//fprintf(stderr, "\t tlcblkxstart =%d\n",tlcblkxstart );
					tlcblkystart = opj_int_floordivpow2(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fy0,
						TOPJ_INT32(cblkheightexpn)) << cblkheightexpn
					//fprintf(stderr, "\t tlcblkystart =%d\n",tlcblkystart );
					brcblkxend = opj_int_ceildivpow2(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fx1,
						TOPJ_INT32(cblkwidthexpn)) << cblkwidthexpn
					//fprintf(stderr, "\t brcblkxend =%d\n",brcblkxend );
					brcblkyend = opj_int_ceildivpow2(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fy1,
						TOPJ_INT32(cblkheightexpn)) << cblkheightexpn
					//fprintf(stderr, "\t brcblkyend =%d\n",brcblkyend );
					(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fcw = TOPJ_UINT32((brcblkxend - tlcblkxstart) >> cblkwidthexpn)
					(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fch = TOPJ_UINT32((brcblkyend - tlcblkystart) >> cblkheightexpn)

					l_nb_code_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fcw * (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fch
					//fprintf(stderr, "\t\t\t\t precinct_cw = %d x recinct_ch = %d\n",l_current_precinct->cw, l_current_precinct->ch);
					if libc.Uint32(libc.Uint32FromInt32(-1))/TOPJ_UINT32(sizeof_block) < l_nb_code_blocks {
						Xopj_event_msg(tls, manager, DEVT_ERROR,
							ts+34032, 0)
						return DOPJ_FALSE
					}
					l_nb_code_blocks_size = l_nb_code_blocks * TOPJ_UINT32(sizeof_block)

					if !(int32(*(*uintptr)(unsafe.Pointer(l_current_precinct + 24))) != 0) && l_nb_code_blocks > 0 {
						*(*uintptr)(unsafe.Pointer(l_current_precinct + 24)) = Xopj_malloc(tls, uint32(l_nb_code_blocks_size))
						if !(int32(*(*uintptr)(unsafe.Pointer(l_current_precinct + 24))) != 0) {
							return DOPJ_FALSE
						}
						//fprintf(stderr, "\t\t\t\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\n",l_nb_code_blocks_size);

						libc.Xmemset(tls, *(*uintptr)(unsafe.Pointer(l_current_precinct + 24)), 0, uint32(l_nb_code_blocks_size))

						(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fblock_size = l_nb_code_blocks_size
					} else if l_nb_code_blocks_size > (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fblock_size {
						var new_blocks uintptr = Xopj_realloc(tls, *(*uintptr)(unsafe.Pointer(l_current_precinct + 24)),
							uint32(l_nb_code_blocks_size))
						if !(new_blocks != 0) {
							Xopj_free(tls, *(*uintptr)(unsafe.Pointer(l_current_precinct + 24)))
							*(*uintptr)(unsafe.Pointer(l_current_precinct + 24)) = uintptr(0)
							(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fblock_size = TOPJ_UINT32(0)
							Xopj_event_msg(tls, manager, DEVT_ERROR,
								ts+34079, 0)
							return DOPJ_FALSE
						}
						*(*uintptr)(unsafe.Pointer(l_current_precinct + 24)) = new_blocks
						//fprintf(stderr, "\t\t\t\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\n",l_current_precinct->block_size, l_nb_code_blocks_size);

						libc.Xmemset(tls, *(*uintptr)(unsafe.Pointer(l_current_precinct + 24))+uintptr((*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fblock_size), 0, uint32(l_nb_code_blocks_size-(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fblock_size))

						(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fblock_size = l_nb_code_blocks_size
					}

					if !(int32((*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fincltree) != 0) {
						(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fincltree = Xopj_tgt_create(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fcw,
							(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fch, manager)
					} else {
						(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fincltree = Xopj_tgt_init(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fincltree,
							(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fcw, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fch, manager)
					}

					if !(int32((*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fimsbtree) != 0) {
						(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fimsbtree = Xopj_tgt_create(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fcw,
							(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fch, manager)
					} else {
						(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fimsbtree = Xopj_tgt_init(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fimsbtree,
							(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fcw, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fch, manager)
					}

					for cblkno = TOPJ_UINT32(0); cblkno < l_nb_code_blocks; cblkno++ {
						var cblkxstart TOPJ_INT32 = tlcblkxstart + TOPJ_INT32(cblkno%(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fcw)*(int32(1)<<cblkwidthexpn)
						var cblkystart TOPJ_INT32 = tlcblkystart + TOPJ_INT32(cblkno/(*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fcw)*(int32(1)<<cblkheightexpn)
						var cblkxend TOPJ_INT32 = cblkxstart + int32(1)<<cblkwidthexpn
						var cblkyend TOPJ_INT32 = cblkystart + int32(1)<<cblkheightexpn

						if isEncoder != 0 {
							var l_code_block uintptr = *(*uintptr)(unsafe.Pointer(l_current_precinct + 24)) + uintptr(cblkno)*64

							if !(opj_tcd_code_block_enc_allocate(tls, l_code_block) != 0) {
								return DOPJ_FALSE
							}
							// code-block size (global)
							(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fx0 = opj_int_max(tls, cblkxstart, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fx0)
							(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fy0 = opj_int_max(tls, cblkystart, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fy0)
							(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fx1 = opj_int_min(tls, cblkxend, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fx1)
							(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fy1 = opj_int_min(tls, cblkyend, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fy1)

							if !(opj_tcd_code_block_enc_allocate_data(tls, l_code_block) != 0) {
								return DOPJ_FALSE
							}
						} else {
							var l_code_block uintptr = *(*uintptr)(unsafe.Pointer(l_current_precinct + 24)) + uintptr(cblkno)*80

							if !(opj_tcd_code_block_dec_allocate(tls, l_code_block) != 0) {
								return DOPJ_FALSE
							}
							// code-block size (global)
							(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fx0 = opj_int_max(tls, cblkxstart, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fx0)
							(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fy0 = opj_int_max(tls, cblkystart, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fy0)
							(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fx1 = opj_int_min(tls, cblkxend, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fx1)
							(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fy1 = opj_int_min(tls, cblkyend, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_current_precinct)).Fy1)
						}
					}
					l_current_precinct += 56
				} // precno

			}
			goto __2
		__2:
			bandno++
			l_band += 48
			l_step_size += 8
			goto __1
			goto __3
		__3:
			; // bandno
			l_res += 192
		} // resno
		l_tccp += 1080
		l_tilec += 104
		l_image_comp += 64
	} // compno
	return DOPJ_TRUE
}

func Xopj_tcd_init_encode_tile(tls *libc.TLS, p_tcd uintptr, p_tile_no TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* tcd.c:1198:10: */
	return opj_tcd_init_tile(tls, p_tcd, p_tile_no, DOPJ_TRUE,
		uint32(unsafe.Sizeof(Topj_tcd_cblk_enc_t{})), p_manager)
}

func Xopj_tcd_init_decode_tile(tls *libc.TLS, p_tcd uintptr, p_tile_no TOPJ_UINT32, p_manager uintptr) TOPJ_BOOL { /* tcd.c:1205:10: */
	return opj_tcd_init_tile(tls, p_tcd, p_tile_no, DOPJ_FALSE,
		uint32(unsafe.Sizeof(Topj_tcd_cblk_dec_t{})), p_manager)
}

// *
// Allocates memory for an encoding code block (but not data memory).
func opj_tcd_code_block_enc_allocate(tls *libc.TLS, p_code_block uintptr) TOPJ_BOOL { /* tcd.c:1215:17: */
	if !(int32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Flayers) != 0) {
		// no memset since data
		(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Flayers = Xopj_calloc(tls, uint32(100),
			uint32(unsafe.Sizeof(Topj_tcd_layer_t{})))
		if !(int32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Flayers) != 0) {
			return DOPJ_FALSE
		}
	}
	if !(int32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fpasses) != 0) {
		(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fpasses = Xopj_calloc(tls, uint32(100),
			uint32(unsafe.Sizeof(Topj_tcd_pass_t{})))
		if !(int32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fpasses) != 0) {
			return DOPJ_FALSE
		}
	}
	return DOPJ_TRUE
}

// *
// Allocates data memory for an encoding code block.
func opj_tcd_code_block_enc_allocate_data(tls *libc.TLS, p_code_block uintptr) TOPJ_BOOL { /* tcd.c:1239:17: */
	var l_data_size TOPJ_UINT32

	// +1 is needed for https://github.com/uclouvain/openjpeg/issues/835
	// and actually +2 required for https://github.com/uclouvain/openjpeg/issues/982
	// and +7 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 3)
	// and +26 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 7)
	// and +28 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 44)
	// and +33 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 4)
	// and +63 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 4 -IMF 2K)
	// and +74 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 4 -n 8 -s 7,7 -I)
	// TODO: is there a theoretical upper-bound for the compressed code
	// block size ?
	l_data_size = TOPJ_UINT32(74) + TOPJ_UINT32(((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fx1-(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fx0)*((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fy1-(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fy0)*TOPJ_INT32(unsafe.Sizeof(TOPJ_UINT32(0))))

	if l_data_size > (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fdata_size {
		if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fdata != 0 {
			// We refer to data - 1 since below we incremented it
			Xopj_free(tls, (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fdata-uintptr(1))
		}
		(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fdata = Xopj_malloc(tls, uint32(l_data_size+TOPJ_UINT32(1)))
		if !(int32((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fdata) != 0) {
			(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fdata_size = 0
			return DOPJ_FALSE
		}
		(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fdata_size = l_data_size

		// We reserve the initial byte as a fake byte to a non-FF value
		// and increment the data pointer, so that opj_mqc_init_enc()
		// can do bp = data - 1, and opj_mqc_byteout() can safely dereference
		// it.
		*(*TOPJ_BYTE)(unsafe.Pointer((*Topj_tcd_cblk_enc_t)(unsafe.Pointer(p_code_block)).Fdata)) = TOPJ_BYTE(0)
		*(*uintptr)(unsafe.Pointer(p_code_block)) += uintptr(1) //why +1 ?
	}
	return DOPJ_TRUE
}

func Xopj_tcd_reinit_segment(tls *libc.TLS, seg uintptr) { /* tcd.c:1280:6: */
	libc.Xmemset(tls, seg, 0, uint32(unsafe.Sizeof(Topj_tcd_seg_t{})))
}

// *
// Allocates memory for a decoding code block.
func opj_tcd_code_block_dec_allocate(tls *libc.TLS, p_code_block uintptr) TOPJ_BOOL { /* tcd.c:1288:17: */
	if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fsegs) != 0) {

		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fsegs = Xopj_calloc(tls, uint32(DOPJ_J2K_DEFAULT_NB_SEGS),
			uint32(unsafe.Sizeof(Topj_tcd_seg_t{})))
		if !(int32((*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fsegs) != 0) {
			return DOPJ_FALSE
		}
		//fprintf(stderr, "Allocate %d elements of code_block->data\n", OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));

		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fm_current_max_segs = TOPJ_UINT32(DOPJ_J2K_DEFAULT_NB_SEGS)
		//fprintf(stderr, "m_current_max_segs of code_block->data = %d\n", p_code_block->m_current_max_segs);
	} else {
		// sanitize
		var l_segs uintptr = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fsegs
		var l_current_max_segs TOPJ_UINT32 = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fm_current_max_segs
		var l_chunks uintptr = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fchunks
		var l_numchunksalloc TOPJ_UINT32 = (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fnumchunksalloc
		var i TOPJ_UINT32

		Xopj_aligned_free(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fdecoded_data)
		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fdecoded_data = uintptr(00)

		libc.Xmemset(tls, p_code_block, 0, uint32(unsafe.Sizeof(Topj_tcd_cblk_dec_t{})))
		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fsegs = l_segs
		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fm_current_max_segs = l_current_max_segs
		for i = TOPJ_UINT32(0); i < l_current_max_segs; i++ {
			Xopj_tcd_reinit_segment(tls, l_segs+uintptr(i)*24)
		}
		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fchunks = l_chunks
		(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(p_code_block)).Fnumchunksalloc = l_numchunksalloc
	}

	return DOPJ_TRUE
}

func Xopj_tcd_get_decoded_tile_size(tls *libc.TLS, p_tcd uintptr, take_into_account_partial_decoding TOPJ_BOOL) TOPJ_UINT32 { /* tcd.c:1326:12: */
	var i TOPJ_UINT32
	var l_data_size TOPJ_UINT32 = TOPJ_UINT32(0)
	var l_img_comp uintptr = uintptr(00)
	var l_tile_comp uintptr = uintptr(00)
	var l_res uintptr = uintptr(00)
	var l_size_comp TOPJ_UINT32
	var l_remaining TOPJ_UINT32
	var l_temp TOPJ_UINT32

	l_tile_comp = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps

	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; i++ {
		var w TOPJ_UINT32
		var h TOPJ_UINT32
		l_size_comp = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec >> 3             //(/ 8)
		l_remaining = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec & TOPJ_UINT32(7) // (%8)

		if l_remaining != 0 {
			l_size_comp++
		}

		if l_size_comp == TOPJ_UINT32(3) {
			l_size_comp = TOPJ_UINT32(4)
		}

		l_res = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fresolutions + uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fminimum_num_resolutions)*192 - uintptr(1)*192
		if take_into_account_partial_decoding != 0 && !((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0) {
			w = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x0
			h = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_y1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_y0
		} else {
			w = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx0)
			h = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy0)
		}
		if h > TOPJ_UINT32(0) && (uint32(0x7fffffff)*2+1)/w < h {
			return uint32(0x7fffffff)*2 + 1
		}
		l_temp = w * h
		if l_size_comp != 0 && (uint32(0x7fffffff)*2+1)/l_size_comp < l_temp {
			return uint32(0x7fffffff)*2 + 1
		}
		l_temp = l_temp * l_size_comp

		if l_temp > uint32(0x7fffffff)*2+1-l_data_size {
			return uint32(0x7fffffff)*2 + 1
		}
		l_data_size = l_data_size + l_temp
		l_img_comp += 64
		l_tile_comp += 104
	}

	return l_data_size
}

func Xopj_tcd_encode_tile(tls *libc.TLS, p_tcd uintptr, p_tile_no TOPJ_UINT32, p_dest uintptr, p_data_written uintptr, p_max_length TOPJ_UINT32, p_cstr_info uintptr, p_marker_info uintptr, p_manager uintptr) TOPJ_BOOL { /* tcd.c:1381:10: */

	if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcur_tp_num == TOPJ_UINT32(0) {

		(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_tileno = p_tile_no
		(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp = (*Topj_cp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcp)).Ftcps + uintptr(p_tile_no)*5696

		// INDEX >> "Precinct_nb_X et Precinct_nb_Y"
		if p_cstr_info != 0 {
			var l_num_packs TOPJ_UINT32 = TOPJ_UINT32(0)
			var i TOPJ_UINT32
			var l_tilec_idx uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps // based on component 0
			var l_tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Ftccps                                                             // based on component 0

			for i = TOPJ_UINT32(0); i < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec_idx)).Fnumresolutions; i++ {
				var l_res_idx uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec_idx)).Fresolutions + uintptr(i)*192

				*(*int32)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Ftile + uintptr(p_tile_no)*608 + 24 + uintptr(i)*4)) = int32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res_idx)).Fpw)
				*(*int32)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Ftile + uintptr(p_tile_no)*608 + 156 + uintptr(i)*4)) = int32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res_idx)).Fph)

				l_num_packs = l_num_packs + (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res_idx)).Fpw*(*Topj_tcd_resolution_t)(unsafe.Pointer(l_res_idx)).Fph
				*(*int32)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Ftile + uintptr(p_tile_no)*608 + 288 + uintptr(i)*4)) = int32(*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 812 + uintptr(i)*4)))
				*(*int32)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Ftile + uintptr(p_tile_no)*608 + 420 + uintptr(i)*4)) = int32(*(*TOPJ_UINT32)(unsafe.Pointer(l_tccp + 944 + uintptr(i)*4)))
			}
			(*Topj_tile_info_t)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Ftile + uintptr(p_tile_no)*608)).Fpacket = Xopj_calloc(tls, TOPJ_SIZE_T((*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Fnumcomps)*TOPJ_SIZE_T((*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Fnumlayers)*TOPJ_SIZE_T(l_num_packs),
				uint32(unsafe.Sizeof(Topj_packet_info_t{})))
			if !(int32((*Topj_tile_info_t)(unsafe.Pointer((*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Ftile+uintptr(p_tile_no)*608)).Fpacket) != 0) {
				// FIXME event manager error callback
				return DOPJ_FALSE
			}
		}
		// << INDEX

		// FIXME _ProfStart(PGROUP_DC_SHIFT);
		//---------------TILE-------------------
		if !(opj_tcd_dc_level_shift_encode(tls, p_tcd) != 0) {
			return DOPJ_FALSE
		}
		// FIXME _ProfStop(PGROUP_DC_SHIFT);

		// FIXME _ProfStart(PGROUP_MCT);
		if !(opj_tcd_mct_encode(tls, p_tcd) != 0) {
			return DOPJ_FALSE
		}
		// FIXME _ProfStop(PGROUP_MCT);

		// FIXME _ProfStart(PGROUP_DWT);
		if !(opj_tcd_dwt_encode(tls, p_tcd) != 0) {
			return DOPJ_FALSE
		}
		// FIXME  _ProfStop(PGROUP_DWT);

		// FIXME  _ProfStart(PGROUP_T1);
		if !(opj_tcd_t1_encode(tls, p_tcd) != 0) {
			return DOPJ_FALSE
		}
		// FIXME _ProfStop(PGROUP_T1);

		// FIXME _ProfStart(PGROUP_RATE);
		if !(opj_tcd_rate_allocate_encode(tls, p_tcd, p_dest, p_max_length,
			p_cstr_info, p_manager) != 0) {
			return DOPJ_FALSE
		}
		// FIXME _ProfStop(PGROUP_RATE);

	}
	//--------------TIER2------------------

	// INDEX
	if p_cstr_info != 0 {
		(*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Findex_write = 1
	}
	// FIXME _ProfStart(PGROUP_T2);

	if !(opj_tcd_t2_encode(tls, p_tcd, p_dest, p_data_written, p_max_length,
		p_cstr_info, p_marker_info, p_manager) != 0) {
		return DOPJ_FALSE
	}
	// FIXME _ProfStop(PGROUP_T2);

	//---------------CLEAN-------------------

	return DOPJ_TRUE
}

func Xopj_tcd_decode_tile(tls *libc.TLS, p_tcd uintptr, win_x0 TOPJ_UINT32, win_y0 TOPJ_UINT32, win_x1 TOPJ_UINT32, win_y1 TOPJ_UINT32, numcomps_to_decode TOPJ_UINT32, comps_indices uintptr, p_src uintptr, p_max_length TOPJ_UINT32, p_tile_no TOPJ_UINT32, p_cstr_index uintptr, p_manager uintptr) TOPJ_BOOL { /* tcd.c:1477:10: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var l_data_read TOPJ_UINT32 at bp, 4

	var compno TOPJ_UINT32

	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_tileno = p_tile_no
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp = (*Topj_cp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcp)).Ftcps + uintptr(p_tile_no)*5696
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_x0 = win_x0
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_y0 = win_y0
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_x1 = win_x1
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_y1 = win_y1
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding = DOPJ_TRUE

	Xopj_free(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component)
	(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component = uintptr(0)

	if numcomps_to_decode != 0 {
		var used_component uintptr = Xopj_calloc(tls, uint32(unsafe.Sizeof(TOPJ_BOOL(0))),
			uint32((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps))
		if used_component == uintptr(0) {
			return DOPJ_FALSE
		}
		for compno = TOPJ_UINT32(0); compno < numcomps_to_decode; compno++ {
			*(*TOPJ_BOOL)(unsafe.Pointer(used_component + uintptr(*(*TOPJ_UINT32)(unsafe.Pointer(comps_indices + uintptr(compno)*4)))*4)) = DOPJ_TRUE
		}

		(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component = used_component
	}

	for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; compno++ {
		if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component != uintptr(0) && !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component + uintptr(compno)*4)) != 0) {
			continue
		}

		if !(opj_tcd_is_whole_tilecomp_decoding(tls, p_tcd, compno) != 0) {
			(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding = DOPJ_FALSE
			break
		}
	}

	if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; compno++ {
			var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(compno)*104
			var l_res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192
			var l_data_size TOPJ_SIZE_T

			// compute l_data_size with overflow check
			var res_w TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx0)
			var res_h TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy0)

			if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component != uintptr(0) && !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component + uintptr(compno)*4)) != 0) {
				continue
			}

			// issue 733, l_data_size == 0U, probably something wrong should be checked before getting here
			if res_h > TOPJ_SIZE_T(0) && uint64(res_w) > libc.Uint64(18446744073709551615)/uint64(res_h) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+33890, 0)
				return DOPJ_FALSE
			}
			l_data_size = res_w * res_h

			if libc.Uint64(18446744073709551615)/uint64(unsafe.Sizeof(TOPJ_UINT32(0))) < uint64(l_data_size) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+33890, 0)
				return DOPJ_FALSE
			}
			l_data_size = l_data_size * TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_UINT32(0)))

			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_size_needed = l_data_size

			if !(Xopj_alloc_tile_component_data(tls, tilec) != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+33890, 0)
				return DOPJ_FALSE
			}
		}
	} else {
		// Compute restricted tile-component and tile-resolution coordinates
		// of the window of interest, but defer the memory allocation until
		// we know the resno_decoded
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; compno++ {
			var resno TOPJ_UINT32
			var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(compno)*104
			var image_comp uintptr = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps + uintptr(compno)*64

			if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component != uintptr(0) && !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component + uintptr(compno)*4)) != 0) {
				continue
			}

			// Compute the intersection of the area of interest, expressed in tile coordinates
			// with the tile coordinates
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x0 = opj_uint_max(tls,
				TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx0),
				opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_x0, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdx))
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y0 = opj_uint_max(tls,
				TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy0),
				opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_y0, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdy))
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x1 = opj_uint_min(tls,
				TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx1),
				opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_x1, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdx))
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y1 = opj_uint_min(tls,
				TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy1),
				opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_y1, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdy))
			if (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x1 < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x0 || (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y1 < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y0 {
				// We should not normally go there. The circumstance is when
				// the tile coordinates do not intersect the area of interest
				// Upper level logic should not even try to decode that tile
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+34137, 0)
				return DOPJ_FALSE
			}

			for resno = TOPJ_UINT32(0); resno < (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions; resno++ {
				var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr(resno)*192
				(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fwin_x0 = opj_uint_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x0,
					(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions-TOPJ_UINT32(1)-resno)
				(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fwin_y0 = opj_uint_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y0,
					(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions-TOPJ_UINT32(1)-resno)
				(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fwin_x1 = opj_uint_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_x1,
					(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions-TOPJ_UINT32(1)-resno)
				(*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fwin_y1 = opj_uint_ceildivpow2(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fwin_y1,
					(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions-TOPJ_UINT32(1)-resno)
			}
		}
	}

	//--------------TIER2------------------
	// FIXME _ProfStart(PGROUP_T2);
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_data_read */)) = TOPJ_UINT32(0)
	if !(opj_tcd_t2_decode(tls, p_tcd, p_src, bp, p_max_length, p_cstr_index,
		p_manager) != 0) {
		return DOPJ_FALSE
	}
	// FIXME _ProfStop(PGROUP_T2);

	//------------------TIER1-----------------

	// FIXME _ProfStart(PGROUP_T1);
	if !(opj_tcd_t1_decode(tls, p_tcd, p_manager) != 0) {
		return DOPJ_FALSE
	}
	// FIXME _ProfStop(PGROUP_T1);

	// For subtile decoding, now we know the resno_decoded, we can allocate
	// the tile data buffer
	if !((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0) {
		for compno = TOPJ_UINT32(0); compno < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; compno++ {
			var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(compno)*104
			var image_comp uintptr = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps + uintptr(compno)*64
			var res uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fresolutions + uintptr((*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fresno_decoded)*192
			var w TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fwin_x1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fwin_x0)
			var h TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fwin_y1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(res)).Fwin_y0)
			var l_data_size TOPJ_SIZE_T

			Xopj_image_data_free(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_win)
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_win = uintptr(0)

			if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component != uintptr(0) && !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component + uintptr(compno)*4)) != 0) {
				continue
			}

			if w > TOPJ_SIZE_T(0) && h > TOPJ_SIZE_T(0) {
				if uint64(w) > libc.Uint64(18446744073709551615)/uint64(h) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+33890, 0)
					return DOPJ_FALSE
				}
				l_data_size = w * h
				if uint64(l_data_size) > libc.Uint64(18446744073709551615)/uint64(unsafe.Sizeof(TOPJ_INT32(0))) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+33890, 0)
					return DOPJ_FALSE
				}
				l_data_size = l_data_size * TOPJ_SIZE_T(unsafe.Sizeof(TOPJ_INT32(0)))

				(*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_win = Xopj_image_data_alloc(tls, l_data_size)
				if (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fdata_win == uintptr(0) {
					Xopj_event_msg(tls, p_manager, DEVT_ERROR,
						ts+33890, 0)
					return DOPJ_FALSE
				}
			}
		}
	}

	//----------------DWT---------------------

	// FIXME _ProfStart(PGROUP_DWT);
	if !(opj_tcd_dwt_decode(tls, p_tcd) != 0) {
		return DOPJ_FALSE
	}
	// FIXME _ProfStop(PGROUP_DWT);

	//----------------MCT-------------------
	// FIXME _ProfStart(PGROUP_MCT);
	if !(opj_tcd_mct_decode(tls, p_tcd, p_manager) != 0) {
		return DOPJ_FALSE
	}
	// FIXME _ProfStop(PGROUP_MCT);

	// FIXME _ProfStart(PGROUP_DC_SHIFT);
	if !(opj_tcd_dc_level_shift_decode(tls, p_tcd) != 0) {
		return DOPJ_FALSE
	}
	// FIXME _ProfStop(PGROUP_DC_SHIFT);

	//---------------TILE-------------------
	return DOPJ_TRUE
}

func Xopj_tcd_update_tile_data(tls *libc.TLS, p_tcd uintptr, p_dest uintptr, p_dest_length TOPJ_UINT32) TOPJ_BOOL { /* tcd.c:1731:10: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var k TOPJ_UINT32
	var l_data_size TOPJ_UINT32 = TOPJ_UINT32(0)
	var l_img_comp uintptr = uintptr(00)
	var l_tilec uintptr = uintptr(00)
	var l_res uintptr
	var l_size_comp TOPJ_UINT32
	var l_remaining TOPJ_UINT32
	var l_stride TOPJ_UINT32
	var l_width TOPJ_UINT32
	var l_height TOPJ_UINT32

	l_data_size = Xopj_tcd_get_decoded_tile_size(tls, p_tcd, DOPJ_TRUE)
	if l_data_size == uint32(0x7fffffff)*2+1 || l_data_size > p_dest_length {
		return DOPJ_FALSE
	}

	l_tilec = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps

	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; i++ {
		var l_src_data uintptr
		l_size_comp = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec >> 3             //(/ 8)
		l_remaining = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec & TOPJ_UINT32(7) // (%8)
		l_res = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions + uintptr((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded)*192
		if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
			l_width = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx0)
			l_height = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy0)
			l_stride = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx1-(*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx0) - l_width
			l_src_data = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata
		} else {
			l_width = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x0
			l_height = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_y1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_y0
			l_stride = TOPJ_UINT32(0)
			l_src_data = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata_win
		}

		if l_remaining != 0 {
			l_size_comp++
		}

		if l_size_comp == TOPJ_UINT32(3) {
			l_size_comp = TOPJ_UINT32(4)
		}

		switch l_size_comp {
		case TOPJ_UINT32(1):
			{
				var l_dest_ptr uintptr = p_dest
				var l_src_ptr uintptr = l_src_data

				if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd != 0 {
					for j = TOPJ_UINT32(0); j < l_height; j++ {
						for k = TOPJ_UINT32(0); k < l_width; k++ {
							*(*TOPJ_CHAR)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 1))) = TOPJ_CHAR(*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 4))))
						}
						l_src_ptr += 4 * uintptr(l_stride)
					}
				} else {
					for j = TOPJ_UINT32(0); j < l_height; j++ {
						for k = TOPJ_UINT32(0); k < l_width; k++ {
							*(*TOPJ_CHAR)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 1))) = TOPJ_CHAR(*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 4))) & 0xff)
						}
						l_src_ptr += 4 * uintptr(l_stride)
					}
				}

				p_dest = l_dest_ptr

			}
			break
		case TOPJ_UINT32(2):
			{
				var l_src_ptr uintptr = l_src_data
				var l_dest_ptr uintptr = p_dest

				if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd != 0 {
					for j = TOPJ_UINT32(0); j < l_height; j++ {
						for k = TOPJ_UINT32(0); k < l_width; k++ {
							*(*TOPJ_INT16)(unsafe.Pointer(bp /* val */)) = TOPJ_INT16(*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 4))))
							libc.Xmemcpy(tls, l_dest_ptr, bp, uint32(unsafe.Sizeof(TOPJ_INT16(0))))
							l_dest_ptr += 2
						}
						l_src_ptr += 4 * uintptr(l_stride)
					}
				} else {
					for j = TOPJ_UINT32(0); j < l_height; j++ {
						for k = TOPJ_UINT32(0); k < l_width; k++ {
							*(*TOPJ_INT16)(unsafe.Pointer(bp + 2 /* val */)) = TOPJ_INT16(*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 4))) & 0xffff)
							libc.Xmemcpy(tls, l_dest_ptr, bp+2, uint32(unsafe.Sizeof(TOPJ_INT16(0))))
							l_dest_ptr += 2
						}
						l_src_ptr += 4 * uintptr(l_stride)
					}
				}

				p_dest = l_dest_ptr

			}
			break
		case TOPJ_UINT32(4):
			{
				var l_dest_ptr uintptr = p_dest
				var l_src_ptr uintptr = l_src_data

				for j = TOPJ_UINT32(0); j < l_height; j++ {
					libc.Xmemcpy(tls, l_dest_ptr, l_src_ptr, uint32(l_width)*uint32(unsafe.Sizeof(TOPJ_INT32(0))))
					l_dest_ptr += 4 * uintptr(l_width)
					l_src_ptr += 4 * uintptr(l_width+l_stride)
				}

				p_dest = l_dest_ptr

			}
			break
		}

		l_img_comp += 64
		l_tilec += 104
	}

	return DOPJ_TRUE
}

func opj_tcd_free_tile(tls *libc.TLS, p_tcd uintptr) { /* tcd.c:1854:13: */
	var compno TOPJ_UINT32
	var resno TOPJ_UINT32
	var bandno TOPJ_UINT32
	var precno TOPJ_UINT32
	var l_tile uintptr = uintptr(00)
	var l_tile_comp uintptr = uintptr(00)
	var l_res uintptr = uintptr(00)
	var l_band uintptr = uintptr(00)
	var l_precinct uintptr = uintptr(00)
	var l_nb_resolutions TOPJ_UINT32
	var l_nb_precincts TOPJ_UINT32
	var l_tcd_code_block_deallocate uintptr = uintptr(00)

	if !(p_tcd != 0) {
		return
	}

	if !(int32((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image) != 0) {
		return
	}

	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(p_tcd + 60))&0x1>>0)) != 0 {
		l_tcd_code_block_deallocate = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{opj_tcd_code_block_dec_deallocate}))
	} else {
		l_tcd_code_block_deallocate = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{opj_tcd_code_block_enc_deallocate}))
	}

	l_tile = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	if !(l_tile != 0) {
		return
	}

	l_tile_comp = (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps

	for compno = TOPJ_UINT32(0); compno < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps; compno++ {
		l_res = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fresolutions
		if l_res != 0 {

			l_nb_resolutions = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fresolutions_size / TOPJ_UINT32(unsafe.Sizeof(Topj_tcd_resolution_t{}))
			for resno = TOPJ_UINT32(0); resno < l_nb_resolutions; resno++ {
				l_band = l_res + 32 /* &.bands */
				for bandno = TOPJ_UINT32(0); bandno < TOPJ_UINT32(3); bandno++ {
					l_precinct = (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts
					if l_precinct != 0 {

						l_nb_precincts = (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts_data_size / TOPJ_UINT32(unsafe.Sizeof(Topj_tcd_precinct_t{}))
						for precno = TOPJ_UINT32(0); precno < l_nb_precincts; precno++ {
							Xopj_tgt_destroy(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_precinct)).Fincltree)
							(*Topj_tcd_precinct_t)(unsafe.Pointer(l_precinct)).Fincltree = uintptr(00)
							Xopj_tgt_destroy(tls, (*Topj_tcd_precinct_t)(unsafe.Pointer(l_precinct)).Fimsbtree)
							(*Topj_tcd_precinct_t)(unsafe.Pointer(l_precinct)).Fimsbtree = uintptr(00)
							(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{l_tcd_code_block_deallocate})).f(tls, l_precinct)
							l_precinct += 56
						}

						Xopj_free(tls, (*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts)
						(*Topj_tcd_band_t)(unsafe.Pointer(l_band)).Fprecincts = uintptr(00)
					}
					l_band += 48
				} // for (resno
				l_res += 192
			}

			Xopj_free(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fresolutions)
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fresolutions = uintptr(00)
		}

		if (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).FownsData != 0 && (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata != 0 {
			Xopj_image_data_free(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata)
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata = uintptr(00)
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).FownsData = 0
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata_size = Tsize_t(0)
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata_size_needed = Tsize_t(0)
		}

		Xopj_image_data_free(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata_win)

		l_tile_comp += 104
	}

	Xopj_free(tls, (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)
	(*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps = uintptr(00)
	Xopj_free(tls, (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)
	(*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles = uintptr(00)
}

func opj_tcd_t2_decode(tls *libc.TLS, p_tcd uintptr, p_src_data uintptr, p_data_read uintptr, p_max_src_size TOPJ_UINT32, p_cstr_index uintptr, p_manager uintptr) TOPJ_BOOL { /* tcd.c:1941:17: */
	var l_t2 uintptr

	l_t2 = Xopj_t2_create(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcp)
	if l_t2 == uintptr(00) {
		return DOPJ_FALSE
	}

	if !(Xopj_t2_decode_packets(tls,
		p_tcd,
		l_t2,
		(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_tileno,
		(*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles,
		p_src_data,
		p_data_read,
		p_max_src_size,
		p_cstr_index,
		p_manager) != 0) {
		Xopj_t2_destroy(tls, l_t2)
		return DOPJ_FALSE
	}

	Xopj_t2_destroy(tls, l_t2)

	//---------------CLEAN-------------------
	return DOPJ_TRUE
}

func opj_tcd_t1_decode(tls *libc.TLS, p_tcd uintptr, p_manager uintptr) TOPJ_BOOL { /* tcd.c:1976:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var compno TOPJ_UINT32
	var l_tile uintptr = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	var l_tile_comp uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps
	var l_tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Ftccps
	*(*TOPJ_BOOL)(unsafe.Pointer(bp /* ret */)) = DOPJ_TRUE
	var check_pterm TOPJ_BOOL = DOPJ_FALSE
	var p_manager_mutex uintptr = uintptr(0)

	p_manager_mutex = Xopj_mutex_create(tls)

	// Only enable PTERM check if we decode all layers
	if (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Fnum_layers_to_decode == (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Fnumlayers && (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fcblksty&TOPJ_UINT32(DJ2K_CCP_CBLKSTY_PTERM) != TOPJ_UINT32(0) {
		check_pterm = DOPJ_TRUE
	}

	compno = TOPJ_UINT32(0)
__1:
	if !(compno < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps) {
		goto __3
	}
	{
		if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component != uintptr(0) && !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component + uintptr(compno)*4)) != 0) {
			goto __2
		}

		Xopj_t1_decode_cblks(tls, p_tcd, bp, l_tile_comp, l_tccp,
			p_manager, p_manager_mutex, check_pterm)
		if !(*(*TOPJ_BOOL)(unsafe.Pointer(bp)) != 0) {
			goto __3
		}

	}
	goto __2
__2:
	compno++
	l_tile_comp += 104
	l_tccp += 1080
	goto __1
	goto __3
__3:
	;

	Xopj_thread_pool_wait_completion(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fthread_pool, 0)
	if p_manager_mutex != 0 {
		Xopj_mutex_destroy(tls, p_manager_mutex)
	}
	return *(*TOPJ_BOOL)(unsafe.Pointer(bp /* ret */))
}

func opj_tcd_dwt_decode(tls *libc.TLS, p_tcd uintptr) TOPJ_BOOL { /* tcd.c:2015:17: */
	var compno TOPJ_UINT32
	var l_tile uintptr = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	var l_tile_comp uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps
	var l_tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Ftccps
	var l_img_comp uintptr = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps

	compno = TOPJ_UINT32(0)
__1:
	if !(compno < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps) {
		goto __3
	}
	{
		if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component != uintptr(0) && !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component + uintptr(compno)*4)) != 0) {
			goto __2
		}

		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid == TOPJ_UINT32(1) {
			if !(Xopj_dwt_decode(tls, p_tcd, l_tile_comp,
				(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded+TOPJ_UINT32(1)) != 0) {
				return DOPJ_FALSE
			}
		} else {
			if !(Xopj_dwt_decode_real(tls, p_tcd, l_tile_comp,
				(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded+TOPJ_UINT32(1)) != 0) {
				return DOPJ_FALSE
			}
		}

	}
	goto __2
__2:
	compno++
	l_tile_comp += 104
	l_img_comp += 64
	l_tccp += 1080
	goto __1
	goto __3
__3:
	;

	return DOPJ_TRUE
}

func opj_tcd_mct_decode(tls *libc.TLS, p_tcd uintptr, p_manager uintptr) TOPJ_BOOL { /* tcd.c:2046:17: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var l_tile uintptr = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	var l_tcp uintptr = (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp
	var l_tile_comp uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps
	var l_samples TOPJ_SIZE_T
	var i TOPJ_UINT32

	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fmct == TOPJ_UINT32(0) || (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component != uintptr(0) {
		return DOPJ_TRUE
	}

	if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
		var res_comp0 uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)).Fresolutions + uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fminimum_num_resolutions)*192 - uintptr(1)*192

		// A bit inefficient: we process more data than needed if
		// resno_decoded < l_tile_comp->minimum_num_resolutions-1,
		// but we would need to take into account a stride then
		l_samples = TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp0)).Fx1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp0)).Fx0) * TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp0)).Fy1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp0)).Fy0)
		if (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps >= TOPJ_UINT32(3) {
			if (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fminimum_num_resolutions != (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fminimum_num_resolutions || (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fminimum_num_resolutions != (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fminimum_num_resolutions {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+34168, 0)
				return DOPJ_FALSE
			}
		}
		if (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps >= TOPJ_UINT32(3) {
			var res_comp1 uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fresolutions + uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fminimum_num_resolutions)*192 - uintptr(1)*192
			var res_comp2 uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fresolutions + uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fminimum_num_resolutions)*192 - uintptr(1)*192
			// testcase 1336.pdf.asan.47.376
			if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps)).Fresno_decoded != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps+1*64)).Fresno_decoded || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps)).Fresno_decoded != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps+2*64)).Fresno_decoded || TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp1)).Fx1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp1)).Fx0)*TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp1)).Fy1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp1)).Fy0) != l_samples || TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp2)).Fx1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp2)).Fx0)*TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp2)).Fy1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp2)).Fy0) != l_samples {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+34168, 0)
				return DOPJ_FALSE
			}
		}
	} else {
		var res_comp0 uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)).Fresolutions + uintptr((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps)).Fresno_decoded)*192

		l_samples = TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp0)).Fwin_x1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp0)).Fwin_x0) * TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp0)).Fwin_y1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp0)).Fwin_y0)
		if (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps >= TOPJ_UINT32(3) {
			var res_comp1 uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fresolutions + uintptr((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps+1*64)).Fresno_decoded)*192
			var res_comp2 uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fresolutions + uintptr((*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps+2*64)).Fresno_decoded)*192
			// testcase 1336.pdf.asan.47.376
			if (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps)).Fresno_decoded != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps+1*64)).Fresno_decoded || (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps)).Fresno_decoded != (*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps+2*64)).Fresno_decoded || TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp1)).Fwin_x1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp1)).Fwin_x0)*TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp1)).Fwin_y1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp1)).Fwin_y0) != l_samples || TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp2)).Fwin_x1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp2)).Fwin_x0)*TOPJ_SIZE_T((*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp2)).Fwin_y1-(*Topj_tcd_resolution_t)(unsafe.Pointer(res_comp2)).Fwin_y0) != l_samples {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+34168, 0)
				return DOPJ_FALSE
			}
		}
	}

	if (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps >= TOPJ_UINT32(3) {
		if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fmct == TOPJ_UINT32(2) {
			var l_data uintptr

			if !(int32((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix) != 0) {
				return DOPJ_TRUE
			}

			l_data = Xopj_malloc(tls, uint32((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps)*uint32(unsafe.Sizeof(uintptr(0))))
			if !(l_data != 0) {
				return DOPJ_FALSE
			}

			for i = TOPJ_UINT32(0); i < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps; i++ {
				if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
					*(*uintptr)(unsafe.Pointer(l_data + uintptr(i)*8)) = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata
				} else {
					*(*uintptr)(unsafe.Pointer(l_data + uintptr(i)*8)) = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata_win
				}
				l_tile_comp += 104
			}

			if !(Xopj_mct_decode_custom(tls,
				(*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fm_mct_decoding_matrix,

				l_samples,

				l_data,

				(*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps,

				(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps)).Fsgnd) != 0) {
				Xopj_free(tls, l_data)
				return DOPJ_FALSE
			}

			Xopj_free(tls, l_data)
		} else {
			if (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps)).Fqmfbid == TOPJ_UINT32(1) {
				if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
					Xopj_mct_decode(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)).Fdata,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fdata,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fdata,
						l_samples)
				} else {
					Xopj_mct_decode(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)).Fdata_win,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fdata_win,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fdata_win,
						l_samples)
				}
			} else {
				if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0 {
					Xopj_mct_decode_real(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)).Fdata,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fdata,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fdata,
						l_samples)
				} else {
					Xopj_mct_decode_real(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)).Fdata_win,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fdata_win,
						(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fdata_win,
						l_samples)
				}
			}
		}
	} else {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+34229,
			libc.VaList(bp, (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps))
	}

	return DOPJ_TRUE
}

func opj_tcd_dc_level_shift_decode(tls *libc.TLS, p_tcd uintptr) TOPJ_BOOL { /* tcd.c:2197:17: */
	var compno TOPJ_UINT32
	var l_tile_comp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)
	var l_res uintptr = uintptr(00)
	var l_tile uintptr
	var l_width TOPJ_UINT32
	var l_height TOPJ_UINT32
	var i TOPJ_UINT32
	var j TOPJ_UINT32
	var l_current_ptr uintptr
	var l_min TOPJ_INT32
	var l_max TOPJ_INT32
	var l_stride TOPJ_UINT32

	l_tile = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	l_tile_comp = (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Ftccps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps

	compno = TOPJ_UINT32(0)
__1:
	if !(compno < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps) {
		goto __3
	}
	{

		if (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component != uintptr(0) && !(*(*TOPJ_BOOL)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fused_component + uintptr(compno)*4)) != 0) {
			goto __2
		}

		l_res = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fresolutions + uintptr((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fresno_decoded)*192

		if !((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwhole_tile_decoding != 0) {
			l_width = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_x0
			l_height = (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_y1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fwin_y0
			l_stride = TOPJ_UINT32(0)
			l_current_ptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata_win
		} else {
			l_width = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fx0)
			l_height = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy1 - (*Topj_tcd_resolution_t)(unsafe.Pointer(l_res)).Fy0)
			l_stride = TOPJ_UINT32((*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx1-(*Topj_tcd_resolution_t)(unsafe.Pointer((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fresolutions+uintptr((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fminimum_num_resolutions-TOPJ_UINT32(1))*192)).Fx0) -
				l_width
			l_current_ptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata

			if l_height == TOPJ_UINT32(0) || Tsize_t(l_width+l_stride) <= (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata_size/Tsize_t(l_height) {
			} else {
				libc.X__assert_fail(tls, ts+34303, ts+34376, uint32(2238), uintptr(unsafe.Pointer(&__func__274)))
			} //MUPDF
		}

		if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd != 0 {
			l_min = -(int32(1) << ((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec - TOPJ_UINT32(1)))
			l_max = int32(1)<<((*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec-TOPJ_UINT32(1)) - 1
		} else {
			l_min = 0
			l_max = TOPJ_INT32(uint32(1)<<(*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec - uint32(1))
		}

		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid == TOPJ_UINT32(1) {
			for j = TOPJ_UINT32(0); j < l_height; j++ {
				for i = TOPJ_UINT32(0); i < l_width; i++ {
					// TODO: do addition on int64 ?
					*(*TOPJ_INT32)(unsafe.Pointer(l_current_ptr)) = opj_int_clamp(tls, *(*TOPJ_INT32)(unsafe.Pointer(l_current_ptr))+(*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fm_dc_level_shift, l_min,
						l_max)
					l_current_ptr += 4
				}
				l_current_ptr += 4 * uintptr(l_stride)
			}
		} else {
			for j = TOPJ_UINT32(0); j < l_height; j++ {
				for i = TOPJ_UINT32(0); i < l_width; i++ {
					var l_value TOPJ_FLOAT32 = *(*TOPJ_FLOAT32)(unsafe.Pointer(l_current_ptr))
					if l_value > float32(0x7fffffff) {
						*(*TOPJ_INT32)(unsafe.Pointer(l_current_ptr)) = l_max
					} else if l_value < float32(-0x7fffffff-1) {
						*(*TOPJ_INT32)(unsafe.Pointer(l_current_ptr)) = l_min
					} else {
						// Do addition on int64 to avoid overflows
						var l_value_int TOPJ_INT64 = opj_lrintf(tls, l_value)
						*(*TOPJ_INT32)(unsafe.Pointer(l_current_ptr)) = TOPJ_INT32(opj_int64_clamp(tls,
							l_value_int+TOPJ_INT64((*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fm_dc_level_shift), int32(l_min), int32(l_max)))
					}
					l_current_ptr += 4
				}
				l_current_ptr += 4 * uintptr(l_stride)
			}
		}

	}
	goto __2
__2:
	compno++
	l_img_comp += 64
	l_tccp += 1080
	l_tile_comp += 104
	goto __1
	goto __3
__3:
	;

	return DOPJ_TRUE
}

var __func__274 = *(*[30]int8)(unsafe.Pointer(ts + 34401)) /* tcd.c:2198:1 */

// *
// Deallocates the encoding data of the given precinct.
func opj_tcd_code_block_dec_deallocate(tls *libc.TLS, p_precinct uintptr) { /* tcd.c:2290:13: */
	var cblkno TOPJ_UINT32
	var l_nb_code_blocks TOPJ_UINT32

	var l_code_block uintptr = *(*uintptr)(unsafe.Pointer(p_precinct + 24))
	if l_code_block != 0 {
		//fprintf(stderr,"deallocate codeblock:{\n");
		//fprintf(stderr,"\t x0=%d, y0=%d, x1=%d, y1=%d\n",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);
		//fprintf(stderr,"\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\n ",
		//                         l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );

		l_nb_code_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(p_precinct)).Fblock_size / TOPJ_UINT32(unsafe.Sizeof(Topj_tcd_cblk_dec_t{}))
		//fprintf(stderr,"nb_code_blocks =%d\t}\n", l_nb_code_blocks);

		for cblkno = TOPJ_UINT32(0); cblkno < l_nb_code_blocks; cblkno++ {

			if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fsegs != 0 {
				Xopj_free(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fsegs)
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fsegs = uintptr(00)
			}

			if (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fchunks != 0 {
				Xopj_free(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fchunks)
				(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fchunks = uintptr(00)
			}

			Xopj_aligned_free(tls, (*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fdecoded_data)
			(*Topj_tcd_cblk_dec_t)(unsafe.Pointer(l_code_block)).Fdecoded_data = uintptr(0)

			l_code_block += 80
		}

		Xopj_free(tls, *(*uintptr)(unsafe.Pointer(p_precinct + 24)))
		*(*uintptr)(unsafe.Pointer(p_precinct + 24)) = uintptr(00)
	}
}

// *
// Deallocates the encoding data of the given precinct.
func opj_tcd_code_block_enc_deallocate(tls *libc.TLS, p_precinct uintptr) { /* tcd.c:2332:13: */
	var cblkno TOPJ_UINT32
	var l_nb_code_blocks TOPJ_UINT32

	var l_code_block uintptr = *(*uintptr)(unsafe.Pointer(p_precinct + 24))
	if l_code_block != 0 {
		l_nb_code_blocks = (*Topj_tcd_precinct_t)(unsafe.Pointer(p_precinct)).Fblock_size / TOPJ_UINT32(unsafe.Sizeof(Topj_tcd_cblk_enc_t{}))

		for cblkno = TOPJ_UINT32(0); cblkno < l_nb_code_blocks; cblkno++ {
			if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fdata != 0 {
				// We refer to data - 1 since below we incremented it
				// in opj_tcd_code_block_enc_allocate_data()
				Xopj_free(tls, (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fdata-uintptr(1))
				(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fdata = uintptr(00)
			}

			if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Flayers != 0 {
				Xopj_free(tls, (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Flayers)
				(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Flayers = uintptr(00)
			}

			if (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fpasses != 0 {
				Xopj_free(tls, (*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fpasses)
				(*Topj_tcd_cblk_enc_t)(unsafe.Pointer(l_code_block)).Fpasses = uintptr(00)
			}
			l_code_block += 64
		}

		Xopj_free(tls, *(*uintptr)(unsafe.Pointer(p_precinct + 24)))

		*(*uintptr)(unsafe.Pointer(p_precinct + 24)) = uintptr(00)
	}
}

func Xopj_tcd_get_encoder_input_buffer_size(tls *libc.TLS, p_tcd uintptr) TOPJ_SIZE_T { /* tcd.c:2367:12: */
	var i TOPJ_UINT32
	var l_data_size TOPJ_SIZE_T = TOPJ_SIZE_T(0)
	var l_img_comp uintptr = uintptr(00)
	var l_tilec uintptr = uintptr(00)
	var l_size_comp TOPJ_UINT32
	var l_remaining TOPJ_UINT32

	l_tilec = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; i++ {
		l_size_comp = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec >> 3             //(/ 8)
		l_remaining = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec & TOPJ_UINT32(7) // (%8)

		if l_remaining != 0 {
			l_size_comp++
		}

		if l_size_comp == TOPJ_UINT32(3) {
			l_size_comp = TOPJ_UINT32(4)
		}

		l_data_size = l_data_size + TOPJ_SIZE_T(l_size_comp)*(TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx1-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0)*TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy1-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0))
		l_img_comp += 64
		l_tilec += 104
	}

	return l_data_size
}

func opj_tcd_dc_level_shift_encode(tls *libc.TLS, p_tcd uintptr) TOPJ_BOOL { /* tcd.c:2398:17: */
	var compno TOPJ_UINT32
	var l_tile_comp uintptr = uintptr(00)
	var l_tccp uintptr = uintptr(00)
	var l_img_comp uintptr = uintptr(00)
	var l_tile uintptr
	var l_nb_elem TOPJ_SIZE_T
	var i TOPJ_SIZE_T
	var l_current_ptr uintptr

	l_tile = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	l_tile_comp = (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps
	l_tccp = (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Ftccps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps

	for compno = TOPJ_UINT32(0); compno < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps; compno++ {
		l_current_ptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata
		l_nb_elem = TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fx1-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fx0) * TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fy1-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fy0)

		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid == TOPJ_UINT32(1) {
			for i = TOPJ_SIZE_T(0); i < l_nb_elem; i++ {
				*(*TOPJ_INT32)(unsafe.Pointer(l_current_ptr)) -= (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fm_dc_level_shift
				l_current_ptr += 4
			}
		} else {
			for i = TOPJ_SIZE_T(0); i < l_nb_elem; i++ {
				*(*TOPJ_FLOAT32)(unsafe.Pointer(l_current_ptr)) = TOPJ_FLOAT32(*(*TOPJ_INT32)(unsafe.Pointer(l_current_ptr)) - (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fm_dc_level_shift)
				l_current_ptr += 4
			}
		}

		l_img_comp += 64
		l_tccp += 1080
		l_tile_comp += 104
	}

	return DOPJ_TRUE
}

func opj_tcd_mct_encode(tls *libc.TLS, p_tcd uintptr) TOPJ_BOOL { /* tcd.c:2439:17: */
	var l_tile uintptr = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	var l_tile_comp uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps
	var samples TOPJ_SIZE_T = TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fx1-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fx0) * TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fy1-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fy0)
	var i TOPJ_UINT32
	var l_data uintptr = uintptr(00)
	var l_tcp uintptr = (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp

	if !(int32((*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Fmct) != 0) {
		return DOPJ_TRUE
	}

	if (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Fmct == TOPJ_UINT32(2) {
		if !(int32((*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Fm_mct_coding_matrix) != 0) {
			return DOPJ_TRUE
		}

		l_data = Xopj_malloc(tls, uint32((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps)*uint32(unsafe.Sizeof(uintptr(0))))
		if !(l_data != 0) {
			return DOPJ_FALSE
		}

		for i = TOPJ_UINT32(0); i < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps; i++ {
			*(*uintptr)(unsafe.Pointer(l_data + uintptr(i)*8)) = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tile_comp)).Fdata
			l_tile_comp += 104
		}

		if !(Xopj_mct_encode_custom(tls,
			(*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Fm_mct_coding_matrix,

			samples,

			l_data,

			(*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps,

			(*Topj_image_comp_t)(unsafe.Pointer((*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps)).Fsgnd) != 0) {
			Xopj_free(tls, l_data)
			return DOPJ_FALSE
		}

		Xopj_free(tls, l_data)
	} else if (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps)).Fqmfbid == TOPJ_UINT32(0) {
		Xopj_mct_encode_real(tls,
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)).Fdata,
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fdata,
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fdata,
			samples)
	} else {
		Xopj_mct_encode(tls, (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps)).Fdata, (*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+1*104)).Fdata,
			(*Topj_tcd_tilecomp_t)(unsafe.Pointer((*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fcomps+2*104)).Fdata, samples)
	}

	return DOPJ_TRUE
}

func opj_tcd_dwt_encode(tls *libc.TLS, p_tcd uintptr) TOPJ_BOOL { /* tcd.c:2497:17: */
	var l_tile uintptr = (*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles
	var l_tile_comp uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps
	var l_tccp uintptr = (*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Ftccps
	var compno TOPJ_UINT32

	for compno = TOPJ_UINT32(0); compno < (*Topj_tcd_tile_t)(unsafe.Pointer(l_tile)).Fnumcomps; compno++ {
		if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid == TOPJ_UINT32(1) {
			if !(Xopj_dwt_encode(tls, p_tcd, l_tile_comp) != 0) {
				return DOPJ_FALSE
			}
		} else if (*Topj_tccp_t)(unsafe.Pointer(l_tccp)).Fqmfbid == TOPJ_UINT32(0) {
			if !(Xopj_dwt_encode_real(tls, p_tcd, l_tile_comp) != 0) {
				return DOPJ_FALSE
			}
		}

		l_tile_comp += 104
		l_tccp += 1080
	}

	return DOPJ_TRUE
}

func opj_tcd_t1_encode(tls *libc.TLS, p_tcd uintptr) TOPJ_BOOL { /* tcd.c:2522:17: */
	var l_mct_norms uintptr
	var l_mct_numcomps TOPJ_UINT32 = 0
	var l_tcp uintptr = (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp

	if (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fmct == TOPJ_UINT32(1) {
		l_mct_numcomps = 3
		// irreversible encoding
		if (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Ftccps)).Fqmfbid == TOPJ_UINT32(0) {
			l_mct_norms = Xopj_mct_get_mct_norms_real(tls)
		} else {
			l_mct_norms = Xopj_mct_get_mct_norms(tls)
		}
	} else {
		l_mct_numcomps = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps
		l_mct_norms = (*Topj_tcp_t)(unsafe.Pointer(l_tcp)).Fmct_norms
	}

	return Xopj_t1_encode_cblks(tls, p_tcd,
		(*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles, l_tcp, l_mct_norms,
		l_mct_numcomps)

	return DOPJ_TRUE
}

func opj_tcd_t2_encode(tls *libc.TLS, p_tcd uintptr, p_dest_data uintptr, p_data_written uintptr, p_max_dest_size TOPJ_UINT32, p_cstr_info uintptr, p_marker_info uintptr, p_manager uintptr) TOPJ_BOOL { /* tcd.c:2548:17: */
	var l_t2 uintptr

	l_t2 = Xopj_t2_create(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcp)
	if l_t2 == uintptr(00) {
		return DOPJ_FALSE
	}

	if !(Xopj_t2_encode_packets(tls,
		l_t2,
		(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_tileno,
		(*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles,
		(*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcp)).Fnumlayers,
		p_dest_data,
		p_data_written,
		p_max_dest_size,
		p_cstr_info,
		p_marker_info,
		(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftp_num,
		(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftp_pos,
		(*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcur_pino,
		FINAL_PASS,
		p_manager) != 0) {
		Xopj_t2_destroy(tls, l_t2)
		return DOPJ_FALSE
	}

	Xopj_t2_destroy(tls, l_t2)

	//---------------CLEAN-------------------
	return DOPJ_TRUE
}

func opj_tcd_rate_allocate_encode(tls *libc.TLS, p_tcd uintptr, p_dest_data uintptr, p_max_dest_size TOPJ_UINT32, p_cstr_info uintptr, p_manager uintptr) TOPJ_BOOL { /* tcd.c:2589:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var l_cp uintptr = (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fcp
	*(*TOPJ_UINT32)(unsafe.Pointer(bp /* l_nb_written */)) = TOPJ_UINT32(0)

	if p_cstr_info != 0 {
		(*Topj_codestream_info_t)(unsafe.Pointer(p_cstr_info)).Findex_write = 0
	}

	if TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(l_cp + 120 + 20))&0x1>>0)) != 0 || TOPJ_BITFIELD(int32(*(*uint8)(unsafe.Pointer(l_cp + 120 + 20))&0x4>>2)) != 0 {
		// fixed_quality
		// Normal Rate/distortion allocation
		if !(Xopj_tcd_rateallocate(tls, p_tcd, p_dest_data, bp, p_max_dest_size,
			p_cstr_info, p_manager) != 0) {
			return DOPJ_FALSE
		}
	} else {
		// Fixed layer allocation
		Xopj_tcd_rateallocate_fixed(tls, p_tcd)
	}

	return DOPJ_TRUE
}

func Xopj_tcd_copy_tile_data(tls *libc.TLS, p_tcd uintptr, p_src uintptr, p_src_length TOPJ_SIZE_T) TOPJ_BOOL { /* tcd.c:2619:10: */
	var i TOPJ_UINT32
	var j TOPJ_SIZE_T
	var l_data_size TOPJ_SIZE_T = TOPJ_SIZE_T(0)
	var l_img_comp uintptr = uintptr(00)
	var l_tilec uintptr = uintptr(00)
	var l_size_comp TOPJ_UINT32
	var l_remaining TOPJ_UINT32
	var l_nb_elem TOPJ_SIZE_T

	l_data_size = Xopj_tcd_get_encoder_input_buffer_size(tls, p_tcd)
	if l_data_size != p_src_length {
		return DOPJ_FALSE
	}

	l_tilec = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps
	l_img_comp = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps
	for i = TOPJ_UINT32(0); i < (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fnumcomps; i++ {
		l_size_comp = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec >> 3             //(/ 8)
		l_remaining = (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fprec & TOPJ_UINT32(7) // (%8)
		l_nb_elem = TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx1-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fx0) * TOPJ_SIZE_T((*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy1-(*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fy0)

		if l_remaining != 0 {
			l_size_comp++
		}

		if l_size_comp == TOPJ_UINT32(3) {
			l_size_comp = TOPJ_UINT32(4)
		}

		switch l_size_comp {
		case TOPJ_UINT32(1):
			{
				var l_src_ptr uintptr = p_src
				var l_dest_ptr uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata

				if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd != 0 {
					for j = TOPJ_SIZE_T(0); j < l_nb_elem; j++ {
						*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 4))) = TOPJ_INT32(*(*TOPJ_CHAR)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 1))))
					}
				} else {
					for j = TOPJ_SIZE_T(0); j < l_nb_elem; j++ {
						*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 4))) = int32(*(*TOPJ_CHAR)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 1)))) & 0xff
					}
				}

				p_src = l_src_ptr

			}
			break
		case TOPJ_UINT32(2):
			{
				var l_dest_ptr uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata
				var l_src_ptr uintptr = p_src

				if (*Topj_image_comp_t)(unsafe.Pointer(l_img_comp)).Fsgnd != 0 {
					for j = TOPJ_SIZE_T(0); j < l_nb_elem; j++ {
						*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 4))) = TOPJ_INT32(*(*TOPJ_INT16)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 2))))
					}
				} else {
					for j = TOPJ_SIZE_T(0); j < l_nb_elem; j++ {
						*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 4))) = int32(*(*TOPJ_INT16)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 2)))) & 0xffff
					}
				}

				p_src = l_src_ptr

			}
			break
		case TOPJ_UINT32(4):
			{
				var l_src_ptr uintptr = p_src
				var l_dest_ptr uintptr = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(l_tilec)).Fdata

				for j = TOPJ_SIZE_T(0); j < l_nb_elem; j++ {
					*(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_dest_ptr, 4))) = *(*TOPJ_INT32)(unsafe.Pointer(libc.PostIncUintptr(&l_src_ptr, 4)))
				}

				p_src = l_src_ptr

			}
			break
		}

		l_img_comp += 64
		l_tilec += 104
	}

	return DOPJ_TRUE
}

func Xopj_tcd_is_band_empty(tls *libc.TLS, band uintptr) TOPJ_BOOL { /* tcd.c:2707:10: */
	return libc.Bool32((*Topj_tcd_band_t)(unsafe.Pointer(band)).Fx1-(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fx0 == 0 || (*Topj_tcd_band_t)(unsafe.Pointer(band)).Fy1-(*Topj_tcd_band_t)(unsafe.Pointer(band)).Fy0 == 0)
}

func Xopj_tcd_is_subband_area_of_interest(tls *libc.TLS, tcd uintptr, compno TOPJ_UINT32, resno TOPJ_UINT32, bandno TOPJ_UINT32, band_x0 TOPJ_UINT32, band_y0 TOPJ_UINT32, band_x1 TOPJ_UINT32, band_y1 TOPJ_UINT32) TOPJ_BOOL { /* tcd.c:2712:10: */
	// Note: those values for filter_margin are in part the result of
	// experimentation. The value 2 for QMFBID=1 (5x3 filter) can be linked
	// to the maximum left/right extension given in tables F.2 and F.3 of the
	// standard. The value 3 for QMFBID=0 (9x7 filter) is more suspicious,
	// since F.2 and F.3 would lead to 4 instead, so the current 3 might be
	// needed to be bumped to 4, in case inconsistencies are found while
	// decoding parts of irreversible coded images.
	// See opj_dwt_decode_partial_53 and opj_dwt_decode_partial_97 as well
	var filter_margin TOPJ_UINT32
	if (*Topj_tccp_t)(unsafe.Pointer((*Topj_tcp_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcp)).Ftccps+uintptr(compno)*1080)).Fqmfbid == TOPJ_UINT32(1) {
		filter_margin = uint32(2)
	} else {
		filter_margin = uint32(3)
	}
	var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(compno)*104
	var image_comp uintptr = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(tcd)).Fimage)).Fcomps + uintptr(compno)*64
	// Compute the intersection of the area of interest, expressed in tile coordinates
	// with the tile coordinates
	var tcx0 TOPJ_UINT32 = opj_uint_max(tls,
		TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx0),
		opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fwin_x0, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdx))
	var tcy0 TOPJ_UINT32 = opj_uint_max(tls,
		TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy0),
		opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fwin_y0, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdy))
	var tcx1 TOPJ_UINT32 = opj_uint_min(tls,
		TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx1),
		opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fwin_x1, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdx))
	var tcy1 TOPJ_UINT32 = opj_uint_min(tls,
		TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy1),
		opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(tcd)).Fwin_y1, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdy))
	// Compute number of decomposition for this band. See table F-1
	var nb TOPJ_UINT32
	if resno == TOPJ_UINT32(0) {
		nb = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions - TOPJ_UINT32(1)
	} else {
		nb = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions - resno
	}
	// Map above tile-based coordinates to sub-band-based coordinates per
	// equation B-15 of the standard
	var x0b TOPJ_UINT32 = bandno & TOPJ_UINT32(1)
	var y0b TOPJ_UINT32 = bandno >> 1
	var tbx0 TOPJ_UINT32
	if nb == TOPJ_UINT32(0) {
		tbx0 = tcx0
	} else {
		if tcx0 <= uint32(1)<<(nb-TOPJ_UINT32(1))*x0b {
			tbx0 = uint32(0)
		} else {
			tbx0 = opj_uint_ceildivpow2(tls, tcx0-uint32(1)<<(nb-TOPJ_UINT32(1))*x0b, nb)
		}
	}
	var tby0 TOPJ_UINT32
	if nb == TOPJ_UINT32(0) {
		tby0 = tcy0
	} else {
		if tcy0 <= uint32(1)<<(nb-TOPJ_UINT32(1))*y0b {
			tby0 = uint32(0)
		} else {
			tby0 = opj_uint_ceildivpow2(tls, tcy0-uint32(1)<<(nb-TOPJ_UINT32(1))*y0b, nb)
		}
	}
	var tbx1 TOPJ_UINT32
	if nb == TOPJ_UINT32(0) {
		tbx1 = tcx1
	} else {
		if tcx1 <= uint32(1)<<(nb-TOPJ_UINT32(1))*x0b {
			tbx1 = uint32(0)
		} else {
			tbx1 = opj_uint_ceildivpow2(tls, tcx1-uint32(1)<<(nb-TOPJ_UINT32(1))*x0b, nb)
		}
	}
	var tby1 TOPJ_UINT32
	if nb == TOPJ_UINT32(0) {
		tby1 = tcy1
	} else {
		if tcy1 <= uint32(1)<<(nb-TOPJ_UINT32(1))*y0b {
			tby1 = uint32(0)
		} else {
			tby1 = opj_uint_ceildivpow2(tls, tcy1-uint32(1)<<(nb-TOPJ_UINT32(1))*y0b, nb)
		}
	}
	var intersects TOPJ_BOOL

	if tbx0 < filter_margin {
		tbx0 = TOPJ_UINT32(0)
	} else {
		tbx0 = tbx0 - filter_margin
	}
	if tby0 < filter_margin {
		tby0 = TOPJ_UINT32(0)
	} else {
		tby0 = tby0 - filter_margin
	}
	tbx1 = opj_uint_adds(tls, tbx1, filter_margin)
	tby1 = opj_uint_adds(tls, tby1, filter_margin)

	intersects = libc.Bool32(band_x0 < tbx1 && band_y0 < tby1 && band_x1 > tbx0 && band_y1 > tby0)

	return intersects
}

// * Returns whether a tile componenent is fully decoded, taking into account
// p_tcd->win_* members.
//
// @param p_tcd    TCD handle.
// @param compno Component number
// @return OPJ_TRUE whether the tile componenent is fully decoded
func opj_tcd_is_whole_tilecomp_decoding(tls *libc.TLS, p_tcd uintptr, compno TOPJ_UINT32) TOPJ_BOOL { /* tcd.c:2800:17: */
	var tilec uintptr = (*Topj_tcd_tile_t)(unsafe.Pointer((*Topj_tcd_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Ftcd_image)).Ftiles)).Fcomps + uintptr(compno)*104
	var image_comp uintptr = (*Topj_image_t)(unsafe.Pointer((*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fimage)).Fcomps + uintptr(compno)*64
	// Compute the intersection of the area of interest, expressed in tile coordinates
	// with the tile coordinates
	var tcx0 TOPJ_UINT32 = opj_uint_max(tls,
		TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx0),
		opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_x0, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdx))
	var tcy0 TOPJ_UINT32 = opj_uint_max(tls,
		TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy0),
		opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_y0, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdy))
	var tcx1 TOPJ_UINT32 = opj_uint_min(tls,
		TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx1),
		opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_x1, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdx))
	var tcy1 TOPJ_UINT32 = opj_uint_min(tls,
		TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy1),
		opj_uint_ceildiv(tls, (*Topj_tcd_t)(unsafe.Pointer(p_tcd)).Fwin_y1, (*Topj_image_comp_t)(unsafe.Pointer(image_comp)).Fdy))

	var shift TOPJ_UINT32 = (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fnumresolutions - (*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fminimum_num_resolutions
	// Tolerate small margin within the reduced resolution factor to consider if
	// the whole tile path must be taken
	return libc.Bool32(tcx0 >= TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx0) && tcy0 >= TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy0) && tcx1 <= TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx1) && tcy1 <= TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy1) && (shift >= TOPJ_UINT32(32) || (tcx0-TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx0))>>shift == TOPJ_UINT32(0) && (tcy0-TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy0))>>shift == TOPJ_UINT32(0) && (TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fx1)-tcx1)>>shift == TOPJ_UINT32(0) && (TOPJ_UINT32((*Topj_tcd_tilecomp_t)(unsafe.Pointer(tilec)).Fy1)-tcy1)>>shift == TOPJ_UINT32(0)))
}

// -----------------------------------------------------------------------

func Xopj_tcd_marker_info_create(tls *libc.TLS, need_PLT TOPJ_BOOL) uintptr { /* tcd.c:2836:22: */
	var l_tcd_marker_info uintptr = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_tcd_marker_info_t{})))
	if !(l_tcd_marker_info != 0) {
		return uintptr(0)
	}

	(*Topj_tcd_marker_info_t)(unsafe.Pointer(l_tcd_marker_info)).Fneed_PLT = need_PLT

	return l_tcd_marker_info
}

// -----------------------------------------------------------------------

func Xopj_tcd_marker_info_destroy(tls *libc.TLS, p_tcd_marker_info uintptr) { /* tcd.c:2851:6: */
	if p_tcd_marker_info != 0 {
		Xopj_free(tls, (*Topj_tcd_marker_info_t)(unsafe.Pointer(p_tcd_marker_info)).Fp_packet_size)
		Xopj_free(tls, p_tcd_marker_info)
	}
}

// -----------------------------------------------------------------------

//
// ==========================================================
//    Tag-tree coder interface
// ==========================================================

func Xopj_tgt_create(tls *libc.TLS, numleafsh TOPJ_UINT32, numleafsv TOPJ_UINT32, p_manager uintptr) uintptr { /* tgt.c:48:16: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	// var nplh [32]TOPJ_INT32 at bp, 128

	// var nplv [32]TOPJ_INT32 at bp+128, 128

	var node uintptr = uintptr(00)
	var l_parent_node uintptr = uintptr(00)
	var l_parent_node0 uintptr = uintptr(00)
	var tree uintptr = uintptr(00)
	var i TOPJ_UINT32
	var j TOPJ_INT32
	var k TOPJ_INT32
	var numlvls TOPJ_UINT32
	var n TOPJ_UINT32

	tree = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_tgt_tree_t{})))
	if !(tree != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR, ts+34431, 0)
		return uintptr(00)
	}

	(*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnumleafsh = numleafsh
	(*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnumleafsv = numleafsv

	numlvls = TOPJ_UINT32(0)
	*(*TOPJ_INT32)(unsafe.Pointer(bp)) = TOPJ_INT32(numleafsh)
	*(*TOPJ_INT32)(unsafe.Pointer(bp + 128)) = TOPJ_INT32(numleafsv)
	(*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnumnodes = TOPJ_UINT32(0)
	for __ccgo := true; __ccgo; __ccgo = n > TOPJ_UINT32(1) {
		n = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(numlvls)*4)) * *(*TOPJ_INT32)(unsafe.Pointer(bp + 128 + uintptr(numlvls)*4)))
		*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(numlvls+TOPJ_UINT32(1))*4)) = (*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(numlvls)*4)) + 1) / 2
		*(*TOPJ_INT32)(unsafe.Pointer(bp + 128 + uintptr(numlvls+TOPJ_UINT32(1))*4)) = (*(*TOPJ_INT32)(unsafe.Pointer(bp + 128 + uintptr(numlvls)*4)) + 1) / 2
		*(*TOPJ_UINT32)(unsafe.Pointer(tree + 8)) += n
		numlvls++
	}

	// ADD
	if (*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnumnodes == TOPJ_UINT32(0) {
		Xopj_free(tls, tree)
		return uintptr(00)
	}

	(*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnodes = Xopj_calloc(tls, uint32((*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnumnodes),
		uint32(unsafe.Sizeof(Topj_tgt_node_t{})))
	if !(int32((*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnodes) != 0) {
		Xopj_event_msg(tls, p_manager, DEVT_ERROR,
			ts+34469, 0)
		Xopj_free(tls, tree)
		return uintptr(00)
	}
	(*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnodes_size = (*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnumnodes * TOPJ_UINT32(unsafe.Sizeof(Topj_tgt_node_t{}))

	node = (*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnodes
	l_parent_node = (*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnodes + uintptr((*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnumleafsh*(*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnumleafsv)*24
	l_parent_node0 = l_parent_node

	for i = TOPJ_UINT32(0); i < numlvls-TOPJ_UINT32(1); i++ {
		for j = 0; j < *(*TOPJ_INT32)(unsafe.Pointer(bp + 128 /* &nplv[0] */ + uintptr(i)*4)); j++ {
			k = *(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(i)*4))
			for libc.PreDecInt32(&k, 1) >= 0 {
				(*Topj_tgt_node_t)(unsafe.Pointer(node)).Fparent = l_parent_node
				node += 24
				if libc.PreDecInt32(&k, 1) >= 0 {
					(*Topj_tgt_node_t)(unsafe.Pointer(node)).Fparent = l_parent_node
					node += 24
				}
				l_parent_node += 24
			}
			if j&1 != 0 || j == *(*TOPJ_INT32)(unsafe.Pointer(bp + 128 + uintptr(i)*4))-1 {
				l_parent_node0 = l_parent_node
			} else {
				l_parent_node = l_parent_node0
				l_parent_node0 += 24 * uintptr(*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(i)*4)))
			}
		}
	}
	(*Topj_tgt_node_t)(unsafe.Pointer(node)).Fparent = uintptr(0)
	Xopj_tgt_reset(tls, tree)
	return tree
}

// *
// Reinitialises a tag-tree from an existing one.
//
// @param       p_tree                          the tree to reinitialize.
// @param       p_num_leafs_h           the width of the array of leafs of the tree
// @param       p_num_leafs_v           the height of the array of leafs of the tree
// @return      a new tag-tree if successful, NULL otherwise
func Xopj_tgt_init(tls *libc.TLS, p_tree uintptr, p_num_leafs_h TOPJ_UINT32, p_num_leafs_v TOPJ_UINT32, p_manager uintptr) uintptr { /* tgt.c:136:16: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	// var l_nplh [32]TOPJ_INT32 at bp, 128

	// var l_nplv [32]TOPJ_INT32 at bp+128, 128

	var l_node uintptr = uintptr(00)
	var l_parent_node uintptr = uintptr(00)
	var l_parent_node0 uintptr = uintptr(00)
	var i TOPJ_UINT32
	var j TOPJ_INT32
	var k TOPJ_INT32
	var l_num_levels TOPJ_UINT32
	var n TOPJ_UINT32
	var l_node_size TOPJ_UINT32

	if !(p_tree != 0) {
		return uintptr(00)
	}

	if (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumleafsh != p_num_leafs_h || (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumleafsv != p_num_leafs_v {
		(*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumleafsh = p_num_leafs_h
		(*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumleafsv = p_num_leafs_v

		l_num_levels = TOPJ_UINT32(0)
		*(*TOPJ_INT32)(unsafe.Pointer(bp)) = TOPJ_INT32(p_num_leafs_h)
		*(*TOPJ_INT32)(unsafe.Pointer(bp + 128)) = TOPJ_INT32(p_num_leafs_v)
		(*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumnodes = TOPJ_UINT32(0)
		for __ccgo := true; __ccgo; __ccgo = n > TOPJ_UINT32(1) {
			n = TOPJ_UINT32(*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(l_num_levels)*4)) * *(*TOPJ_INT32)(unsafe.Pointer(bp + 128 + uintptr(l_num_levels)*4)))
			*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(l_num_levels+TOPJ_UINT32(1))*4)) = (*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(l_num_levels)*4)) + 1) / 2
			*(*TOPJ_INT32)(unsafe.Pointer(bp + 128 + uintptr(l_num_levels+TOPJ_UINT32(1))*4)) = (*(*TOPJ_INT32)(unsafe.Pointer(bp + 128 + uintptr(l_num_levels)*4)) + 1) / 2
			*(*TOPJ_UINT32)(unsafe.Pointer(p_tree + 8)) += n
			l_num_levels++
		}

		// ADD
		if (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumnodes == TOPJ_UINT32(0) {
			Xopj_tgt_destroy(tls, p_tree)
			return uintptr(00)
		}
		l_node_size = (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumnodes * TOPJ_UINT32(unsafe.Sizeof(Topj_tgt_node_t{}))

		if l_node_size > (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes_size {
			var new_nodes uintptr = Xopj_realloc(tls, (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes,
				uint32(l_node_size))
			if !(new_nodes != 0) {
				Xopj_event_msg(tls, p_manager, DEVT_ERROR,
					ts+34513, 0)
				Xopj_tgt_destroy(tls, p_tree)
				return uintptr(00)
			}
			(*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes = new_nodes
			libc.Xmemset(tls, (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes+uintptr((*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes_size), 0,
				uint32(l_node_size-(*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes_size))
			(*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes_size = l_node_size
		}
		l_node = (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes
		l_parent_node = (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes + uintptr((*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumleafsh*(*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumleafsv)*24
		l_parent_node0 = l_parent_node

		for i = TOPJ_UINT32(0); i < l_num_levels-TOPJ_UINT32(1); i++ {
			for j = 0; j < *(*TOPJ_INT32)(unsafe.Pointer(bp + 128 /* &l_nplv[0] */ + uintptr(i)*4)); j++ {
				k = *(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(i)*4))
				for libc.PreDecInt32(&k, 1) >= 0 {
					(*Topj_tgt_node_t)(unsafe.Pointer(l_node)).Fparent = l_parent_node
					l_node += 24
					if libc.PreDecInt32(&k, 1) >= 0 {
						(*Topj_tgt_node_t)(unsafe.Pointer(l_node)).Fparent = l_parent_node
						l_node += 24
					}
					l_parent_node += 24
				}
				if j&1 != 0 || j == *(*TOPJ_INT32)(unsafe.Pointer(bp + 128 + uintptr(i)*4))-1 {
					l_parent_node0 = l_parent_node
				} else {
					l_parent_node = l_parent_node0
					l_parent_node0 += 24 * uintptr(*(*TOPJ_INT32)(unsafe.Pointer(bp + uintptr(i)*4)))
				}
			}
		}
		(*Topj_tgt_node_t)(unsafe.Pointer(l_node)).Fparent = uintptr(0)
	}
	Xopj_tgt_reset(tls, p_tree)

	return p_tree
}

func Xopj_tgt_destroy(tls *libc.TLS, p_tree uintptr) { /* tgt.c:223:6: */
	if !(p_tree != 0) {
		return
	}

	if (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes != 0 {
		Xopj_free(tls, (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes)
		(*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes = uintptr(00)
	}
	Xopj_free(tls, p_tree)
}

func Xopj_tgt_reset(tls *libc.TLS, p_tree uintptr) { /* tgt.c:236:6: */
	var i TOPJ_UINT32
	var l_current_node uintptr = uintptr(00)

	if !(p_tree != 0) {
		return
	}

	l_current_node = (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnodes
	for i = TOPJ_UINT32(0); i < (*Topj_tgt_tree_t)(unsafe.Pointer(p_tree)).Fnumnodes; i++ {
		(*Topj_tgt_node_t)(unsafe.Pointer(l_current_node)).Fvalue = 999
		(*Topj_tgt_node_t)(unsafe.Pointer(l_current_node)).Flow = 0
		(*Topj_tgt_node_t)(unsafe.Pointer(l_current_node)).Fknown = TOPJ_UINT32(0)
		l_current_node += 24
	}
}

func Xopj_tgt_setvalue(tls *libc.TLS, tree uintptr, leafno TOPJ_UINT32, value TOPJ_INT32) { /* tgt.c:254:6: */
	var node uintptr
	node = (*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnodes + uintptr(leafno)*24
	for node != 0 && (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fvalue > value {
		(*Topj_tgt_node_t)(unsafe.Pointer(node)).Fvalue = value
		node = (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fparent
	}
}

func Xopj_tgt_encode(tls *libc.TLS, bio uintptr, tree uintptr, leafno TOPJ_UINT32, threshold TOPJ_INT32) { /* tgt.c:264:6: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	// var stk [31]uintptr at bp, 248

	var stkptr uintptr
	var node uintptr
	var low TOPJ_INT32

	stkptr = bp /* &stk[0] */
	node = (*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnodes + uintptr(leafno)*24
	for (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fparent != 0 {
		*(*uintptr)(unsafe.Pointer(libc.PostIncUintptr(&stkptr, 8))) = node
		node = (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fparent
	}

	low = 0
	for {
		if low > (*Topj_tgt_node_t)(unsafe.Pointer(node)).Flow {
			(*Topj_tgt_node_t)(unsafe.Pointer(node)).Flow = low
		} else {
			low = (*Topj_tgt_node_t)(unsafe.Pointer(node)).Flow
		}

		for low < threshold {
			if low >= (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fvalue {
				if !(int32((*Topj_tgt_node_t)(unsafe.Pointer(node)).Fknown) != 0) {
					Xopj_bio_write(tls, bio, uint32(1), uint32(1))
					(*Topj_tgt_node_t)(unsafe.Pointer(node)).Fknown = TOPJ_UINT32(1)
				}
				break
			}
			Xopj_bio_write(tls, bio, uint32(0), uint32(1))
			low++
		}

		(*Topj_tgt_node_t)(unsafe.Pointer(node)).Flow = low
		if stkptr == bp {
			break
		}
		node = *(*uintptr)(unsafe.Pointer(libc.PreDecUintptr(&stkptr, 8)))
	}
}

func Xopj_tgt_decode(tls *libc.TLS, bio uintptr, tree uintptr, leafno TOPJ_UINT32, threshold TOPJ_INT32) TOPJ_UINT32 { /* tgt.c:307:12: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	// var stk [31]uintptr at bp, 248

	var stkptr uintptr
	var node uintptr
	var low TOPJ_INT32

	stkptr = bp /* &stk[0] */
	node = (*Topj_tgt_tree_t)(unsafe.Pointer(tree)).Fnodes + uintptr(leafno)*24
	for (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fparent != 0 {
		*(*uintptr)(unsafe.Pointer(libc.PostIncUintptr(&stkptr, 8))) = node
		node = (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fparent
	}

	low = 0
	for {
		if low > (*Topj_tgt_node_t)(unsafe.Pointer(node)).Flow {
			(*Topj_tgt_node_t)(unsafe.Pointer(node)).Flow = low
		} else {
			low = (*Topj_tgt_node_t)(unsafe.Pointer(node)).Flow
		}
		for low < threshold && low < (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fvalue {
			if Xopj_bio_read(tls, bio, uint32(1)) != 0 {
				(*Topj_tgt_node_t)(unsafe.Pointer(node)).Fvalue = low
			} else {
				low++
			}
		}
		(*Topj_tgt_node_t)(unsafe.Pointer(node)).Flow = low
		if stkptr == bp {
			break
		}
		node = *(*uintptr)(unsafe.Pointer(libc.PreDecUintptr(&stkptr, 8)))
	}

	if (*Topj_tgt_node_t)(unsafe.Pointer(node)).Fvalue < threshold {
		return uint32(1)
	}
	return uint32(0)
}

//@}

//* @name Thread local storage
//@{
//* Opaque type for a thread local storage
type Topj_tls_t = Sopj_tls_t /* thread.h:167:26 */

//@}

//* @name Thread pool
//@{

//* Opaque type for a thread pool
type Topj_thread_pool_t = Sopj_thread_pool_t /* thread.h:195:34 */

func Xopj_has_thread_support(tls *libc.TLS) TOPJ_BOOL { /* thread.c:433:23: */
	return DOPJ_FALSE
}

func Xopj_get_num_cpus(tls *libc.TLS) int32 { /* thread.c:438:18: */
	return 1
}

func Xopj_mutex_create(tls *libc.TLS) uintptr { /* thread.c:443:12: */
	return uintptr(0)
}

func Xopj_mutex_lock(tls *libc.TLS, mutex uintptr) { /* thread.c:448:6: */
	_ = mutex
}

func Xopj_mutex_unlock(tls *libc.TLS, mutex uintptr) { /* thread.c:453:6: */
	_ = mutex
}

func Xopj_mutex_destroy(tls *libc.TLS, mutex uintptr) { /* thread.c:458:6: */
	_ = mutex
}

func Xopj_cond_create(tls *libc.TLS) uintptr { /* thread.c:463:11: */
	return uintptr(0)
}

func Xopj_cond_wait(tls *libc.TLS, cond uintptr, mutex uintptr) { /* thread.c:468:6: */
	_ = cond
	_ = mutex
}

func Xopj_cond_signal(tls *libc.TLS, cond uintptr) { /* thread.c:474:6: */
	_ = cond
}

func Xopj_cond_destroy(tls *libc.TLS, cond uintptr) { /* thread.c:479:6: */
	_ = cond
}

func Xopj_thread_create(tls *libc.TLS, thread_fn Topj_thread_fn, user_data uintptr) uintptr { /* thread.c:484:13: */
	_ = thread_fn
	_ = user_data
	return uintptr(0)
}

func Xopj_thread_join(tls *libc.TLS, thread uintptr) { /* thread.c:491:6: */
	_ = thread
}

type Topj_tls_key_val_t = struct {
	Fkey           int32
	F__ccgo_pad1   [4]byte
	Fvalue         uintptr
	Fopj_free_func Topj_tls_free_func
} /* thread.c:502:3 */

func opj_tls_new(tls *libc.TLS) uintptr { /* thread.c:509:17: */
	return Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_tls_t{})))
}

func opj_tls_destroy(tls *libc.TLS, tls1 uintptr) { /* thread.c:514:13: */
	var i int32
	if !(tls1 != 0) {
		return
	}
	for i = 0; i < (*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count; i++ {
		if (*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val+uintptr(i)*24)).Fopj_free_func != 0 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val + uintptr(i)*24)).Fopj_free_func})).f(tls, (*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val+uintptr(i)*24)).Fvalue)
		}
	}
	Xopj_free(tls, (*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val)
	Xopj_free(tls, tls1)
}

func Xopj_tls_get(tls *libc.TLS, tls1 uintptr, key int32) uintptr { /* thread.c:529:5: */
	var i int32
	for i = 0; i < (*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count; i++ {
		if (*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val+uintptr(i)*24)).Fkey == key {
			return (*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val + uintptr(i)*24)).Fvalue
		}
	}
	return uintptr(0)
}

func Xopj_tls_set(tls *libc.TLS, tls1 uintptr, key int32, value uintptr, opj_free_func Topj_tls_free_func) TOPJ_BOOL { /* thread.c:540:10: */
	var new_key_val uintptr
	var i int32

	if (*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count == 0x7fffffff {
		return DOPJ_FALSE
	}
	for i = 0; i < (*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count; i++ {
		if (*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val+uintptr(i)*24)).Fkey == key {
			if (*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val+uintptr(i)*24)).Fopj_free_func != 0 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val + uintptr(i)*24)).Fopj_free_func})).f(tls, (*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val+uintptr(i)*24)).Fvalue)
			}
			(*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val + uintptr(i)*24)).Fvalue = value
			(*Topj_tls_key_val_t)(unsafe.Pointer((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val + uintptr(i)*24)).Fopj_free_func = opj_free_func
			return DOPJ_TRUE
		}
	}
	new_key_val = Xopj_realloc(tls, (*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val,
		(Tsize_t((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count)+1)*Tsize_t(unsafe.Sizeof(Topj_tls_key_val_t{})))
	if !(new_key_val != 0) {
		return DOPJ_FALSE
	}
	(*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val = new_key_val
	(*Topj_tls_key_val_t)(unsafe.Pointer(new_key_val + uintptr((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count)*24)).Fkey = key
	(*Topj_tls_key_val_t)(unsafe.Pointer(new_key_val + uintptr((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count)*24)).Fvalue = value
	(*Topj_tls_key_val_t)(unsafe.Pointer(new_key_val + uintptr((*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count)*24)).Fopj_free_func = opj_free_func
	(*Topj_tls_t)(unsafe.Pointer(tls1)).Fkey_val_count++
	return DOPJ_TRUE
}

type Topj_worker_thread_job_t = struct {
	Fjob_fn    Topj_job_fn
	Fuser_data uintptr
} /* thread.c:576:3 */

type Topj_worker_thread_t = struct {
	Ftp                uintptr
	Fthread            uintptr
	Fmarked_as_waiting int32
	F__ccgo_pad1       [4]byte
	Fmutex             uintptr
	Fcond              uintptr
} /* thread.c:585:3 */

type Topj_worker_thread_state = uint32 /* thread.c:591:3 */

type Sopj_job_list_t = struct {
	Fjob  uintptr
	Fnext uintptr
} /* thread.h:195:9 */

type Topj_job_list_t = Sopj_job_list_t /* thread.c:597:31 */

type Sopj_worker_thread_list_t = struct {
	Fworker_thread uintptr
	Fnext          uintptr
} /* thread.h:195:9 */

type Topj_worker_thread_list_t = Sopj_worker_thread_list_t /* thread.c:603:41 */

func Xopj_thread_pool_create(tls *libc.TLS, num_threads int32) uintptr { /* thread.c:625:18: */
	var tp uintptr

	tp = Xopj_calloc(tls, uint32(1), uint32(unsafe.Sizeof(Topj_thread_pool_t{})))
	if !(tp != 0) {
		return uintptr(0)
	}
	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fstate = OPJWTS_OK

	if num_threads <= 0 {
		(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Ftls = opj_tls_new(tls)
		if !(int32((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Ftls) != 0) {
			Xopj_free(tls, tp)
			tp = uintptr(0)
		}
		return tp
	}

	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex = Xopj_mutex_create(tls)
	if !(int32((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex) != 0) {
		Xopj_free(tls, tp)
		return uintptr(0)
	}
	if !(opj_thread_pool_setup(tls, tp, num_threads) != 0) {
		Xopj_thread_pool_destroy(tls, tp)
		return uintptr(0)
	}
	return tp
}

func opj_worker_thread_function(tls *libc.TLS, user_data uintptr) { /* thread.c:656:13: */
	var worker_thread uintptr
	var tp uintptr
	var tls1 uintptr
	var job_finished TOPJ_BOOL = DOPJ_FALSE

	worker_thread = user_data
	tp = (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Ftp
	tls1 = opj_tls_new(tls)

	for 1 != 0 {
		var job uintptr = opj_thread_pool_get_next_job(tls, tp, worker_thread,
			job_finished)
		if job == uintptr(0) {
			break
		}

		if (*Topj_worker_thread_job_t)(unsafe.Pointer(job)).Fjob_fn != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Topj_worker_thread_job_t)(unsafe.Pointer(job)).Fjob_fn})).f(tls, (*Topj_worker_thread_job_t)(unsafe.Pointer(job)).Fuser_data, tls1)
		}
		Xopj_free(tls, job)
		job_finished = DOPJ_TRUE
	}

	opj_tls_destroy(tls, tls1)
}

func opj_thread_pool_setup(tls *libc.TLS, tp uintptr, num_threads int32) TOPJ_BOOL { /* thread.c:684:17: */
	var i int32
	var bRet TOPJ_BOOL = DOPJ_TRUE

	if num_threads > 0 {
	} else {
		libc.X__assert_fail(tls, ts+34561, ts+34577, uint32(689), uintptr(unsafe.Pointer(&__func__283)))
	}

	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond = Xopj_cond_create(tls)
	if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond == uintptr(0) {
		return DOPJ_FALSE
	}

	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads = Xopj_calloc(tls, Tsize_t(num_threads),
		uint32(unsafe.Sizeof(Topj_worker_thread_t{})))
	if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads == uintptr(0) {
		return DOPJ_FALSE
	}
	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count = num_threads

	for i = 0; i < num_threads; i++ {
		(*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads + uintptr(i)*40)).Ftp = tp

		(*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads + uintptr(i)*40)).Fmutex = Xopj_mutex_create(tls)
		if (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fmutex == uintptr(0) {
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count = i
			bRet = DOPJ_FALSE
			break
		}

		(*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads + uintptr(i)*40)).Fcond = Xopj_cond_create(tls)
		if (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fcond == uintptr(0) {
			Xopj_mutex_destroy(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fmutex)
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count = i
			bRet = DOPJ_FALSE
			break
		}

		(*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads + uintptr(i)*40)).Fmarked_as_waiting = DOPJ_FALSE

		(*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads + uintptr(i)*40)).Fthread = Xopj_thread_create(tls, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{opj_worker_thread_function})),
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)
		if (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fthread == uintptr(0) {
			Xopj_mutex_destroy(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fmutex)
			Xopj_cond_destroy(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fcond)
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count = i
			bRet = DOPJ_FALSE
			break
		}
	}

	// Wait all threads to be started
	// printf("waiting for all threads to be started\n");
	Xopj_mutex_lock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
	for (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_count < (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count {
		Xopj_cond_wait(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
	}
	Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
	// printf("all threads started\n");

	if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fstate == OPJWTS_ERROR {
		bRet = DOPJ_FALSE
	}

	return bRet
}

var __func__283 = *(*[22]int8)(unsafe.Pointer(ts + 34605)) /* thread.c:685:1 */

//
// void opj_waiting()
// {
//     printf("waiting!\n");
// }

func opj_thread_pool_get_next_job(tls *libc.TLS, tp uintptr, worker_thread uintptr, signal_job_finished TOPJ_BOOL) uintptr { /* thread.c:757:31: */
	for 1 != 0 {
		var top_job_iter uintptr

		Xopj_mutex_lock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)

		if signal_job_finished != 0 {
			signal_job_finished = DOPJ_FALSE
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fpending_jobs_count--
			//printf("tp=%p, remaining jobs: %d\n", tp, tp->pending_jobs_count);
			if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fpending_jobs_count <= (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fsignaling_threshold {
				Xopj_cond_signal(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond)
			}
		}

		if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fstate == OPJWTS_STOP {
			Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
			return uintptr(0)
		}
		top_job_iter = (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fjob_queue
		if top_job_iter != 0 {
			var job uintptr
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fjob_queue = (*Topj_job_list_t)(unsafe.Pointer(top_job_iter)).Fnext

			job = (*Topj_job_list_t)(unsafe.Pointer(top_job_iter)).Fjob
			Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
			Xopj_free(tls, top_job_iter)
			return job
		}

		// opj_waiting();
		if !((*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmarked_as_waiting != 0) {
			var item uintptr

			(*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmarked_as_waiting = DOPJ_TRUE
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_count++
			if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_count <= (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count {
			} else {
				libc.X__assert_fail(tls, ts+34627, ts+34577, uint32(797), uintptr(unsafe.Pointer(&__func__284)))
			}

			item = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_worker_thread_list_t{})))
			if item == uintptr(0) {
				(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fstate = OPJWTS_ERROR
				Xopj_cond_signal(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond)

				Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
				return uintptr(0)
			}

			(*Topj_worker_thread_list_t)(unsafe.Pointer(item)).Fworker_thread = worker_thread
			(*Topj_worker_thread_list_t)(unsafe.Pointer(item)).Fnext = (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list = item
		}

		// printf("signaling that worker thread is ready\n");
		Xopj_cond_signal(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond)

		Xopj_mutex_lock(tls, (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmutex)
		Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)

		// printf("waiting for job\n");
		Xopj_cond_wait(tls, (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fcond, (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmutex)

		Xopj_mutex_unlock(tls, (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmutex)
		// printf("got job\n");
	}
	return uintptr(0)
}

var __func__284 = *(*[29]int8)(unsafe.Pointer(ts + 34687)) /* thread.c:761:1 */

func Xopj_thread_pool_submit_job(tls *libc.TLS, tp uintptr, job_fn Topj_job_fn, user_data uintptr) TOPJ_BOOL { /* thread.c:827:10: */
	var job uintptr
	var item uintptr

	if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex == uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{job_fn})).f(tls, user_data, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Ftls)
		return DOPJ_TRUE
	}

	job = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_worker_thread_job_t{})))
	if job == uintptr(0) {
		return DOPJ_FALSE
	}
	(*Topj_worker_thread_job_t)(unsafe.Pointer(job)).Fjob_fn = job_fn
	(*Topj_worker_thread_job_t)(unsafe.Pointer(job)).Fuser_data = user_data

	item = Xopj_malloc(tls, uint32(unsafe.Sizeof(Topj_job_list_t{})))
	if item == uintptr(0) {
		Xopj_free(tls, job)
		return DOPJ_FALSE
	}
	(*Topj_job_list_t)(unsafe.Pointer(item)).Fjob = job

	Xopj_mutex_lock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)

	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fsignaling_threshold = 100 * (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count
	for (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fpending_jobs_count > (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fsignaling_threshold {
		// printf("%d jobs enqueued. Waiting\n", tp->pending_jobs_count);
		Xopj_cond_wait(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
		// printf("...%d jobs enqueued.\n", tp->pending_jobs_count);
	}

	(*Topj_job_list_t)(unsafe.Pointer(item)).Fnext = (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fjob_queue
	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fjob_queue = item
	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fpending_jobs_count++

	if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list != 0 {
		var worker_thread uintptr
		var next uintptr
		var to_opj_free uintptr

		worker_thread = (*Topj_worker_thread_list_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list)).Fworker_thread

		if (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmarked_as_waiting != 0 {
		} else {
			libc.X__assert_fail(tls, ts+34716, ts+34577, uint32(873), uintptr(unsafe.Pointer(&__func__285)))
		}
		(*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmarked_as_waiting = DOPJ_FALSE

		next = (*Topj_worker_thread_list_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list)).Fnext
		to_opj_free = (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list
		(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list = next
		(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_count--

		Xopj_mutex_lock(tls, (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmutex)
		Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
		Xopj_cond_signal(tls, (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fcond)
		Xopj_mutex_unlock(tls, (*Topj_worker_thread_t)(unsafe.Pointer(worker_thread)).Fmutex)

		Xopj_free(tls, to_opj_free)
	} else {
		Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
	}

	return DOPJ_TRUE
}

var __func__285 = *(*[27]int8)(unsafe.Pointer(ts + 34749)) /* thread.c:830:1 */

func Xopj_thread_pool_wait_completion(tls *libc.TLS, tp uintptr, max_remaining_jobs int32) { /* thread.c:894:6: */
	if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex == uintptr(0) {
		return
	}

	if max_remaining_jobs < 0 {
		max_remaining_jobs = 0
	}
	Xopj_mutex_lock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
	(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fsignaling_threshold = max_remaining_jobs
	for (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fpending_jobs_count > max_remaining_jobs {
		//printf("tp=%p, jobs before wait = %d, max_remaining_jobs = %d\n", tp, tp->pending_jobs_count, max_remaining_jobs);
		Xopj_cond_wait(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
		//printf("tp=%p, jobs after wait = %d\n", tp, tp->pending_jobs_count);
	}
	Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
}

func Xopj_thread_pool_get_thread_count(tls *libc.TLS, tp uintptr) int32 { /* thread.c:914:5: */
	return (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count
}

func Xopj_thread_pool_destroy(tls *libc.TLS, tp uintptr) { /* thread.c:919:6: */
	if !(tp != 0) {
		return
	}
	if (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond != 0 {
		var i int32
		Xopj_thread_pool_wait_completion(tls, tp, 0)

		Xopj_mutex_lock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
		(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fstate = OPJWTS_STOP
		Xopj_mutex_unlock(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)

		for i = 0; i < (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads_count; i++ {
			Xopj_mutex_lock(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fmutex)
			Xopj_cond_signal(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fcond)
			Xopj_mutex_unlock(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fmutex)
			Xopj_thread_join(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fthread)
			Xopj_cond_destroy(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fcond)
			Xopj_mutex_destroy(tls, (*Topj_worker_thread_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads+uintptr(i)*40)).Fmutex)
		}

		Xopj_free(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fworker_threads)

		for (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list != uintptr(0) {
			var next uintptr = (*Topj_worker_thread_list_t)(unsafe.Pointer((*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list)).Fnext
			Xopj_free(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list)
			(*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fwaiting_worker_thread_list = next
		}

		Xopj_cond_destroy(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fcond)
	}
	Xopj_mutex_destroy(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Fmutex)
	opj_tls_destroy(tls, (*Topj_thread_pool_t)(unsafe.Pointer(tp)).Ftls)
	Xopj_free(tls, tp)
}

func init() {
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_read_functions_to_float)) + 0)) = opj_j2k_read_int16_to_float         // j2k.c:1375:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_read_functions_to_float)) + 8)) = opj_j2k_read_int32_to_float         // j2k.c:1376:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_read_functions_to_float)) + 16)) = opj_j2k_read_float32_to_float      // j2k.c:1377:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_read_functions_to_float)) + 24)) = opj_j2k_read_float64_to_float      // j2k.c:1378:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_read_functions_to_int32)) + 0)) = opj_j2k_read_int16_to_int32         // j2k.c:1382:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_read_functions_to_int32)) + 8)) = opj_j2k_read_int32_to_int32         // j2k.c:1383:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_read_functions_to_int32)) + 16)) = opj_j2k_read_float32_to_int32      // j2k.c:1384:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_read_functions_to_int32)) + 24)) = opj_j2k_read_float64_to_int32      // j2k.c:1385:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_write_functions_from_float)) + 0)) = opj_j2k_write_float_to_int16     // j2k.c:1389:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_write_functions_from_float)) + 8)) = opj_j2k_write_float_to_int32     // j2k.c:1390:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_write_functions_from_float)) + 16)) = opj_j2k_write_float_to_float    // j2k.c:1391:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32))(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_mct_write_functions_from_float)) + 24)) = opj_j2k_write_float_to_float64  // j2k.c:1392:5:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 8)) = opj_j2k_read_sot   // j2k.c:1410:51:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 24)) = opj_j2k_read_cod  // j2k.c:1411:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 40)) = opj_j2k_read_coc  // j2k.c:1412:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 56)) = opj_j2k_read_rgn  // j2k.c:1413:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 72)) = opj_j2k_read_qcd  // j2k.c:1414:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 88)) = opj_j2k_read_qcc  // j2k.c:1415:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 104)) = opj_j2k_read_poc // j2k.c:1416:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 120)) = opj_j2k_read_siz // j2k.c:1417:35:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 136)) = opj_j2k_read_tlm // j2k.c:1418:32:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 152)) = opj_j2k_read_plm // j2k.c:1419:32:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 168)) = opj_j2k_read_plt // j2k.c:1420:33:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 184)) = opj_j2k_read_ppm // j2k.c:1421:32:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 200)) = opj_j2k_read_ppt // j2k.c:1422:33:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 232)) = opj_j2k_read_crg // j2k.c:1424:32:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 248)) = opj_j2k_read_com // j2k.c:1425:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 264)) = opj_j2k_read_mct // j2k.c:1426:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 280)) = opj_j2k_read_cbd // j2k.c:1427:32:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 296)) = opj_j2k_read_cap // j2k.c:1428:32:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 312)) = opj_j2k_read_cpf // j2k.c:1429:32:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 328)) = opj_j2k_read_mcc // j2k.c:1430:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&j2k_memory_marker_handler_tab)) + 344)) = opj_j2k_read_mco // j2k.c:1431:48:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_header)) + 8)) = opj_jp2_read_jp                       // jp2.c:426:14:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_header)) + 24)) = opj_jp2_read_ftyp                    // jp2.c:427:16:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_header)) + 40)) = opj_jp2_read_jp2h                    // jp2.c:428:16:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_img_header)) + 8)) = opj_jp2_read_ihdr                 // jp2.c:432:16:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_img_header)) + 24)) = opj_jp2_read_colr                // jp2.c:433:16:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_img_header)) + 40)) = opj_jp2_read_bpcc                // jp2.c:434:16:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_img_header)) + 56)) = opj_jp2_read_pclr                // jp2.c:435:16:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_img_header)) + 72)) = opj_jp2_read_cmap                // jp2.c:436:16:
	*(*func(*libc.TLS, uintptr, uintptr, TOPJ_UINT32, uintptr) TOPJ_BOOL)(unsafe.Pointer(uintptr(unsafe.Pointer(&jp2_img_header)) + 88)) = opj_jp2_read_cdef                // jp2.c:437:16:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 8 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 2*24                                         // mqc.c:62:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 16 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 3*24                                        // mqc.c:62:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 32 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 3*24                                        // mqc.c:63:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 40 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 2*24                                        // mqc.c:63:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 56 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 4*24                                        // mqc.c:64:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 64 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 12*24                                       // mqc.c:64:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 80 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 5*24                                        // mqc.c:65:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 88 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 13*24                                       // mqc.c:65:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 104 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 6*24                                       // mqc.c:66:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 112 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 18*24                                      // mqc.c:66:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 128 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 7*24                                       // mqc.c:67:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 136 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 19*24                                      // mqc.c:67:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 152 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 8*24                                       // mqc.c:68:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 160 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 24*24                                      // mqc.c:68:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 176 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 9*24                                       // mqc.c:69:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 184 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 25*24                                      // mqc.c:69:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 200 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 10*24                                      // mqc.c:70:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 208 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 58*24                                      // mqc.c:70:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 224 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 11*24                                      // mqc.c:71:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 232 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 59*24                                      // mqc.c:71:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 248 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 76*24                                      // mqc.c:72:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 256 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 66*24                                      // mqc.c:72:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 272 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 77*24                                      // mqc.c:73:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 280 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 67*24                                      // mqc.c:73:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 296 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 14*24                                      // mqc.c:74:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 304 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 13*24                                      // mqc.c:74:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 320 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 15*24                                      // mqc.c:75:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 328 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 12*24                                      // mqc.c:75:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 344 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 16*24                                      // mqc.c:76:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 352 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 28*24                                      // mqc.c:76:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 368 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 17*24                                      // mqc.c:77:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 376 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 29*24                                      // mqc.c:77:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 392 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 18*24                                      // mqc.c:78:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 400 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 28*24                                      // mqc.c:78:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 416 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 19*24                                      // mqc.c:79:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 424 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 29*24                                      // mqc.c:79:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 440 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 20*24                                      // mqc.c:80:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 448 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 28*24                                      // mqc.c:80:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 464 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 21*24                                      // mqc.c:81:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 472 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 29*24                                      // mqc.c:81:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 488 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 22*24                                      // mqc.c:82:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 496 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 34*24                                      // mqc.c:82:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 512 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 23*24                                      // mqc.c:83:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 520 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 35*24                                      // mqc.c:83:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 536 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 24*24                                      // mqc.c:84:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 544 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 36*24                                      // mqc.c:84:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 560 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 25*24                                      // mqc.c:85:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 568 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 37*24                                      // mqc.c:85:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 584 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 26*24                                      // mqc.c:86:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 592 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 40*24                                      // mqc.c:86:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 608 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 27*24                                      // mqc.c:87:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 616 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 41*24                                      // mqc.c:87:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 632 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 58*24                                      // mqc.c:88:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 640 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 42*24                                      // mqc.c:88:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 656 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 59*24                                      // mqc.c:89:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 664 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 43*24                                      // mqc.c:89:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 680 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 30*24                                      // mqc.c:90:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 688 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 29*24                                      // mqc.c:90:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 704 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 31*24                                      // mqc.c:91:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 712 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 28*24                                      // mqc.c:91:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 728 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 32*24                                      // mqc.c:92:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 736 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 28*24                                      // mqc.c:92:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 752 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 33*24                                      // mqc.c:93:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 760 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 29*24                                      // mqc.c:93:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 776 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 34*24                                      // mqc.c:94:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 784 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 30*24                                      // mqc.c:94:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 800 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 35*24                                      // mqc.c:95:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 808 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 31*24                                      // mqc.c:95:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 824 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 36*24                                      // mqc.c:96:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 832 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 32*24                                      // mqc.c:96:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 848 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 37*24                                      // mqc.c:97:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 856 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 33*24                                      // mqc.c:97:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 872 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 38*24                                      // mqc.c:98:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 880 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 34*24                                      // mqc.c:98:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 896 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 39*24                                      // mqc.c:99:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 904 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 35*24                                      // mqc.c:99:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 920 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 40*24                                      // mqc.c:100:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 928 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 36*24                                      // mqc.c:100:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 944 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 41*24                                      // mqc.c:101:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 952 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 37*24                                      // mqc.c:101:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 968 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 42*24                                      // mqc.c:102:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 976 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 38*24                                      // mqc.c:102:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 992 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 43*24                                      // mqc.c:103:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1000 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 39*24                                     // mqc.c:103:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1016 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 44*24                                     // mqc.c:104:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1024 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 38*24                                     // mqc.c:104:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1040 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 45*24                                     // mqc.c:105:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1048 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 39*24                                     // mqc.c:105:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1064 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 46*24                                     // mqc.c:106:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1072 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 40*24                                     // mqc.c:106:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1088 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 47*24                                     // mqc.c:107:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1096 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 41*24                                     // mqc.c:107:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1112 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 48*24                                     // mqc.c:108:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1120 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 42*24                                     // mqc.c:108:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1136 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 49*24                                     // mqc.c:109:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1144 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 43*24                                     // mqc.c:109:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1160 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 50*24                                     // mqc.c:110:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1168 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 44*24                                     // mqc.c:110:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1184 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 51*24                                     // mqc.c:111:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1192 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 45*24                                     // mqc.c:111:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1208 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 52*24                                     // mqc.c:112:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1216 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 46*24                                     // mqc.c:112:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1232 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 53*24                                     // mqc.c:113:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1240 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 47*24                                     // mqc.c:113:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1256 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 54*24                                     // mqc.c:114:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1264 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 48*24                                     // mqc.c:114:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1280 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 55*24                                     // mqc.c:115:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1288 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 49*24                                     // mqc.c:115:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1304 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 56*24                                     // mqc.c:116:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1312 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 50*24                                     // mqc.c:116:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1328 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 57*24                                     // mqc.c:117:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1336 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 51*24                                     // mqc.c:117:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1352 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 58*24                                     // mqc.c:118:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1360 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 52*24                                     // mqc.c:118:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1376 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 59*24                                     // mqc.c:119:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1384 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 53*24                                     // mqc.c:119:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1400 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 60*24                                     // mqc.c:120:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1408 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 54*24                                     // mqc.c:120:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1424 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 61*24                                     // mqc.c:121:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1432 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 55*24                                     // mqc.c:121:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1448 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 62*24                                     // mqc.c:122:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1456 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 56*24                                     // mqc.c:122:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1472 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 63*24                                     // mqc.c:123:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1480 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 57*24                                     // mqc.c:123:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1496 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 64*24                                     // mqc.c:124:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1504 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 58*24                                     // mqc.c:124:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1520 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 65*24                                     // mqc.c:125:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1528 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 59*24                                     // mqc.c:125:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1544 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 66*24                                     // mqc.c:126:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1552 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 60*24                                     // mqc.c:126:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1568 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 67*24                                     // mqc.c:127:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1576 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 61*24                                     // mqc.c:127:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1592 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 68*24                                     // mqc.c:128:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1600 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 62*24                                     // mqc.c:128:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1616 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 69*24                                     // mqc.c:129:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1624 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 63*24                                     // mqc.c:129:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1640 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 70*24                                     // mqc.c:130:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1648 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 64*24                                     // mqc.c:130:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1664 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 71*24                                     // mqc.c:131:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1672 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 65*24                                     // mqc.c:131:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1688 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 72*24                                     // mqc.c:132:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1696 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 66*24                                     // mqc.c:132:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1712 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 73*24                                     // mqc.c:133:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1720 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 67*24                                     // mqc.c:133:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1736 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 74*24                                     // mqc.c:134:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1744 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 68*24                                     // mqc.c:134:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1760 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 75*24                                     // mqc.c:135:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1768 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 69*24                                     // mqc.c:135:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1784 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 76*24                                     // mqc.c:136:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1792 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 70*24                                     // mqc.c:136:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1808 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 77*24                                     // mqc.c:137:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1816 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 71*24                                     // mqc.c:137:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1832 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 78*24                                     // mqc.c:138:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1840 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 72*24                                     // mqc.c:138:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1856 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 79*24                                     // mqc.c:139:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1864 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 73*24                                     // mqc.c:139:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1880 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 80*24                                     // mqc.c:140:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1888 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 74*24                                     // mqc.c:140:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1904 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 81*24                                     // mqc.c:141:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1912 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 75*24                                     // mqc.c:141:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1928 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 82*24                                     // mqc.c:142:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1936 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 76*24                                     // mqc.c:142:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1952 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 83*24                                     // mqc.c:143:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1960 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 77*24                                     // mqc.c:143:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1976 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 84*24                                     // mqc.c:144:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 1984 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 78*24                                     // mqc.c:144:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2000 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 85*24                                     // mqc.c:145:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2008 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 79*24                                     // mqc.c:145:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2024 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 86*24                                     // mqc.c:146:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2032 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 80*24                                     // mqc.c:146:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2048 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 87*24                                     // mqc.c:147:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2056 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 81*24                                     // mqc.c:147:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2072 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 88*24                                     // mqc.c:148:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2080 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 82*24                                     // mqc.c:148:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2096 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 89*24                                     // mqc.c:149:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2104 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 83*24                                     // mqc.c:149:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2120 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 90*24                                     // mqc.c:150:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2128 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 84*24                                     // mqc.c:150:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2144 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 91*24                                     // mqc.c:151:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2152 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 85*24                                     // mqc.c:151:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2168 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 90*24                                     // mqc.c:152:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2176 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 86*24                                     // mqc.c:152:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2192 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 91*24                                     // mqc.c:153:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2200 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 87*24                                     // mqc.c:153:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2216 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 92*24                                     // mqc.c:154:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2224 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 92*24                                     // mqc.c:154:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2240 /* .nmps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 93*24                                     // mqc.c:155:17:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&mqc_states)) + 2248 /* .nlps */)) = uintptr(unsafe.Pointer(&mqc_states)) + 93*24                                     // mqc.c:155:34:
}

var ts1 = "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n\x00../src/bin/common/color.c\x00%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n\x00%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n\x00b\x00../src/lib/openjp2/opj_intmath.h\x00opj_int_ceildiv\x00opj_uint_ceildiv\x00(temp >> 13) <= (OPJ_INT64)0x7FFFFFFF\x00(temp >> 13) >= (-(OPJ_INT64)0x7FFFFFFF - (OPJ_INT64)1)\x00opj_int_fix_mul\x00(n > 0U) && (n <= 32U)\x00../src/lib/openjp2/bio.c\x00opj_bio_write\x00(n > 0U)\x00opj_bio_read\x00p_nb_bytes > 0 && p_nb_bytes <= sizeof(OPJ_UINT32)\x00../src/lib/openjp2/cio.c\x00opj_write_bytes_BE\x00opj_write_bytes_LE\x00opj_read_bytes_BE\x00opj_read_bytes_LE\x00Stream reached its end !\n\x00Error on writing stream!\n\x00p_size >= 0\x00opj_stream_read_skip\x00Stream error!\n\x00p_stream->m_byte_offset >= 0\x00p_stream->m_user_data_length >= (OPJ_UINT64)p_stream->m_byte_offset\x00opj_stream_get_number_byte_left\x00opj_stream_skip\x00opj_stream_seek\x00(((OPJ_SIZE_T)fw) & 0xf) == 0\x00../src/lib/openjp2/dwt.c\x00opj_int_abs((OPJ_INT32)iters_c1 - (OPJ_INT32)iters_c2) <= 1\x00opj_dwt_encode_step1_combined\x00m + 1 == end\x00opj_dwt_encode_step2\x00dn + sn > 1\x00opj_dwt_encode_1_real\x00opj_v8dwt_encode_step2\x00ret\x00opj_dwt_interleave_partial_h\x00opj_dwt_interleave_partial_v\x00opj_dwt_decode_partial_tile\x00opj_v8dwt_interleave_partial_h\x00opj_v8dwt_interleave_partial_v\x00opj_v8dwt_decode_step2\x00(job->nb_rows % NB_ELTS_V8) == 0\x00opj_dwt97_decode_h_func\x00(job->nb_columns % NB_ELTS_V8) == 0\x00opj_dwt97_decode_v_func\x00opj_dwt_decode_partial_97\x00p_manager != NULL\x00../src/lib/openjp2/function_list.c\x00Not enough memory to add a new validation procedure\n\x00opj_procedure_list_add_procedure\x00rb\x00wb\x00ERROR -> failed to create the stream from buffer\n\x00ERROR -> opj_decompress: failed to setup the decoder\n\x00ERROR -> j2k_to_image: failed to read the header\n\x00ERROR -> opj_decompress: failed to set the decoded area\n\x00ERROR -> opj_decompress: failed to decode image!\n\x00melp->unstuff == OPJ_FALSE || melp->data[0] <= 0x8F\x00../src/lib/openjp2/ht_dec.c\x00mel_init\x00num_bits <= vlcp->bits\x00rev_advance\x00num_bits <= mrp->bits\x00rev_advance_mrp\x00msp->bits <= 32\x00frwd_read\x00msp->X == 0 || msp->X == 0xFF\x00frwd_init\x00num_bits <= msp->bits\x00frwd_advance\x00w <= 1024\x00h <= 1024\x00w * h <= 4096\x00opj_t1_allocate_buffers\x00We do not support ROI in decoding HT codeblocks\n\x00A malformed codeblock that has more than one coding pass, but zero length for 2nd and potentially the 3rd pass in an HT codeblock.\n\x00We do not support more than 3 coding passes in an HT codeblock; This codeblocks has %d passes.\n\x0032 bits are not enough to decode this codeblock, since the number of bitplane, %d, is larger than 30.\n\x00Malformed HT codeblock. Decoding this codeblock is stopped. There are %d zero bitplanes in %d bitplanes.\n\x00Malformed HT codeblock. When the number of zero planes bitplanes is equal to the number of bitplanes, only the cleanup pass makes sense, but we have %d passes in this codeblock. Therefore, only the cleanup pass will be decoded. This message will not be displayed again.\n\x00Malformed HT codeblock. Invalid codeblock length values.\n\x00Malformed HT codeblock. One of the following condition is not met: 2 <= Scup <= min(Lcup, 4079)\n\x00Malformed HT codeblock. Decoding this codeblock is stopped. U_q is larger than zero bitplanes + 1 \n\x00Malformed HT codeblock. VLC code produces significant samples outside the codeblock area.\n\x00Malformed HT codeblock. Decoding this codeblock is stopped. U_q islarger than bitplanes + 1 \n\x00dp[0] != 0\x00dp[stride] != 0\x00dp[2 * stride] != 0\x00dp[3 * stride] != 0\x00dp[0] == 0\x00dp[stride] == 0\x00dp[2 * stride] == 0\x00dp[3 * stride] == 0\x00opj_t1_ht_decode_cblk\x00p_image_src != 00\x00../src/lib/openjp2/image.c\x00p_image_dest != 00\x00opj_copy_image_header\x00nb_compo != 0\x00../src/lib/openjp2/invert.c\x00opj_lupSolve\x00CPRL\x00LRCP\x00PCRL\x00RLCP\x00RPCL\x00\x00\x00\x00\x00\x00p_nb_pocs > 0\x00../src/lib/openjp2/j2k.c\x00Not enough memory for checking the poc values.\n\x00Missing packets possible loss of data\n\x00opj_j2k_check_poc_val\x00tileno < (cp->tw * cp->th)\x00pino < (cp->tcps[tileno].numpocs + 1)\x00tcp != 00\x00l_current_poc != 0\x00strlen(prog) > 0\x00opj_j2k_get_num_tp\x00p_nb_tiles != 00\x00cp != 00\x00image != 00\x00p_j2k != 00\x00p_manager != 00\x00opj_j2k_calculate_tp\x00p_stream != 00\x00opj_j2k_write_soc\x00Start to read j2k main header (%ld).\n\x00Not enough memory to add mh marker\n\x00opj_j2k_read_soc\x00Not enough memory for the SIZ marker\n\x00opj_j2k_write_siz\x00p_header_data != 00\x00Error with SIZ marker size\n\x00Error with SIZ marker: number of component is illegal -> %d\n\x00Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n\x00Error with SIZ marker: negative or zero image size (%ld x %ld)\n\x00Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n\x00Error with SIZ marker: illegal tile offset\n\x00Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n\x00Not enough memory to take in charge SIZ marker\n\x00Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n\x00Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\x00Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n\x00Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n\x00opj_j2k_read_siz\x00Not enough memory to write the COM marker\n\x00opj_j2k_write_com\x00opj_j2k_read_com\x00Not enough memory to write COD marker\n\x00Error writing COD marker\n\x00opj_j2k_write_cod\x00Error reading COD marker\n\x00Unknown Scod value in COD marker\n\x00Unknown progression order in COD marker\n\x00Invalid number of layers in COD marker : %d not in range [1-65535]\n\x00Invalid multiple component transformation\n\x00opj_j2k_read_cod\x00Not enough memory to write COC marker\n\x00opj_j2k_write_coc\x00opj_j2k_compare_coc\x00opj_j2k_write_coc_in_memory\x00Error reading COC marker\n\x00Error reading COC marker (bad number of components)\n\x00opj_j2k_read_coc\x00Not enough memory to write QCD marker\n\x00Error writing QCD marker\n\x00opj_j2k_write_qcd\x00Error reading QCD marker\n\x00opj_j2k_read_qcd\x00Not enough memory to write QCC marker\n\x00opj_j2k_write_qcc\x00opj_j2k_write_qcc_in_memory\x00Error reading QCC marker\n\x00Invalid component number: %d, regarding the number of components %d\n\x00opj_j2k_read_qcc\x00Not enough memory to write POC marker\n\x00opj_j2k_write_poc\x00opj_j2k_write_poc_in_memory\x00Error reading POC marker\n\x00Too many POCs %d\n\x00opj_j2k_read_poc\x00Error reading CRG marker\n\x00opj_j2k_read_crg\x00Error reading TLM marker\n\x00opj_j2k_read_tlm\x00Error reading PLM marker\n\x00opj_j2k_read_plm\x00Error reading PLT marker\n\x00opj_j2k_read_plt\x00Error reading PPM marker\n\x00l_cp->ppm_markers_count == 0U\x00Not enough memory to read PPM marker\n\x00Zppm %u already read\n\x00opj_j2k_read_ppm\x00p_cp != 00\x00p_cp->ppm_buffer == NULL\x00Not enough bytes to read Nppm\n\x00Corrupted PPM markers\n\x00opj_j2k_merge_ppm\x00Error reading PPT marker\n\x00Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n\x00l_tcp->ppt_markers_count == 0U\x00Not enough memory to read PPT marker\n\x00Zppt %u already read\n\x00opj_j2k_read_ppt\x00p_tcp != 00\x00opj_j2k_merge_ppt() has already been called\n\x00opj_j2k_merge_ppt\x00A maximum of 10921 tile-parts are supported currently when writing TLM marker\n\x00Not enough memory to write TLM marker\n\x00opj_j2k_write_tlm\x00Not enough bytes in output buffer to write SOT marker\n\x00opj_j2k_write_sot\x00Error reading SOT marker\n\x00opj_j2k_get_sot_values\x00Invalid tile number %d\n\x00Invalid tile part index for tile number %d. Got %d, expected %d\n\x00Empty SOT marker detected: Psot=%d.\n\x00Psot value is not correct regards to the JPEG2000 norm: %d.\n\x00Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\n\x00In SOT marker, TPSot (%d) is not valid regards to the previous number of tile-part (%d), giving up\n\x00In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (%d), giving up\n\x00In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (header) (%d), giving up\n\x00p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec >= 0\x00p_j2k->cstr_index->tile_index != 00\x00Not enough memory to read SOT marker. Tile index allocation failed\n\x00opj_j2k_read_sot\x00More than 255 PLT markers would be needed for current tile-part !\n\x00Not enough bytes in output buffer to write SOD marker\n\x00Cannot encode tile: opj_tcd_marker_info_create() failed\n\x00Cannot encode tile\n\x00Cannot allocate memory\n\x00l_data_written_PLT <= p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT\x00opj_j2k_write_sod\x00Tile part length size inconsistent with stream length\n\x00p_j2k->m_specific_param.m_decoder.m_sot_length > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA\x00*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA - p_j2k->m_specific_param.m_decoder.m_sot_length\x00Not enough memory to decode tile\n\x00Not enough memory to add tl marker\n\x00opj_j2k_read_sod\x00opj_j2k_write_rgn\x00opj_j2k_write_eoc\x00Error reading RGN marker\n\x00bad component number in RGN (%d when there are only %d)\n\x00opj_j2k_read_rgn\x00Not enough memory to allocate m_encoded_tile_data. %u MB required\n\x00opj_j2k_update_rates\x00opj_j2k_get_end_header\x00opj_j2k_write_mct_data_group\x00opj_j2k_write_all_coc\x00opj_j2k_write_all_qcc\x00opj_j2k_write_regions\x00opj_j2k_write_epc\x00Unknown marker\n\x00Stream too short\n\x00Marker is not compliant with its position\n\x00opj_j2k_read_unk\x00Not enough memory to write MCT marker\n\x00opj_j2k_write_mct_record\x00Error reading MCT marker\n\x00Cannot take in charge mct data within multiple MCT records\n\x00Not enough memory to read MCT marker\n\x00Cannot take in charge multiple MCT markers\n\x00opj_j2k_read_mct\x00Not enough memory to write MCC marker\n\x00opj_j2k_write_mcc_record\x00Error reading MCC marker\n\x00Cannot take in charge multiple data spanning\n\x00Not enough memory to read MCC marker\n\x00Cannot take in charge multiple collections\n\x00Cannot take in charge collections other than array decorrelation\n\x00Cannot take in charge collections with indix shuffle\n\x00Cannot take in charge collections without same number of indixes\n\x00opj_j2k_read_mcc\x00Not enough memory to write MCO marker\n\x00opj_j2k_write_mco\x00Error reading MCO marker\n\x00Cannot take in charge multiple transformation stages.\n\x00opj_j2k_read_mco\x00opj_j2k_add_mct\x00Not enough memory to write CBD marker\n\x00opj_j2k_write_cbd\x00Crror reading CBD marker\n\x00opj_j2k_read_cbd\x00opj_j2k_read_cap\x00opj_j2k_read_cpf\x00OPJ_NUM_THREADS\x00ALL_CPUS\x00JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n1 single quality layer-> Number of layers forced to 1 (rather than %d)\n-> Rate of the last layer (%3.1f) will be used\x00JPEG 2000 Profile-3 (2k dc profile) requires:\nNumber of decomposition levels <= 5\n-> Number of decomposition levels forced to 5 (rather than %d)\n\x00JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 1 (rather than %d)\n\x00JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 6 (rather than %d)\n\x00JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n\x00JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n\x00JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n\x00JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n\x00JPEG 2000 Profile-3 (2k dc profile) requires:\n3 components-> Number of components of input image (%d) is not compliant\n-> Non-profile-3 codestream will be generated\n\x00signed\x00unsigned\x00JPEG 2000 Profile-3 (2k dc profile) requires:\nPrecision of each component shall be 12 bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-profile-3 codestream will be generated\n\x00JPEG 2000 Profile-3 (2k dc profile) requires:\nwidth <= 2048 and height <= 1080\n-> Input image size %d x %d is not compliant\n-> Non-profile-3 codestream will be generated\n\x00JPEG 2000 Profile-4 (4k dc profile) requires:\nwidth <= 4096 and height <= 2160\n-> Image size %d x %d is not compliant\n-> Non-profile-4 codestream will be generated\n\x00IMF profile require mainlevel <= 11.\n-> %d is thus not compliant\n-> Non-IMF codestream will be generated\n\x00sizeof(tabMaxSubLevelFromMainLevel) == (OPJ_IMF_MAINLEVEL_MAX + 1) * sizeof(tabMaxSubLevelFromMainLevel[0])\x00IMF profile require sublevel <= %d for mainlevel = %d.\n-> %d is thus not compliant\n-> Non-IMF codestream will be generated\n\x00IMF profiles require at most 3 components.\n-> Number of components of input image (%d) is not compliant\n-> Non-IMF codestream will be generated\n\x00IMF profiles require image origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n\x00IMF profiles require tile origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n\x00IMF 2K/4K/8K single tile profiles require tile to be greater or equal to image size.\n-> %d,%d is lesser than %d,%d\n-> Non-IMF codestream will be generated\n\x00IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n\x00IMF profiles require precision of each component to b in [8-16] bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-IMF codestream will be generated\n\x00IMF profiles require XRSiz1 == 1. Here it is set to %d.\n-> Non-IMF codestream will be generated\n\x00IMF profiles require XRSiz2 == 1 or 2. Here it is set to %d.\n-> Non-IMF codestream will be generated\n\x00IMF profiles require XRSiz%d to be the same as XRSiz2. Here it is set to %d instead of %d.\n-> Non-IMF codestream will be generated\n\x00IMF profiles require YRsiz == 1. Here it is set to %d for component %d.\n-> Non-IMF codestream will be generated\n\x00IMF 2K/2K_R profile require:\nwidth <= 2048 and height <= 1556\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n\x00IMF 4K/4K_R profile require:\nwidth <= 4096 and height <= 3112\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n\x00IMF 8K/8K_R profile require:\nwidth <= 8192 and height <= 6224\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n\x000\x00IMF profile forbid RGN / region of interest marker.\n-> Compression parameters specify a ROI\n-> Non-IMF codestream will be generated\n\x00IMF profile require code block size to be 32x32.\n-> Compression parameters set it to %dx%d.\n-> Non-IMF codestream will be generated\n\x00IMF profile require progression order to be CPRL.\n-> Compression parameters set it to %d.\n-> Non-IMF codestream will be generated\n\x00IMF profile forbid POC markers.\n-> Compression parameters set %d POC.\n-> Non-IMF codestream will be generated\n\x00IMF profile forbid mode switch in code block style.\n-> Compression parameters set code block style to %d.\n-> Non-IMF codestream will be generated\n\x00IMF 2K/4K/8K profiles require 9-7 Irreversible Transform.\n-> Compression parameters set it to reversible.\n-> Non-IMF codestream will be generated\n\x00IMF 2K/4K/8K profiles require 5-3 reversible Transform.\n-> Compression parameters set it to irreversible.\n-> Non-IMF codestream will be generated\n\x00IMF 2K/4K/8K profiles require 1 single quality layer.\n-> Number of layers is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 2K profile requires 1 <= NL <= 5:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 4K profile requires 1 <= NL <= 6:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 8K profile requires 1 <= NL <= 7:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 2K_R profile requires 1 <= NL <= 5 for XTsiz >= 2048:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 2K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz >= 4096:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 4K_R profile requires 1 <= NL <= 7 for XTsiz >= 8192:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz in [4096,8192[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n\x00IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n\x00opj_j2k_is_imf_compliant\x00Invalid number of resolutions : %d not in range [1,%d]\n\x00Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n\x00Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n\x00Invalid value for cblockw_init * cblockh_init: should be <= 4096\n\x00Deprecated fields cp_cinema or cp_rsiz are used\nPlease consider using only the rsiz field\nSee openjpeg.h documentation for more details\n\x00tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n\x00tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f\n\x00tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n\x00tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f\n\x00tcp_distoratio[%d]=%f should be strictly greater than tcp_distoratio[%d]=%f\n\x00The desired maximum codestream size has limited\nat least one of the desired quality layers\n\x00JPEG 2000 Scalable Digital Cinema profiles not yet supported\n\x00JPEG 2000 Long Term Storage profile not yet supported\n\x00JPEG 2000 Broadcast profiles not yet supported\n\x00JPEG 2000 Part-2 profile defined\nbut no Part-2 extension enabled.\nProfile set to NONE.\n\x00Unsupported Part-2 extension enabled\nProfile set to NONE.\n\x00Not enough memory to allocate copy of user encoding parameters matrix \n\x00Not enough memory to allocate copy of comment string\n\x00Created by OpenJPEG version \x00Not enough memory to allocate comment string\n\x00%s%s\x00Invalid tile width\n\x00Invalid tile height\n\x00Not enough memory to allocate tile coding parameters\n\x00Invalid compno0 for POC %d\n\x00Not enough memory to allocate tile component coding parameters\n\x00Not enough memory to allocate temp buffer\n\x00Not enough memory to allocate encoder MCT coding matrix \n\x00Not enough memory to allocate encoder MCT decoding matrix \n\x00Failed to inverse encoder MCT decoding matrix \n\x00Not enough memory to allocate encoder MCT norms \n\x00Failed to setup j2k mct encoding\n\x00Cannot perform MCT on components with different sizes. Disabling MCT.\n\x00tccp->numresolutions > 0\x00res_spec > 0\x00opj_j2k_setup_encoder\x00cstr_index != 00\x00opj_j2k_add_mhmarker\x00cstr_index->tile_index != 00\x00opj_j2k_add_tlmarker\x00opj_j2k_read_header\x00opj_j2k_setup_header_reading\x00opj_j2k_setup_decoding_validation\x00opj_j2k_mct_validation\x00opj_j2k_setup_mct_encoding\x00Number of resolutions is too high in comparison to the size of tiles\n\x00opj_j2k_encoding_validation\x00opj_j2k_decoding_validation\x00Expected a SOC marker \n\x00A marker ID was expected (0xff--) instead of %.8x\n\x00Unknown marker has been detected and generated error.\n\x00Invalid marker size\n\x00Not enough memory to read header\n\x00Marker handler function failed to read the marker segment\n\x00required SIZ marker not found in main header\n\x00required COD marker not found in main header\n\x00required QCD marker not found in main header\n\x00Failed to merge PPM data\n\x00Main header has been correctly decoded.\n\x00opj_j2k_read_header_procedure\x00p_procedure_list != 00\x00opj_j2k_exec\x00Cannot decode tile, memory error\n\x00opj_j2k_copy_default_tcp_and_create_tcd\x00Inconsistent marker size\n\x00Marker size inconsistent with stream length\n\x00Not sure how that happened.\n\x00Fail to read the current marker segment (%#x)\n\x00opj_j2k_apply_nb_tile_parts_correction error\n\x00Non conformant codestream TPsot==TNsot.\n\x00Tile %u has TPsot == 0 and TNsot == 0, but no other tile-parts were found. EOC is also missing.\n\x00Failed to merge PPT data\n\x00Header of tile %d / %d has been read.\n\x00opj_j2k_read_tile_header\x00Failed to decode.\n\x00Stream does not end with EOC\n\x00Stream too short, expected SOT\n\x00opj_j2k_decode_tile\x00res_x0 >= 0\x00res_x1 >= 0\x00opj_j2k_update_image_data\x00Image coordinates above INT_MAX are not supported\n\x00Size x of the decoded component image is incorrect (comp[%d].w=%d).\n\x00Size y of the decoded component image is incorrect (comp[%d].h=%d).\n\x00opj_read_header() should be called before opj_set_decoded_components().\n\x00Invalid component index: %u\n\x00Component index %u used several times\n\x00Need to decode the main header before begin to decode the remaining codestream.\n\x00No decoded area parameters, set the decoded area to the whole image\n\x00Left position of the decoded area (region_x0=%d) should be >= 0.\n\x00Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n\x00Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n\x00Up position of the decoded area (region_y0=%d) should be >= 0.\n\x00Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\n\x00Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\n\x00Right position of the decoded area (region_x1=%d) should be > 0.\n\x00Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n\x00Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n\x00Bottom position of the decoded area (region_y1=%d) should be > 0.\n\x00Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n\x00Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n\x00Setting decoding area to %d,%d,%d,%d\n\x00p_tile_no < (l_cp->tw * l_cp->th)\x00p_comp_no < p_j2k->m_private_image->numcomps\x00opj_j2k_get_SPCod_SPCoc_size\x00opj_j2k_compare_SPCod_SPCoc\x00p_header_size != 00\x00p_data != 00\x00p_comp_no < (p_j2k->m_private_image->numcomps)\x00Error writing SPCod SPCoc element\n\x00opj_j2k_write_SPCod_SPCoc\x00compno < p_j2k->m_private_image->numcomps\x00Error reading SPCod SPCoc element\n\x00Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n\x00Error decoding component %d.\nThe number of resolutions to remove (%d) is greater or equal than the number of resolutions of this component (%d)\nModify the cp_reduce parameter.\n\n\x00Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n\x00Error reading SPCod SPCoc element. Unsupported Mixed HT code-block style found\n\x00Error reading SPCod SPCoc element, Invalid transformation found\n\x00Invalid precinct size\n\x00opj_j2k_read_SPCod_SPCoc\x00opj_j2k_copy_tile_component_parameters\x00p_tile_no < l_cp->tw * l_cp->th\x00opj_j2k_get_SQcd_SQcc_size\x00opj_j2k_compare_SQcd_SQcc\x00Error writing SQcd SQcc element\n\x00opj_j2k_write_SQcd_SQcc\x00Error reading SQcd or SQcc element\n\x00While reading CCP_QNTSTY element inside QCD or QCC marker segment, number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to OPJ_J2K_MAXBANDS (%d) and skip the rest. \n\x00opj_j2k_read_SQcd_SQcc\x00opj_j2k_copy_tile_quantization_parameters\x00\t default tile {\n\x00\t\t csty=%#x\n\x00\t\t prg=%#x\n\x00\t\t numlayers=%d\n\x00\t\t mct=%x\n\x00\t\t comp %d {\n\x00\t\t\t csty=%#x\n\x00\t\t\t numresolutions=%d\n\x00\t\t\t cblkw=2^%d\n\x00\t\t\t cblkh=2^%d\n\x00\t\t\t cblksty=%#x\n\x00\t\t\t qmfbid=%d\n\x00\t\t\t preccintsize (w,h)=\x00(%d,%d) \x00\n\x00\t\t\t qntsty=%d\n\x00\t\t\t numgbits=%d\n\x00\t\t\t stepsizes (m,e)=\x00\t\t\t roishift=%d\n\x00\t\t }\n\x00\t }\n\x00Wrong flag\n\x00Codestream index from main header: {\n\x00\t Main header start position=%li\n\t Main header end position=%li\n\x00\t Marker list: {\n\x00\t\t type=%#x, pos=%li, len=%d\n\x00\t Tile index: {\n\x00\t\t nb of tile-part in tile [%d]=%d\n\x00\t\t\t tile-part[%d]: star_pos=%li, end_header=%li, end_pos=%li.\n\x00}\n\x00Codestream info from main header: {\n\x00\t tx0=%d, ty0=%d\n\x00\t tdx=%d, tdy=%d\n\x00\t tw=%d, th=%d\n\x00[DEV] Dump an image_header struct {\n\x00Image info {\n\x00%s x0=%d, y0=%d\n\x00%s x1=%d, y1=%d\n\x00%s numcomps=%d\n\x00%s\t component %d {\n\x00%s}\n\x00[DEV] Dump an image_comp_header struct {\n\x00%s dx=%d, dy=%d\n\x00%s prec=%d\n\x00%s sgnd=%d\n\x00Failed to decode component %d\n\x00Failed to decode all used components\n\x00Failed to decode tile 1/1\n\x00Failed to decode tile %d/%d\n\x00Tile %d/%d has been decoded.\n\x00Image data has been updated with tile %d.\n\n\x00opj_j2k_setup_decoding\x00Problem with seek function\n\x00Tile read, decoded and updated is not the desired one (%d vs %d).\n\x00opj_j2k_setup_decoding_tile\x00p_j2k->m_output_image->comps[compno].data == NULL\x00opj_j2k_move_data_from_codec_to_output_image\x00We need an image previously created.\n\x00Image has less components than codestream.\n\x00Tile index provided by the user is incorrect %d (max = %d) \n\x00Resolution factor is greater than the maximum resolution in the component.\n\x00PLT=\x00PLT=YES\x00PLT=NO\x00Invalid value for option: %s.\n\x00TLM=\x00TLM=YES\x00TLM=NO\x00GUARD_BITS=\x00Invalid value for option: %s. Should be in [0,7]\n\x00Invalid option: %s.\n\x00Error allocating tile component data.\x00Not enough memory to encode all tiles\n\x00Size mismatch between tile data and sent data.\x00opj_j2k_encode\x00Failed to allocate image header.\x00opj_j2k_start_compress\x00The given tile index does not match.\x00tile number %d / %d\n\x00p_j2k->m_specific_param.m_encoder.m_encoded_tile_data\x00opj_j2k_post_write_tile\x00opj_j2k_setup_end_compress\x00opj_j2k_setup_encoding_validation\x00opj_j2k_setup_header_writing\x00opj_j2k_write_updated_tlm\x00opj_j2k_end_encoding\x00opj_j2k_destroy_header_memory\x00opj_j2k_init_info\x00Not enough memory to create Tile Coder\n\x00opj_j2k_create_tcd\x00Error while opj_j2k_pre_write_tile with tile index = %d\n\x00Error while opj_j2k_post_write_tile with tile index = %d\n\x00cio != 00\x00../src/lib/openjp2/jp2.c\x00box != 00\x00p_number_bytes_read != 00\x00Cannot handle box sizes higher than 2^32\n\x00(OPJ_OFF_T)box->length == bleft + 8\x00opj_jp2_read_boxhdr\x00p_image_header_data != 00\x00jp2 != 00\x00Ignoring ihdr box. First ihdr box already read\n\x00Bad image header box (bad size)\n\x00Wrong values for: w(%d) h(%d) numcomps(%d) (ihdr)\n\x00Invalid number of components (ihdr)\n\x00Not enough memory to handle image header (ihdr)\n\x00JP2 IHDR box: compression type indicate that the file is not a conforming JP2 file (%d) \n\x00opj_jp2_read_ihdr\x00p_nb_bytes_written != 00\x00opj_jp2_write_ihdr\x00opj_jp2_write_bpcc\x00p_bpc_header_data != 00\x00A BPCC header box is available although BPC given by the IHDR box (%d) indicate components bit depth is constant\n\x00Bad BPCC header box (bad size)\n\x00opj_jp2_read_bpcc\x00jp2->color.jp2_cdef != 00\x00jp2->color.jp2_cdef->info != 00\x00jp2->color.jp2_cdef->n > 0U\x00opj_jp2_write_cdef\x00jp2->meth == 1 || jp2->meth == 2\x00jp2->color.icc_profile_len\x00opj_jp2_write_colr\x00Invalid component index %d (>= %d).\n\x00Incomplete channel definitions.\n\x00Unexpected OOM.\n\x00Invalid value for cmap[%d].mtyp = %d.\n\x00Invalid component/palette index for direct mapping %d.\n\x00Component %d is mapped twice.\n\x00Direct use at #%d however pcol=%d.\n\x00Implementation limitation: for palette mapping, pcol[%d] should be equal to %d, but is equal to %d.\n\x00Component %d doesn't have a mapping.\n\x00Component mapping seems wrong. Trying to correct.\n\x00image->comps[%d].data == NULL in opj_jp2_apply_pclr().\n\x00Memory allocation failure in opj_jp2_apply_pclr().\n\x00pcol == 0\x00i == pcol\x00src\x00dst\x00opj_jp2_apply_pclr\x00p_pclr_header_data != 00\x00Invalid PCLR box. Reports %d entries\n\x00Invalid PCLR box. Reports 0 palette columns\n\x00opj_jp2_read_pclr\x00p_cmap_header_data != 00\x00Need to read a PCLR box before the CMAP box.\n\x00Only one CMAP box is allowed.\n\x00Insufficient data for CMAP box.\n\x00opj_jp2_read_cmap\x00opj_jp2_apply_cdef: cn=%d, numcomps=%d\n\x00opj_jp2_apply_cdef: acn=%d, numcomps=%d\n\x00p_cdef_header_data != 00\x00Insufficient data for CDEF box.\n\x00Number of channel description is equal to zero in CDEF box.\n\x00opj_jp2_read_cdef\x00p_colr_header_data != 00\x00Bad COLR header box (bad size)\n\x00A conforming JP2 reader shall ignore all Colour Specification boxes after the first, so we ignore this one.\n\x00Bad COLR header box (bad size: %d)\n\x00Not enough memory for cielab\n\x00Bad COLR header box (CIELab, bad size: %d)\n\x00COLR BOX meth value is not a regular value (%d), so we will ignore the entire Colour Specification box. \n\x00opj_jp2_read_colr\x00Failed to decode the codestream in the JP2 file\n\x00stream != 00\x00Not enough memory to hold JP2 Header data\n\x00Stream error while writing JP2 Header box\n\x00opj_jp2_write_jp2h\x00Not enough memory to handle ftyp data\n\x00Error while writing ftyp data to stream\n\x00opj_jp2_write_ftyp\x00opj_stream_has_seek(cio)\x00Failed to seek in the stream.\n\x00opj_jp2_write_jp2c\x00opj_jp2_write_jp\x00Invalid number of components specified while setting up JP2 encoder\n\x00Not enough memory when setup the JP2 encoder\n\x00Alpha channel specified but unknown enumcs. No cdef box will be created.\n\x00Alpha channel specified but not enough image components for an automatic cdef box creation.\n\x00Alpha channel position conflicts with color channel. No cdef box will be created.\n\x00Multiple alpha channels specified. No cdef box will be created.\n\x00Not enough memory to setup the JP2 encoder\n\x00opj_jp2_end_decompress\x00opj_jp2_end_compress\x00opj_jp2_setup_end_header_writing\x00opj_jp2_setup_end_header_reading\x00opj_jp2_default_validation\x00Not enough memory to handle jpeg2000 file header\n\x00bad placed jpeg codestream\n\x00Cannot handle box of undefined sizes\n\x00invalid box size %d (%x)\n\x00Found a misplaced '%c%c%c%c' box outside jp2h box\n\x00JPEG2000 Header box not read yet, '%c%c%c%c' box will be ignored\n\x00Problem with skipping JPEG2000 box, stream error\n\x00Invalid box size %d for box '%c%c%c%c'. Need %d bytes, %d bytes remaining \n\x00Not enough memory to handle jpeg2000 box\n\x00Problem with reading JPEG2000 box, stream error\n\x00Malformed JP2 file format: first box must be JPEG 2000 signature box\n\x00Malformed JP2 file format: second box must be file type box\n\x00opj_jp2_read_header_procedure\x00opj_jp2_exec\x00opj_jp2_start_compress\x00The signature box must be the first box in the file.\n\x00Error with JP signature Box size\n\x00Error with JP Signature : bad magic number\n\x00opj_jp2_read_jp\x00The ftyp box must be the second box in the file.\n\x00Error with FTYP signature Box size\n\x00Not enough memory with FTYP Box\n\x00opj_jp2_read_ftyp\x00opj_jp2_skip_jp2c\x00opj_jpip_skip_iptr\x00The  box must be the first box in the file.\n\x00Stream error while reading JP2 Header box\n\x00Stream error while reading JP2 Header box: box length is inconsistent.\n\x00Stream error while reading JP2 Header box: no 'ihdr' box.\n\x00opj_jp2_read_jp2h\x00Cannot handle box of less than 8 bytes\n\x00Cannot handle XL box of less than 16 bytes\n\x00Box length is inconsistent.\n\x00opj_jp2_read_boxhdr_char\x00JP2H box missing. Required.\n\x00IHDR box_missing. Required.\n\x00opj_jp2_read_header\x00opj_jp2_setup_encoding_validation\x00opj_jp2_setup_decoding_validation\x00opj_jp2_setup_header_writing\x00opj_jp2_setup_header_reading\x00JP2 box which are after the codestream will not be read by this function.\n\x00p_jp2 != 00\x00jp2_dump\x00*(mqc->bp) != 0xff\x00../src/lib/openjp2/mqc.c\x00opj_mqc_init_enc\x00mqc->bp >= mqc->start\x00mqc->bp[-1] != 0xff\x00opj_mqc_bypass_init_enc\x00!erterm\x00opj_mqc_bypass_flush_enc\x00mqc->bp >= mqc->start - 1\x00*mqc->bp != 0xff\x00opj_mqc_restart_init_enc\x00extra_writable_bytes >= OPJ_COMMON_CBLK_DATA_EXTRA\x00opj_mqc_init_dec_common\x00opj_mqc_byteout\x002.5.0\x00Codec provided to the opj_setup_decoder function is not a decompressor handler.\n\x00Codec provided to the opj_decoder_set_strict_mode function is not a decompressor handler.\n\x00Codec provided to the opj_read_header function is not a decompressor handler.\n\x00Codec provided to the opj_set_decoded_components function is not a decompressor handler.\n\x00apply_color_transforms = OPJ_TRUE is not supported.\n\x00[INFO] %s\x00is not decompressor\x00(alignment != 0U) && ((alignment & (alignment - 1U)) == 0U)\x00../src/lib/openjp2/opj_malloc.c\x00alignment >= sizeof(void*)\x00alignment <= (SIZE_MAX - sizeof(void *))\x00opj_aligned_alloc_n\x00opj_aligned_realloc_n\x00opj_pi_next_lrcp(): invalid compno0/compno1\n\x00Invalid access to pi->include\x00opj_pi_next_rlcp(): invalid compno0/compno1\n\x00opj_pi_next_rpcl(): invalid compno0/compno1\n\x00opj_pi_next_pcrl(): invalid compno0/compno1\n\x00opj_pi_next_cprl(): invalid compno0/compno1\n\x00../src/lib/openjp2/pi.c\x00p_image != 00\x00p_tileno < p_cp->tw * p_cp->th\x00opj_get_encoding_parameters\x00tileno < p_cp->tw * p_cp->th\x00opj_get_all_encoding_parameters\x00tileno < cp->tw * cp->th\x00opj_pi_create\x00opj_pi_update_encode_poc_and_final\x00opj_pi_update_encode_not_poc\x00p_pi != 00\x00opj_pi_update_decode_poc\x00opj_pi_update_decode_not_poc\x00p_tile_no < p_cp->tw * p_cp->th\x00opj_pi_create_decode\x00opj_get_encoding_packet_count\x00opj_pi_initialise_encode\x00opj_pi_update_encoding_parameters\x00../src/lib/openjp2/t1.c\x00Cannot allocate cblk->decoded_data\n\x00Cannot allocate Tier 1 handle\n\x00Unable to set t1 handle as TLS\n\x00(cblk->decoded_data != NULL) || (tilec->data != NULL)\x00opj_t1_clbl_decode_processor\x00opj_t1_decode_cblk(): unsupported bpno_plus_one = %d >= 31\n\x00PTERM check failure: %d remaining bytes in code block (%d used / %d)\n\x00PTERM check failure: %d synthetized 0xFF markers read\n\x00pass->rate > 0\x00opj_t1_encode_cblk\x00p_marker_info->packet_count == 0\x00../src/lib/openjp2/t2.c\x00p_marker_info->p_packet_size == NULL\x00opj_t2_encode_packets\x00packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n\n\x00opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n\x00opj_t2_encode_packet(): accessing precno=%u >= %u\n\x00c >= dest\x00opj_t2_encode_packet\x00Invalid precinct\n\x00Not enough space for expected SOP marker\n\x00Expected SOP marker\n\x00present=%d \n\x00Not enough space for expected EPH marker\n\x00Expected EPH marker\n\x00included=%d \n\x00Invalid bit number %d in opj_t2_read_packet_header()\n\x00included=%d numnewpasses=%d increment=%d len=%d \n\x00hdrlen=%d \n\x00packet body\n\x00read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n\x00cannot allocate opj_tcd_seg_data_chunk_t* array\x00skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n\x00p_data_read (%d) newlen (%d) \n\x00Tile X coordinates are not supported\n\x00Tile Y coordinates are not supported\n\x00tiles require at least one resolution\n\x00Size of tile data exceeds system limits\n\x00Not enough memory for tile resolutions\n\x00Integer overflow\n\x00Not enough memory to handle band precints\n\x00Size of code block data exceeds system limits\n\x00Not enough memory for current precinct codeblock element\n\x00Invalid tilec->win_xxx values\n\x00Tiles don't all have the same dimension. Skip the MCT step.\n\x00Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n\x00l_height == 0 || l_width + l_stride <= l_tile_comp->data_size / l_height\x00../src/lib/openjp2/tcd.c\x00opj_tcd_dc_level_shift_decode\x00Not enough memory to create Tag-tree\n\x00Not enough memory to create Tag-tree nodes\n\x00Not enough memory to reinitialize the tag tree\n\x00num_threads > 0\x00../src/lib/openjp2/thread.c\x00opj_thread_pool_setup\x00tp->waiting_worker_thread_count <= tp->worker_threads_count\x00opj_thread_pool_get_next_job\x00worker_thread->marked_as_waiting\x00opj_thread_pool_submit_job\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
